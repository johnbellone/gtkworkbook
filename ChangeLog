commit eca5c47d45e892e8a6389e845e1bfca48d41955b
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Aug 13 22:29:14 2009 -0400

    Added Makefile.in for autotools support

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..dd64934
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,620 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+pkgdatadir = $(datadir)/gtkworkbook
+pkglibdir = $(libdir)/gtkworkbook
+pkgincludedir = $(includedir)/gtkworkbook
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = x86_64-unknown-linux-gnu
+host_triplet = x86_64-unknown-linux-gnu
+subdir = .
+DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in $(top_srcdir)/configure INSTALL TODO \
+	config.guess config.sub depcomp install-sh ltmain.sh missing
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  { test ! -d $(distdir) \
+    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \
+         && rm -fr $(distdir); }; }
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+distuninstallcheck_listfiles = find . -type f -print
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run aclocal-1.10
+AMTAR = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run automake-1.10
+AWK = mawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DPACKAGE_NAME=\"gtkworkbook\" -DPACKAGE_TARNAME=\"gtkworkbook\" -DPACKAGE_VERSION=\"0.20\" -DPACKAGE_STRING=\"gtkworkbook\ 0.20\" -DPACKAGE_BUGREPORT=\"jvb4@njit.edu\" -DPACKAGE=\"gtkworkbook\" -DVERSION=\"0.20\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DHAVE_LIBDL=1 -DHAVE_ARPA_INET_H=1 -DHAVE_NETDB_H=1 -DHAVE_NETINET_IN_H=1 -DHAVE_STRING_H=1 -DHAVE_SYS_SOCKET_H=1 -DHAVE_SYS_TIME_H=1 -DHAVE_UNISTD_H=1 -DHAVE__BOOL=1 -DHAVE_STDBOOL_H=1 -DHAVE_GETHOSTBYNAME=1 -DHAVE_GETTIMEOFDAY=1 -DHAVE_MEMSET=1 -DHAVE_SOCKET=1
+DEPDIR = .deps
+DSYMUTIL = 
+DUMPBIN = 
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = /bin/grep -E
+EXEEXT = 
+FGREP = /bin/grep -F
+GREP = /bin/grep
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LD = /usr/bin/ld -m elf_x86_64
+LDFLAGS = 
+LIBOBJS = 
+LIBS = -ldl 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LIPO = 
+LN_S = ln -s
+LTLIBOBJS = 
+MAKEINFO = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run makeinfo
+MKDIR_P = /bin/mkdir -p
+NM = /usr/bin/nm -B
+NMEDIT = 
+OBJDUMP = objdump
+OBJEXT = o
+OTOOL = 
+OTOOL64 = 
+PACKAGE = gtkworkbook
+PACKAGE_BUGREPORT = jvb4@njit.edu
+PACKAGE_NAME = gtkworkbook
+PACKAGE_STRING = gtkworkbook 0.20
+PACKAGE_TARNAME = gtkworkbook
+PACKAGE_VERSION = 0.20
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SED = /bin/sed
+SET_MAKE = 
+SHELL = /bin/bash
+STRIP = strip
+VERSION = 0.20
+abs_builddir = /home/jbellone/work/gtkworkbook
+abs_srcdir = /home/jbellone/work/gtkworkbook
+abs_top_builddir = /home/jbellone/work/gtkworkbook
+abs_top_srcdir = /home/jbellone/work/gtkworkbook
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_DUMPBIN = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build = x86_64-unknown-linux-gnu
+build_alias = 
+build_cpu = x86_64
+build_os = linux-gnu
+build_vendor = unknown
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host = x86_64-unknown-linux-gnu
+host_alias = 
+host_cpu = x86_64
+host_os = linux-gnu
+host_vendor = unknown
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = $(SHELL) /home/jbellone/work/gtkworkbook/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+lt_ECHO = echo
+mandir = ${datarootdir}/man
+mkdir_p = /bin/mkdir -p
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = ${prefix}/etc
+target_alias = 
+top_build_prefix = 
+top_builddir = .
+top_srcdir = .
+AUTOMAKE_OPTIONS = foreign
+SUBDIRS = cfg gtkworkbook/OBJS src/OBJS
+all: all-recursive
+
+.SUFFIXES:
+am--refresh:
+	@:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
+	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	test -d $(distdir) || mkdir $(distdir)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r $(distdir)
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
+	$(am__remove_distdir)
+
+dist-lzma: distdir
+	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
+	$(am__remove_distdir)
+
+dist-tarZ: distdir
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__remove_distdir)
+
+dist-shar: distdir
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__remove_distdir)
+
+dist dist-all: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lzma*) \
+	  unlzma -c $(distdir).tar.lzma | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir); chmod a+w $(distdir)
+	mkdir $(distdir)/_build
+	mkdir $(distdir)/_inst
+	chmod a-w $(distdir)
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && cd $(distdir)/_build \
+	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck
+	$(am__remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@cd $(distuninstallcheck_dir) \
+	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am am--refresh check check-am clean clean-generic \
+	clean-libtool ctags ctags-recursive dist dist-all dist-bzip2 \
+	dist-gzip dist-lzma dist-shar dist-tarZ dist-zip distcheck \
+	distclean distclean-generic distclean-libtool distclean-tags \
+	distcleancheck distdir distuninstallcheck dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/Makefile.am b/Makefile.am
index dc9d4a5..a0792af 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,2 +1,2 @@
 AUTOMAKE_OPTIONS= foreign
-SUBDIRS= gtkworkbook/OBJS src/OBJS src/largefile/OBJS src/realtime/OBJS
\ No newline at end of file
+SUBDIRS=cfg gtkworkbook/OBJS src/OBJS
diff --git a/Makefile.in b/Makefile.in
new file mode 100644
index 0000000..bdbd25a
--- /dev/null
+++ b/Makefile.in
@@ -0,0 +1,620 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = .
+DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in $(top_srcdir)/configure INSTALL TODO \
+	config.guess config.sub depcomp install-sh ltmain.sh missing
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  { test ! -d $(distdir) \
+    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \
+         && rm -fr $(distdir); }; }
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+distuninstallcheck_listfiles = find . -type f -print
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = foreign
+SUBDIRS = cfg gtkworkbook/OBJS src/OBJS
+all: all-recursive
+
+.SUFFIXES:
+am--refresh:
+	@:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
+	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	test -d $(distdir) || mkdir $(distdir)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r $(distdir)
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
+	$(am__remove_distdir)
+
+dist-lzma: distdir
+	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
+	$(am__remove_distdir)
+
+dist-tarZ: distdir
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__remove_distdir)
+
+dist-shar: distdir
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__remove_distdir)
+
+dist dist-all: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lzma*) \
+	  unlzma -c $(distdir).tar.lzma | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir); chmod a+w $(distdir)
+	mkdir $(distdir)/_build
+	mkdir $(distdir)/_inst
+	chmod a-w $(distdir)
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && cd $(distdir)/_build \
+	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck
+	$(am__remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@cd $(distuninstallcheck_dir) \
+	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am am--refresh check check-am clean clean-generic \
+	clean-libtool ctags ctags-recursive dist dist-all dist-bzip2 \
+	dist-gzip dist-lzma dist-shar dist-tarZ dist-zip distcheck \
+	distclean distclean-generic distclean-libtool distclean-tags \
+	distcleancheck distdir distuninstallcheck dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/cfg/Makefile b/cfg/Makefile
new file mode 100644
index 0000000..fbe1a96
--- /dev/null
+++ b/cfg/Makefile
@@ -0,0 +1,337 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# cfg/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+pkgdatadir = $(datadir)/gtkworkbook
+pkglibdir = $(libdir)/gtkworkbook
+pkgincludedir = $(includedir)/gtkworkbook
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = x86_64-unknown-linux-gnu
+host_triplet = x86_64-unknown-linux-gnu
+subdir = cfg
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run aclocal-1.10
+AMTAR = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run automake-1.10
+AWK = mawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DPACKAGE_NAME=\"gtkworkbook\" -DPACKAGE_TARNAME=\"gtkworkbook\" -DPACKAGE_VERSION=\"0.20\" -DPACKAGE_STRING=\"gtkworkbook\ 0.20\" -DPACKAGE_BUGREPORT=\"jvb4@njit.edu\" -DPACKAGE=\"gtkworkbook\" -DVERSION=\"0.20\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DHAVE_LIBDL=1 -DHAVE_ARPA_INET_H=1 -DHAVE_NETDB_H=1 -DHAVE_NETINET_IN_H=1 -DHAVE_STRING_H=1 -DHAVE_SYS_SOCKET_H=1 -DHAVE_SYS_TIME_H=1 -DHAVE_UNISTD_H=1 -DHAVE__BOOL=1 -DHAVE_STDBOOL_H=1 -DHAVE_GETHOSTBYNAME=1 -DHAVE_GETTIMEOFDAY=1 -DHAVE_MEMSET=1 -DHAVE_SOCKET=1
+DEPDIR = .deps
+DSYMUTIL = 
+DUMPBIN = 
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = /bin/grep -E
+EXEEXT = 
+FGREP = /bin/grep -F
+GREP = /bin/grep
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LD = /usr/bin/ld -m elf_x86_64
+LDFLAGS = 
+LIBOBJS = 
+LIBS = -ldl 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LIPO = 
+LN_S = ln -s
+LTLIBOBJS = 
+MAKEINFO = ${SHELL} /home/jbellone/work/gtkworkbook/missing --run makeinfo
+MKDIR_P = /bin/mkdir -p
+NM = /usr/bin/nm -B
+NMEDIT = 
+OBJDUMP = objdump
+OBJEXT = o
+OTOOL = 
+OTOOL64 = 
+PACKAGE = gtkworkbook
+PACKAGE_BUGREPORT = jvb4@njit.edu
+PACKAGE_NAME = gtkworkbook
+PACKAGE_STRING = gtkworkbook 0.20
+PACKAGE_TARNAME = gtkworkbook
+PACKAGE_VERSION = 0.20
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SED = /bin/sed
+SET_MAKE = 
+SHELL = /bin/bash
+STRIP = strip
+VERSION = 0.20
+abs_builddir = /home/jbellone/work/gtkworkbook/cfg
+abs_srcdir = /home/jbellone/work/gtkworkbook/cfg
+abs_top_builddir = /home/jbellone/work/gtkworkbook
+abs_top_srcdir = /home/jbellone/work/gtkworkbook
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_DUMPBIN = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build = x86_64-unknown-linux-gnu
+build_alias = 
+build_cpu = x86_64
+build_os = linux-gnu
+build_vendor = unknown
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host = x86_64-unknown-linux-gnu
+host_alias = 
+host_cpu = x86_64
+host_os = linux-gnu
+host_vendor = unknown
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = $(SHELL) /home/jbellone/work/gtkworkbook/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+lt_ECHO = echo
+mandir = ${datarootdir}/man
+mkdir_p = /bin/mkdir -p
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = ${prefix}/etc
+target_alias = 
+top_build_prefix = ../
+top_builddir = ..
+top_srcdir = ..
+AUTOMAKE_OPTIONS = foreign
+cfgdir = $(prefix)/cfg
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  cfg/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  cfg/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+	@$(NORMAL_INSTALL)
+	$(MAKE) $(AM_MAKEFLAGS) install-data-hook
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-data-am install-strip
+
+.PHONY: all all-am check check-am clean clean-generic clean-libtool \
+	distclean distclean-generic distclean-libtool distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-data-hook install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	uninstall uninstall-am
+
+
+install-data-hook:
+	mkdir -p $(cfgdir)
+	cp $(top_srcdir)/cfg/application.cfg $(cfgdir)/application.cfg
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/cfg/Makefile.am b/cfg/Makefile.am
new file mode 100644
index 0000000..33b363a
--- /dev/null
+++ b/cfg/Makefile.am
@@ -0,0 +1,6 @@
+AUTOMAKE_OPTIONS= foreign
+cfgdir=$(prefix)/cfg
+
+install-data-hook:
+	mkdir -p $(cfgdir)
+	cp $(top_srcdir)/cfg/application.cfg $(cfgdir)/application.cfg
diff --git a/cfg/Makefile.in b/cfg/Makefile.in
new file mode 100644
index 0000000..9f51899
--- /dev/null
+++ b/cfg/Makefile.in
@@ -0,0 +1,337 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = cfg
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = foreign
+cfgdir = $(prefix)/cfg
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  cfg/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  cfg/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+	@$(NORMAL_INSTALL)
+	$(MAKE) $(AM_MAKEFLAGS) install-data-hook
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-data-am install-strip
+
+.PHONY: all all-am check check-am clean clean-generic clean-libtool \
+	distclean distclean-generic distclean-libtool distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-data-hook install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	uninstall uninstall-am
+
+
+install-data-hook:
+	mkdir -p $(cfgdir)
+	cp $(top_srcdir)/cfg/application.cfg $(cfgdir)/application.cfg
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/configure b/configure
index 11e19eb..80649ea 100755
--- a/configure
+++ b/configure
@@ -573,6 +573,155 @@ as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
 
+
+# Check that we are running under the correct shell.
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+case X$lt_ECHO in
+X*--fallback-echo)
+  # Remove one level of quotation (which was required for Make).
+  ECHO=`echo "$lt_ECHO" | sed 's,\\\\\$\\$0,'$0','`
+  ;;
+esac
+
+ECHO=${lt_ECHO-echo}
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' ; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell.
+  exec $SHELL "$0" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<_LT_EOF
+$*
+_LT_EOF
+  exit 0
+fi
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test -z "$lt_ECHO"; then
+  if test "X${echo_test_string+set}" != Xset; then
+    # find a string as large as possible, as long as the shell can cope with it
+    for cmd in 'sed 50q "$0"' 'sed 20q "$0"' 'sed 10q "$0"' 'sed 2q "$0"' 'echo test'; do
+      # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...
+      if { echo_test_string=`eval $cmd`; } 2>/dev/null &&
+	 { test "X$echo_test_string" = "X$echo_test_string"; } 2>/dev/null
+      then
+        break
+      fi
+    done
+  fi
+
+  if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
+     echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+     test "X$echo_testing_string" = "X$echo_test_string"; then
+    :
+  else
+    # The Solaris, AIX, and Digital Unix default echo programs unquote
+    # backslashes.  This makes it impossible to quote backslashes using
+    #   echo "$something" | sed 's/\\/\\\\/g'
+    #
+    # So, first we look for a working echo in the user's PATH.
+
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for dir in $PATH /usr/ucb; do
+      IFS="$lt_save_ifs"
+      if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&
+         test "X`($dir/echo '\t') 2>/dev/null`" = 'X\t' &&
+         echo_testing_string=`($dir/echo "$echo_test_string") 2>/dev/null` &&
+         test "X$echo_testing_string" = "X$echo_test_string"; then
+        ECHO="$dir/echo"
+        break
+      fi
+    done
+    IFS="$lt_save_ifs"
+
+    if test "X$ECHO" = Xecho; then
+      # We didn't find a better echo, so look for alternatives.
+      if test "X`{ print -r '\t'; } 2>/dev/null`" = 'X\t' &&
+         echo_testing_string=`{ print -r "$echo_test_string"; } 2>/dev/null` &&
+         test "X$echo_testing_string" = "X$echo_test_string"; then
+        # This shell has a builtin print -r that does the trick.
+        ECHO='print -r'
+      elif { test -f /bin/ksh || test -f /bin/ksh$ac_exeext; } &&
+	   test "X$CONFIG_SHELL" != X/bin/ksh; then
+        # If we have ksh, try running configure again with it.
+        ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+        export ORIGINAL_CONFIG_SHELL
+        CONFIG_SHELL=/bin/ksh
+        export CONFIG_SHELL
+        exec $CONFIG_SHELL "$0" --no-reexec ${1+"$@"}
+      else
+        # Try using printf.
+        ECHO='printf %s\n'
+        if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
+	   echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	  # Cool, printf works
+	  :
+        elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	     test "X$echo_testing_string" = 'X\t' &&
+	     echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	     test "X$echo_testing_string" = "X$echo_test_string"; then
+	  CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL
+	  export CONFIG_SHELL
+	  SHELL="$CONFIG_SHELL"
+	  export SHELL
+	  ECHO="$CONFIG_SHELL $0 --fallback-echo"
+        elif echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	     test "X$echo_testing_string" = 'X\t' &&
+	     echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	     test "X$echo_testing_string" = "X$echo_test_string"; then
+	  ECHO="$CONFIG_SHELL $0 --fallback-echo"
+        else
+	  # maybe with a smaller string...
+	  prev=:
+
+	  for cmd in 'echo test' 'sed 2q "$0"' 'sed 10q "$0"' 'sed 20q "$0"' 'sed 50q "$0"'; do
+	    if { test "X$echo_test_string" = "X`eval $cmd`"; } 2>/dev/null
+	    then
+	      break
+	    fi
+	    prev="$cmd"
+	  done
+
+	  if test "$prev" != 'sed 50q "$0"'; then
+	    echo_test_string=`eval $prev`
+	    export echo_test_string
+	    exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} "$0" ${1+"$@"}
+	  else
+	    # Oops.  We lost completely, so just stick with echo.
+	    ECHO=echo
+	  fi
+        fi
+      fi
+    fi
+  fi
+fi
+
+# Copy echo and quote the copy suitably for passing to libtool from
+# the Makefile, instead of quoting the original, which is used later.
+lt_ECHO=$ECHO
+if test "X$lt_ECHO" = "X$CONFIG_SHELL $0 --fallback-echo"; then
+   lt_ECHO="$CONFIG_SHELL \\\$\$0 --fallback-echo"
+fi
+
+
+
+
 exec 7<&0 </dev/null 6>&1
 
 # Name of the host.
@@ -639,19 +788,50 @@ ac_includes_default="\
 
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+CXXCPP
+OTOOL64
+OTOOL
+LIPO
+NMEDIT
+DSYMUTIL
+lt_ECHO
+AR
+OBJDUMP
+NM
+ac_ct_DUMPBIN
+DUMPBIN
+LD
+FGREP
 EGREP
 GREP
+SED
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+LIBTOOL
 RANLIB
-SET_MAKE
 LN_S
-INSTALL_DATA
-INSTALL_SCRIPT
-INSTALL_PROGRAM
 CPP
+am__fastdepCC_FALSE
+am__fastdepCC_TRUE
+CCDEPMODE
 ac_ct_CC
 CFLAGS
 CC
-AWK
+am__fastdepCXX_FALSE
+am__fastdepCXX_TRUE
+CXXDEPMODE
+AMDEPBACKSLASH
+AMDEP_FALSE
+AMDEP_TRUE
+am__quote
+am__include
+DEPDIR
 OBJEXT
 EXEEXT
 ac_ct_CXX
@@ -659,6 +839,29 @@ CPPFLAGS
 LDFLAGS
 CXXFLAGS
 CXX
+am__untar
+am__tar
+AMTAR
+am__leading_dot
+SET_MAKE
+AWK
+mkdir_p
+MKDIR_P
+INSTALL_STRIP_PROGRAM
+STRIP
+install_sh
+MAKEINFO
+AUTOHEADER
+AUTOMAKE
+AUTOCONF
+ACLOCAL
+VERSION
+PACKAGE
+CYGPATH_W
+am__isrc
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
 target_alias
 host_alias
 build_alias
@@ -699,6 +902,13 @@ SHELL'
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
+enable_dependency_tracking
+enable_shared
+enable_static
+with_pic
+enable_fast_install
+with_gnu_ld
+enable_libtool_lock
 '
       ac_precious_vars='build_alias
 host_alias
@@ -711,7 +921,8 @@ CPPFLAGS
 CCC
 CC
 CFLAGS
-CPP'
+CPP
+CXXCPP'
 
 
 # Initialize some variables set by options.
@@ -1320,6 +1531,15 @@ Fine tuning of the installation directories:
 _ACEOF
 
   cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
@@ -1329,6 +1549,25 @@ if test -n "$ac_init_help"; then
    esac
   cat <<\_ACEOF
 
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+  --enable-shared[=PKGS]  build shared libraries [default=yes]
+  --enable-static[=PKGS]  build static libraries [default=yes]
+  --enable-fast-install[=PKGS]
+                          optimize for fast installation [default=yes]
+  --disable-libtool-lock  avoid locking (might break parallel builds)
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-pic              try to use only PIC/non-PIC objects [default=use
+                          both]
+  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
+
 Some influential environment variables:
   CXX         C++ compiler command
   CXXFLAGS    C++ compiler flags
@@ -1340,6 +1579,7 @@ Some influential environment variables:
   CC          C compiler command
   CFLAGS      C compiler flags
   CPP         C preprocessor
+  CXXCPP      C++ preprocessor
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
@@ -1790,6 +2030,496 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
+am__api_version='1.10'
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { $as_echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
+$as_echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ $as_echo "$as_me:$LINENO: checking whether build environment is sane" >&5
+$as_echo_n "checking whether build environment is sane... " >&6; }
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      { { $as_echo "$as_me:$LINENO: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" >&5
+$as_echo "$as_me: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" >&2;}
+   { (exit 1); exit 1; }; }
+   fi
+
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   { { $as_echo "$as_me:$LINENO: error: newly created file is older than distributed files!
+Check your system clock" >&5
+$as_echo "$as_me: error: newly created file is older than distributed files!
+Check your system clock" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.
+# By default was `s,x,x', remove it if useless.
+ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
+program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
+
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  { $as_echo "$as_me:$LINENO: WARNING: \`missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for a thread-safe mkdir -p" >&5
+$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
+if test -z "$MKDIR_P"; then
+  if test "${ac_cv_path_mkdir+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in mkdir gmkdir; do
+	 for ac_exec_ext in '' $ac_executable_extensions; do
+	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
+	     'mkdir (GNU coreutils) '* | \
+	     'mkdir (coreutils) '* | \
+	     'mkdir (fileutils) '4.1*)
+	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
+	       break 3;;
+	   esac
+	 done
+       done
+done
+IFS=$as_save_IFS
+
+fi
+
+  if test "${ac_cv_path_mkdir+set}" = set; then
+    MKDIR_P="$ac_cv_path_mkdir -p"
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for MKDIR_P within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    test -d ./--version && rmdir ./--version
+    MKDIR_P="$ac_install_sh -d"
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $MKDIR_P" >&5
+$as_echo "$MKDIR_P" >&6; }
+
+mkdir_p="$MKDIR_P"
+case $mkdir_p in
+  [\\/$]* | ?:[\\/]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AWK+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:$LINENO: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+{ $as_echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  am__isrc=' -I$(srcdir)'
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    { { $as_echo "$as_me:$LINENO: error: source directory already configured; run \"make distclean\" there first" >&5
+$as_echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+ PACKAGE=gtkworkbook
+ VERSION=0.20
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE "$PACKAGE"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define VERSION "$VERSION"
+_ACEOF
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+install_sh=${install_sh-"\$(SHELL) $am_aux_dir/install-sh"}
+
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:$LINENO: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
+
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+
+
+
+
 
 # Checks for programs.
 ac_ext=cpp
@@ -2413,6 +3143,176 @@ ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ $as_echo "$as_me:$LINENO: checking for style of include used by $am_make" >&5
+$as_echo_n "checking for style of include used by $am_make... " >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: result: $_am_result" >&5
+$as_echo "$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+ if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+depcc="$CXX"  am_compiler_list=
+
+{ $as_echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if test "${am_cv_CXX_dependencies_compiler_type+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CXX_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CXX_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CXX_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $am_cv_CXX_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CXX_dependencies_compiler_type" >&6; }
+CXXDEPMODE=depmode=$am_cv_CXX_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CXX_dependencies_compiler_type" = gcc3; then
+  am__fastdepCXX_TRUE=
+  am__fastdepCXX_FALSE='#'
+else
+  am__fastdepCXX_TRUE='#'
+  am__fastdepCXX_FALSE=
+fi
+
 
 for ac_prog in gawk mawk nawk awk
 do
@@ -3139,6 +4039,114 @@ ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
+depcc="$CC"   am_compiler_list=
+
+{ $as_echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $am_cv_CC_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -3375,37 +4383,6 @@ ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  { { $as_echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
-$as_echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
-
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
 # incompatible versions:
@@ -3633,81 +4610,197 @@ else
   RANLIB="$ac_cv_prog_RANLIB"
 fi
 
+case `pwd` in
+  *\ * | *\	*)
+    { $as_echo "$as_me:$LINENO: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
+$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
+esac
 
-# Checks for libraries.
-# FIXME: Replace `main' with a function in `-ldl':
 
 
-{ $as_echo "$as_me:$LINENO: checking for main in -ldl" >&5
-$as_echo_n "checking for main in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_main+set}" = set; then
+macro_version='2.2.6'
+macro_revision='1.3012'
+
+
+
+
+
+
+
+
+
+
+
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  { { $as_echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
+$as_echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+{ $as_echo "$as_me:$LINENO: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if test "${ac_cv_build+set}" = set; then
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  { { $as_echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+$as_echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
+$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
 
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
+$as_echo "$as_me: error: invalid value of canonical build" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:$LINENO: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if test "${ac_cv_host+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
+$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+fi
 
-int
-main ()
-{
-return main ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
+$as_echo "$as_me: error: invalid value of canonical host" >&2;}
+   { (exit 1); exit 1; }; };;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_dl_main=yes
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:$LINENO: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if test "${ac_cv_path_SED+set}" = set; then
+  $as_echo_n "(cached) " >&6
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     $as_unset ac_script || ac_script=
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
 
-	ac_cv_lib_dl_main=no
+      $ac_path_SED_found && break 3
+    done
+  done
+done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    { { $as_echo "$as_me:$LINENO: error: no acceptable sed could be found in \$PATH" >&5
+$as_echo "$as_me: error: no acceptable sed could be found in \$PATH" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  ac_cv_path_SED=$SED
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_main" >&5
-$as_echo "$ac_cv_lib_dl_main" >&6; }
-if test "x$ac_cv_lib_dl_main" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBDL 1
-_ACEOF
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+
+
+
+
+
+
 
-  LIBS="-ldl $LIBS"
 
-fi
 
 
-# Checks for header files.
 
 { $as_echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
 $as_echo_n "checking for grep that handles long lines and -e... " >&6; }
@@ -3843,6 +4936,2389 @@ $as_echo "$ac_cv_path_EGREP" >&6; }
  EGREP="$ac_cv_path_EGREP"
 
 
+{ $as_echo "$as_me:$LINENO: checking for fgrep" >&5
+$as_echo_n "checking for fgrep... " >&6; }
+if test "${ac_cv_path_FGREP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
+   then ac_cv_path_FGREP="$GREP -F"
+   else
+     if test -z "$FGREP"; then
+  ac_path_FGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in fgrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
+# Check for GNU ac_path_FGREP and select it if it is found.
+  # Check for GNU $ac_path_FGREP
+case `"$ac_path_FGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'FGREP' >> "conftest.nl"
+    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_FGREP="$ac_path_FGREP"
+      ac_path_FGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_FGREP_found && break 3
+    done
+  done
+done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_FGREP"; then
+    { { $as_echo "$as_me:$LINENO: error: no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+$as_echo "$as_me: error: no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  ac_cv_path_FGREP=$FGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_FGREP" >&5
+$as_echo "$ac_cv_path_FGREP" >&6; }
+ FGREP="$ac_cv_path_FGREP"
+
+
+test -z "$GREP" && GREP=grep
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:$LINENO: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:$LINENO: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:$LINENO: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${lt_cv_path_LD+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:$LINENO: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && { { $as_echo "$as_me:$LINENO: error: no acceptable ld found in \$PATH" >&5
+$as_echo "$as_me: error: no acceptable ld found in \$PATH" >&2;}
+   { (exit 1); exit 1; }; }
+{ $as_echo "$as_me:$LINENO: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${lt_cv_prog_gnu_ld+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for BSD- or MS-compatible name lister (nm)" >&5
+$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
+if test "${lt_cv_path_NM+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_path_NM" >&5
+$as_echo "$lt_cv_path_NM" >&6; }
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in "dumpbin -symbols" "link -dump -symbols"
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DUMPBIN+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DUMPBIN"; then
+  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+DUMPBIN=$ac_cv_prog_DUMPBIN
+if test -n "$DUMPBIN"; then
+  { $as_echo "$as_me:$LINENO: result: $DUMPBIN" >&5
+$as_echo "$DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$DUMPBIN" && break
+  done
+fi
+if test -z "$DUMPBIN"; then
+  ac_ct_DUMPBIN=$DUMPBIN
+  for ac_prog in "dumpbin -symbols" "link -dump -symbols"
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DUMPBIN"; then
+  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
+if test -n "$ac_ct_DUMPBIN"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_DUMPBIN" >&5
+$as_echo "$ac_ct_DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_DUMPBIN" && break
+done
+
+  if test "x$ac_ct_DUMPBIN" = x; then
+    DUMPBIN=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DUMPBIN=$ac_ct_DUMPBIN
+  fi
+fi
+
+
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+
+
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking the name lister ($NM) interface" >&5
+$as_echo_n "checking the name lister ($NM) interface... " >&6; }
+if test "${lt_cv_nm_interface+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:5315: $ac_compile\"" >&5)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:5318: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:5321: output\"" >&5)
+  cat conftest.out >&5
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_nm_interface" >&5
+$as_echo "$lt_cv_nm_interface" >&6; }
+
+# find the maximum length of command line arguments
+{ $as_echo "$as_me:$LINENO: checking the maximum length of command line arguments" >&5
+$as_echo_n "checking the maximum length of command line arguments... " >&6; }
+if test "${lt_cv_sys_max_cmd_len+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+    i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`$SHELL $0 --fallback-echo "X$teststring$teststring" 2>/dev/null` \
+	         = "XX$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+
+fi
+
+if test -n $lt_cv_sys_max_cmd_len ; then
+  { $as_echo "$as_me:$LINENO: result: $lt_cv_sys_max_cmd_len" >&5
+$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: none" >&5
+$as_echo "none" >&6; }
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+
+
+
+
+
+
+: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+
+{ $as_echo "$as_me:$LINENO: checking whether the shell understands some XSI constructs" >&5
+$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+{ $as_echo "$as_me:$LINENO: result: $xsi_shell" >&5
+$as_echo "$xsi_shell" >&6; }
+
+
+{ $as_echo "$as_me:$LINENO: checking whether the shell understands \"+=\"" >&5
+$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+{ $as_echo "$as_me:$LINENO: result: $lt_shell_append" >&5
+$as_echo "$lt_shell_append" >&6; }
+
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+
+
+
+
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for $LD option to reload object files" >&5
+$as_echo_n "checking for $LD option to reload object files... " >&6; }
+if test "${lt_cv_ld_reload_flag+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_ld_reload_flag" >&5
+$as_echo "$lt_cv_ld_reload_flag" >&6; }
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
+set dummy ${ac_tool_prefix}objdump; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OBJDUMP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OBJDUMP"; then
+  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+OBJDUMP=$ac_cv_prog_OBJDUMP
+if test -n "$OBJDUMP"; then
+  { $as_echo "$as_me:$LINENO: result: $OBJDUMP" >&5
+$as_echo "$OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OBJDUMP"; then
+  ac_ct_OBJDUMP=$OBJDUMP
+  # Extract the first word of "objdump", so it can be a program name with args.
+set dummy objdump; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OBJDUMP"; then
+  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OBJDUMP="objdump"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
+if test -n "$ac_ct_OBJDUMP"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_OBJDUMP" >&5
+$as_echo "$ac_ct_OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OBJDUMP" = x; then
+    OBJDUMP="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OBJDUMP=$ac_ct_OBJDUMP
+  fi
+else
+  OBJDUMP="$ac_cv_prog_OBJDUMP"
+fi
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking how to recognize dependent libraries" >&5
+$as_echo_n "checking how to recognize dependent libraries... " >&6; }
+if test "${lt_cv_deplibs_check_method+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[4-9]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[45]*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  if ( file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - PA-RISC [0-9].[0-9]'
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9].[0-9]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[3-9]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd* | netbsdelf*-gnu)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_deplibs_check_method" >&5
+$as_echo "$lt_cv_deplibs_check_method" >&6; }
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AR+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:$LINENO: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_AR="ar"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_AR" = x; then
+    AR="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+else
+  AR="$ac_cv_prog_AR"
+fi
+
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:$LINENO: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+test -z "$STRIP" && STRIP=:
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:$LINENO: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+test -z "$RANLIB" && RANLIB=:
+
+
+
+
+
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+{ $as_echo "$as_me:$LINENO: checking command to parse $NM output from $compiler object" >&5
+$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
+if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[BCDEGRST]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[BCDT]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[ABCDGISTW]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[ABCDEGRST]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[BCDEGRST]'
+  ;;
+osf*)
+  symcode='[BCDEGQRST]'
+  ;;
+solaris*)
+  symcode='[BDRT]'
+  ;;
+sco3.2v5*)
+  symcode='[DT]'
+  ;;
+sysv4.2uw2*)
+  symcode='[DT]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[ABDT]'
+  ;;
+sysv4)
+  symcode='[DFNSTU]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[ABCDGIRSTW]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK '"\
+"     {last_section=section; section=\$ 3};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if { (eval echo "$as_me:$LINENO: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\"") >&5
+  (eval $NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+const struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_save_LIBS="$LIBS"
+	  lt_save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
+	  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$lt_save_LIBS"
+	  CFLAGS="$lt_save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&5
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&5
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
+    fi
+  else
+    echo "$progname: failed program was:" >&5
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+
+fi
+
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  { $as_echo "$as_me:$LINENO: result: failed" >&5
+$as_echo "failed" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: ok" >&5
+$as_echo "ok" >&6; }
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --enable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then
+  enableval=$enable_libtool_lock;
+fi
+
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line 6516 "configure"' > conftest.$ac_ext
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_i386"
+	    ;;
+	  ppc64-*linux*|powerpc64-*linux*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  ppc*-*linux*|powerpc*-*linux*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  { $as_echo "$as_me:$LINENO: checking whether the C compiler needs -belf" >&5
+$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
+if test "${lt_cv_cc_needs_belf+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+     cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  lt_cv_cc_needs_belf=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	lt_cv_cc_needs_belf=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_cc_needs_belf" >&5
+$as_echo "$lt_cv_cc_needs_belf" >&6; }
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+
+
+  case $host_os in
+    rhapsody* | darwin*)
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
+set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DSYMUTIL+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DSYMUTIL"; then
+  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+DSYMUTIL=$ac_cv_prog_DSYMUTIL
+if test -n "$DSYMUTIL"; then
+  { $as_echo "$as_me:$LINENO: result: $DSYMUTIL" >&5
+$as_echo "$DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_DSYMUTIL"; then
+  ac_ct_DSYMUTIL=$DSYMUTIL
+  # Extract the first word of "dsymutil", so it can be a program name with args.
+set dummy dsymutil; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DSYMUTIL"; then
+  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
+if test -n "$ac_ct_DSYMUTIL"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_DSYMUTIL" >&5
+$as_echo "$ac_ct_DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_DSYMUTIL" = x; then
+    DSYMUTIL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DSYMUTIL=$ac_ct_DSYMUTIL
+  fi
+else
+  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
+set dummy ${ac_tool_prefix}nmedit; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_NMEDIT+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NMEDIT"; then
+  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+NMEDIT=$ac_cv_prog_NMEDIT
+if test -n "$NMEDIT"; then
+  { $as_echo "$as_me:$LINENO: result: $NMEDIT" >&5
+$as_echo "$NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_NMEDIT"; then
+  ac_ct_NMEDIT=$NMEDIT
+  # Extract the first word of "nmedit", so it can be a program name with args.
+set dummy nmedit; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_NMEDIT"; then
+  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_NMEDIT="nmedit"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
+if test -n "$ac_ct_NMEDIT"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_NMEDIT" >&5
+$as_echo "$ac_ct_NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_NMEDIT" = x; then
+    NMEDIT=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    NMEDIT=$ac_ct_NMEDIT
+  fi
+else
+  NMEDIT="$ac_cv_prog_NMEDIT"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
+set dummy ${ac_tool_prefix}lipo; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_LIPO+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$LIPO"; then
+  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+LIPO=$ac_cv_prog_LIPO
+if test -n "$LIPO"; then
+  { $as_echo "$as_me:$LINENO: result: $LIPO" >&5
+$as_echo "$LIPO" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_LIPO"; then
+  ac_ct_LIPO=$LIPO
+  # Extract the first word of "lipo", so it can be a program name with args.
+set dummy lipo; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_LIPO"; then
+  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_LIPO="lipo"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
+if test -n "$ac_ct_LIPO"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_LIPO" >&5
+$as_echo "$ac_ct_LIPO" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_LIPO" = x; then
+    LIPO=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    LIPO=$ac_ct_LIPO
+  fi
+else
+  LIPO="$ac_cv_prog_LIPO"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL"; then
+  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL=$ac_cv_prog_OTOOL
+if test -n "$OTOOL"; then
+  { $as_echo "$as_me:$LINENO: result: $OTOOL" >&5
+$as_echo "$OTOOL" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL"; then
+  ac_ct_OTOOL=$OTOOL
+  # Extract the first word of "otool", so it can be a program name with args.
+set dummy otool; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL"; then
+  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL="otool"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
+if test -n "$ac_ct_OTOOL"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_OTOOL" >&5
+$as_echo "$ac_ct_OTOOL" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL" = x; then
+    OTOOL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL=$ac_ct_OTOOL
+  fi
+else
+  OTOOL="$ac_cv_prog_OTOOL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool64; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL64+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL64"; then
+  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL64=$ac_cv_prog_OTOOL64
+if test -n "$OTOOL64"; then
+  { $as_echo "$as_me:$LINENO: result: $OTOOL64" >&5
+$as_echo "$OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL64"; then
+  ac_ct_OTOOL64=$OTOOL64
+  # Extract the first word of "otool64", so it can be a program name with args.
+set dummy otool64; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL64"; then
+  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL64="otool64"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
+if test -n "$ac_ct_OTOOL64"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_OTOOL64" >&5
+$as_echo "$ac_ct_OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL64" = x; then
+    OTOOL64=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL64=$ac_ct_OTOOL64
+  fi
+else
+  OTOOL64="$ac_cv_prog_OTOOL64"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    { $as_echo "$as_me:$LINENO: checking for -single_module linker flag" >&5
+$as_echo_n "checking for -single_module linker flag... " >&6; }
+if test "${lt_cv_apple_cc_single_mod+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&5
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&5
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_apple_cc_single_mod" >&5
+$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
+    { $as_echo "$as_me:$LINENO: checking for -exported_symbols_list linker flag" >&5
+$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
+if test "${lt_cv_ld_exported_symbols_list+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  lt_cv_ld_exported_symbols_list=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	lt_cv_ld_exported_symbols_list=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+	LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_ld_exported_symbols_list" >&5
+$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
+    case $host_os in
+    rhapsody* | darwin1.[012])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[012]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+
+
 { $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
 $as_echo_n "checking for ANSI C header files... " >&6; }
 if test "${ac_cv_header_stdc+set}" = set; then
@@ -4095,6 +7571,7937 @@ done
 
 
 
+for ac_header in dlfcn.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  { $as_echo "$as_me:$LINENO: result: $CXX" >&5
+$as_echo "$CXX" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CXX" >&5
+$as_echo "$ac_ct_CXX" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CXX" && break
+done
+
+  if test "x$ac_ct_CXX" = x; then
+    CXX="g++"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CXX=$ac_ct_CXX
+  fi
+fi
+
+  fi
+fi
+# Provide some information about the compiler.
+$as_echo "$as_me:$LINENO: checking for C++ compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C++ compiler" >&5
+$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
+if test "${ac_cv_cxx_compiler_gnu+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu" >&5
+$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GXX=yes
+else
+  GXX=
+fi
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+{ $as_echo "$as_me:$LINENO: checking whether $CXX accepts -g" >&5
+$as_echo_n "checking whether $CXX accepts -g... " >&6; }
+if test "${ac_cv_prog_cxx_g+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
+   ac_cxx_werror_flag=yes
+   ac_cv_prog_cxx_g=no
+   CXXFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cxx_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CXXFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+	 CXXFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cxx_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cxx_g" >&5
+$as_echo "$ac_cv_prog_cxx_g" >&6; }
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+depcc="$CXX"  am_compiler_list=
+
+{ $as_echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if test "${am_cv_CXX_dependencies_compiler_type+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CXX_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CXX_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CXX_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $am_cv_CXX_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CXX_dependencies_compiler_type" >&6; }
+CXXDEPMODE=depmode=$am_cv_CXX_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CXX_dependencies_compiler_type" = gcc3; then
+  am__fastdepCXX_TRUE=
+  am__fastdepCXX_FALSE='#'
+else
+  am__fastdepCXX_TRUE='#'
+  am__fastdepCXX_FALSE=
+fi
+
+
+if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+    (test "X$CXX" != "Xg++"))) ; then
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+{ $as_echo "$as_me:$LINENO: checking how to run the C++ preprocessor" >&5
+$as_echo_n "checking how to run the C++ preprocessor... " >&6; }
+if test -z "$CXXCPP"; then
+  if test "${ac_cv_prog_CXXCPP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CXXCPP needs to be expanded
+    for CXXCPP in "$CXX -E" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_cxx_preproc_warn_flag$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_cxx_preproc_warn_flag$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CXXCPP=$CXXCPP
+
+fi
+  CXXCPP=$ac_cv_prog_CXXCPP
+else
+  ac_cv_prog_CXXCPP=$CXXCPP
+fi
+{ $as_echo "$as_me:$LINENO: result: $CXXCPP" >&5
+$as_echo "$CXXCPP" >&6; }
+ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_cxx_preproc_warn_flag$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_cxx_preproc_warn_flag$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+_lt_caught_CXX_error=yes; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+else
+  _lt_caught_CXX_error=yes
+fi
+
+
+
+
+
+# Set options
+
+
+
+        enable_dlopen=no
+
+
+  enable_win32_dll=no
+
+
+            # Check whether --enable-shared was given.
+if test "${enable_shared+set}" = set; then
+  enableval=$enable_shared; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_shared=yes
+fi
+
+
+
+
+
+
+
+
+
+  # Check whether --enable-static was given.
+if test "${enable_static+set}" = set; then
+  enableval=$enable_static; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_static=yes
+fi
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-pic was given.
+if test "${with_pic+set}" = set; then
+  withval=$with_pic; pic_mode="$withval"
+else
+  pic_mode=default
+fi
+
+
+test -z "$pic_mode" && pic_mode=default
+
+
+
+
+
+
+
+  # Check whether --enable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then
+  enableval=$enable_fast_install; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_fast_install=yes
+fi
+
+
+
+
+
+
+
+
+
+
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+test -z "$LN_S" && LN_S="ln -s"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for objdir" >&5
+$as_echo_n "checking for objdir... " >&6; }
+if test "${lt_cv_objdir+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_objdir" >&5
+$as_echo "$lt_cv_objdir" >&6; }
+objdir=$lt_cv_objdir
+
+
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define LT_OBJDIR "$lt_cv_objdir/"
+_ACEOF
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
+
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    { $as_echo "$as_me:$LINENO: checking for ${ac_tool_prefix}file" >&5
+$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:$LINENO: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    { $as_echo "$as_me:$LINENO: checking for file" >&5
+$as_echo_n "checking for file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:$LINENO: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  else
+    MAGIC_CMD=:
+  fi
+fi
+
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+
+lt_save_CC="$CC"
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+objext=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+
+
+if test -n "$compiler"; then
+
+lt_prog_compiler_no_builtin_flag=
+
+if test "$GCC" = yes; then
+  lt_prog_compiler_no_builtin_flag=' -fno-builtin'
+
+  { $as_echo "$as_me:$LINENO: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
+if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_rtti_exceptions=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:8852: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:8856: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_rtti_exceptions=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
+
+if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
+else
+    :
+fi
+
+fi
+
+
+
+
+
+
+  lt_prog_compiler_wl=
+lt_prog_compiler_pic=
+lt_prog_compiler_static=
+
+{ $as_echo "$as_me:$LINENO: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl='-Wl,'
+    lt_prog_compiler_static='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            lt_prog_compiler_pic='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic='-fno-common'
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[3-9]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      lt_prog_compiler_pic='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      else
+	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-KPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='--shared'
+	lt_prog_compiler_static='--static'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fpic'
+	lt_prog_compiler_static='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static='-non_shared'
+        ;;
+      xl*)
+	# IBM XL C 8.0/Fortran 10.1 on PPC
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-qpic'
+	lt_prog_compiler_static='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)
+	  # Sun C 5.9
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl='-Wl,'
+	  ;;
+	*Sun\ F*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl=''
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    rdos*)
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    solaris*)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	lt_prog_compiler_wl='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      lt_prog_compiler_wl='-Qoption ld '
+      lt_prog_compiler_pic='-PIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic='-Kconform_pic'
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    unicos*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_can_build_shared=no
+      ;;
+
+    uts4*)
+      lt_prog_compiler_pic='-pic'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *)
+      lt_prog_compiler_can_build_shared=no
+      ;;
+    esac
+  fi
+
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic=
+    ;;
+  *)
+    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: result: $lt_prog_compiler_pic" >&5
+$as_echo "$lt_prog_compiler_pic" >&6; }
+
+
+
+
+
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic"; then
+  { $as_echo "$as_me:$LINENO: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
+if test "${lt_cv_prog_compiler_pic_works+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_pic_works=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:9191: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:9195: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_pic_works=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_pic_works" >&5
+$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
+    case $lt_prog_compiler_pic in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
+     esac
+else
+    lt_prog_compiler_pic=
+     lt_prog_compiler_can_build_shared=no
+fi
+
+fi
+
+
+
+
+
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
+{ $as_echo "$as_me:$LINENO: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_cv_prog_compiler_static_works+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_static_works=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler_static_works=yes
+       fi
+     else
+       lt_cv_prog_compiler_static_works=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_static_works" >&5
+$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_static_works" = xyes; then
+    :
+else
+    lt_prog_compiler_static=
+fi
+
+
+
+
+
+
+
+  { $as_echo "$as_me:$LINENO: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:9296: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:9300: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+
+
+  { $as_echo "$as_me:$LINENO: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:9351: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:9355: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:$LINENO: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:$LINENO: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:$LINENO: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+
+
+
+
+
+
+  { $as_echo "$as_me:$LINENO: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+
+  runpath_var=
+  allow_undefined_flag=
+  always_export_symbols=no
+  archive_cmds=
+  archive_expsym_cmds=
+  compiler_needs_object=no
+  enable_shared_with_static_runtimes=no
+  export_dynamic_flag_spec=
+  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  hardcode_automatic=no
+  hardcode_direct=no
+  hardcode_direct_absolute=no
+  hardcode_libdir_flag_spec=
+  hardcode_libdir_flag_spec_ld=
+  hardcode_libdir_separator=
+  hardcode_minus_L=no
+  hardcode_shlibpath_var=unsupported
+  inherit_rpath=no
+  link_all_deplibs=unknown
+  module_cmds=
+  module_expsym_cmds=
+  old_archive_from_new_cmds=
+  old_archive_from_expsyms_cmds=
+  thread_safe_flag_spec=
+  whole_archive_flag_spec=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
+
+  ld_shlibs=yes
+  if test "$with_gnu_ld" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      whole_archive_flag_spec=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[3-9]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      allow_undefined_flag=unsupported
+      always_export_symbols=no
+      enable_shared_with_static_runtimes=yes
+      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95*)	# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  whole_archive_flag_spec=
+	  tmp_sharedflag='--shared' ;;
+	xl[cC]*)			# IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
+	  hardcode_libdir_flag_spec=
+	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
+	  archive_cmds='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        ld_shlibs=no
+      fi
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    ld_shlibs=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+    esac
+
+    if test "$ld_shlibs" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec=
+      export_dynamic_flag_spec=
+      whole_archive_flag_spec=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      allow_undefined_flag=unsupported
+      always_export_symbols=yes
+      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct=unsupported
+      fi
+      ;;
+
+    aix[4-9]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      archive_cmds=''
+      hardcode_direct=yes
+      hardcode_direct_absolute=yes
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      file_list_spec='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  hardcode_direct=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L=yes
+	  hardcode_libdir_flag_spec='-L$libdir'
+	  hardcode_libdir_separator=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+	link_all_deplibs=no
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      export_dynamic_flag_spec='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag="-z nodefs"
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag=' ${wl}-bernotok'
+	  allow_undefined_flag=' ${wl}-berok'
+	  # Exported symbols can be pulled into shared objects from archives
+	  whole_archive_flag_spec='$convenience'
+	  archive_cmds_need_lc=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[45]*)
+      export_dynamic_flag_spec=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      allow_undefined_flag=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      archive_cmds='$CC -o $lib $libobjs $compiler_flags `$ECHO "X$deplibs" | $Xsed -e '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      old_archive_from_new_cmds='true'
+      # FIXME: Should let the user specify the lib program.
+      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
+      fix_srcfile_path='`cygpath -w "$srcfile"`'
+      enable_shared_with_static_runtimes=yes
+      ;;
+
+    darwin* | rhapsody*)
+
+
+  archive_cmds_need_lc=no
+  hardcode_direct=no
+  hardcode_automatic=yes
+  hardcode_shlibpath_var=unsupported
+  whole_archive_flag_spec=''
+  link_all_deplibs=yes
+  allow_undefined_flag="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=echo
+    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+
+  else
+  ld_shlibs=no
+  fi
+
+      ;;
+
+    dgux*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      export_dynamic_flag_spec='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_flag_spec_ld='+b $libdir'
+	hardcode_libdir_separator=:
+	hardcode_direct=yes
+	hardcode_direct_absolute=yes
+	export_dynamic_flag_spec='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_direct=no
+	  hardcode_shlibpath_var=no
+	  ;;
+	*)
+	  hardcode_direct=yes
+	  hardcode_direct_absolute=yes
+	  export_dynamic_flag_spec='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+        cat >conftest.$ac_ext <<_ACEOF
+int foo(void) {}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+        LDFLAGS="$save_LDFLAGS"
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      inherit_rpath=yes
+      link_all_deplibs=yes
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    newsos6)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_shlibpath_var=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	hardcode_direct=yes
+	hardcode_shlibpath_var=no
+	hardcode_direct_absolute=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	  export_dynamic_flag_spec='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     hardcode_libdir_flag_spec='-R$libdir'
+	     ;;
+	   *)
+	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      allow_undefined_flag=unsupported
+      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$ECHO DATA >> $output_objdir/$libname.def~$ECHO " SINGLE NONSHARED" >> $output_objdir/$libname.def~$ECHO EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_separator=:
+      ;;
+
+    solaris*)
+      no_undefined_flag=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_shlibpath_var=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      link_all_deplibs=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds='$CC -r -o $output$reload_objs'
+	  hardcode_direct=no
+        ;;
+	motorola)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4.3*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      export_dynamic_flag_spec='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      no_undefined_flag='${wl}-z,text'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag='${wl}-z,text'
+      allow_undefined_flag='${wl}-z,nodefs'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-R,$libdir'
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      export_dynamic_flag_spec='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      ld_shlibs=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	export_dynamic_flag_spec='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+
+{ $as_echo "$as_me:$LINENO: result: $ld_shlibs" >&5
+$as_echo "$ld_shlibs" >&6; }
+test "$ld_shlibs" = no && can_build_shared=no
+
+with_gnu_ld=$with_gnu_ld
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:$LINENO: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+      $RM conftest*
+      echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+      if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } 2>conftest.err; then
+        soname=conftest
+        lib=conftest
+        libobjs=conftest.$ac_objext
+        deplibs=
+        wl=$lt_prog_compiler_wl
+	pic_flag=$lt_prog_compiler_pic
+        compiler_flags=-v
+        linker_flags=-v
+        verstring=
+        output_objdir=.
+        libname=conftest
+        lt_save_allow_undefined_flag=$allow_undefined_flag
+        allow_undefined_flag=
+        if { (eval echo "$as_me:$LINENO: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\"") >&5
+  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+        then
+	  archive_cmds_need_lc=no
+        else
+	  archive_cmds_need_lc=yes
+        fi
+        allow_undefined_flag=$lt_save_allow_undefined_flag
+      else
+        cat conftest.err 1>&5
+      fi
+      $RM conftest*
+      { $as_echo "$as_me:$LINENO: result: $archive_cmds_need_lc" >&5
+$as_echo "$archive_cmds_need_lc" >&6; }
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:$LINENO: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+  if $ECHO "$lt_search_path_spec" | $GREP ';' >/dev/null ; then
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED -e 's/;/ /g'`
+  else
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+  fi
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO $lt_tmp_lt_search_path_spec | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[lt_foo]++; }
+  if (lt_freq[lt_foo] == 1) { print lt_foo; }
+}'`
+  sys_lib_search_path_spec=`$ECHO $lt_search_path_spec`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[4-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
+        # It is most probably a Windows format PATH printed by
+        # mingw gcc, but we are running on Cygwin. Gcc prints its search
+        # path with ; separators, and with drive letters. We can handle the
+        # drive letters (cygwin fileutils understands them), so leave them,
+        # especially as we might pass files found there to a mingw objdump,
+        # which wouldn't understand a cygwinified path. Ahh.
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[123]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+interix[3-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # Some binutils ld are patched to set DT_RUNPATH
+  save_LDFLAGS=$LDFLAGS
+  save_libdir=$libdir
+  eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
+       LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then
+  shlibpath_overrides_runpath=yes
+fi
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+  LDFLAGS=$save_LDFLAGS
+  libdir=$save_libdir
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:$LINENO: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:$LINENO: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" ||
+   test -n "$runpath_var" ||
+   test "X$hardcode_automatic" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+{ $as_echo "$as_me:$LINENO: result: $hardcode_action" >&5
+$as_echo "$hardcode_action" >&6; }
+
+if test "$hardcode_action" = relink ||
+   test "$inherit_rpath" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+
+
+
+
+
+  if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    { $as_echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dl_dlopen=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+
+fi
+
+    ;;
+
+  *)
+    { $as_echo "$as_me:$LINENO: checking for shl_load" >&5
+$as_echo_n "checking for shl_load... " >&6; }
+if test "${ac_cv_func_shl_load+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define shl_load to an innocuous variant, in case <limits.h> declares shl_load.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define shl_load innocuous_shl_load
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char shl_load (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef shl_load
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_shl_load || defined __stub___shl_load
+choke me
+#endif
+
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_func_shl_load=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_func_shl_load=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_shl_load" >&5
+$as_echo "$ac_cv_func_shl_load" >&6; }
+if test "x$ac_cv_func_shl_load" = x""yes; then
+  lt_cv_dlopen="shl_load"
+else
+  { $as_echo "$as_me:$LINENO: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dld_shl_load=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dld_shl_load=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = x""yes; then
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
+else
+  { $as_echo "$as_me:$LINENO: checking for dlopen" >&5
+$as_echo_n "checking for dlopen... " >&6; }
+if test "${ac_cv_func_dlopen+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define dlopen to an innocuous variant, in case <limits.h> declares dlopen.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define dlopen innocuous_dlopen
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char dlopen (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef dlopen
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_dlopen || defined __stub___dlopen
+choke me
+#endif
+
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_func_dlopen=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_func_dlopen=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_dlopen" >&5
+$as_echo "$ac_cv_func_dlopen" >&6; }
+if test "x$ac_cv_func_dlopen" = x""yes; then
+  lt_cv_dlopen="dlopen"
+else
+  { $as_echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dl_dlopen=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  { $as_echo "$as_me:$LINENO: checking for dlopen in -lsvld" >&5
+$as_echo_n "checking for dlopen in -lsvld... " >&6; }
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_svld_dlopen=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_svld_dlopen=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_svld_dlopen" >&5
+$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
+if test "x$ac_cv_lib_svld_dlopen" = x""yes; then
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  { $as_echo "$as_me:$LINENO: checking for dld_link in -ldld" >&5
+$as_echo_n "checking for dld_link in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dld_link ();
+int
+main ()
+{
+return dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dld_dld_link=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dld_dld_link=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dld_dld_link" >&5
+$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
+if test "x$ac_cv_lib_dld_dld_link" = x""yes; then
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    { $as_echo "$as_me:$LINENO: checking whether a program can dlopen itself" >&5
+$as_echo_n "checking whether a program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line 12164 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_dlopen_self" >&5
+$as_echo "$lt_cv_dlopen_self" >&6; }
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      { $as_echo "$as_me:$LINENO: checking whether a statically linked program can dlopen itself" >&5
+$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self_static+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line 12260 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_dlopen_self_static" >&5
+$as_echo "$lt_cv_dlopen_self_static" >&6; }
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+striplib=
+old_striplib=
+{ $as_echo "$as_me:$LINENO: checking whether stripping libraries is possible" >&5
+$as_echo_n "checking whether stripping libraries is possible... " >&6; }
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+      { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+    fi
+    ;;
+  *)
+    { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+    ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+  # Report which library types will actually be built
+  { $as_echo "$as_me:$LINENO: checking if libtool supports shared libraries" >&5
+$as_echo_n "checking if libtool supports shared libraries... " >&6; }
+  { $as_echo "$as_me:$LINENO: result: $can_build_shared" >&5
+$as_echo "$can_build_shared" >&6; }
+
+  { $as_echo "$as_me:$LINENO: checking whether to build shared libraries" >&5
+$as_echo_n "checking whether to build shared libraries... " >&6; }
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[4-9]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  { $as_echo "$as_me:$LINENO: result: $enable_shared" >&5
+$as_echo "$enable_shared" >&6; }
+
+  { $as_echo "$as_me:$LINENO: checking whether to build static libraries" >&5
+$as_echo_n "checking whether to build static libraries... " >&6; }
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  { $as_echo "$as_me:$LINENO: result: $enable_static" >&5
+$as_echo "$enable_static" >&6; }
+
+
+
+
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+CC="$lt_save_CC"
+
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+archive_cmds_need_lc_CXX=no
+allow_undefined_flag_CXX=
+always_export_symbols_CXX=no
+archive_expsym_cmds_CXX=
+compiler_needs_object_CXX=no
+export_dynamic_flag_spec_CXX=
+hardcode_direct_CXX=no
+hardcode_direct_absolute_CXX=no
+hardcode_libdir_flag_spec_CXX=
+hardcode_libdir_flag_spec_ld_CXX=
+hardcode_libdir_separator_CXX=
+hardcode_minus_L_CXX=no
+hardcode_shlibpath_var_CXX=unsupported
+hardcode_automatic_CXX=no
+inherit_rpath_CXX=no
+module_cmds_CXX=
+module_expsym_cmds_CXX=
+link_all_deplibs_CXX=unknown
+old_archive_cmds_CXX=$old_archive_cmds
+no_undefined_flag_CXX=
+whole_archive_flag_spec_CXX=
+enable_shared_with_static_runtimes_CXX=no
+
+# Source file extension for C++ test sources.
+ac_ext=cpp
+
+# Object file extension for compiled C++ test sources.
+objext=o
+objext_CXX=$objext
+
+# No sense in running all these tests if we already determined that
+# the CXX compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_caught_CXX_error" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="int some_variable = 0;"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code='int main(int, char *[]) { return(0); }'
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+
+  # save warnings/boilerplate of simple test code
+  ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+
+  ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC=$CC
+  lt_save_LD=$LD
+  lt_save_GCC=$GCC
+  GCC=$GXX
+  lt_save_with_gnu_ld=$with_gnu_ld
+  lt_save_path_LD=$lt_cv_path_LD
+  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
+    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
+  else
+    $as_unset lt_cv_prog_gnu_ld
+  fi
+  if test -n "${lt_cv_path_LDCXX+set}"; then
+    lt_cv_path_LD=$lt_cv_path_LDCXX
+  else
+    $as_unset lt_cv_path_LD
+  fi
+  test -z "${LDCXX+set}" || LD=$LDCXX
+  CC=${CXX-"c++"}
+  compiler=$CC
+  compiler_CXX=$CC
+  for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
+
+
+  if test -n "$compiler"; then
+    # We don't want -fno-exception when compiling C++ code, so set the
+    # no_builtin_flag separately
+    if test "$GXX" = yes; then
+      lt_prog_compiler_no_builtin_flag_CXX=' -fno-builtin'
+    else
+      lt_prog_compiler_no_builtin_flag_CXX=
+    fi
+
+    if test "$GXX" = yes; then
+      # Set up default GNU C++ configuration
+
+
+
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:$LINENO: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:$LINENO: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:$LINENO: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${lt_cv_path_LD+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:$LINENO: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && { { $as_echo "$as_me:$LINENO: error: no acceptable ld found in \$PATH" >&5
+$as_echo "$as_me: error: no acceptable ld found in \$PATH" >&2;}
+   { (exit 1); exit 1; }; }
+{ $as_echo "$as_me:$LINENO: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${lt_cv_prog_gnu_ld+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+
+
+
+
+
+      # Check if GNU C++ uses GNU ld as the underlying linker, since the
+      # archiving commands below assume that GNU ld is being used.
+      if test "$with_gnu_ld" = yes; then
+        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        archive_expsym_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+
+        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+        export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+
+        # If archive_cmds runs LD, not CC, wlarc should be empty
+        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
+        #     investigate it a little bit more. (MM)
+        wlarc='${wl}'
+
+        # ancient GNU ld didn't support --whole-archive et. al.
+        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
+	  $GREP 'no-whole-archive' > /dev/null; then
+          whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+        else
+          whole_archive_flag_spec_CXX=
+        fi
+      else
+        with_gnu_ld=no
+        wlarc=
+
+        # A generic and very simple default shared library creation
+        # command for GNU C++ for the case where it uses the native
+        # linker, instead of GNU ld.  If possible, this setting should
+        # overridden to take advantage of the native linker features on
+        # the platform it is being used on.
+        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+      fi
+
+      # Commands to make compiler produce verbose output that lists
+      # what "hidden" libraries, object files and flags are used when
+      # linking a shared library.
+      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+
+    else
+      GXX=no
+      with_gnu_ld=no
+      wlarc=
+    fi
+
+    # PORTME: fill in a description of your system's C++ link characteristics
+    { $as_echo "$as_me:$LINENO: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+    ld_shlibs_CXX=yes
+    case $host_os in
+      aix3*)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+        ;;
+      aix[4-9]*)
+        if test "$host_cpu" = ia64; then
+          # On IA64, the linker does run time linking by default, so we don't
+          # have to do anything special.
+          aix_use_runtimelinking=no
+          exp_sym_flag='-Bexport'
+          no_entry_flag=""
+        else
+          aix_use_runtimelinking=no
+
+          # Test if we are trying to use run time linking or normal
+          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+          # need to do runtime linking.
+          case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
+	    for ld_flag in $LDFLAGS; do
+	      case $ld_flag in
+	      *-brtl*)
+	        aix_use_runtimelinking=yes
+	        break
+	        ;;
+	      esac
+	    done
+	    ;;
+          esac
+
+          exp_sym_flag='-bexport'
+          no_entry_flag='-bnoentry'
+        fi
+
+        # When large executables or shared objects are built, AIX ld can
+        # have problems creating the table of contents.  If linking a library
+        # or program results in "error TOC overflow" add -mminimal-toc to
+        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+        archive_cmds_CXX=''
+        hardcode_direct_CXX=yes
+        hardcode_direct_absolute_CXX=yes
+        hardcode_libdir_separator_CXX=':'
+        link_all_deplibs_CXX=yes
+        file_list_spec_CXX='${wl}-f,'
+
+        if test "$GXX" = yes; then
+          case $host_os in aix4.[012]|aix4.[012].*)
+          # We only want to do this on AIX 4.2 and lower, the check
+          # below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	    # We have reworked collect2
+	    :
+	  else
+	    # We have old collect2
+	    hardcode_direct_CXX=unsupported
+	    # It fails to find uninstalled libraries when the uninstalled
+	    # path is not listed in the libpath.  Setting hardcode_minus_L
+	    # to unsupported forces relinking
+	    hardcode_minus_L_CXX=yes
+	    hardcode_libdir_flag_spec_CXX='-L$libdir'
+	    hardcode_libdir_separator_CXX=
+	  fi
+          esac
+          shared_flag='-shared'
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag="$shared_flag "'${wl}-G'
+	  fi
+        else
+          # not using gcc
+          if test "$host_cpu" = ia64; then
+	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	  # chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+          else
+	    if test "$aix_use_runtimelinking" = yes; then
+	      shared_flag='${wl}-G'
+	    else
+	      shared_flag='${wl}-bM:SRE'
+	    fi
+          fi
+        fi
+
+        export_dynamic_flag_spec_CXX='${wl}-bexpall'
+        # It seems that -bexpall does not export symbols beginning with
+        # underscore (_), so it is better to generate a list of symbols to
+	# export.
+        always_export_symbols_CXX=yes
+        if test "$aix_use_runtimelinking" = yes; then
+          # Warning - without using the other runtime loading flags (-brtl),
+          # -berok will link without error, but may produce a broken library.
+          allow_undefined_flag_CXX='-berok'
+          # Determine the default libpath from the value encoded in an empty
+          # executable.
+          cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+          hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
+
+          archive_expsym_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        else
+          if test "$host_cpu" = ia64; then
+	    hardcode_libdir_flag_spec_CXX='${wl}-R $libdir:/usr/lib:/lib'
+	    allow_undefined_flag_CXX="-z nodefs"
+	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+          else
+	    # Determine the default libpath from the value encoded in an
+	    # empty executable.
+	    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+	    hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    # Warning - without using the other run time loading flags,
+	    # -berok will link without error, but may produce a broken library.
+	    no_undefined_flag_CXX=' ${wl}-bernotok'
+	    allow_undefined_flag_CXX=' ${wl}-berok'
+	    # Exported symbols can be pulled into shared objects from archives
+	    whole_archive_flag_spec_CXX='$convenience'
+	    archive_cmds_need_lc_CXX=yes
+	    # This is similar to how AIX traditionally builds its shared
+	    # libraries.
+	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+          fi
+        fi
+        ;;
+
+      beos*)
+	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	  allow_undefined_flag_CXX=unsupported
+	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	  # support --undefined.  This deserves some investigation.  FIXME
+	  archive_cmds_CXX='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	else
+	  ld_shlibs_CXX=no
+	fi
+	;;
+
+      chorus*)
+        case $cc_basename in
+          *)
+	  # FIXME: insert proper C++ library support
+	  ld_shlibs_CXX=no
+	  ;;
+        esac
+        ;;
+
+      cygwin* | mingw* | pw32* | cegcc*)
+        # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
+        # as there is no search path for DLLs.
+        hardcode_libdir_flag_spec_CXX='-L$libdir'
+        allow_undefined_flag_CXX=unsupported
+        always_export_symbols_CXX=no
+        enable_shared_with_static_runtimes_CXX=yes
+
+        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+          archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+          # If the export-symbols file already is a .def file (1st line
+          # is EXPORTS), use it as is; otherwise, prepend...
+          archive_expsym_cmds_CXX='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	    cp $export_symbols $output_objdir/$soname.def;
+          else
+	    echo EXPORTS > $output_objdir/$soname.def;
+	    cat $export_symbols >> $output_objdir/$soname.def;
+          fi~
+          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+        else
+          ld_shlibs_CXX=no
+        fi
+        ;;
+      darwin* | rhapsody*)
+
+
+  archive_cmds_need_lc_CXX=no
+  hardcode_direct_CXX=no
+  hardcode_automatic_CXX=yes
+  hardcode_shlibpath_var_CXX=unsupported
+  whole_archive_flag_spec_CXX=''
+  link_all_deplibs_CXX=yes
+  allow_undefined_flag_CXX="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=echo
+    archive_cmds_CXX="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    module_cmds_CXX="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    module_expsym_cmds_CXX="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+       if test "$lt_cv_apple_cc_single_mod" != "yes"; then
+      archive_cmds_CXX="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
+      archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+    fi
+
+  else
+  ld_shlibs_CXX=no
+  fi
+
+	;;
+
+      dgux*)
+        case $cc_basename in
+          ec++*)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          ghcx*)
+	    # Green Hills C++ Compiler
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+        esac
+        ;;
+
+      freebsd[12]*)
+        # C++ shared libraries reported to be fairly broken before
+	# switch to ELF
+        ld_shlibs_CXX=no
+        ;;
+
+      freebsd-elf*)
+        archive_cmds_need_lc_CXX=no
+        ;;
+
+      freebsd* | dragonfly*)
+        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
+        # conventions
+        ld_shlibs_CXX=yes
+        ;;
+
+      gnu*)
+        ;;
+
+      hpux9*)
+        hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator_CXX=:
+        export_dynamic_flag_spec_CXX='${wl}-E'
+        hardcode_direct_CXX=yes
+        hardcode_minus_L_CXX=yes # Not in the search PATH,
+				             # but as the default
+				             # location of the library.
+
+        case $cc_basename in
+          CC*)
+            # FIXME: insert proper C++ library support
+            ld_shlibs_CXX=no
+            ;;
+          aCC*)
+            archive_cmds_CXX='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            # Commands to make compiler produce verbose output that lists
+            # what "hidden" libraries, object files and flags are used when
+            # linking a shared library.
+            #
+            # There doesn't appear to be a way to prevent this compiler from
+            # explicitly linking system object files so we need to strip them
+            # from the output so that they don't get included in the library
+            # dependencies.
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+            ;;
+          *)
+            if test "$GXX" = yes; then
+              archive_cmds_CXX='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            else
+              # FIXME: insert proper C++ library support
+              ld_shlibs_CXX=no
+            fi
+            ;;
+        esac
+        ;;
+
+      hpux10*|hpux11*)
+        if test $with_gnu_ld = no; then
+	  hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
+	  hardcode_libdir_separator_CXX=:
+
+          case $host_cpu in
+            hppa*64*|ia64*)
+              ;;
+            *)
+	      export_dynamic_flag_spec_CXX='${wl}-E'
+              ;;
+          esac
+        fi
+        case $host_cpu in
+          hppa*64*|ia64*)
+            hardcode_direct_CXX=no
+            hardcode_shlibpath_var_CXX=no
+            ;;
+          *)
+            hardcode_direct_CXX=yes
+            hardcode_direct_absolute_CXX=yes
+            hardcode_minus_L_CXX=yes # Not in the search PATH,
+					         # but as the default
+					         # location of the library.
+            ;;
+        esac
+
+        case $cc_basename in
+          CC*)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          aCC*)
+	    case $host_cpu in
+	      hppa*64*)
+	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      ia64*)
+	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      *)
+	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	    esac
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test $with_gnu_ld = no; then
+	        case $host_cpu in
+	          hppa*64*)
+	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          ia64*)
+	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          *)
+	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	        esac
+	      fi
+	    else
+	      # FIXME: insert proper C++ library support
+	      ld_shlibs_CXX=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      interix[3-9]*)
+	hardcode_direct_CXX=no
+	hardcode_shlibpath_var_CXX=no
+	hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	export_dynamic_flag_spec_CXX='${wl}-E'
+	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+	# Instead, shared libraries are loaded at an image base (0x10000000 by
+	# default) and relocated if they conflict, which is a slow very memory
+	# consuming and fragmenting process.  To avoid this, we pick a random,
+	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+	archive_cmds_CXX='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	archive_expsym_cmds_CXX='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	;;
+      irix5* | irix6*)
+        case $cc_basename in
+          CC*)
+	    # SGI C++
+	    archive_cmds_CXX='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    old_archive_cmds_CXX='$CC -ar -WR,-u -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test "$with_gnu_ld" = no; then
+	        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	      else
+	        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` -o $lib'
+	      fi
+	    fi
+	    link_all_deplibs_CXX=yes
+	    ;;
+        esac
+        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+        hardcode_libdir_separator_CXX=:
+        inherit_rpath_CXX=yes
+        ;;
+
+      linux* | k*bsd*-gnu)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    archive_expsym_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+
+	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	    old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs'
+	    ;;
+	  icpc* | ecpc* )
+	    # Intel C++
+	    with_gnu_ld=yes
+	    # version 8.0 and above of icpc choke on multiply defined symbols
+	    # if we add $predep_objects and $postdep_objects, however 7.1 and
+	    # earlier do not add the objects themselves.
+	    case `$CC -V 2>&1` in
+	      *"Version 7."*)
+	        archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	      *)  # Version 8.0 or newer
+	        tmp_idyn=
+	        case $host_cpu in
+		  ia64*) tmp_idyn=' -i_dynamic';;
+		esac
+	        archive_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		archive_expsym_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	    esac
+	    archive_cmds_need_lc_CXX=no
+	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	    whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    ;;
+          pgCC* | pgcpp*)
+            # Portland Group C++ compiler
+	    case `$CC -V` in
+	    *pgCC\ [1-5]* | *pgcpp\ [1-5]*)
+	      prelink_cmds_CXX='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+		compile_command="$compile_command `find $tpldir -name \*.o | $NL2SP`"'
+	      old_archive_cmds_CXX='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | $NL2SP`~
+		$RANLIB $oldlib'
+	      archive_cmds_CXX='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      archive_expsym_cmds_CXX='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    *) # Version 6 will use weak symbols
+	      archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    esac
+
+	    hardcode_libdir_flag_spec_CXX='${wl}--rpath ${wl}$libdir'
+	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	    whole_archive_flag_spec_CXX='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+            ;;
+	  cxx*)
+	    # Compaq C++
+	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+
+	    runpath_var=LD_RUN_PATH
+	    hardcode_libdir_flag_spec_CXX='-rpath $libdir'
+	    hardcode_libdir_separator_CXX=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`$ECHO "X$templist" | $Xsed -e "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+	  xl*)
+	    # IBM XL 8.0 on PPC, with GNU ld
+	    hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	    archive_cmds_CXX='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    if test "x$supports_anon_versioning" = xyes; then
+	      archive_expsym_cmds_CXX='echo "{ global:" > $output_objdir/$libname.ver~
+		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+		echo "local: *; };" >> $output_objdir/$libname.ver~
+		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	    fi
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      no_undefined_flag_CXX=' -zdefs'
+	      archive_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      archive_expsym_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      hardcode_libdir_flag_spec_CXX='-R$libdir'
+	      whole_archive_flag_spec_CXX='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	      compiler_needs_object_CXX=yes
+
+	      # Not sure whether something based on
+	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
+	      # would be better.
+	      output_verbose_link_cmd='echo'
+
+	      # Archives containing C++ object files must be created using
+	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	      # necessary to make sure instantiated templates are included
+	      # in the archive.
+	      old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+
+      lynxos*)
+        # FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+
+      m88k*)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+	;;
+
+      mvs*)
+        case $cc_basename in
+          cxx*)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+	  *)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+	esac
+	;;
+
+      netbsd*)
+        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	  archive_cmds_CXX='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
+	  wlarc=
+	  hardcode_libdir_flag_spec_CXX='-R$libdir'
+	  hardcode_direct_CXX=yes
+	  hardcode_shlibpath_var_CXX=no
+	fi
+	# Workaround some broken pre-1.5 toolchains
+	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
+	;;
+
+      *nto* | *qnx*)
+        ld_shlibs_CXX=yes
+	;;
+
+      openbsd2*)
+        # C++ shared libraries are fairly broken
+	ld_shlibs_CXX=no
+	;;
+
+      openbsd*)
+	if test -f /usr/libexec/ld.so; then
+	  hardcode_direct_CXX=yes
+	  hardcode_shlibpath_var_CXX=no
+	  hardcode_direct_absolute_CXX=yes
+	  archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+	  hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	    archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
+	    export_dynamic_flag_spec_CXX='${wl}-E'
+	    whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  fi
+	  output_verbose_link_cmd=echo
+	else
+	  ld_shlibs_CXX=no
+	fi
+	;;
+
+      osf3* | osf4* | osf5*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+
+	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	    hardcode_libdir_separator_CXX=:
+
+	    # Archives containing C++ object files must be created using
+	    # the KAI C++ compiler.
+	    case $host in
+	      osf3*) old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs' ;;
+	      *) old_archive_cmds_CXX='$CC -o $oldlib $oldobjs' ;;
+	    esac
+	    ;;
+          RCC*)
+	    # Rational C++ 2.4.1
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          cxx*)
+	    case $host in
+	      osf3*)
+	        allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
+	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && $ECHO "X${wl}-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+		;;
+	      *)
+	        allow_undefined_flag_CXX=' -expect_unresolved \*'
+	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	        archive_expsym_cmds_CXX='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
+	          echo "-hidden">> $lib.exp~
+	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~
+	          $RM $lib.exp'
+	        hardcode_libdir_flag_spec_CXX='-rpath $libdir'
+		;;
+	    esac
+
+	    hardcode_libdir_separator_CXX=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`$ECHO "X$templist" | $Xsed -e "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+	  *)
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
+	      case $host in
+	        osf3*)
+	          archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	        *)
+	          archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	      esac
+
+	      hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	      hardcode_libdir_separator_CXX=:
+
+	      # Commands to make compiler produce verbose output that lists
+	      # what "hidden" libraries, object files and flags are used when
+	      # linking a shared library.
+	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+
+	    else
+	      # FIXME: insert proper C++ library support
+	      ld_shlibs_CXX=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      psos*)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+        ;;
+
+      sunos4*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.x
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          lcc*)
+	    # Lucid
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+        esac
+        ;;
+
+      solaris*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+            archive_cmds_need_lc_CXX=yes
+	    no_undefined_flag_CXX=' -zdefs'
+	    archive_cmds_CXX='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	    hardcode_libdir_flag_spec_CXX='-R$libdir'
+	    hardcode_shlibpath_var_CXX=no
+	    case $host_os in
+	      solaris2.[0-5] | solaris2.[0-5].*) ;;
+	      *)
+		# The compiler driver will combine and reorder linker options,
+		# but understands `-z linker_flag'.
+	        # Supported since Solaris 2.6 (maybe 2.5.1?)
+		whole_archive_flag_spec_CXX='-z allextract$convenience -z defaultextract'
+	        ;;
+	    esac
+	    link_all_deplibs_CXX=yes
+
+	    output_verbose_link_cmd='echo'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
+	    ;;
+          gcx*)
+	    # Green Hills C++ Compiler
+	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+
+	    # The C++ compiler must be used to create the archive.
+	    old_archive_cmds_CXX='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    # GNU C++ compiler with Solaris linker
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      no_undefined_flag_CXX=' ${wl}-z ${wl}defs'
+	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
+	        archive_cmds_CXX='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+	      else
+	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # platform.
+	        archive_cmds_CXX='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+	      fi
+
+	      hardcode_libdir_flag_spec_CXX='${wl}-R $wl$libdir'
+	      case $host_os in
+		solaris2.[0-5] | solaris2.[0-5].*) ;;
+		*)
+		  whole_archive_flag_spec_CXX='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  ;;
+	      esac
+	    fi
+	    ;;
+        esac
+        ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      no_undefined_flag_CXX='${wl}-z,text'
+      archive_cmds_need_lc_CXX=no
+      hardcode_shlibpath_var_CXX=no
+      runpath_var='LD_RUN_PATH'
+
+      case $cc_basename in
+        CC*)
+	  archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+      esac
+      ;;
+
+      sysv5* | sco3.2v5* | sco5v6*)
+	# Note: We can NOT use -z defs as we might desire, because we do not
+	# link with -lc, and that would cause any symbols used from libc to
+	# always be unresolved, which means just about no library would
+	# ever link correctly.  If we're not using GNU ld we use -z text
+	# though, which does catch some bad symbols but isn't as heavy-handed
+	# as -z defs.
+	no_undefined_flag_CXX='${wl}-z,text'
+	allow_undefined_flag_CXX='${wl}-z,nodefs'
+	archive_cmds_need_lc_CXX=no
+	hardcode_shlibpath_var_CXX=no
+	hardcode_libdir_flag_spec_CXX='${wl}-R,$libdir'
+	hardcode_libdir_separator_CXX=':'
+	link_all_deplibs_CXX=yes
+	export_dynamic_flag_spec_CXX='${wl}-Bexport'
+	runpath_var='LD_RUN_PATH'
+
+	case $cc_basename in
+          CC*)
+	    archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	  *)
+	    archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	esac
+      ;;
+
+      tandem*)
+        case $cc_basename in
+          NCC*)
+	    # NonStop-UX NCC 3.20
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+        esac
+        ;;
+
+      vxworks*)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+        ;;
+
+      *)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+        ;;
+    esac
+
+    { $as_echo "$as_me:$LINENO: result: $ld_shlibs_CXX" >&5
+$as_echo "$ld_shlibs_CXX" >&6; }
+    test "$ld_shlibs_CXX" = no && can_build_shared=no
+
+    GCC_CXX="$GXX"
+    LD_CXX="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    # Dependencies to place before and after the object being linked:
+predep_objects_CXX=
+postdep_objects_CXX=
+predeps_CXX=
+postdeps_CXX=
+compiler_lib_search_path_CXX=
+
+cat > conftest.$ac_ext <<_LT_EOF
+class Foo
+{
+public:
+  Foo (void) { a = 0; }
+private:
+  int a;
+};
+_LT_EOF
+
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Parse the compiler output and extract the necessary
+  # objects, libraries and library flags.
+
+  # Sentinel used to keep track of whether or not we are before
+  # the conftest object file.
+  pre_test_object_deps_done=no
+
+  for p in `eval "$output_verbose_link_cmd"`; do
+    case $p in
+
+    -L* | -R* | -l*)
+       # Some compilers place space between "-{L,R}" and the path.
+       # Remove the space.
+       if test $p = "-L" ||
+          test $p = "-R"; then
+	 prev=$p
+	 continue
+       else
+	 prev=
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 case $p in
+	 -L* | -R*)
+	   # Internal compiler library paths should come after those
+	   # provided the user.  The postdeps already come after the
+	   # user supplied libs so there is no need to process them.
+	   if test -z "$compiler_lib_search_path_CXX"; then
+	     compiler_lib_search_path_CXX="${prev}${p}"
+	   else
+	     compiler_lib_search_path_CXX="${compiler_lib_search_path_CXX} ${prev}${p}"
+	   fi
+	   ;;
+	 # The "-l" case would never come before the object being
+	 # linked, so don't bother handling this case.
+	 esac
+       else
+	 if test -z "$postdeps_CXX"; then
+	   postdeps_CXX="${prev}${p}"
+	 else
+	   postdeps_CXX="${postdeps_CXX} ${prev}${p}"
+	 fi
+       fi
+       ;;
+
+    *.$objext)
+       # This assumes that the test object file only shows up
+       # once in the compiler output.
+       if test "$p" = "conftest.$objext"; then
+	 pre_test_object_deps_done=yes
+	 continue
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 if test -z "$predep_objects_CXX"; then
+	   predep_objects_CXX="$p"
+	 else
+	   predep_objects_CXX="$predep_objects_CXX $p"
+	 fi
+       else
+	 if test -z "$postdep_objects_CXX"; then
+	   postdep_objects_CXX="$p"
+	 else
+	   postdep_objects_CXX="$postdep_objects_CXX $p"
+	 fi
+       fi
+       ;;
+
+    *) ;; # Ignore the rest.
+
+    esac
+  done
+
+  # Clean up.
+  rm -f a.out a.exe
+else
+  echo "libtool.m4: error: problem compiling CXX test program"
+fi
+
+$RM -f confest.$objext
+
+# PORTME: override above test on systems where it is broken
+case $host_os in
+interix[3-9]*)
+  # Interix 3.5 installs completely hosed .la files for C++, so rather than
+  # hack all around it, let's just trust "g++" to DTRT.
+  predep_objects_CXX=
+  postdep_objects_CXX=
+  postdeps_CXX=
+  ;;
+
+linux*)
+  case `$CC -V 2>&1 | sed 5q` in
+  *Sun\ C*)
+    # Sun C++ 5.9
+
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    if test "$solaris_use_stlport4" != yes; then
+      postdeps_CXX='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+
+solaris*)
+  case $cc_basename in
+  CC*)
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    # Adding this requires a known-good setup of shared libraries for
+    # Sun compiler versions before 5.6, else PIC objects from an old
+    # archive will be linked into the output, leading to subtle bugs.
+    if test "$solaris_use_stlport4" != yes; then
+      postdeps_CXX='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+esac
+
+
+case " $postdeps_CXX " in
+*" -lc "*) archive_cmds_need_lc_CXX=no ;;
+esac
+ compiler_lib_search_dirs_CXX=
+if test -n "${compiler_lib_search_path_CXX}"; then
+ compiler_lib_search_dirs_CXX=`echo " ${compiler_lib_search_path_CXX}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    lt_prog_compiler_wl_CXX=
+lt_prog_compiler_pic_CXX=
+lt_prog_compiler_static_CXX=
+
+{ $as_echo "$as_me:$LINENO: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+
+  # C++ specific cases for pic, static, wl, etc.
+  if test "$GXX" = yes; then
+    lt_prog_compiler_wl_CXX='-Wl,'
+    lt_prog_compiler_static_CXX='-static'
+
+    case $host_os in
+    aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static_CXX='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            lt_prog_compiler_pic_CXX='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            lt_prog_compiler_pic_CXX='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    mingw* | cygwin* | os2* | pw32* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      lt_prog_compiler_pic_CXX='-DDLL_EXPORT'
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic_CXX='-fno-common'
+      ;;
+    *djgpp*)
+      # DJGPP does not support shared libraries at all
+      lt_prog_compiler_pic_CXX=
+      ;;
+    interix[3-9]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic_CXX=-Kconform_pic
+      fi
+      ;;
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	;;
+      *)
+	lt_prog_compiler_pic_CXX='-fPIC'
+	;;
+      esac
+      ;;
+    *qnx* | *nto*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic_CXX='-fPIC -shared'
+      ;;
+    *)
+      lt_prog_compiler_pic_CXX='-fPIC'
+      ;;
+    esac
+  else
+    case $host_os in
+      aix[4-9]*)
+	# All AIX code is PIC.
+	if test "$host_cpu" = ia64; then
+	  # AIX 5 now supports IA64 processor
+	  lt_prog_compiler_static_CXX='-Bstatic'
+	else
+	  lt_prog_compiler_static_CXX='-bnso -bI:/lib/syscalls.exp'
+	fi
+	;;
+      chorus*)
+	case $cc_basename in
+	cxch68*)
+	  # Green Hills C++ Compiler
+	  # _LT_TAGVAR(lt_prog_compiler_static, CXX)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	  ;;
+	esac
+	;;
+      dgux*)
+	case $cc_basename in
+	  ec++*)
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    ;;
+	  ghcx*)
+	    # Green Hills C++ Compiler
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      freebsd* | dragonfly*)
+	# FreeBSD uses GNU C++
+	;;
+      hpux9* | hpux10* | hpux11*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
+	    if test "$host_cpu" != ia64; then
+	      lt_prog_compiler_pic_CXX='+Z'
+	    fi
+	    ;;
+	  aCC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
+	    case $host_cpu in
+	    hppa*64*|ia64*)
+	      # +Z the default
+	      ;;
+	    *)
+	      lt_prog_compiler_pic_CXX='+Z'
+	      ;;
+	    esac
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      interix*)
+	# This is c89, which is MS Visual C++ (no shared libs)
+	# Anyone wants to do a port?
+	;;
+      irix5* | irix6* | nonstopux*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    # CC pic flag -KPIC is the default.
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      linux* | k*bsd*-gnu)
+	case $cc_basename in
+	  KCC*)
+	    # KAI C++ Compiler
+	    lt_prog_compiler_wl_CXX='--backend -Wl,'
+	    lt_prog_compiler_pic_CXX='-fPIC'
+	    ;;
+	  ecpc* )
+	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-static'
+	    ;;
+	  icpc* )
+	    # Intel C++, used to be incompatible with GCC.
+	    # ICC 10 doesn't accept -KPIC any more.
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-fPIC'
+	    lt_prog_compiler_static_CXX='-static'
+	    ;;
+	  pgCC* | pgcpp*)
+	    # Portland Group C++ compiler
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-fpic'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	  cxx*)
+	    # Compaq C++
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    lt_prog_compiler_pic_CXX=
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    ;;
+	  xlc* | xlC*)
+	    # IBM XL 8.0 on PPC
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-qpic'
+	    lt_prog_compiler_static_CXX='-qstaticlink'
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      lt_prog_compiler_pic_CXX='-KPIC'
+	      lt_prog_compiler_static_CXX='-Bstatic'
+	      lt_prog_compiler_wl_CXX='-Qoption ld '
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+      lynxos*)
+	;;
+      m88k*)
+	;;
+      mvs*)
+	case $cc_basename in
+	  cxx*)
+	    lt_prog_compiler_pic_CXX='-W c,exportall'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      netbsd* | netbsdelf*-gnu)
+	;;
+      *qnx* | *nto*)
+        # QNX uses GNU C++, but need to define -shared option too, otherwise
+        # it will coredump.
+        lt_prog_compiler_pic_CXX='-fPIC -shared'
+        ;;
+      osf3* | osf4* | osf5*)
+	case $cc_basename in
+	  KCC*)
+	    lt_prog_compiler_wl_CXX='--backend -Wl,'
+	    ;;
+	  RCC*)
+	    # Rational C++ 2.4.1
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  cxx*)
+	    # Digital/Compaq C++
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    lt_prog_compiler_pic_CXX=
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      psos*)
+	;;
+      solaris*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    lt_prog_compiler_wl_CXX='-Qoption ld '
+	    ;;
+	  gcx*)
+	    # Green Hills C++ Compiler
+	    lt_prog_compiler_pic_CXX='-PIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sunos4*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.x
+	    lt_prog_compiler_pic_CXX='-pic'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	  lcc*)
+	    # Lucid
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	esac
+	;;
+      tandem*)
+	case $cc_basename in
+	  NCC*)
+	    # NonStop-UX NCC 3.20
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      vxworks*)
+	;;
+      *)
+	lt_prog_compiler_can_build_shared_CXX=no
+	;;
+    esac
+  fi
+
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic_CXX=
+    ;;
+  *)
+    lt_prog_compiler_pic_CXX="$lt_prog_compiler_pic_CXX -DPIC"
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: result: $lt_prog_compiler_pic_CXX" >&5
+$as_echo "$lt_prog_compiler_pic_CXX" >&6; }
+
+
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic_CXX"; then
+  { $as_echo "$as_me:$LINENO: checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works... " >&6; }
+if test "${lt_cv_prog_compiler_pic_works_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_pic_works_CXX=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic_CXX -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:14280: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:14284: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_pic_works_CXX=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_pic_works_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_pic_works_CXX" >&6; }
+
+if test x"$lt_cv_prog_compiler_pic_works_CXX" = xyes; then
+    case $lt_prog_compiler_pic_CXX in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic_CXX=" $lt_prog_compiler_pic_CXX" ;;
+     esac
+else
+    lt_prog_compiler_pic_CXX=
+     lt_prog_compiler_can_build_shared_CXX=no
+fi
+
+fi
+
+
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl_CXX eval lt_tmp_static_flag=\"$lt_prog_compiler_static_CXX\"
+{ $as_echo "$as_me:$LINENO: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_cv_prog_compiler_static_works_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_static_works_CXX=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler_static_works_CXX=yes
+       fi
+     else
+       lt_cv_prog_compiler_static_works_CXX=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_static_works_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_static_works_CXX" >&6; }
+
+if test x"$lt_cv_prog_compiler_static_works_CXX" = xyes; then
+    :
+else
+    lt_prog_compiler_static_CXX=
+fi
+
+
+
+
+    { $as_echo "$as_me:$LINENO: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o_CXX=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:14379: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:14383: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o_CXX=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_c_o_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
+
+
+
+    { $as_echo "$as_me:$LINENO: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o_CXX=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:14431: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:14435: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o_CXX=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_c_o_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
+
+
+
+
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o_CXX" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:$LINENO: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:$LINENO: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:$LINENO: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+
+
+
+    { $as_echo "$as_me:$LINENO: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+
+  export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  case $host_os in
+  aix[4-9]*)
+    # If we're using GNU nm, then we don't want the "-C" option.
+    # -C means demangle to AIX nm, but means don't demangle with GNU nm
+    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+      export_symbols_cmds_CXX='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    else
+      export_symbols_cmds_CXX='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    fi
+    ;;
+  pw32*)
+    export_symbols_cmds_CXX="$ltdll_cmds"
+  ;;
+  cygwin* | mingw* | cegcc*)
+    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/;/^.*[ ]__nm__/s/^.*[ ]__nm__\([^ ]*\)[ ][^ ]*/\1 DATA/;/^I[ ]/d;/^[AITW][ ]/s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  linux* | k*bsd*-gnu)
+    link_all_deplibs_CXX=no
+  ;;
+  *)
+    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  esac
+  exclude_expsyms_CXX='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
+
+{ $as_echo "$as_me:$LINENO: result: $ld_shlibs_CXX" >&5
+$as_echo "$ld_shlibs_CXX" >&6; }
+test "$ld_shlibs_CXX" = no && can_build_shared=no
+
+with_gnu_ld_CXX=$with_gnu_ld
+
+
+
+
+
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc_CXX" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc_CXX=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds_CXX in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:$LINENO: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+      $RM conftest*
+      echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+      if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } 2>conftest.err; then
+        soname=conftest
+        lib=conftest
+        libobjs=conftest.$ac_objext
+        deplibs=
+        wl=$lt_prog_compiler_wl_CXX
+	pic_flag=$lt_prog_compiler_pic_CXX
+        compiler_flags=-v
+        linker_flags=-v
+        verstring=
+        output_objdir=.
+        libname=conftest
+        lt_save_allow_undefined_flag=$allow_undefined_flag_CXX
+        allow_undefined_flag_CXX=
+        if { (eval echo "$as_me:$LINENO: \"$archive_cmds_CXX 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\"") >&5
+  (eval $archive_cmds_CXX 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+        then
+	  archive_cmds_need_lc_CXX=no
+        else
+	  archive_cmds_need_lc_CXX=yes
+        fi
+        allow_undefined_flag_CXX=$lt_save_allow_undefined_flag
+      else
+        cat conftest.err 1>&5
+      fi
+      $RM conftest*
+      { $as_echo "$as_me:$LINENO: result: $archive_cmds_need_lc_CXX" >&5
+$as_echo "$archive_cmds_need_lc_CXX" >&6; }
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    { $as_echo "$as_me:$LINENO: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[4-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
+        # It is most probably a Windows format PATH printed by
+        # mingw gcc, but we are running on Cygwin. Gcc prints its search
+        # path with ; separators, and with drive letters. We can handle the
+        # drive letters (cygwin fileutils understands them), so leave them,
+        # especially as we might pass files found there to a mingw objdump,
+        # which wouldn't understand a cygwinified path. Ahh.
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[123]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+interix[3-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # Some binutils ld are patched to set DT_RUNPATH
+  save_LDFLAGS=$LDFLAGS
+  save_libdir=$libdir
+  eval "libdir=/foo; wl=\"$lt_prog_compiler_wl_CXX\"; \
+       LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec_CXX\""
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then
+  shlibpath_overrides_runpath=yes
+fi
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+  LDFLAGS=$save_LDFLAGS
+  libdir=$save_libdir
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:$LINENO: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    { $as_echo "$as_me:$LINENO: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action_CXX=
+if test -n "$hardcode_libdir_flag_spec_CXX" ||
+   test -n "$runpath_var_CXX" ||
+   test "X$hardcode_automatic_CXX" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$hardcode_direct_CXX" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, CXX)" != no &&
+     test "$hardcode_minus_L_CXX" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action_CXX=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action_CXX=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action_CXX=unsupported
+fi
+{ $as_echo "$as_me:$LINENO: result: $hardcode_action_CXX" >&5
+$as_echo "$hardcode_action_CXX" >&6; }
+
+if test "$hardcode_action_CXX" = relink ||
+   test "$inherit_rpath_CXX" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+
+
+
+
+
+
+  fi # test -n "$compiler"
+
+  CC=$lt_save_CC
+  LDCXX=$LD
+  LD=$lt_save_LD
+  GCC=$lt_save_GCC
+  with_gnu_ld=$lt_save_with_gnu_ld
+  lt_cv_path_LDCXX=$lt_cv_path_LD
+  lt_cv_path_LD=$lt_save_path_LD
+  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
+  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
+fi # test "$_lt_caught_CXX_error" != yes
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+        ac_config_commands="$ac_config_commands libtool"
+
+
+
+
+# Only expand once:
+
+
+
+# Checks for libraries.
+# FIXME: Replace `main' with a function in `-ldl':
+
+{ $as_echo "$as_me:$LINENO: checking for main in -ldl" >&5
+$as_echo_n "checking for main in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_main+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+return main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dl_main=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dl_main=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_main" >&5
+$as_echo "$ac_cv_lib_dl_main" >&6; }
+if test "x$ac_cv_lib_dl_main" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBDL 1
+_ACEOF
+
+  LIBS="-ldl $LIBS"
+
+fi
+
+
+# Checks for header files.
+
 
 
 
@@ -4764,7 +16171,7 @@ fi
 done
 
 
-ac_config_files="$ac_config_files Makefile gtkworkbook/OBJS/Makefile src/OBJS/Makefile src/largefile/OBJS/Makefile src/realtime/OBJS/Makefile"
+ac_config_files="$ac_config_files Makefile cfg/Makefile gtkworkbook/OBJS/Makefile src/OBJS/Makefile"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -4899,6 +16306,34 @@ LIBOBJS=$ac_libobjs
 LTLIBOBJS=$ac_ltlibobjs
 
 
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  { { $as_echo "$as_me:$LINENO: error: conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+$as_echo "$as_me: error: conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${am__fastdepCXX_TRUE}" && test -z "${am__fastdepCXX_FALSE}"; then
+  { { $as_echo "$as_me:$LINENO: error: conditional \"am__fastdepCXX\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+$as_echo "$as_me: error: conditional \"am__fastdepCXX\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  { { $as_echo "$as_me:$LINENO: error: conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+$as_echo "$as_me: error: conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${am__fastdepCXX_TRUE}" && test -z "${am__fastdepCXX_FALSE}"; then
+  { { $as_echo "$as_me:$LINENO: error: conditional \"am__fastdepCXX\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+$as_echo "$as_me: error: conditional \"am__fastdepCXX\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
@@ -5244,6 +16679,7 @@ esac
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 # Files that config.status was made for.
 config_files="$ac_config_files"
+config_commands="$ac_config_commands"
 
 _ACEOF
 
@@ -5266,6 +16702,9 @@ Usage: $0 [OPTION]... [FILE]...
 Configuration files:
 $config_files
 
+Configuration commands:
+$config_commands
+
 Report bugs to <bug-autoconf@gnu.org>."
 
 _ACEOF
@@ -5282,6 +16721,7 @@ gives unlimited permission to copy, distribute and modify it."
 ac_pwd='$ac_pwd'
 srcdir='$srcdir'
 INSTALL='$INSTALL'
+MKDIR_P='$MKDIR_P'
 AWK='$AWK'
 test -n "\$AWK" || AWK=awk
 _ACEOF
@@ -5368,6 +16808,362 @@ _ASBOX
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+macro_version='`$ECHO "X$macro_version" | $Xsed -e "$delay_single_quote_subst"`'
+macro_revision='`$ECHO "X$macro_revision" | $Xsed -e "$delay_single_quote_subst"`'
+enable_shared='`$ECHO "X$enable_shared" | $Xsed -e "$delay_single_quote_subst"`'
+enable_static='`$ECHO "X$enable_static" | $Xsed -e "$delay_single_quote_subst"`'
+pic_mode='`$ECHO "X$pic_mode" | $Xsed -e "$delay_single_quote_subst"`'
+enable_fast_install='`$ECHO "X$enable_fast_install" | $Xsed -e "$delay_single_quote_subst"`'
+host_alias='`$ECHO "X$host_alias" | $Xsed -e "$delay_single_quote_subst"`'
+host='`$ECHO "X$host" | $Xsed -e "$delay_single_quote_subst"`'
+host_os='`$ECHO "X$host_os" | $Xsed -e "$delay_single_quote_subst"`'
+build_alias='`$ECHO "X$build_alias" | $Xsed -e "$delay_single_quote_subst"`'
+build='`$ECHO "X$build" | $Xsed -e "$delay_single_quote_subst"`'
+build_os='`$ECHO "X$build_os" | $Xsed -e "$delay_single_quote_subst"`'
+SED='`$ECHO "X$SED" | $Xsed -e "$delay_single_quote_subst"`'
+Xsed='`$ECHO "X$Xsed" | $Xsed -e "$delay_single_quote_subst"`'
+GREP='`$ECHO "X$GREP" | $Xsed -e "$delay_single_quote_subst"`'
+EGREP='`$ECHO "X$EGREP" | $Xsed -e "$delay_single_quote_subst"`'
+FGREP='`$ECHO "X$FGREP" | $Xsed -e "$delay_single_quote_subst"`'
+LD='`$ECHO "X$LD" | $Xsed -e "$delay_single_quote_subst"`'
+NM='`$ECHO "X$NM" | $Xsed -e "$delay_single_quote_subst"`'
+LN_S='`$ECHO "X$LN_S" | $Xsed -e "$delay_single_quote_subst"`'
+max_cmd_len='`$ECHO "X$max_cmd_len" | $Xsed -e "$delay_single_quote_subst"`'
+ac_objext='`$ECHO "X$ac_objext" | $Xsed -e "$delay_single_quote_subst"`'
+exeext='`$ECHO "X$exeext" | $Xsed -e "$delay_single_quote_subst"`'
+lt_unset='`$ECHO "X$lt_unset" | $Xsed -e "$delay_single_quote_subst"`'
+lt_SP2NL='`$ECHO "X$lt_SP2NL" | $Xsed -e "$delay_single_quote_subst"`'
+lt_NL2SP='`$ECHO "X$lt_NL2SP" | $Xsed -e "$delay_single_quote_subst"`'
+reload_flag='`$ECHO "X$reload_flag" | $Xsed -e "$delay_single_quote_subst"`'
+reload_cmds='`$ECHO "X$reload_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+OBJDUMP='`$ECHO "X$OBJDUMP" | $Xsed -e "$delay_single_quote_subst"`'
+deplibs_check_method='`$ECHO "X$deplibs_check_method" | $Xsed -e "$delay_single_quote_subst"`'
+file_magic_cmd='`$ECHO "X$file_magic_cmd" | $Xsed -e "$delay_single_quote_subst"`'
+AR='`$ECHO "X$AR" | $Xsed -e "$delay_single_quote_subst"`'
+AR_FLAGS='`$ECHO "X$AR_FLAGS" | $Xsed -e "$delay_single_quote_subst"`'
+STRIP='`$ECHO "X$STRIP" | $Xsed -e "$delay_single_quote_subst"`'
+RANLIB='`$ECHO "X$RANLIB" | $Xsed -e "$delay_single_quote_subst"`'
+old_postinstall_cmds='`$ECHO "X$old_postinstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+old_postuninstall_cmds='`$ECHO "X$old_postuninstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_cmds='`$ECHO "X$old_archive_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+CC='`$ECHO "X$CC" | $Xsed -e "$delay_single_quote_subst"`'
+CFLAGS='`$ECHO "X$CFLAGS" | $Xsed -e "$delay_single_quote_subst"`'
+compiler='`$ECHO "X$compiler" | $Xsed -e "$delay_single_quote_subst"`'
+GCC='`$ECHO "X$GCC" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_pipe='`$ECHO "X$lt_cv_sys_global_symbol_pipe" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_cdecl='`$ECHO "X$lt_cv_sys_global_symbol_to_cdecl" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "X$lt_cv_sys_global_symbol_to_c_name_address" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "X$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $Xsed -e "$delay_single_quote_subst"`'
+objdir='`$ECHO "X$objdir" | $Xsed -e "$delay_single_quote_subst"`'
+SHELL='`$ECHO "X$SHELL" | $Xsed -e "$delay_single_quote_subst"`'
+ECHO='`$ECHO "X$ECHO" | $Xsed -e "$delay_single_quote_subst"`'
+MAGIC_CMD='`$ECHO "X$MAGIC_CMD" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_no_builtin_flag='`$ECHO "X$lt_prog_compiler_no_builtin_flag" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_wl='`$ECHO "X$lt_prog_compiler_wl" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_pic='`$ECHO "X$lt_prog_compiler_pic" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_static='`$ECHO "X$lt_prog_compiler_static" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_prog_compiler_c_o='`$ECHO "X$lt_cv_prog_compiler_c_o" | $Xsed -e "$delay_single_quote_subst"`'
+need_locks='`$ECHO "X$need_locks" | $Xsed -e "$delay_single_quote_subst"`'
+DSYMUTIL='`$ECHO "X$DSYMUTIL" | $Xsed -e "$delay_single_quote_subst"`'
+NMEDIT='`$ECHO "X$NMEDIT" | $Xsed -e "$delay_single_quote_subst"`'
+LIPO='`$ECHO "X$LIPO" | $Xsed -e "$delay_single_quote_subst"`'
+OTOOL='`$ECHO "X$OTOOL" | $Xsed -e "$delay_single_quote_subst"`'
+OTOOL64='`$ECHO "X$OTOOL64" | $Xsed -e "$delay_single_quote_subst"`'
+libext='`$ECHO "X$libext" | $Xsed -e "$delay_single_quote_subst"`'
+shrext_cmds='`$ECHO "X$shrext_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+extract_expsyms_cmds='`$ECHO "X$extract_expsyms_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+archive_cmds_need_lc='`$ECHO "X$archive_cmds_need_lc" | $Xsed -e "$delay_single_quote_subst"`'
+enable_shared_with_static_runtimes='`$ECHO "X$enable_shared_with_static_runtimes" | $Xsed -e "$delay_single_quote_subst"`'
+export_dynamic_flag_spec='`$ECHO "X$export_dynamic_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
+whole_archive_flag_spec='`$ECHO "X$whole_archive_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
+compiler_needs_object='`$ECHO "X$compiler_needs_object" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_from_new_cmds='`$ECHO "X$old_archive_from_new_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_from_expsyms_cmds='`$ECHO "X$old_archive_from_expsyms_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+archive_cmds='`$ECHO "X$archive_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+archive_expsym_cmds='`$ECHO "X$archive_expsym_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+module_cmds='`$ECHO "X$module_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+module_expsym_cmds='`$ECHO "X$module_expsym_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+with_gnu_ld='`$ECHO "X$with_gnu_ld" | $Xsed -e "$delay_single_quote_subst"`'
+allow_undefined_flag='`$ECHO "X$allow_undefined_flag" | $Xsed -e "$delay_single_quote_subst"`'
+no_undefined_flag='`$ECHO "X$no_undefined_flag" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec='`$ECHO "X$hardcode_libdir_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec_ld='`$ECHO "X$hardcode_libdir_flag_spec_ld" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_separator='`$ECHO "X$hardcode_libdir_separator" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_direct='`$ECHO "X$hardcode_direct" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_direct_absolute='`$ECHO "X$hardcode_direct_absolute" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_minus_L='`$ECHO "X$hardcode_minus_L" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_shlibpath_var='`$ECHO "X$hardcode_shlibpath_var" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_automatic='`$ECHO "X$hardcode_automatic" | $Xsed -e "$delay_single_quote_subst"`'
+inherit_rpath='`$ECHO "X$inherit_rpath" | $Xsed -e "$delay_single_quote_subst"`'
+link_all_deplibs='`$ECHO "X$link_all_deplibs" | $Xsed -e "$delay_single_quote_subst"`'
+fix_srcfile_path='`$ECHO "X$fix_srcfile_path" | $Xsed -e "$delay_single_quote_subst"`'
+always_export_symbols='`$ECHO "X$always_export_symbols" | $Xsed -e "$delay_single_quote_subst"`'
+export_symbols_cmds='`$ECHO "X$export_symbols_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+exclude_expsyms='`$ECHO "X$exclude_expsyms" | $Xsed -e "$delay_single_quote_subst"`'
+include_expsyms='`$ECHO "X$include_expsyms" | $Xsed -e "$delay_single_quote_subst"`'
+prelink_cmds='`$ECHO "X$prelink_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+file_list_spec='`$ECHO "X$file_list_spec" | $Xsed -e "$delay_single_quote_subst"`'
+variables_saved_for_relink='`$ECHO "X$variables_saved_for_relink" | $Xsed -e "$delay_single_quote_subst"`'
+need_lib_prefix='`$ECHO "X$need_lib_prefix" | $Xsed -e "$delay_single_quote_subst"`'
+need_version='`$ECHO "X$need_version" | $Xsed -e "$delay_single_quote_subst"`'
+version_type='`$ECHO "X$version_type" | $Xsed -e "$delay_single_quote_subst"`'
+runpath_var='`$ECHO "X$runpath_var" | $Xsed -e "$delay_single_quote_subst"`'
+shlibpath_var='`$ECHO "X$shlibpath_var" | $Xsed -e "$delay_single_quote_subst"`'
+shlibpath_overrides_runpath='`$ECHO "X$shlibpath_overrides_runpath" | $Xsed -e "$delay_single_quote_subst"`'
+libname_spec='`$ECHO "X$libname_spec" | $Xsed -e "$delay_single_quote_subst"`'
+library_names_spec='`$ECHO "X$library_names_spec" | $Xsed -e "$delay_single_quote_subst"`'
+soname_spec='`$ECHO "X$soname_spec" | $Xsed -e "$delay_single_quote_subst"`'
+postinstall_cmds='`$ECHO "X$postinstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+postuninstall_cmds='`$ECHO "X$postuninstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+finish_cmds='`$ECHO "X$finish_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+finish_eval='`$ECHO "X$finish_eval" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_into_libs='`$ECHO "X$hardcode_into_libs" | $Xsed -e "$delay_single_quote_subst"`'
+sys_lib_search_path_spec='`$ECHO "X$sys_lib_search_path_spec" | $Xsed -e "$delay_single_quote_subst"`'
+sys_lib_dlsearch_path_spec='`$ECHO "X$sys_lib_dlsearch_path_spec" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_action='`$ECHO "X$hardcode_action" | $Xsed -e "$delay_single_quote_subst"`'
+enable_dlopen='`$ECHO "X$enable_dlopen" | $Xsed -e "$delay_single_quote_subst"`'
+enable_dlopen_self='`$ECHO "X$enable_dlopen_self" | $Xsed -e "$delay_single_quote_subst"`'
+enable_dlopen_self_static='`$ECHO "X$enable_dlopen_self_static" | $Xsed -e "$delay_single_quote_subst"`'
+old_striplib='`$ECHO "X$old_striplib" | $Xsed -e "$delay_single_quote_subst"`'
+striplib='`$ECHO "X$striplib" | $Xsed -e "$delay_single_quote_subst"`'
+compiler_lib_search_dirs='`$ECHO "X$compiler_lib_search_dirs" | $Xsed -e "$delay_single_quote_subst"`'
+predep_objects='`$ECHO "X$predep_objects" | $Xsed -e "$delay_single_quote_subst"`'
+postdep_objects='`$ECHO "X$postdep_objects" | $Xsed -e "$delay_single_quote_subst"`'
+predeps='`$ECHO "X$predeps" | $Xsed -e "$delay_single_quote_subst"`'
+postdeps='`$ECHO "X$postdeps" | $Xsed -e "$delay_single_quote_subst"`'
+compiler_lib_search_path='`$ECHO "X$compiler_lib_search_path" | $Xsed -e "$delay_single_quote_subst"`'
+LD_CXX='`$ECHO "X$LD_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_cmds_CXX='`$ECHO "X$old_archive_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+compiler_CXX='`$ECHO "X$compiler_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+GCC_CXX='`$ECHO "X$GCC_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_no_builtin_flag_CXX='`$ECHO "X$lt_prog_compiler_no_builtin_flag_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_wl_CXX='`$ECHO "X$lt_prog_compiler_wl_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_pic_CXX='`$ECHO "X$lt_prog_compiler_pic_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_static_CXX='`$ECHO "X$lt_prog_compiler_static_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_prog_compiler_c_o_CXX='`$ECHO "X$lt_cv_prog_compiler_c_o_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+archive_cmds_need_lc_CXX='`$ECHO "X$archive_cmds_need_lc_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+enable_shared_with_static_runtimes_CXX='`$ECHO "X$enable_shared_with_static_runtimes_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+export_dynamic_flag_spec_CXX='`$ECHO "X$export_dynamic_flag_spec_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+whole_archive_flag_spec_CXX='`$ECHO "X$whole_archive_flag_spec_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+compiler_needs_object_CXX='`$ECHO "X$compiler_needs_object_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_from_new_cmds_CXX='`$ECHO "X$old_archive_from_new_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_from_expsyms_cmds_CXX='`$ECHO "X$old_archive_from_expsyms_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+archive_cmds_CXX='`$ECHO "X$archive_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+archive_expsym_cmds_CXX='`$ECHO "X$archive_expsym_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+module_cmds_CXX='`$ECHO "X$module_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+module_expsym_cmds_CXX='`$ECHO "X$module_expsym_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+with_gnu_ld_CXX='`$ECHO "X$with_gnu_ld_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+allow_undefined_flag_CXX='`$ECHO "X$allow_undefined_flag_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+no_undefined_flag_CXX='`$ECHO "X$no_undefined_flag_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec_CXX='`$ECHO "X$hardcode_libdir_flag_spec_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec_ld_CXX='`$ECHO "X$hardcode_libdir_flag_spec_ld_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_separator_CXX='`$ECHO "X$hardcode_libdir_separator_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_direct_CXX='`$ECHO "X$hardcode_direct_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_direct_absolute_CXX='`$ECHO "X$hardcode_direct_absolute_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_minus_L_CXX='`$ECHO "X$hardcode_minus_L_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_shlibpath_var_CXX='`$ECHO "X$hardcode_shlibpath_var_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_automatic_CXX='`$ECHO "X$hardcode_automatic_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+inherit_rpath_CXX='`$ECHO "X$inherit_rpath_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+link_all_deplibs_CXX='`$ECHO "X$link_all_deplibs_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+fix_srcfile_path_CXX='`$ECHO "X$fix_srcfile_path_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+always_export_symbols_CXX='`$ECHO "X$always_export_symbols_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+export_symbols_cmds_CXX='`$ECHO "X$export_symbols_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+exclude_expsyms_CXX='`$ECHO "X$exclude_expsyms_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+include_expsyms_CXX='`$ECHO "X$include_expsyms_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+prelink_cmds_CXX='`$ECHO "X$prelink_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+file_list_spec_CXX='`$ECHO "X$file_list_spec_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_action_CXX='`$ECHO "X$hardcode_action_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+compiler_lib_search_dirs_CXX='`$ECHO "X$compiler_lib_search_dirs_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+predep_objects_CXX='`$ECHO "X$predep_objects_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+postdep_objects_CXX='`$ECHO "X$postdep_objects_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+predeps_CXX='`$ECHO "X$predeps_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+postdeps_CXX='`$ECHO "X$postdeps_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+compiler_lib_search_path_CXX='`$ECHO "X$compiler_lib_search_path_CXX" | $Xsed -e "$delay_single_quote_subst"`'
+
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# Quote evaled strings.
+for var in SED \
+GREP \
+EGREP \
+FGREP \
+LD \
+NM \
+LN_S \
+lt_SP2NL \
+lt_NL2SP \
+reload_flag \
+OBJDUMP \
+deplibs_check_method \
+file_magic_cmd \
+AR \
+AR_FLAGS \
+STRIP \
+RANLIB \
+CC \
+CFLAGS \
+compiler \
+lt_cv_sys_global_symbol_pipe \
+lt_cv_sys_global_symbol_to_cdecl \
+lt_cv_sys_global_symbol_to_c_name_address \
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
+SHELL \
+ECHO \
+lt_prog_compiler_no_builtin_flag \
+lt_prog_compiler_wl \
+lt_prog_compiler_pic \
+lt_prog_compiler_static \
+lt_cv_prog_compiler_c_o \
+need_locks \
+DSYMUTIL \
+NMEDIT \
+LIPO \
+OTOOL \
+OTOOL64 \
+shrext_cmds \
+export_dynamic_flag_spec \
+whole_archive_flag_spec \
+compiler_needs_object \
+with_gnu_ld \
+allow_undefined_flag \
+no_undefined_flag \
+hardcode_libdir_flag_spec \
+hardcode_libdir_flag_spec_ld \
+hardcode_libdir_separator \
+fix_srcfile_path \
+exclude_expsyms \
+include_expsyms \
+file_list_spec \
+variables_saved_for_relink \
+libname_spec \
+library_names_spec \
+soname_spec \
+finish_eval \
+old_striplib \
+striplib \
+compiler_lib_search_dirs \
+predep_objects \
+postdep_objects \
+predeps \
+postdeps \
+compiler_lib_search_path \
+LD_CXX \
+compiler_CXX \
+lt_prog_compiler_no_builtin_flag_CXX \
+lt_prog_compiler_wl_CXX \
+lt_prog_compiler_pic_CXX \
+lt_prog_compiler_static_CXX \
+lt_cv_prog_compiler_c_o_CXX \
+export_dynamic_flag_spec_CXX \
+whole_archive_flag_spec_CXX \
+compiler_needs_object_CXX \
+with_gnu_ld_CXX \
+allow_undefined_flag_CXX \
+no_undefined_flag_CXX \
+hardcode_libdir_flag_spec_CXX \
+hardcode_libdir_flag_spec_ld_CXX \
+hardcode_libdir_separator_CXX \
+fix_srcfile_path_CXX \
+exclude_expsyms_CXX \
+include_expsyms_CXX \
+file_list_spec_CXX \
+compiler_lib_search_dirs_CXX \
+predep_objects_CXX \
+postdep_objects_CXX \
+predeps_CXX \
+postdeps_CXX \
+compiler_lib_search_path_CXX; do
+    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in reload_cmds \
+old_postinstall_cmds \
+old_postuninstall_cmds \
+old_archive_cmds \
+extract_expsyms_cmds \
+old_archive_from_new_cmds \
+old_archive_from_expsyms_cmds \
+archive_cmds \
+archive_expsym_cmds \
+module_cmds \
+module_expsym_cmds \
+export_symbols_cmds \
+prelink_cmds \
+postinstall_cmds \
+postuninstall_cmds \
+finish_cmds \
+sys_lib_search_path_spec \
+sys_lib_dlsearch_path_spec \
+old_archive_cmds_CXX \
+old_archive_from_new_cmds_CXX \
+old_archive_from_expsyms_cmds_CXX \
+archive_cmds_CXX \
+archive_expsym_cmds_CXX \
+module_cmds_CXX \
+module_expsym_cmds_CXX \
+export_symbols_cmds_CXX \
+prelink_cmds_CXX; do
+    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Fix-up fallback echo if it was mangled by the above quoting rules.
+case \$lt_ECHO in
+*'\\\$0 --fallback-echo"')  lt_ECHO=\`\$ECHO "X\$lt_ECHO" | \$Xsed -e 's/\\\\\\\\\\\\\\\$0 --fallback-echo"\$/\$0 --fallback-echo"/'\`
+  ;;
+esac
+
+ac_aux_dir='$ac_aux_dir'
+xsi_shell='$xsi_shell'
+lt_shell_append='$lt_shell_append'
+
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'
+
+
+
+
+
+
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
@@ -5376,11 +17172,12 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 for ac_config_target in $ac_config_targets
 do
   case $ac_config_target in
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "cfg/Makefile") CONFIG_FILES="$CONFIG_FILES cfg/Makefile" ;;
     "gtkworkbook/OBJS/Makefile") CONFIG_FILES="$CONFIG_FILES gtkworkbook/OBJS/Makefile" ;;
     "src/OBJS/Makefile") CONFIG_FILES="$CONFIG_FILES src/OBJS/Makefile" ;;
-    "src/largefile/OBJS/Makefile") CONFIG_FILES="$CONFIG_FILES src/largefile/OBJS/Makefile" ;;
-    "src/realtime/OBJS/Makefile") CONFIG_FILES="$CONFIG_FILES src/realtime/OBJS/Makefile" ;;
 
   *) { { $as_echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
 $as_echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
@@ -5395,6 +17192,7 @@ done
 # bizarre bug on SunOS 4.1.3.
 if $ac_need_defaults; then
   test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
 fi
 
 # Have a temporary directory for convenience.  Make it in the build tree
@@ -5579,7 +17377,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 fi # test -n "$CONFIG_FILES"
 
 
-eval set X "  :F $CONFIG_FILES      "
+eval set X "  :F $CONFIG_FILES      :C $CONFIG_COMMANDS"
 shift
 for ac_tag
 do
@@ -5763,6 +17561,11 @@ ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
   *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
   esac
+  ac_MKDIR_P=$MKDIR_P
+  case $MKDIR_P in
+  [\\/$]* | ?:[\\/]* ) ;;
+  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
+  esac
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
@@ -5819,6 +17622,7 @@ s&@builddir@&$ac_builddir&;t t
 s&@abs_builddir@&$ac_abs_builddir&;t t
 s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
 s&@INSTALL@&$ac_INSTALL&;t t
+s&@MKDIR_P@&$ac_MKDIR_P&;t t
 $ac_datarootdir_hack
 "
 eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
@@ -5845,9 +17649,952 @@ $as_echo "$as_me: error: could not create $ac_file" >&2;}
  ;;
 
 
+  :C)  { $as_echo "$as_me:$LINENO: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
 
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      { as_dir=$dirpart/$fdir
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
   esac
+  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
+   { (exit 1); exit 1; }; }; }
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+ ;;
+    "libtool":C)
+
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+
+# The names of the tagged configurations supported by this script.
+available_tags="CXX "
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Which release of libtool.m4 was used?
+macro_version=$macro_version
+macro_revision=$macro_revision
+
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
+
+# What type of objects to build.
+pic_mode=$pic_mode
+
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
+
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
+
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
+
+# A sed program that does not truncate output.
+SED=$lt_SED
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="\$SED -e 1s/^X//"
+
+# A grep program that handles long lines.
+GREP=$lt_GREP
+
+# An ERE matcher.
+EGREP=$lt_EGREP
+
+# A literal string matcher.
+FGREP=$lt_FGREP
+
+# A BSD- or MS-compatible name lister.
+NM=$lt_NM
+
+# Whether we need soft or hard links.
+LN_S=$lt_LN_S
+
+# What is the maximum length of a command?
+max_cmd_len=$max_cmd_len
+
+# Object file suffix (normally "o").
+objext=$ac_objext
+
+# Executable file suffix (normally "").
+exeext=$exeext
+
+# whether the shell understands "unset".
+lt_unset=$lt_unset
+
+# turn spaces into newlines.
+SP2NL=$lt_lt_SP2NL
+
+# turn newlines into spaces.
+NL2SP=$lt_lt_NL2SP
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
+
+# An object symbol dumper.
+OBJDUMP=$lt_OBJDUMP
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method == "file_magic".
+file_magic_cmd=$lt_file_magic_cmd
+
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
+
+# A symbol stripping program.
+STRIP=$lt_STRIP
+
+# Commands used to install an old-style archive.
+RANLIB=$lt_RANLIB
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
+
+# A C compiler.
+LTCC=$lt_CC
+
+# LTCC compiler flags.
+LTCFLAGS=$lt_CFLAGS
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
+
+# Transform the output of nm in a proper C declaration.
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
+
+# Transform the output of nm in a C name address pair.
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
+
+# Transform the output of nm in a C name address pair when lib prefix is needed.
+global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
+
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
+
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
+
+# An echo program that does not interpret backslashes.
+ECHO=$lt_ECHO
+
+# Used to examine libraries when file_magic_cmd begins with "file".
+MAGIC_CMD=$MAGIC_CMD
+
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
+
+# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
+DSYMUTIL=$lt_DSYMUTIL
+
+# Tool to change global to local symbols on Mac OS X.
+NMEDIT=$lt_NMEDIT
+
+# Tool to manipulate fat objects and archives on Mac OS X.
+LIPO=$lt_LIPO
+
+# ldd/readelf like tool for Mach-O binaries on Mac OS X.
+OTOOL=$lt_OTOOL
+
+# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
+OTOOL64=$lt_OTOOL64
+
+# Old archive suffix (normally "a").
+libext=$libext
+
+# Shared library suffix (normally ".so").
+shrext_cmds=$lt_shrext_cmds
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at link time.
+variables_saved_for_relink=$lt_variables_saved_for_relink
+
+# Do we need the "lib" prefix for modules?
+need_lib_prefix=$need_lib_prefix
+
+# Do we need a version for libraries?
+need_version=$need_version
+
+# Library versioning type.
+version_type=$version_type
+
+# Shared library runtime path variable.
+runpath_var=$runpath_var
+
+# Shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
+
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME
+library_names_spec=$lt_library_names_spec
+
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
+
+# Command to use after installation of a shared archive.
+postinstall_cmds=$lt_postinstall_cmds
+
+# Command to use after uninstallation of a shared archive.
+postuninstall_cmds=$lt_postuninstall_cmds
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
+
+# As "finish_cmds", except a single script fragment to be evaled but
+# not shown.
+finish_eval=$lt_finish_eval
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
+
+# Compile-time system search path for libraries.
+sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
+
+# Run-time system search path for libraries.
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
+
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
+
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
+
+
+# The linker used to build libraries.
+LD=$lt_LD
+
+# Commands used to build an old-style archive.
+old_archive_cmds=$lt_old_archive_cmds
+
+# A language specific compiler.
+CC=$lt_compiler
+
+# Is the compiler the GNU compiler?
+with_gcc=$GCC
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
+
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic
 
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object=$lt_compiler_needs_object
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
+
+# Commands used to build a shared archive.
+archive_cmds=$lt_archive_cmds
+archive_expsym_cmds=$lt_archive_expsym_cmds
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=$lt_module_cmds
+module_expsym_cmds=$lt_module_expsym_cmds
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld=$lt_with_gnu_ld
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
+
+# If ld is used when linking, flag to hardcode \$libdir into a binary
+# during linking.  This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=$hardcode_direct
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=$hardcode_direct_absolute
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=$hardcode_minus_L
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=$hardcode_automatic
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=$inherit_rpath
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path=$lt_fix_srcfile_path
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=$always_export_symbols
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=$lt_prelink_cmds
+
+# Specify filename containing input files.
+file_list_spec=$lt_file_list_spec
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
+
+# The directories searched by this compiler when creating a shared library.
+compiler_lib_search_dirs=$lt_compiler_lib_search_dirs
+
+# Dependencies to place before and after the objects being linked to
+# create a shared library.
+predep_objects=$lt_predep_objects
+postdep_objects=$lt_postdep_objects
+predeps=$lt_predeps
+postdeps=$lt_postdeps
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=$lt_compiler_lib_search_path
+
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  case $xsi_shell in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $* ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+_LT_EOF
+    ;;
+  *) # Bourne compatible functions.
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+# func_strip_suffix prefix name
+func_stripname ()
+{
+  case ${2} in
+    .*) func_stripname_result=`$ECHO "X${3}" \
+           | $Xsed -e "s%^${1}%%" -e "s%\\\\${2}\$%%"`;;
+    *)  func_stripname_result=`$ECHO "X${3}" \
+           | $Xsed -e "s%^${1}%%" -e "s%${2}\$%%"`;;
+  esac
+}
+
+# sed scripts:
+my_sed_long_opt='1s/^\(-[^=]*\)=.*/\1/;q'
+my_sed_long_arg='1s/^-[^=]*=//'
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_opt"`
+  func_opt_split_arg=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_arg"`
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  func_lo2o_result=`$ECHO "X${1}" | $Xsed -e "$lo2o"`
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=`$ECHO "X${1}" | $Xsed -e 's/\.[^.]*$/.lo/'`
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=`expr "$@"`
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
+}
+
+_LT_EOF
+esac
+
+case $lt_shell_append in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1+=\$2"
+}
+_LT_EOF
+    ;;
+  *)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1=\$$1\$2"
+}
+
+_LT_EOF
+    ;;
+  esac
+
+
+  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+
+
+    cat <<_LT_EOF >> "$ofile"
+
+# ### BEGIN LIBTOOL TAG CONFIG: CXX
+
+# The linker used to build libraries.
+LD=$lt_LD_CXX
+
+# Commands used to build an old-style archive.
+old_archive_cmds=$lt_old_archive_cmds_CXX
+
+# A language specific compiler.
+CC=$lt_compiler_CXX
+
+# Is the compiler the GNU compiler?
+with_gcc=$GCC_CXX
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_CXX
+
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl_CXX
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic_CXX
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static_CXX
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o_CXX
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc_CXX
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_CXX
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_CXX
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec_CXX
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object=$lt_compiler_needs_object_CXX
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_CXX
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_CXX
+
+# Commands used to build a shared archive.
+archive_cmds=$lt_archive_cmds_CXX
+archive_expsym_cmds=$lt_archive_expsym_cmds_CXX
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=$lt_module_cmds_CXX
+module_expsym_cmds=$lt_module_expsym_cmds_CXX
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld=$lt_with_gnu_ld_CXX
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag_CXX
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag_CXX
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_CXX
+
+# If ld is used when linking, flag to hardcode \$libdir into a binary
+# during linking.  This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld_CXX
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator_CXX
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=$hardcode_direct_CXX
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=$hardcode_direct_absolute_CXX
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=$hardcode_minus_L_CXX
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var_CXX
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=$hardcode_automatic_CXX
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=$inherit_rpath_CXX
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs_CXX
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path=$lt_fix_srcfile_path_CXX
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=$always_export_symbols_CXX
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds_CXX
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms_CXX
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms_CXX
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=$lt_prelink_cmds_CXX
+
+# Specify filename containing input files.
+file_list_spec=$lt_file_list_spec_CXX
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action_CXX
+
+# The directories searched by this compiler when creating a shared library.
+compiler_lib_search_dirs=$lt_compiler_lib_search_dirs_CXX
+
+# Dependencies to place before and after the objects being linked to
+# create a shared library.
+predep_objects=$lt_predep_objects_CXX
+postdep_objects=$lt_postdep_objects_CXX
+predeps=$lt_predeps_CXX
+postdeps=$lt_postdeps_CXX
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=$lt_compiler_lib_search_path_CXX
+
+# ### END LIBTOOL TAG CONFIG: CXX
+_LT_EOF
+
+ ;;
+
+  esac
 done # for ac_tag
 
 
@@ -5886,4 +18633,3 @@ if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
   { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
 $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
-
diff --git a/configure.ac b/configure.ac
index c17fa88..f703228 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,9 +1,9 @@
 #                                               -*- Autoconf -*-
 # Process this file with autoconf to produce a configure script.
-
 AC_PREREQ([2.59])
 AC_INIT([gtkworkbook], [0.20], [jvb4@njit.edu])
 AC_CONFIG_SRCDIR([gtkworkbook/cell.c])
+AM_INIT_AUTOMAKE([gtkworkbook],[0.20])
 
 # Checks for programs.
 AC_PROG_CXX
@@ -14,6 +14,7 @@ AC_PROG_INSTALL
 AC_PROG_LN_S
 AC_PROG_MAKE_SET
 AC_PROG_RANLIB
+AC_PROG_LIBTOOL
 
 # Checks for libraries.
 # FIXME: Replace `main' with a function in `-ldl':
@@ -30,9 +31,7 @@ AC_TYPE_SIZE_T
 # Checks for library functions.
 AC_CHECK_FUNCS([gethostbyname gettimeofday memset socket])
 
-AC_CONFIG_FILES([Makefile
-                 gtkworkbook/OBJS/Makefile
-                 src/OBJS/Makefile
-                 src/largefile/OBJS/Makefile
-                 src/realtime/OBJS/Makefile])
-AC_OUTPUT
+AC_OUTPUT([Makefile
+	   cfg/Makefile
+	   gtkworkbook/OBJS/Makefile
+           src/OBJS/Makefile])
\ No newline at end of file
diff --git a/depcomp b/depcomp
new file mode 120000
index 0000000..50adcba
--- /dev/null
+++ b/depcomp
@@ -0,0 +1 @@
+/usr/share/automake-1.10/depcomp
\ No newline at end of file
diff --git a/install-sh b/install-sh
new file mode 120000
index 0000000..8272958
--- /dev/null
+++ b/install-sh
@@ -0,0 +1 @@
+/usr/share/automake-1.10/install-sh
\ No newline at end of file
diff --git a/libtool b/libtool
new file mode 100755
index 0000000..e0306e7
--- /dev/null
+++ b/libtool
@@ -0,0 +1,9062 @@
+#! /bin/bash
+
+# libtool - Provide generalized library-building support services.
+# Generated automatically by config.status (gtkworkbook) 0.20
+# Libtool was configured on host bigblue:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+
+# The names of the tagged configurations supported by this script.
+available_tags="CXX "
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Which release of libtool.m4 was used?
+macro_version=2.2.6
+macro_revision=1.3012
+
+# Whether or not to build shared libraries.
+build_libtool_libs=yes
+
+# Whether or not to build static libraries.
+build_old_libs=yes
+
+# What type of objects to build.
+pic_mode=default
+
+# Whether or not to optimize for fast installation.
+fast_install=yes
+
+# The host system.
+host_alias=
+host=x86_64-unknown-linux-gnu
+host_os=linux-gnu
+
+# The build system.
+build_alias=
+build=x86_64-unknown-linux-gnu
+build_os=linux-gnu
+
+# A sed program that does not truncate output.
+SED="/bin/sed"
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="$SED -e 1s/^X//"
+
+# A grep program that handles long lines.
+GREP="/bin/grep"
+
+# An ERE matcher.
+EGREP="/bin/grep -E"
+
+# A literal string matcher.
+FGREP="/bin/grep -F"
+
+# A BSD- or MS-compatible name lister.
+NM="/usr/bin/nm -B"
+
+# Whether we need soft or hard links.
+LN_S="ln -s"
+
+# What is the maximum length of a command?
+max_cmd_len=1572864
+
+# Object file suffix (normally "o").
+objext=o
+
+# Executable file suffix (normally "").
+exeext=
+
+# whether the shell understands "unset".
+lt_unset=unset
+
+# turn spaces into newlines.
+SP2NL="tr \\040 \\012"
+
+# turn newlines into spaces.
+NL2SP="tr \\015\\012 \\040\\040"
+
+# How to create reloadable object files.
+reload_flag=" -r"
+reload_cmds="\$LD\$reload_flag -o \$output\$reload_objs"
+
+# An object symbol dumper.
+OBJDUMP="objdump"
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method="pass_all"
+
+# Command to use when deplibs_check_method == "file_magic".
+file_magic_cmd="\$MAGIC_CMD"
+
+# The archiver.
+AR="ar"
+AR_FLAGS="cru"
+
+# A symbol stripping program.
+STRIP="strip"
+
+# Commands used to install an old-style archive.
+RANLIB="ranlib"
+old_postinstall_cmds="chmod 644 \$oldlib~\$RANLIB \$oldlib"
+old_postuninstall_cmds=""
+
+# A C compiler.
+LTCC="gcc"
+
+# LTCC compiler flags.
+LTCFLAGS="-g -O2"
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe="sed -n -e 's/^.*[	 ]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[	 ][	 ]*\\([_A-Za-z][_A-Za-z0-9]*\\)\$/\\1 \\2 \\2/p'"
+
+# Transform the output of nm in a proper C declaration.
+global_symbol_to_cdecl="sed -n -e 's/^T .* \\(.*\\)\$/extern int \\1();/p' -e 's/^[ABCDGIRSTW]* .* \\(.*\\)\$/extern char \\1;/p'"
+
+# Transform the output of nm in a C name address pair.
+global_symbol_to_c_name_address="sed -n -e 's/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (void *) 0},/p' -e 's/^[ABCDGIRSTW]* \\([^ ]*\\) \\([^ ]*\\)\$/  {\"\\2\", (void *) \\&\\2},/p'"
+
+# Transform the output of nm in a C name address pair when lib prefix is needed.
+global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (void *) 0},/p' -e 's/^[ABCDGIRSTW]* \\([^ ]*\\) \\(lib[^ ]*\\)\$/  {\"\\2\", (void *) \\&\\2},/p' -e 's/^[ABCDGIRSTW]* \\([^ ]*\\) \\([^ ]*\\)\$/  {\"lib\\2\", (void *) \\&\\2},/p'"
+
+# The name of the directory that contains temporary libtool files.
+objdir=.libs
+
+# Shell to use when invoking shell scripts.
+SHELL="/bin/bash"
+
+# An echo program that does not interpret backslashes.
+ECHO="echo"
+
+# Used to examine libraries when file_magic_cmd begins with "file".
+MAGIC_CMD=file
+
+# Must we lock files when doing compilation?
+need_locks="no"
+
+# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
+DSYMUTIL=""
+
+# Tool to change global to local symbols on Mac OS X.
+NMEDIT=""
+
+# Tool to manipulate fat objects and archives on Mac OS X.
+LIPO=""
+
+# ldd/readelf like tool for Mach-O binaries on Mac OS X.
+OTOOL=""
+
+# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
+OTOOL64=""
+
+# Old archive suffix (normally "a").
+libext=a
+
+# Shared library suffix (normally ".so").
+shrext_cmds=".so"
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=""
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at link time.
+variables_saved_for_relink="PATH LD_LIBRARY_PATH LD_RUN_PATH GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+
+# Do we need the "lib" prefix for modules?
+need_lib_prefix=no
+
+# Do we need a version for libraries?
+need_version=no
+
+# Library versioning type.
+version_type=linux
+
+# Shared library runtime path variable.
+runpath_var=LD_RUN_PATH
+
+# Shared library path variable.
+shlibpath_var=LD_LIBRARY_PATH
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=no
+
+# Format of library name prefix.
+libname_spec="lib\$name"
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME
+library_names_spec="\${libname}\${release}\${shared_ext}\$versuffix \${libname}\${release}\${shared_ext}\$major \$libname\${shared_ext}"
+
+# The coded name of the library, if different from the real name.
+soname_spec="\${libname}\${release}\${shared_ext}\$major"
+
+# Command to use after installation of a shared archive.
+postinstall_cmds=""
+
+# Command to use after uninstallation of a shared archive.
+postuninstall_cmds=""
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds="PATH=\\\"\\\$PATH:/sbin\\\" ldconfig -n \$libdir"
+
+# As "finish_cmds", except a single script fragment to be evaled but
+# not shown.
+finish_eval=""
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=yes
+
+# Compile-time system search path for libraries.
+sys_lib_search_path_spec="/usr/lib/gcc/x86_64-linux-gnu/4.3.3 /usr/lib /lib"
+
+# Run-time system search path for libraries.
+sys_lib_dlsearch_path_spec="/lib /usr/lib /usr/lib32/alsa-lib /usr/lib/alsa-lib /usr/local/lib /lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu "
+
+# Whether dlopen is supported.
+dlopen_support=unknown
+
+# Whether dlopen of programs is supported.
+dlopen_self=unknown
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=unknown
+
+# Commands to strip libraries.
+old_striplib="strip --strip-debug"
+striplib="strip --strip-unneeded"
+
+
+# The linker used to build libraries.
+LD="/usr/bin/ld -m elf_x86_64"
+
+# Commands used to build an old-style archive.
+old_archive_cmds="\$AR \$AR_FLAGS \$oldlib\$oldobjs~\$RANLIB \$oldlib"
+
+# A language specific compiler.
+CC="gcc"
+
+# Is the compiler the GNU compiler?
+with_gcc=yes
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=" -fno-builtin"
+
+# How to pass a linker flag through the compiler.
+wl="-Wl,"
+
+# Additional compiler flags for building library objects.
+pic_flag=" -fPIC -DPIC"
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag="-static"
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o="yes"
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=no
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=no
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec="\${wl}--export-dynamic"
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec="\${wl}--whole-archive\$convenience \${wl}--no-whole-archive"
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object="no"
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=""
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=""
+
+# Commands used to build a shared archive.
+archive_cmds="\$CC -shared \$libobjs \$deplibs \$compiler_flags \${wl}-soname \$wl\$soname -o \$lib"
+archive_expsym_cmds="echo \\\"{ global:\\\" > \$output_objdir/\$libname.ver~
+	    cat \$export_symbols | sed -e \\\"s/\\\\(.*\\\\)/\\\\1;/\\\" >> \$output_objdir/\$libname.ver~
+	    echo \\\"local: *; };\\\" >> \$output_objdir/\$libname.ver~
+	    \$CC -shared \$libobjs \$deplibs \$compiler_flags \${wl}-soname \$wl\$soname \${wl}-version-script \${wl}\$output_objdir/\$libname.ver -o \$lib"
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=""
+module_expsym_cmds=""
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld="yes"
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=""
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=""
+
+# Flag to hardcode $libdir into a binary during linking.
+# This must work even if $libdir does not exist
+hardcode_libdir_flag_spec="\${wl}-rpath \${wl}\$libdir"
+
+# If ld is used when linking, flag to hardcode $libdir into a binary
+# during linking.  This must work even if $libdir does not exist.
+hardcode_libdir_flag_spec_ld=""
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=""
+
+# Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=no
+
+# Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting ${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=no
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=no
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=unsupported
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=no
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=no
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=unknown
+
+# Fix the shell variable $srcfile for the compiler.
+fix_srcfile_path=""
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=no
+
+# The commands to list exported symbols.
+export_symbols_cmds="\$NM \$libobjs \$convenience | \$global_symbol_pipe | \$SED 's/.* //' | sort | uniq > \$export_symbols"
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms="_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*"
+
+# Symbols that must always be exported.
+include_expsyms=""
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=""
+
+# Specify filename containing input files.
+file_list_spec=""
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=immediate
+
+# The directories searched by this compiler when creating a shared library.
+compiler_lib_search_dirs=""
+
+# Dependencies to place before and after the objects being linked to
+# create a shared library.
+predep_objects=""
+postdep_objects=""
+predeps=""
+postdeps=""
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=""
+
+# ### END LIBTOOL CONFIG
+
+# Generated from ltmain.m4sh.
+
+# ltmain.sh (GNU libtool) 2.2.6
+# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 2008 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# GNU Libtool is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html,
+# or obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+# Usage: $progname [OPTION]... [MODE-ARG]...
+#
+# Provide generalized library-building support services.
+#
+#     --config             show all configuration variables
+#     --debug              enable verbose shell tracing
+# -n, --dry-run            display commands without modifying any files
+#     --features           display basic configuration information and exit
+#     --mode=MODE          use operation mode MODE
+#     --preserve-dup-deps  don't remove duplicate dependency libraries
+#     --quiet, --silent    don't print informational messages
+#     --tag=TAG            use configuration variables from tag TAG
+# -v, --verbose            print informational messages (default)
+#     --version            print version information
+# -h, --help               print short or long help message
+#
+# MODE must be one of the following:
+#
+#       clean              remove files from the build directory
+#       compile            compile a source file into a libtool object
+#       execute            automatically set library path, then run a program
+#       finish             complete the installation of libtool libraries
+#       install            install libraries or executables
+#       link               create a library or an executable
+#       uninstall          remove libraries from an installed directory
+#
+# MODE-ARGS vary depending on the MODE.
+# Try `$progname --help --mode=MODE' for a more detailed description of MODE.
+#
+# When reporting a bug, please describe a test case to reproduce it and
+# include the following information:
+#
+#       host-triplet:	$host
+#       shell:		$SHELL
+#       compiler:		$LTCC
+#       compiler flags:		$LTCFLAGS
+#       linker:		$LD (gnu? $with_gnu_ld)
+#       $progname:		(GNU libtool) 2.2.6 Debian-2.2.6a-1ubuntu1
+#       automake:		$automake_version
+#       autoconf:		$autoconf_version
+#
+# Report bugs to <bug-libtool@gnu.org>.
+
+PROGRAM=ltmain.sh
+PACKAGE=libtool
+VERSION="2.2.6 Debian-2.2.6a-1ubuntu1"
+TIMESTAMP=""
+package_revision=1.3012
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# NLS nuisances: We save the old values to restore during execute mode.
+# Only set LANG and LC_ALL to C if already set.
+# These must not be set unconditionally because not all systems understand
+# e.g. LANG=C (notably SCO).
+lt_user_locale=
+lt_safe_locale=
+for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+do
+  eval "if test \"\${$lt_var+set}\" = set; then
+          save_$lt_var=\$$lt_var
+          $lt_var=C
+	  export $lt_var
+	  lt_user_locale=\"$lt_var=\\\$save_\$lt_var; \$lt_user_locale\"
+	  lt_safe_locale=\"$lt_var=C; \$lt_safe_locale\"
+	fi"
+done
+
+$lt_unset CDPATH
+
+
+
+
+
+: ${CP="cp -f"}
+: ${ECHO="echo"}
+: ${EGREP="/bin/grep -E"}
+: ${FGREP="/bin/grep -F"}
+: ${GREP="/bin/grep"}
+: ${LN_S="ln -s"}
+: ${MAKE="make"}
+: ${MKDIR="mkdir"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+: ${SED="/bin/sed"}
+: ${SHELL="${CONFIG_SHELL-/bin/sh}"}
+: ${Xsed="$SED -e 1s/^X//"}
+
+# Global variables:
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
+EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
+
+exit_status=$EXIT_SUCCESS
+
+# Make sure IFS has a sensible default
+lt_nl='
+'
+IFS=" 	$lt_nl"
+
+dirname="s,/[^/]*$,,"
+basename="s,^.*/,,"
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+# Generated shell functions inserted here.
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $* ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1+=\$2"
+}
+# Generated shell functions inserted here.
+
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath="$0"
+
+# The name of this program:
+# In the unlikely event $progname began with a '-', it would play havoc with
+# func_echo (imagine progname=-n), so we prepend ./ in that case:
+func_dirname_and_basename "$progpath"
+progname=$func_basename_result
+case $progname in
+  -*) progname=./$progname ;;
+esac
+
+# Make sure we have an absolute path for reexecution:
+case $progpath in
+  [\\/]*|[A-Za-z]:\\*) ;;
+  *[\\/]*)
+     progdir=$func_dirname_result
+     progdir=`cd "$progdir" && pwd`
+     progpath="$progdir/$progname"
+     ;;
+  *)
+     save_IFS="$IFS"
+     IFS=:
+     for progdir in $PATH; do
+       IFS="$save_IFS"
+       test -x "$progdir/$progname" && break
+     done
+     IFS="$save_IFS"
+     test -n "$progdir" || progdir=`pwd`
+     progpath="$progdir/$progname"
+     ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed="${SED}"' -e 1s/^X//'
+sed_quote_subst='s/\([`"$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Re-`\' parameter expansions in output of double_quote_subst that were
+# `\'-ed in input to the same.  If an odd number of `\' preceded a '$'
+# in input to double_quote_subst, that '$' was protected from expansion.
+# Since each input `\' is now two `\'s, look for any number of runs of
+# four `\'s followed by two `\'s and then a '$'.  `\' that '$'.
+bs='\\'
+bs2='\\\\'
+bs4='\\\\\\\\'
+dollar='\$'
+sed_double_backslash="\
+  s/$bs4/&\\
+/g
+  s/^$bs2$dollar/$bs&/
+  s/\\([^$bs]\\)$bs2$dollar/\\1$bs2$bs$dollar/g
+  s/\n//g"
+
+# Standard options:
+opt_dry_run=false
+opt_help=false
+opt_quiet=false
+opt_verbose=false
+opt_warning=:
+
+# func_echo arg...
+# Echo program name prefixed message, along with the current mode
+# name if it has been set yet.
+func_echo ()
+{
+    $ECHO "$progname${mode+: }$mode: $*"
+}
+
+# func_verbose arg...
+# Echo program name prefixed message in verbose mode only.
+func_verbose ()
+{
+    $opt_verbose && func_echo ${1+"$@"}
+
+    # A bug in bash halts the script if the last line of a function
+    # fails when set -e is in force, so we need another command to
+    # work around that:
+    :
+}
+
+# func_error arg...
+# Echo program name prefixed message to standard error.
+func_error ()
+{
+    $ECHO "$progname${mode+: }$mode: "${1+"$@"} 1>&2
+}
+
+# func_warning arg...
+# Echo program name prefixed warning message to standard error.
+func_warning ()
+{
+    $opt_warning && $ECHO "$progname${mode+: }$mode: warning: "${1+"$@"} 1>&2
+
+    # bash bug again:
+    :
+}
+
+# func_fatal_error arg...
+# Echo program name prefixed message to standard error, and exit.
+func_fatal_error ()
+{
+    func_error ${1+"$@"}
+    exit $EXIT_FAILURE
+}
+
+# func_fatal_help arg...
+# Echo program name prefixed message to standard error, followed by
+# a help hint, and exit.
+func_fatal_help ()
+{
+    func_error ${1+"$@"}
+    func_fatal_error "$help"
+}
+help="Try \`$progname --help' for more information."  ## default
+
+
+# func_grep expression filename
+# Check whether EXPRESSION matches any line of FILENAME, without output.
+func_grep ()
+{
+    $GREP "$1" "$2" >/dev/null 2>&1
+}
+
+
+# func_mkdir_p directory-path
+# Make sure the entire path to DIRECTORY-PATH is available.
+func_mkdir_p ()
+{
+    my_directory_path="$1"
+    my_dir_list=
+
+    if test -n "$my_directory_path" && test "$opt_dry_run" != ":"; then
+
+      # Protect directory names starting with `-'
+      case $my_directory_path in
+        -*) my_directory_path="./$my_directory_path" ;;
+      esac
+
+      # While some portion of DIR does not yet exist...
+      while test ! -d "$my_directory_path"; do
+        # ...make a list in topmost first order.  Use a colon delimited
+	# list incase some portion of path contains whitespace.
+        my_dir_list="$my_directory_path:$my_dir_list"
+
+        # If the last portion added has no slash in it, the list is done
+        case $my_directory_path in */*) ;; *) break ;; esac
+
+        # ...otherwise throw away the child directory and loop
+        my_directory_path=`$ECHO "X$my_directory_path" | $Xsed -e "$dirname"`
+      done
+      my_dir_list=`$ECHO "X$my_dir_list" | $Xsed -e 's,:*$,,'`
+
+      save_mkdir_p_IFS="$IFS"; IFS=':'
+      for my_dir in $my_dir_list; do
+	IFS="$save_mkdir_p_IFS"
+        # mkdir can fail with a `File exist' error if two processes
+        # try to create one of the directories concurrently.  Don't
+        # stop in that case!
+        $MKDIR "$my_dir" 2>/dev/null || :
+      done
+      IFS="$save_mkdir_p_IFS"
+
+      # Bail out if we (or some other process) failed to create a directory.
+      test -d "$my_directory_path" || \
+        func_fatal_error "Failed to create \`$1'"
+    fi
+}
+
+
+# func_mktempdir [string]
+# Make a temporary directory that won't clash with other running
+# libtool processes, and avoids race conditions if possible.  If
+# given, STRING is the basename for that directory.
+func_mktempdir ()
+{
+    my_template="${TMPDIR-/tmp}/${1-$progname}"
+
+    if test "$opt_dry_run" = ":"; then
+      # Return a directory name, but don't create it in dry-run mode
+      my_tmpdir="${my_template}-$$"
+    else
+
+      # If mktemp works, use that first and foremost
+      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+
+      if test ! -d "$my_tmpdir"; then
+        # Failing that, at least try and use $RANDOM to avoid a race
+        my_tmpdir="${my_template}-${RANDOM-0}$$"
+
+        save_mktempdir_umask=`umask`
+        umask 0077
+        $MKDIR "$my_tmpdir"
+        umask $save_mktempdir_umask
+      fi
+
+      # If we're not in dry-run mode, bomb out on failure
+      test -d "$my_tmpdir" || \
+        func_fatal_error "cannot create temporary directory \`$my_tmpdir'"
+    fi
+
+    $ECHO "X$my_tmpdir" | $Xsed
+}
+
+
+# func_quote_for_eval arg
+# Aesthetically quote ARG to be evaled later.
+# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT
+# is double-quoted, suitable for a subsequent eval, whereas
+# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters
+# which are still active within double quotes backslashified.
+func_quote_for_eval ()
+{
+    case $1 in
+      *[\\\`\"\$]*)
+	func_quote_for_eval_unquoted_result=`$ECHO "X$1" | $Xsed -e "$sed_quote_subst"` ;;
+      *)
+        func_quote_for_eval_unquoted_result="$1" ;;
+    esac
+
+    case $func_quote_for_eval_unquoted_result in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting, command substitution and and variable
+      # expansion for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        func_quote_for_eval_result="\"$func_quote_for_eval_unquoted_result\""
+        ;;
+      *)
+        func_quote_for_eval_result="$func_quote_for_eval_unquoted_result"
+    esac
+}
+
+
+# func_quote_for_expand arg
+# Aesthetically quote ARG to be evaled later; same as above,
+# but do not quote variable references.
+func_quote_for_expand ()
+{
+    case $1 in
+      *[\\\`\"]*)
+	my_arg=`$ECHO "X$1" | $Xsed \
+	    -e "$double_quote_subst" -e "$sed_double_backslash"` ;;
+      *)
+        my_arg="$1" ;;
+    esac
+
+    case $my_arg in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting and command substitution for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        my_arg="\"$my_arg\""
+        ;;
+    esac
+
+    func_quote_for_expand_result="$my_arg"
+}
+
+
+# func_show_eval cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.
+func_show_eval ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$my_cmd"
+      my_status=$?
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+# func_show_eval_locale cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.  Use the saved locale for evaluation.
+func_show_eval_locale ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$lt_user_locale
+	    $my_cmd"
+      my_status=$?
+      eval "$lt_safe_locale"
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+
+
+
+# func_version
+# Echo version message to standard output and exit.
+func_version ()
+{
+    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {
+        s/^# //
+	s/^# *$//
+        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
+        p
+     }' < "$progpath"
+     exit $?
+}
+
+# func_usage
+# Echo short help message to standard output and exit.
+func_usage ()
+{
+    $SED -n '/^# Usage:/,/# -h/ {
+        s/^# //
+	s/^# *$//
+	s/\$progname/'$progname'/
+	p
+    }' < "$progpath"
+    $ECHO
+    $ECHO "run \`$progname --help | more' for full usage"
+    exit $?
+}
+
+# func_help
+# Echo long help message to standard output and exit.
+func_help ()
+{
+    $SED -n '/^# Usage:/,/# Report bugs to/ {
+        s/^# //
+	s/^# *$//
+	s*\$progname*'$progname'*
+	s*\$host*'"$host"'*
+	s*\$SHELL*'"$SHELL"'*
+	s*\$LTCC*'"$LTCC"'*
+	s*\$LTCFLAGS*'"$LTCFLAGS"'*
+	s*\$LD*'"$LD"'*
+	s/\$with_gnu_ld/'"$with_gnu_ld"'/
+	s/\$automake_version/'"`(automake --version) 2>/dev/null |$SED 1q`"'/
+	s/\$autoconf_version/'"`(autoconf --version) 2>/dev/null |$SED 1q`"'/
+	p
+     }' < "$progpath"
+    exit $?
+}
+
+# func_missing_arg argname
+# Echo program name prefixed message to standard error and set global
+# exit_cmd.
+func_missing_arg ()
+{
+    func_error "missing argument for $1"
+    exit_cmd=exit
+}
+
+exit_cmd=:
+
+
+
+
+
+# Check that we have a working $ECHO.
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t'; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell, and then maybe $ECHO will work.
+  exec $SHELL "$progpath" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+$*
+EOF
+  exit $EXIT_SUCCESS
+fi
+
+magic="%%%MAGIC variable%%%"
+magic_exe="%%%MAGIC EXE variable%%%"
+
+# Global variables.
+# $mode is unset
+nonopt=
+execute_dlfiles=
+preserve_args=
+lo2o="s/\\.lo\$/.${objext}/"
+o2lo="s/\\.${objext}\$/.lo/"
+extracted_archives=
+extracted_serial=0
+
+opt_dry_run=false
+opt_duplicate_deps=false
+opt_silent=false
+opt_debug=:
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+# func_fatal_configuration arg...
+# Echo program name prefixed message to standard error, followed by
+# a configuration failure hint, and exit.
+func_fatal_configuration ()
+{
+    func_error ${1+"$@"}
+    func_error "See the $PACKAGE documentation for more information."
+    func_fatal_error "Fatal configuration error."
+}
+
+
+# func_config
+# Display the configuration for all the tags in this script.
+func_config ()
+{
+    re_begincf='^# ### BEGIN LIBTOOL'
+    re_endcf='^# ### END LIBTOOL'
+
+    # Default configuration.
+    $SED "1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\$d" < "$progpath"
+
+    # Now print the configurations for the tags.
+    for tagname in $taglist; do
+      $SED -n "/$re_begincf TAG CONFIG: $tagname\$/,/$re_endcf TAG CONFIG: $tagname\$/p" < "$progpath"
+    done
+
+    exit $?
+}
+
+# func_features
+# Display the features supported by this script.
+func_features ()
+{
+    $ECHO "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      $ECHO "enable shared libraries"
+    else
+      $ECHO "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      $ECHO "enable static libraries"
+    else
+      $ECHO "disable static libraries"
+    fi
+
+    exit $?
+}
+
+# func_enable_tag tagname
+# Verify that TAGNAME is valid, and either flag an error and exit, or
+# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist
+# variable here.
+func_enable_tag ()
+{
+  # Global variable:
+  tagname="$1"
+
+  re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
+  re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
+  sed_extractcf="/$re_begincf/,/$re_endcf/p"
+
+  # Validate tagname.
+  case $tagname in
+    *[!-_A-Za-z0-9,/]*)
+      func_fatal_error "invalid tag name: $tagname"
+      ;;
+  esac
+
+  # Don't test for the "default" C tag, as we know it's
+  # there but not specially marked.
+  case $tagname in
+    CC) ;;
+    *)
+      if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
+	taglist="$taglist $tagname"
+
+	# Evaluate the configuration.  Be careful to quote the path
+	# and the sed script, to avoid splitting on whitespace, but
+	# also don't use non-portable quotes within backquotes within
+	# quotes we have to do it in 2 steps:
+	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
+	eval "$extractedcf"
+      else
+	func_error "ignoring unknown tag $tagname"
+      fi
+      ;;
+  esac
+}
+
+# Parse options once, thoroughly.  This comes as soon as possible in
+# the script to make things like `libtool --version' happen quickly.
+{
+
+  # Shorthand for --mode=foo, only valid as the first argument
+  case $1 in
+  clean|clea|cle|cl)
+    shift; set dummy --mode clean ${1+"$@"}; shift
+    ;;
+  compile|compil|compi|comp|com|co|c)
+    shift; set dummy --mode compile ${1+"$@"}; shift
+    ;;
+  execute|execut|execu|exec|exe|ex|e)
+    shift; set dummy --mode execute ${1+"$@"}; shift
+    ;;
+  finish|finis|fini|fin|fi|f)
+    shift; set dummy --mode finish ${1+"$@"}; shift
+    ;;
+  install|instal|insta|inst|ins|in|i)
+    shift; set dummy --mode install ${1+"$@"}; shift
+    ;;
+  link|lin|li|l)
+    shift; set dummy --mode link ${1+"$@"}; shift
+    ;;
+  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
+    shift; set dummy --mode uninstall ${1+"$@"}; shift
+    ;;
+  esac
+
+  # Parse non-mode specific arguments:
+  while test "$#" -gt 0; do
+    opt="$1"
+    shift
+
+    case $opt in
+      --config)		func_config					;;
+
+      --debug)		preserve_args="$preserve_args $opt"
+			func_echo "enabling shell trace mode"
+			opt_debug='set -x'
+			$opt_debug
+			;;
+
+      -dlopen)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			execute_dlfiles="$execute_dlfiles $1"
+			shift
+			;;
+
+      --dry-run | -n)	opt_dry_run=:					;;
+      --features)       func_features					;;
+      --finish)		mode="finish"					;;
+
+      --mode)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			case $1 in
+			  # Valid mode arguments:
+			  clean)	;;
+			  compile)	;;
+			  execute)	;;
+			  finish)	;;
+			  install)	;;
+			  link)		;;
+			  relink)	;;
+			  uninstall)	;;
+
+			  # Catch anything else as an error
+			  *) func_error "invalid argument for $opt"
+			     exit_cmd=exit
+			     break
+			     ;;
+		        esac
+
+			mode="$1"
+			shift
+			;;
+
+      --preserve-dup-deps)
+			opt_duplicate_deps=:				;;
+
+      --quiet|--silent)	preserve_args="$preserve_args $opt"
+			opt_silent=:
+			;;
+
+      --verbose| -v)	preserve_args="$preserve_args $opt"
+			opt_silent=false
+			;;
+
+      --tag)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			preserve_args="$preserve_args $opt $1"
+			func_enable_tag "$1"	# tagname is set here
+			shift
+			;;
+
+      # Separate optargs to long options:
+      -dlopen=*|--mode=*|--tag=*)
+			func_opt_split "$opt"
+			set dummy "$func_opt_split_opt" "$func_opt_split_arg" ${1+"$@"}
+			shift
+			;;
+
+      -\?|-h)		func_usage					;;
+      --help)		opt_help=:					;;
+      --version)	func_version					;;
+
+      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
+
+      *)		nonopt="$opt"
+			break
+			;;
+    esac
+  done
+
+
+  case $host in
+    *cygwin* | *mingw* | *pw32* | *cegcc*)
+      # don't eliminate duplications in $postdeps and $predeps
+      opt_duplicate_compiler_generated_deps=:
+      ;;
+    *)
+      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps
+      ;;
+  esac
+
+  # Having warned about all mis-specified options, bail out if
+  # anything was wrong.
+  $exit_cmd $EXIT_FAILURE
+}
+
+# func_check_version_match
+# Ensure that we are using m4 macros, and libtool script from the same
+# release of libtool.
+func_check_version_match ()
+{
+  if test "$package_revision" != "$macro_revision"; then
+    if test "$VERSION" != "$macro_version"; then
+      if test -z "$macro_version"; then
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from an older release.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      else
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      fi
+    else
+      cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,
+$progname: but the definition of this LT_INIT comes from revision $macro_revision.
+$progname: You should recreate aclocal.m4 with macros from revision $package_revision
+$progname: of $PACKAGE $VERSION and run autoconf again.
+_LT_EOF
+    fi
+
+    exit $EXIT_MISMATCH
+  fi
+}
+
+
+## ----------- ##
+##    Main.    ##
+## ----------- ##
+
+$opt_help || {
+  # Sanity checks first:
+  func_check_version_match
+
+  if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+    func_fatal_configuration "not configured to build any kind of library"
+  fi
+
+  test -z "$mode" && func_fatal_error "error: you must specify a MODE."
+
+
+  # Darwin sucks
+  eval std_shrext=\"$shrext_cmds\"
+
+
+  # Only execute mode is allowed to have -dlopen flags.
+  if test -n "$execute_dlfiles" && test "$mode" != execute; then
+    func_error "unrecognized option \`-dlopen'"
+    $ECHO "$help" 1>&2
+    exit $EXIT_FAILURE
+  fi
+
+  # Change the help message to a mode-specific one.
+  generic_help="$help"
+  help="Try \`$progname --help --mode=$mode' for more information."
+}
+
+
+# func_lalib_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_lalib_p ()
+{
+    test -f "$1" &&
+      $SED -e 4q "$1" 2>/dev/null \
+        | $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+}
+
+# func_lalib_unsafe_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function implements the same check as func_lalib_p without
+# resorting to external programs.  To this end, it redirects stdin and
+# closes it afterwards, without saving the original file descriptor.
+# As a safety measure, use it only where a negative result would be
+# fatal anyway.  Works if `file' does not exist.
+func_lalib_unsafe_p ()
+{
+    lalib_p=no
+    if test -f "$1" && test -r "$1" && exec 5<&0 <"$1"; then
+	for lalib_p_l in 1 2 3 4
+	do
+	    read lalib_p_line
+	    case "$lalib_p_line" in
+		\#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
+	    esac
+	done
+	exec 0<&5 5<&-
+    fi
+    test "$lalib_p" = yes
+}
+
+# func_ltwrapper_script_p file
+# True iff FILE is a libtool wrapper script
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_script_p ()
+{
+    func_lalib_p "$1"
+}
+
+# func_ltwrapper_executable_p file
+# True iff FILE is a libtool wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_executable_p ()
+{
+    func_ltwrapper_exec_suffix=
+    case $1 in
+    *.exe) ;;
+    *) func_ltwrapper_exec_suffix=.exe ;;
+    esac
+    $GREP "$magic_exe" "$1$func_ltwrapper_exec_suffix" >/dev/null 2>&1
+}
+
+# func_ltwrapper_scriptname file
+# Assumes file is an ltwrapper_executable
+# uses $file to determine the appropriate filename for a
+# temporary ltwrapper_script.
+func_ltwrapper_scriptname ()
+{
+    func_ltwrapper_scriptname_result=""
+    if func_ltwrapper_executable_p "$1"; then
+	func_dirname_and_basename "$1" "" "."
+	func_stripname '' '.exe' "$func_basename_result"
+	func_ltwrapper_scriptname_result="$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper"
+    fi
+}
+
+# func_ltwrapper_p file
+# True iff FILE is a libtool wrapper script or wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_p ()
+{
+    func_ltwrapper_script_p "$1" || func_ltwrapper_executable_p "$1"
+}
+
+
+# func_execute_cmds commands fail_cmd
+# Execute tilde-delimited COMMANDS.
+# If FAIL_CMD is given, eval that upon failure.
+# FAIL_CMD may read-access the current command in variable CMD!
+func_execute_cmds ()
+{
+    $opt_debug
+    save_ifs=$IFS; IFS='~'
+    for cmd in $1; do
+      IFS=$save_ifs
+      eval cmd=\"$cmd\"
+      func_show_eval "$cmd" "${2-:}"
+    done
+    IFS=$save_ifs
+}
+
+
+# func_source file
+# Source FILE, adding directory component if necessary.
+# Note that it is not necessary on cygwin/mingw to append a dot to
+# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
+# behavior happens only for exec(3), not for open(2)!  Also, sourcing
+# `FILE.' does not work on cygwin managed mounts.
+func_source ()
+{
+    $opt_debug
+    case $1 in
+    */* | *\\*)	. "$1" ;;
+    *)		. "./$1" ;;
+    esac
+}
+
+
+# func_infer_tag arg
+# Infer tagged configuration to use if any are available and
+# if one wasn't chosen via the "--tag" command line option.
+# Only attempt this if the compiler in the base compile
+# command doesn't match the default compiler.
+# arg is usually of the form 'gcc ...'
+func_infer_tag ()
+{
+    $opt_debug
+    if test -n "$available_tags" && test -z "$tagname"; then
+      CC_quoted=
+      for arg in $CC; do
+        func_quote_for_eval "$arg"
+	CC_quoted="$CC_quoted $func_quote_for_eval_result"
+      done
+      case $@ in
+      # Blanks in the command may have been stripped by the calling shell,
+      # but not from the CC environment variable when configure was run.
+      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*) ;;
+      # Blanks at the start of $base_compile will cause this to fail
+      # if we don't check for them as well.
+      *)
+	for z in $available_tags; do
+	  if $GREP "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
+	    # Evaluate the configuration.
+	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    CC_quoted=
+	    for arg in $CC; do
+	      # Double-quote args containing other shell metacharacters.
+	      func_quote_for_eval "$arg"
+	      CC_quoted="$CC_quoted $func_quote_for_eval_result"
+	    done
+	    case "$@ " in
+	      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*)
+	      # The compiler in the base compile command matches
+	      # the one in the tagged configuration.
+	      # Assume this is the tagged configuration we want.
+	      tagname=$z
+	      break
+	      ;;
+	    esac
+	  fi
+	done
+	# If $tagname still isn't set, then no tagged configuration
+	# was found and let the user know that the "--tag" command
+	# line option must be used.
+	if test -z "$tagname"; then
+	  func_echo "unable to infer tagged configuration"
+	  func_fatal_error "specify a tag with \`--tag'"
+#	else
+#	  func_verbose "using $tagname tagged configuration"
+	fi
+	;;
+      esac
+    fi
+}
+
+
+
+# func_write_libtool_object output_name pic_name nonpic_name
+# Create a libtool object file (analogous to a ".la" file),
+# but don't create it if we're doing a dry run.
+func_write_libtool_object ()
+{
+    write_libobj=${1}
+    if test "$build_libtool_libs" = yes; then
+      write_lobj=\'${2}\'
+    else
+      write_lobj=none
+    fi
+
+    if test "$build_old_libs" = yes; then
+      write_oldobj=\'${3}\'
+    else
+      write_oldobj=none
+    fi
+
+    $opt_dry_run || {
+      cat >${write_libobj}T <<EOF
+# $write_libobj - a libtool object file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# Name of the PIC object.
+pic_object=$write_lobj
+
+# Name of the non-PIC object
+non_pic_object=$write_oldobj
+
+EOF
+      $MV "${write_libobj}T" "${write_libobj}"
+    }
+}
+
+# func_mode_compile arg...
+func_mode_compile ()
+{
+    $opt_debug
+    # Get the compilation command and the source file.
+    base_compile=
+    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    suppress_opt=yes
+    suppress_output=
+    arg_mode=normal
+    libobj=
+    later=
+    pie_flag=
+
+    for arg
+    do
+      case $arg_mode in
+      arg  )
+	# do not "continue".  Instead, add this to base_compile
+	lastarg="$arg"
+	arg_mode=normal
+	;;
+
+      target )
+	libobj="$arg"
+	arg_mode=normal
+	continue
+	;;
+
+      normal )
+	# Accept any command-line options.
+	case $arg in
+	-o)
+	  test -n "$libobj" && \
+	    func_fatal_error "you cannot specify \`-o' more than once"
+	  arg_mode=target
+	  continue
+	  ;;
+
+	-pie | -fpie | -fPIE)
+          pie_flag="$pie_flag $arg"
+	  continue
+	  ;;
+
+	-shared | -static | -prefer-pic | -prefer-non-pic)
+	  later="$later $arg"
+	  continue
+	  ;;
+
+	-no-suppress)
+	  suppress_opt=no
+	  continue
+	  ;;
+
+	-Xcompiler)
+	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
+	  continue      #  The current "srcfile" will either be retained or
+	  ;;            #  replaced later.  I would guess that would be a bug.
+
+	-Wc,*)
+	  func_stripname '-Wc,' '' "$arg"
+	  args=$func_stripname_result
+	  lastarg=
+	  save_ifs="$IFS"; IFS=','
+	  for arg in $args; do
+	    IFS="$save_ifs"
+	    func_quote_for_eval "$arg"
+	    lastarg="$lastarg $func_quote_for_eval_result"
+	  done
+	  IFS="$save_ifs"
+	  func_stripname ' ' '' "$lastarg"
+	  lastarg=$func_stripname_result
+
+	  # Add the arguments to base_compile.
+	  base_compile="$base_compile $lastarg"
+	  continue
+	  ;;
+
+	*)
+	  # Accept the current argument as the source file.
+	  # The previous "srcfile" becomes the current argument.
+	  #
+	  lastarg="$srcfile"
+	  srcfile="$arg"
+	  ;;
+	esac  #  case $arg
+	;;
+      esac    #  case $arg_mode
+
+      # Aesthetically quote the previous argument.
+      func_quote_for_eval "$lastarg"
+      base_compile="$base_compile $func_quote_for_eval_result"
+    done # for arg
+
+    case $arg_mode in
+    arg)
+      func_fatal_error "you must specify an argument for -Xcompile"
+      ;;
+    target)
+      func_fatal_error "you must specify a target with \`-o'"
+      ;;
+    *)
+      # Get the name of the library object.
+      test -z "$libobj" && {
+	func_basename "$srcfile"
+	libobj="$func_basename_result"
+      }
+      ;;
+    esac
+
+    # Recognize several different file suffixes.
+    # If the user specifies -o file.o, it is replaced with file.lo
+    case $libobj in
+    *.[cCFSifmso] | \
+    *.ada | *.adb | *.ads | *.asm | \
+    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \
+    *.[fF][09]? | *.for | *.java | *.obj | *.sx)
+      func_xform "$libobj"
+      libobj=$func_xform_result
+      ;;
+    esac
+
+    case $libobj in
+    *.lo) func_lo2o "$libobj"; obj=$func_lo2o_result ;;
+    *)
+      func_fatal_error "cannot determine name of library object from \`$libobj'"
+      ;;
+    esac
+
+    func_infer_tag $base_compile
+
+    for arg in $later; do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	continue
+	;;
+
+      -static)
+	build_libtool_libs=no
+	build_old_libs=yes
+	continue
+	;;
+
+      -prefer-pic)
+	pic_mode=yes
+	continue
+	;;
+
+      -prefer-non-pic)
+	pic_mode=no
+	continue
+	;;
+      esac
+    done
+
+    func_quote_for_eval "$libobj"
+    test "X$libobj" != "X$func_quote_for_eval_result" \
+      && $ECHO "X$libobj" | $GREP '[]~#^*{};<>?"'"'"'	 &()|`$[]' \
+      && func_warning "libobj name \`$libobj' may not contain shell special characters."
+    func_dirname_and_basename "$obj" "/" ""
+    objname="$func_basename_result"
+    xdir="$func_dirname_result"
+    lobj=${xdir}$objdir/$objname
+
+    test -z "$base_compile" && \
+      func_fatal_help "you must specify a compilation command"
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      removelist="$obj $lobj $libobj ${libobj}T"
+    else
+      removelist="$lobj $libobj ${libobj}T"
+    fi
+
+    # On Cygwin there's no "real" PIC flag so we must build both object types
+    case $host_os in
+    cygwin* | mingw* | pw32* | os2* | cegcc*)
+      pic_mode=default
+      ;;
+    esac
+    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+      # non-PIC code in shared libraries is not supported
+      pic_mode=default
+    fi
+
+    # Calculate the filename of the output object if compiler does
+    # not support -o with -c
+    if test "$compiler_c_o" = no; then
+      output_obj=`$ECHO "X$srcfile" | $Xsed -e 's%^.*/%%' -e 's%\.[^.]*$%%'`.${objext}
+      lockfile="$output_obj.lock"
+    else
+      output_obj=
+      need_locks=no
+      lockfile=
+    fi
+
+    # Lock this critical section if it is needed
+    # We use this script file to make the link, it avoids creating a new file
+    if test "$need_locks" = yes; then
+      until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
+	func_echo "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    elif test "$need_locks" = warn; then
+      if test -f "$lockfile"; then
+	$ECHO "\
+*** ERROR, $lockfile exists and contains:
+`cat $lockfile 2>/dev/null`
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+      removelist="$removelist $output_obj"
+      $ECHO "$srcfile" > "$lockfile"
+    fi
+
+    $opt_dry_run || $RM $removelist
+    removelist="$removelist $lockfile"
+    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15
+
+    if test -n "$fix_srcfile_path"; then
+      eval srcfile=\"$fix_srcfile_path\"
+    fi
+    func_quote_for_eval "$srcfile"
+    qsrcfile=$func_quote_for_eval_result
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # Without this assignment, base_compile gets emptied.
+      fbsd_hideous_sh_bug=$base_compile
+
+      if test "$pic_mode" != no; then
+	command="$base_compile $qsrcfile $pic_flag"
+      else
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      fi
+
+      func_mkdir_p "$xdir$objdir"
+
+      if test -z "$output_obj"; then
+	# Place PIC objects in $objdir
+	command="$command -o $lobj"
+      fi
+
+      func_show_eval_locale "$command"	\
+          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed, then go on to compile the next one
+      if test -n "$output_obj" && test "X$output_obj" != "X$lobj"; then
+	func_show_eval '$MV "$output_obj" "$lobj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+
+      # Allow error messages only from the first compilation.
+      if test "$suppress_opt" = yes; then
+	suppress_output=' >/dev/null 2>&1'
+      fi
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      if test "$pic_mode" != yes; then
+	# Don't build PIC code
+	command="$base_compile $qsrcfile$pie_flag"
+      else
+	command="$base_compile $qsrcfile $pic_flag"
+      fi
+      if test "$compiler_c_o" = yes; then
+	command="$command -o $obj"
+      fi
+
+      # Suppress compiler output if we already did a PIC compilation.
+      command="$command$suppress_output"
+      func_show_eval_locale "$command" \
+        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed
+      if test -n "$output_obj" && test "X$output_obj" != "X$obj"; then
+	func_show_eval '$MV "$output_obj" "$obj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+    fi
+
+    $opt_dry_run || {
+      func_write_libtool_object "$libobj" "$objdir/$objname" "$objname"
+
+      # Unlock the critical section if it was locked
+      if test "$need_locks" != no; then
+	removelist=$lockfile
+        $RM "$lockfile"
+      fi
+    }
+
+    exit $EXIT_SUCCESS
+}
+
+$opt_help || {
+test "$mode" = compile && func_mode_compile ${1+"$@"}
+}
+
+func_mode_help ()
+{
+    # We need to display help for each of the modes.
+    case $mode in
+      "")
+        # Generic help is extracted from the usage comments
+        # at the start of this file.
+        func_help
+        ;;
+
+      clean)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...
+
+Remove files from the build directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, object or program, all the files associated
+with it are deleted. Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      compile)
+      $ECHO \
+"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+This mode accepts the following additional options:
+
+  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE
+  -no-suppress      do not suppress compiler output for multiple passes
+  -prefer-pic       try to building PIC objects only
+  -prefer-non-pic   try to building non-PIC objects only
+  -shared           do not build a \`.o' file suitable for static linking
+  -static           only build a \`.o' file suitable for static linking
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'."
+        ;;
+
+      execute)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
+
+Automatically set library path, then run a program.
+
+This mode accepts the following additional options:
+
+  -dlopen FILE      add the directory containing FILE to the library path
+
+This mode sets the library path environment variable according to \`-dlopen'
+flags.
+
+If any of the ARGS are libtool executable wrappers, then they are translated
+into their corresponding uninstalled binary, and any of their required library
+directories are added to the library path.
+
+Then, COMMAND is executed, with ARGS as arguments."
+        ;;
+
+      finish)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed."
+        ;;
+
+      install)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The following components of INSTALL-COMMAND are treated specially:
+
+  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized)."
+        ;;
+
+      link)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -all-static       do not do any dynamic linking at all
+  -avoid-version    do not add a version suffix if possible
+  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -export-symbols SYMFILE
+                    try to export only the symbols listed in SYMFILE
+  -export-symbols-regex REGEX
+                    try to export only the symbols matching REGEX
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -module           build a library that can dlopened
+  -no-fast-install  disable the fast-install mode
+  -no-install       link a not-installable executable
+  -no-undefined     declare that a library does not refer to external symbols
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -precious-files-regex REGEX
+                    don't remove output files matching REGEX
+  -release RELEASE  specify package release information
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries
+  -shared           only do dynamic linking of libtool libraries
+  -shrext SUFFIX    override the standard shared library file extension
+  -static           do not do any dynamic linking of uninstalled libtool libraries
+  -static-libtool-libs
+                    do not do any dynamic linking of libtool libraries
+  -version-info CURRENT[:REVISION[:AGE]]
+                    specify library version info [each variable defaults to 0]
+  -weak LIBNAME     declare that the target provides the LIBNAME interface
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
+only library objects (\`.lo' files) may be specified, and \`-rpath' is
+required, except when creating a convenience library.
+
+If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
+using \`ar' and \`ranlib', or on Windows using \`lib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+is created, otherwise an executable program is created."
+        ;;
+
+      uninstall)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      *)
+        func_fatal_help "invalid operation mode \`$mode'"
+        ;;
+    esac
+
+    $ECHO
+    $ECHO "Try \`$progname --help' for more information about other modes."
+
+    exit $?
+}
+
+  # Now that we've collected a possible --mode arg, show help if necessary
+  $opt_help && func_mode_help
+
+
+# func_mode_execute arg...
+func_mode_execute ()
+{
+    $opt_debug
+    # The first argument is the command name.
+    cmd="$nonopt"
+    test -z "$cmd" && \
+      func_fatal_help "you must specify a COMMAND"
+
+    # Handle -dlopen flags immediately.
+    for file in $execute_dlfiles; do
+      test -f "$file" \
+	|| func_fatal_help "\`$file' is not a file"
+
+      dir=
+      case $file in
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$lib' is not a valid libtool archive"
+
+	# Read the libtool library.
+	dlname=
+	library_names=
+	func_source "$file"
+
+	# Skip this library if it cannot be dlopened.
+	if test -z "$dlname"; then
+	  # Warn if it was a shared library.
+	  test -n "$library_names" && \
+	    func_warning "\`$file' was not linked with \`-export-dynamic'"
+	  continue
+	fi
+
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+
+	if test -f "$dir/$objdir/$dlname"; then
+	  dir="$dir/$objdir"
+	else
+	  if test ! -f "$dir/$dlname"; then
+	    func_fatal_error "cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'"
+	  fi
+	fi
+	;;
+
+      *.lo)
+	# Just add the directory containing the .lo file.
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+	;;
+
+      *)
+	func_warning "\`-dlopen' is ignored for non-libtool libraries and objects"
+	continue
+	;;
+      esac
+
+      # Get the absolute pathname.
+      absdir=`cd "$dir" && pwd`
+      test -n "$absdir" && dir="$absdir"
+
+      # Now add the directory to shlibpath_var.
+      if eval "test -z \"\$$shlibpath_var\""; then
+	eval "$shlibpath_var=\"\$dir\""
+      else
+	eval "$shlibpath_var=\"\$dir:\$$shlibpath_var\""
+      fi
+    done
+
+    # This variable tells wrapper scripts just to set shlibpath_var
+    # rather than running their programs.
+    libtool_execute_magic="$magic"
+
+    # Check if any of the arguments is a wrapper script.
+    args=
+    for file
+    do
+      case $file in
+      -*) ;;
+      *)
+	# Do a test to see if this is really a libtool program.
+	if func_ltwrapper_script_p "$file"; then
+	  func_source "$file"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	elif func_ltwrapper_executable_p "$file"; then
+	  func_ltwrapper_scriptname "$file"
+	  func_source "$func_ltwrapper_scriptname_result"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	fi
+	;;
+      esac
+      # Quote arguments (to preserve shell metacharacters).
+      func_quote_for_eval "$file"
+      args="$args $func_quote_for_eval_result"
+    done
+
+    if test "X$opt_dry_run" = Xfalse; then
+      if test -n "$shlibpath_var"; then
+	# Export the shlibpath_var.
+	eval "export $shlibpath_var"
+      fi
+
+      # Restore saved environment variables
+      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+      do
+	eval "if test \"\${save_$lt_var+set}\" = set; then
+                $lt_var=\$save_$lt_var; export $lt_var
+	      else
+		$lt_unset $lt_var
+	      fi"
+      done
+
+      # Now prepare to actually exec the command.
+      exec_cmd="\$cmd$args"
+    else
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
+	$ECHO "export $shlibpath_var"
+      fi
+      $ECHO "$cmd$args"
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = execute && func_mode_execute ${1+"$@"}
+
+
+# func_mode_finish arg...
+func_mode_finish ()
+{
+    $opt_debug
+    libdirs="$nonopt"
+    admincmds=
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      for dir
+      do
+	libdirs="$libdirs $dir"
+      done
+
+      for libdir in $libdirs; do
+	if test -n "$finish_cmds"; then
+	  # Do each command in the finish commands.
+	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
+'"$cmd"'"'
+	fi
+	if test -n "$finish_eval"; then
+	  # Do the single finish_eval.
+	  eval cmds=\"$finish_eval\"
+	  $opt_dry_run || eval "$cmds" || admincmds="$admincmds
+       $cmds"
+	fi
+      done
+    fi
+
+    # Exit here if they wanted silent mode.
+    $opt_silent && exit $EXIT_SUCCESS
+
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    $ECHO "Libraries have been installed in:"
+    for libdir in $libdirs; do
+      $ECHO "   $libdir"
+    done
+    $ECHO
+    $ECHO "If you ever happen to want to link against installed libraries"
+    $ECHO "in a given directory, LIBDIR, you must either use libtool, and"
+    $ECHO "specify the full pathname of the library, or use the \`-LLIBDIR'"
+    $ECHO "flag during linking and do at least one of the following:"
+    if test -n "$shlibpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+      $ECHO "     during execution"
+    fi
+    if test -n "$runpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$runpath_var' environment variable"
+      $ECHO "     during linking"
+    fi
+    if test -n "$hardcode_libdir_flag_spec"; then
+      libdir=LIBDIR
+      eval flag=\"$hardcode_libdir_flag_spec\"
+
+      $ECHO "   - use the \`$flag' linker flag"
+    fi
+    if test -n "$admincmds"; then
+      $ECHO "   - have your system administrator run these commands:$admincmds"
+    fi
+    if test -f /etc/ld.so.conf; then
+      $ECHO "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+    fi
+    $ECHO
+
+    $ECHO "See any operating system documentation about shared libraries for"
+    case $host in
+      solaris2.[6789]|solaris2.1[0-9])
+        $ECHO "more information, such as the ld(1), crle(1) and ld.so(8) manual"
+	$ECHO "pages."
+	;;
+      *)
+        $ECHO "more information, such as the ld(1) and ld.so(8) manual pages."
+        ;;
+    esac
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    exit $EXIT_SUCCESS
+}
+
+test "$mode" = finish && func_mode_finish ${1+"$@"}
+
+
+# func_mode_install arg...
+func_mode_install ()
+{
+    $opt_debug
+    # There may be an optional sh(1) argument at the beginning of
+    # install_prog (especially on Windows NT).
+    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+       # Allow the use of GNU shtool's install command.
+       $ECHO "X$nonopt" | $GREP shtool >/dev/null; then
+      # Aesthetically quote it.
+      func_quote_for_eval "$nonopt"
+      install_prog="$func_quote_for_eval_result "
+      arg=$1
+      shift
+    else
+      install_prog=
+      arg=$nonopt
+    fi
+
+    # The real first argument should be the name of the installation program.
+    # Aesthetically quote it.
+    func_quote_for_eval "$arg"
+    install_prog="$install_prog$func_quote_for_eval_result"
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=no
+    stripme=
+    for arg
+    do
+      if test -n "$dest"; then
+	files="$files $dest"
+	dest=$arg
+	continue
+      fi
+
+      case $arg in
+      -d) isdir=yes ;;
+      -f)
+	case " $install_prog " in
+	*[\\\ /]cp\ *) ;;
+	*) prev=$arg ;;
+	esac
+	;;
+      -g | -m | -o)
+	prev=$arg
+	;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*)
+	;;
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  prev=
+	else
+	  dest=$arg
+	  continue
+	fi
+	;;
+      esac
+
+      # Aesthetically quote the argument.
+      func_quote_for_eval "$arg"
+      install_prog="$install_prog $func_quote_for_eval_result"
+    done
+
+    test -z "$install_prog" && \
+      func_fatal_help "you must specify an install program"
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prev' option requires an argument"
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+	func_fatal_help "no file or destination specified"
+      else
+	func_fatal_help "you must specify a destination"
+      fi
+    fi
+
+    # Strip any trailing slash from the destination.
+    func_stripname '' '/' "$dest"
+    dest=$func_stripname_result
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test "$isdir" = yes; then
+      destdir="$dest"
+      destname=
+    else
+      func_dirname_and_basename "$dest" "" "."
+      destdir="$func_dirname_result"
+      destname="$func_basename_result"
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files; shift
+      test "$#" -gt 1 && \
+	func_fatal_help "\`$dest' is not a directory"
+    fi
+    case $destdir in
+    [\\/]* | [A-Za-z]:[\\/]*) ;;
+    *)
+      for file in $files; do
+	case $file in
+	*.lo) ;;
+	*)
+	  func_fatal_help "\`$destdir' must be an absolute directory name"
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case $file in
+      *.$libext)
+	# Do the static libraries later.
+	staticlibs="$staticlibs $file"
+	;;
+
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$file' is not a valid libtool archive"
+
+	library_names=
+	old_library=
+	relink_command=
+	func_source "$file"
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "X$destdir" = "X$libdir"; then
+	  case "$current_libdirs " in
+	  *" $libdir "*) ;;
+	  *) current_libdirs="$current_libdirs $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  *" $libdir "*) ;;
+	  *) future_libdirs="$future_libdirs $libdir" ;;
+	  esac
+	fi
+
+	func_dirname "$file" "/" ""
+	dir="$func_dirname_result"
+	dir="$dir$objdir"
+
+	if test -n "$relink_command"; then
+	  # Determine the prefix the user has applied to our future dir.
+	  inst_prefix_dir=`$ECHO "X$destdir" | $Xsed -e "s%$libdir\$%%"`
+
+	  # Don't allow the user to place us outside of our expected
+	  # location b/c this prevents finding dependent libraries that
+	  # are installed to the same prefix.
+	  # At present, this check doesn't affect windows .dll's that
+	  # are installed into $libdir/../bin (currently, that works fine)
+	  # but it's something to keep an eye on.
+	  test "$inst_prefix_dir" = "$destdir" && \
+	    func_fatal_error "error: cannot install \`$file' to a directory not ending in $libdir"
+
+	  if test -n "$inst_prefix_dir"; then
+	    # Stick the inst_prefix_dir data into the link command.
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
+	  else
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%%"`
+	  fi
+
+	  func_warning "relinking \`$file'"
+	  func_show_eval "$relink_command" \
+	    'func_fatal_error "error: relink \`$file'\'' with the above command before installing it"'
+	fi
+
+	# See the names of the shared library.
+	set dummy $library_names; shift
+	if test -n "$1"; then
+	  realname="$1"
+	  shift
+
+	  srcname="$realname"
+	  test -n "$relink_command" && srcname="$realname"T
+
+	  # Install the shared library and build the symlinks.
+	  func_show_eval "$install_prog $dir/$srcname $destdir/$realname" \
+	      'exit $?'
+	  tstripme="$stripme"
+	  case $host_os in
+	  cygwin* | mingw* | pw32* | cegcc*)
+	    case $realname in
+	    *.dll.a)
+	      tstripme=""
+	      ;;
+	    esac
+	    ;;
+	  esac
+	  if test -n "$tstripme" && test -n "$striplib"; then
+	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
+	  fi
+
+	  if test "$#" -gt 0; then
+	    # Delete the old symlinks, and create new ones.
+	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
+	    # so we also need to try rm && ln -s.
+	    for linkname
+	    do
+	      test "$linkname" != "$realname" \
+		&& func_show_eval "(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })"
+	    done
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  func_execute_cmds "$postinstall_cmds" 'exit $?'
+	fi
+
+	# Install the pseudo-library for information purposes.
+	func_basename "$file"
+	name="$func_basename_result"
+	instname="$dir/$name"i
+	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && staticlibs="$staticlibs $dir/$old_library"
+	;;
+
+      *.lo)
+	# Install (i.e. copy) a libtool object.
+
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# Deduce the name of the destination old-style object file.
+	case $destfile in
+	*.lo)
+	  func_lo2o "$destfile"
+	  staticdest=$func_lo2o_result
+	  ;;
+	*.$objext)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  func_fatal_help "cannot copy a libtool object to \`$destfile'"
+	  ;;
+	esac
+
+	# Install the libtool object if requested.
+	test -n "$destfile" && \
+	  func_show_eval "$install_prog $file $destfile" 'exit $?'
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  func_lo2o "$file"
+	  staticobj=$func_lo2o_result
+	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
+	fi
+	exit $EXIT_SUCCESS
+	;;
+
+      *)
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# If the file is missing, and there is a .exe on the end, strip it
+	# because it is most likely a libtool script we actually want to
+	# install
+	stripped_ext=""
+	case $file in
+	  *.exe)
+	    if test ! -f "$file"; then
+	      func_stripname '' '.exe' "$file"
+	      file=$func_stripname_result
+	      stripped_ext=".exe"
+	    fi
+	    ;;
+	esac
+
+	# Do a test to see if this is really a libtool program.
+	case $host in
+	*cygwin* | *mingw*)
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      wrapper=$func_ltwrapper_scriptname_result
+	    else
+	      func_stripname '' '.exe' "$file"
+	      wrapper=$func_stripname_result
+	    fi
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if func_ltwrapper_script_p "$wrapper"; then
+	  notinst_deplibs=
+	  relink_command=
+
+	  func_source "$wrapper"
+
+	  # Check the variables that should have been set.
+	  test -z "$generated_by_libtool_version" && \
+	    func_fatal_error "invalid libtool wrapper script \`$wrapper'"
+
+	  finalize=yes
+	  for lib in $notinst_deplibs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      func_source "$lib"
+	    fi
+	    libfile="$libdir/"`$ECHO "X$lib" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    if test -n "$libdir" && test ! -f "$libfile"; then
+	      func_warning "\`$lib' has not been installed in \`$libdir'"
+	      finalize=no
+	    fi
+	  done
+
+	  relink_command=
+	  func_source "$wrapper"
+
+	  outputname=
+	  if test "$fast_install" = no && test -n "$relink_command"; then
+	    $opt_dry_run || {
+	      if test "$finalize" = yes; then
+	        tmpdir=`func_mktempdir`
+		func_basename "$file$stripped_ext"
+		file="$func_basename_result"
+	        outputname="$tmpdir/$file"
+	        # Replace the output file specification.
+	        relink_command=`$ECHO "X$relink_command" | $Xsed -e 's%@OUTPUT@%'"$outputname"'%g'`
+
+	        $opt_silent || {
+	          func_quote_for_expand "$relink_command"
+		  eval "func_echo $func_quote_for_expand_result"
+	        }
+	        if eval "$relink_command"; then :
+	          else
+		  func_error "error: relink \`$file' with the above command before installing it"
+		  $opt_dry_run || ${RM}r "$tmpdir"
+		  continue
+	        fi
+	        file="$outputname"
+	      else
+	        func_warning "cannot relink \`$file'"
+	      fi
+	    }
+	  else
+	    # Install the binary that we compiled earlier.
+	    file=`$ECHO "X$file$stripped_ext" | $Xsed -e "s%\([^/]*\)$%$objdir/\1%"`
+	  fi
+	fi
+
+	# remove .exe since cygwin /usr/bin/install will append another
+	# one anyway
+	case $install_prog,$host in
+	*/usr/bin/install*,*cygwin*)
+	  case $file:$destfile in
+	  *.exe:*.exe)
+	    # this is ok
+	    ;;
+	  *.exe:*)
+	    destfile=$destfile.exe
+	    ;;
+	  *:*.exe)
+	    func_stripname '' '.exe' "$destfile"
+	    destfile=$func_stripname_result
+	    ;;
+	  esac
+	  ;;
+	esac
+	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
+	$opt_dry_run || if test -n "$outputname"; then
+	  ${RM}r "$tmpdir"
+	fi
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      func_basename "$file"
+      name="$func_basename_result"
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+
+      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
+
+      if test -n "$stripme" && test -n "$old_striplib"; then
+	func_show_eval "$old_striplib $oldlib" 'exit $?'
+      fi
+
+      # Do each command in the postinstall commands.
+      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
+    done
+
+    test -n "$future_libdirs" && \
+      func_warning "remember to run \`$progname --finish$future_libdirs'"
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      $opt_dry_run && current_libdirs=" -n$current_libdirs"
+      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+    else
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = install && func_mode_install ${1+"$@"}
+
+
+# func_generate_dlsyms outputname originator pic_p
+# Extract symbols from dlprefiles and create ${outputname}S.o with
+# a dlpreopen symbol table.
+func_generate_dlsyms ()
+{
+    $opt_debug
+    my_outputname="$1"
+    my_originator="$2"
+    my_pic_p="${3-no}"
+    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
+    my_dlsyms=
+
+    if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+      if test -n "$NM" && test -n "$global_symbol_pipe"; then
+	my_dlsyms="${my_outputname}S.c"
+      else
+	func_error "not configured to extract global symbols from dlpreopened files"
+      fi
+    fi
+
+    if test -n "$my_dlsyms"; then
+      case $my_dlsyms in
+      "") ;;
+      *.c)
+	# Discover the nlist of each of the dlfiles.
+	nlist="$output_objdir/${my_outputname}.nm"
+
+	func_show_eval "$RM $nlist ${nlist}S ${nlist}T"
+
+	# Parse the name list into a source file.
+	func_verbose "creating $output_objdir/$my_dlsyms"
+
+	$opt_dry_run || $ECHO > "$output_objdir/$my_dlsyms" "\
+/* $my_dlsyms - symbol resolution table for \`$my_outputname' dlsym emulation. */
+/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */
+
+#ifdef __cplusplus
+extern \"C\" {
+#endif
+
+/* External symbol declarations for the compiler. */\
+"
+
+	if test "$dlself" = yes; then
+	  func_verbose "generating symbol list for \`$output'"
+
+	  $opt_dry_run || echo ': @PROGRAM@ ' > "$nlist"
+
+	  # Add our own program objects to the symbol list.
+	  progfiles=`$ECHO "X$objs$old_deplibs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	  for progfile in $progfiles; do
+	    func_verbose "extracting global C symbols from \`$progfile'"
+	    $opt_dry_run || eval "$NM $progfile | $global_symbol_pipe >> '$nlist'"
+	  done
+
+	  if test -n "$exclude_expsyms"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  if test -n "$export_symbols_regex"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  # Prepare the list of exported symbols
+	  if test -z "$export_symbols"; then
+	    export_symbols="$output_objdir/$outputname.exp"
+	    $opt_dry_run || {
+	      $RM $export_symbols
+	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+	      case $host in
+	      *cygwin* | *mingw* | *cegcc* )
+                eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
+	        ;;
+	      esac
+	    }
+	  else
+	    $opt_dry_run || {
+	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	      case $host in
+	        *cygwin | *mingw* | *cegcc* )
+	          eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+	          eval 'cat "$nlist" >> "$output_objdir/$outputname.def"'
+	          ;;
+	      esac
+	    }
+	  fi
+	fi
+
+	for dlprefile in $dlprefiles; do
+	  func_verbose "extracting global C symbols from \`$dlprefile'"
+	  func_basename "$dlprefile"
+	  name="$func_basename_result"
+	  $opt_dry_run || {
+	    eval '$ECHO ": $name " >> "$nlist"'
+	    eval "$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'"
+	  }
+	done
+
+	$opt_dry_run || {
+	  # Make sure we have at least an empty file.
+	  test -f "$nlist" || : > "$nlist"
+
+	  if test -n "$exclude_expsyms"; then
+	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
+	    $MV "$nlist"T "$nlist"
+	  fi
+
+	  # Try sorting and uniquifying the output.
+	  if $GREP -v "^: " < "$nlist" |
+	      if sort -k 3 </dev/null >/dev/null 2>&1; then
+		sort -k 3
+	      else
+		sort +2
+	      fi |
+	      uniq > "$nlist"S; then
+	    :
+	  else
+	    $GREP -v "^: " < "$nlist" > "$nlist"S
+	  fi
+
+	  if test -f "$nlist"S; then
+	    eval "$global_symbol_to_cdecl"' < "$nlist"S >> "$output_objdir/$my_dlsyms"'
+	  else
+	    $ECHO '/* NONE */' >> "$output_objdir/$my_dlsyms"
+	  fi
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+
+/* The mapping between symbol names and symbols.  */
+typedef struct {
+  const char *name;
+  void *address;
+} lt_dlsymlist;
+"
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc* )
+	    $ECHO >> "$output_objdir/$my_dlsyms" "\
+/* DATA imports from DLLs on WIN32 con't be const, because
+   runtime relocations are performed -- see ld's documentation
+   on pseudo-relocs.  */"
+	    lt_dlsym_const= ;;
+	  *osf5*)
+	    echo >> "$output_objdir/$my_dlsyms" "\
+/* This system does not cope well with relocations in const data */"
+	    lt_dlsym_const= ;;
+	  *)
+	    lt_dlsym_const=const ;;
+	  esac
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+extern $lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[];
+$lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[] =
+{\
+  { \"$my_originator\", (void *) 0 },"
+
+	  case $need_lib_prefix in
+	  no)
+	    eval "$global_symbol_to_c_name_address" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  *)
+	    eval "$global_symbol_to_c_name_address_lib_prefix" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  esac
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt_${my_prefix}_LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif\
+"
+	} # !$opt_dry_run
+
+	pic_flag_for_symtable=
+	case "$compile_command " in
+	*" -static "*) ;;
+	*)
+	  case $host in
+	  # compiling the symbol table file with pic_flag works around
+	  # a FreeBSD bug that causes programs to crash when -lm is
+	  # linked before any other PIC object.  But we must not use
+	  # pic_flag when linking with -static.  The problem exists in
+	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
+	  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)
+	    pic_flag_for_symtable=" $pic_flag -DFREEBSD_WORKAROUND" ;;
+	  *-*-hpux*)
+	    pic_flag_for_symtable=" $pic_flag"  ;;
+	  *)
+	    if test "X$my_pic_p" != Xno; then
+	      pic_flag_for_symtable=" $pic_flag"
+	    fi
+	    ;;
+	  esac
+	  ;;
+	esac
+	symtab_cflags=
+	for arg in $LTCFLAGS; do
+	  case $arg in
+	  -pie | -fpie | -fPIE) ;;
+	  *) symtab_cflags="$symtab_cflags $arg" ;;
+	  esac
+	done
+
+	# Now compile the dynamic symbol file.
+	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
+
+	# Clean up the generated files.
+	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T"'
+
+	# Transform the symbol file into the correct name.
+	symfileobj="$output_objdir/${my_outputname}S.$objext"
+	case $host in
+	*cygwin* | *mingw* | *cegcc* )
+	  if test -f "$output_objdir/$my_outputname.def"; then
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	  else
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  fi
+	  ;;
+	*)
+	  compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  ;;
+	esac
+	;;
+      *)
+	func_fatal_error "unknown suffix for \`$my_dlsyms'"
+	;;
+      esac
+    else
+      # We keep going just in case the user didn't refer to
+      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe
+      # really was required.
+
+      # Nullify the symbol file.
+      compile_command=`$ECHO "X$compile_command" | $Xsed -e "s% @SYMFILE@%%"`
+      finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s% @SYMFILE@%%"`
+    fi
+}
+
+# func_win32_libid arg
+# return the library type of file 'arg'
+#
+# Need a lot of goo to handle *both* DLLs and import libs
+# Has to be a shell function in order to 'eat' the argument
+# that is supplied when $file_magic_command is called.
+func_win32_libid ()
+{
+  $opt_debug
+  win32_libid_type="unknown"
+  win32_fileres=`file -L $1 2>/dev/null`
+  case $win32_fileres in
+  *ar\ archive\ import\ library*) # definitely import
+    win32_libid_type="x86 archive import"
+    ;;
+  *ar\ archive*) # could be an import, or static
+    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |
+       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then
+      win32_nmres=`eval $NM -f posix -A $1 |
+	$SED -n -e '
+	    1,100{
+		/ I /{
+		    s,.*,import,
+		    p
+		    q
+		}
+	    }'`
+      case $win32_nmres in
+      import*)  win32_libid_type="x86 archive import";;
+      *)        win32_libid_type="x86 archive static";;
+      esac
+    fi
+    ;;
+  *DLL*)
+    win32_libid_type="x86 DLL"
+    ;;
+  *executable*) # but shell scripts are "executable" too...
+    case $win32_fileres in
+    *MS\ Windows\ PE\ Intel*)
+      win32_libid_type="x86 DLL"
+      ;;
+    esac
+    ;;
+  esac
+  $ECHO "$win32_libid_type"
+}
+
+
+
+# func_extract_an_archive dir oldlib
+func_extract_an_archive ()
+{
+    $opt_debug
+    f_ex_an_ar_dir="$1"; shift
+    f_ex_an_ar_oldlib="$1"
+    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" 'exit $?'
+    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
+     :
+    else
+      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
+    fi
+}
+
+
+# func_extract_archives gentop oldlib ...
+func_extract_archives ()
+{
+    $opt_debug
+    my_gentop="$1"; shift
+    my_oldlibs=${1+"$@"}
+    my_oldobjs=""
+    my_xlib=""
+    my_xabs=""
+    my_xdir=""
+
+    for my_xlib in $my_oldlibs; do
+      # Extract the objects.
+      case $my_xlib in
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	*) my_xabs=`pwd`"/$my_xlib" ;;
+      esac
+      func_basename "$my_xlib"
+      my_xlib="$func_basename_result"
+      my_xlib_u=$my_xlib
+      while :; do
+        case " $extracted_archives " in
+	*" $my_xlib_u "*)
+	  func_arith $extracted_serial + 1
+	  extracted_serial=$func_arith_result
+	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
+	*) break ;;
+	esac
+      done
+      extracted_archives="$extracted_archives $my_xlib_u"
+      my_xdir="$my_gentop/$my_xlib_u"
+
+      func_mkdir_p "$my_xdir"
+
+      case $host in
+      *-darwin*)
+	func_verbose "Extracting $my_xabs"
+	# Do not bother doing anything if just a dry run
+	$opt_dry_run || {
+	  darwin_orig_dir=`pwd`
+	  cd $my_xdir || exit $?
+	  darwin_archive=$my_xabs
+	  darwin_curdir=`pwd`
+	  darwin_base_archive=`basename "$darwin_archive"`
+	  darwin_arches=`$LIPO -info "$darwin_archive" 2>/dev/null | $GREP Architectures 2>/dev/null || true`
+	  if test -n "$darwin_arches"; then
+	    darwin_arches=`$ECHO "$darwin_arches" | $SED -e 's/.*are://'`
+	    darwin_arch=
+	    func_verbose "$darwin_base_archive has multiple architectures $darwin_arches"
+	    for darwin_arch in  $darwin_arches ; do
+	      func_mkdir_p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      $LIPO -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
+	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	      cd "$darwin_curdir"
+	      $RM "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	    done # $darwin_arches
+            ## Okay now we've a bunch of thin objects, gotta fatten them up :)
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print | $SED -e "$basename" | sort -u`
+	    darwin_file=
+	    darwin_files=
+	    for darwin_file in $darwin_filelist; do
+	      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`
+	      $LIPO -create -output "$darwin_file" $darwin_files
+	    done # $darwin_filelist
+	    $RM -rf unfat-$$
+	    cd "$darwin_orig_dir"
+	  else
+	    cd $darwin_orig_dir
+	    func_extract_an_archive "$my_xdir" "$my_xabs"
+	  fi # $darwin_arches
+	} # !$opt_dry_run
+	;;
+      *)
+        func_extract_an_archive "$my_xdir" "$my_xabs"
+	;;
+      esac
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | $NL2SP`
+    done
+
+    func_extract_archives_result="$my_oldobjs"
+}
+
+
+
+# func_emit_wrapper_part1 [arg=no]
+#
+# Emit the first part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part1 ()
+{
+	func_emit_wrapper_part1_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part1_arg1=$1
+	fi
+
+	$ECHO "\
+#! $SHELL
+
+# $output - temporary wrapper script for $objdir/$outputname
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of the build directory.
+# If it is, it will not operate correctly.
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='${SED} -e 1s/^X//'
+sed_quote_subst='$sed_quote_subst'
+
+# Be Bourne compatible
+if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+relink_command=\"$relink_command\"
+
+# This environment variable determines our operation mode.
+if test \"\$libtool_install_magic\" = \"$magic\"; then
+  # install mode needs the following variables:
+  generated_by_libtool_version='$macro_version'
+  notinst_deplibs='$notinst_deplibs'
+else
+  # When we are sourced in execute mode, \$file and \$ECHO are already set.
+  if test \"\$libtool_execute_magic\" != \"$magic\"; then
+    ECHO=\"$qecho\"
+    file=\"\$0\"
+    # Make sure echo works.
+    if test \"X\$1\" = X--no-reexec; then
+      # Discard the --no-reexec flag, and continue.
+      shift
+    elif test \"X\`{ \$ECHO '\t'; } 2>/dev/null\`\" = 'X\t'; then
+      # Yippee, \$ECHO works!
+      :
+    else
+      # Restart under the correct shell, and then maybe \$ECHO will work.
+      exec $SHELL \"\$0\" --no-reexec \${1+\"\$@\"}
+    fi
+  fi\
+"
+	$ECHO "\
+
+  # Find the directory that this script lives in.
+  thisdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*$%%'\`
+  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
+
+  # Follow symbolic links until we get to the real thisdir.
+  file=\`ls -ld \"\$file\" | ${SED} -n 's/.*-> //p'\`
+  while test -n \"\$file\"; do
+    destdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*\$%%'\`
+
+    # If there was a directory component, then change thisdir.
+    if test \"x\$destdir\" != \"x\$file\"; then
+      case \"\$destdir\" in
+      [\\\\/]* | [A-Za-z]:[\\\\/]*) thisdir=\"\$destdir\" ;;
+      *) thisdir=\"\$thisdir/\$destdir\" ;;
+      esac
+    fi
+
+    file=\`\$ECHO \"X\$file\" | \$Xsed -e 's%^.*/%%'\`
+    file=\`ls -ld \"\$thisdir/\$file\" | ${SED} -n 's/.*-> //p'\`
+  done
+"
+}
+# end: func_emit_wrapper_part1
+
+# func_emit_wrapper_part2 [arg=no]
+#
+# Emit the second part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part2 ()
+{
+	func_emit_wrapper_part2_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part2_arg1=$1
+	fi
+
+	$ECHO "\
+
+  # Usually 'no', except on cygwin/mingw when embedded into
+  # the cwrapper.
+  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_part2_arg1
+  if test \"\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\" = \"yes\"; then
+    # special case for '.'
+    if test \"\$thisdir\" = \".\"; then
+      thisdir=\`pwd\`
+    fi
+    # remove .libs from thisdir
+    case \"\$thisdir\" in
+    *[\\\\/]$objdir ) thisdir=\`\$ECHO \"X\$thisdir\" | \$Xsed -e 's%[\\\\/][^\\\\/]*$%%'\` ;;
+    $objdir )   thisdir=. ;;
+    esac
+  fi
+
+  # Try to get the absolute directory name.
+  absdir=\`cd \"\$thisdir\" && pwd\`
+  test -n \"\$absdir\" && thisdir=\"\$absdir\"
+"
+
+	if test "$fast_install" = yes; then
+	  $ECHO "\
+  program=lt-'$outputname'$exeext
+  progdir=\"\$thisdir/$objdir\"
+
+  if test ! -f \"\$progdir/\$program\" ||
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+       test \"X\$file\" != \"X\$progdir/\$program\"; }; then
+
+    file=\"\$\$-\$program\"
+
+    if test ! -d \"\$progdir\"; then
+      $MKDIR \"\$progdir\"
+    else
+      $RM \"\$progdir/\$file\"
+    fi"
+
+	  $ECHO "\
+
+    # relink executable if necessary
+    if test -n \"\$relink_command\"; then
+      if relink_command_output=\`eval \$relink_command 2>&1\`; then :
+      else
+	$ECHO \"\$relink_command_output\" >&2
+	$RM \"\$progdir/\$file\"
+	exit 1
+      fi
+    fi
+
+    $MV \"\$progdir/\$file\" \"\$progdir/\$program\" 2>/dev/null ||
+    { $RM \"\$progdir/\$program\";
+      $MV \"\$progdir/\$file\" \"\$progdir/\$program\"; }
+    $RM \"\$progdir/\$file\"
+  fi"
+	else
+	  $ECHO "\
+  program='$outputname'
+  progdir=\"\$thisdir/$objdir\"
+"
+	fi
+
+	$ECHO "\
+
+  if test -f \"\$progdir/\$program\"; then"
+
+	# Export our shlibpath_var if we have one.
+	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  $ECHO "\
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    # The second colon is a workaround for a bug in BeOS R4 sed
+    $shlibpath_var=\`\$ECHO \"X\$$shlibpath_var\" | \$Xsed -e 's/::*\$//'\`
+
+    export $shlibpath_var
+"
+	fi
+
+	# fixup the dll searchpath if we need to.
+	if test -n "$dllsearchpath"; then
+	  $ECHO "\
+    # Add the dll search path components to the executable PATH
+    PATH=$dllsearchpath:\$PATH
+"
+	fi
+
+	$ECHO "\
+    if test \"\$libtool_execute_magic\" != \"$magic\"; then
+      # Run the actual program with our arguments.
+"
+	case $host in
+	# Backslashes separate directories on plain windows
+	*-*-mingw | *-*-os2* | *-cegcc*)
+	  $ECHO "\
+      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
+"
+	  ;;
+
+	*)
+	  $ECHO "\
+      exec \"\$progdir/\$program\" \${1+\"\$@\"}
+"
+	  ;;
+	esac
+	$ECHO "\
+      \$ECHO \"\$0: cannot exec \$program \$*\" 1>&2
+      exit 1
+    fi
+  else
+    # The program doesn't exist.
+    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$ECHO \"This script is just a wrapper for \$program.\" 1>&2
+    $ECHO \"See the $PACKAGE documentation for more information.\" 1>&2
+    exit 1
+  fi
+fi\
+"
+}
+# end: func_emit_wrapper_part2
+
+
+# func_emit_wrapper [arg=no]
+#
+# Emit a libtool wrapper script on stdout.
+# Don't directly open a file because we may want to
+# incorporate the script contents within a cygwin/mingw
+# wrapper executable.  Must ONLY be called from within
+# func_mode_link because it depends on a number of variables
+# set therein.
+#
+# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR
+# variable will take.  If 'yes', then the emitted script
+# will assume that the directory in which it is stored is
+# the $objdir directory.  This is a cygwin/mingw-specific
+# behavior.
+func_emit_wrapper ()
+{
+	func_emit_wrapper_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_arg1=$1
+	fi
+
+	# split this up so that func_emit_cwrapperexe_src
+	# can call each part independently.
+	func_emit_wrapper_part1 "${func_emit_wrapper_arg1}"
+	func_emit_wrapper_part2 "${func_emit_wrapper_arg1}"
+}
+
+
+# func_to_host_path arg
+#
+# Convert paths to host format when used with build tools.
+# Intended for use with "native" mingw (where libtool itself
+# is running under the msys shell), or in the following cross-
+# build environments:
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+# where wine is equipped with the `winepath' executable.
+# In the native mingw case, the (msys) shell automatically
+# converts paths for any non-msys applications it launches,
+# but that facility isn't available from inside the cwrapper.
+# Similar accommodations are necessary for $host mingw and
+# $build cygwin.  Calling this function does no harm for other
+# $host/$build combinations not listed above.
+#
+# ARG is the path (on $build) that should be converted to
+# the proper representation for $host. The result is stored
+# in $func_to_host_path_result.
+func_to_host_path ()
+{
+  func_to_host_path_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        case $build in
+          *mingw* ) # actually, msys
+            # awkward: cmd appends spaces to result
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_path_tmp1=`( cmd //c echo "$1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_path_tmp1=`cygpath -w "$1"`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # Unfortunately, winepath does not exit with a non-zero
+            # error code, so we are forced to check the contents of
+            # stdout. On the other hand, if the command is not
+            # found, the shell will set an exit code of 127 and print
+            # *an error message* to stdout. So we must check for both
+            # error code of zero AND non-empty stdout, which explains
+            # the odd construction:
+            func_to_host_path_tmp1=`winepath -w "$1" 2>/dev/null`
+            if test "$?" -eq 0 && test -n "${func_to_host_path_tmp1}"; then
+              func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+                $SED -e "$lt_sed_naive_backslashify"`
+            else
+              # Allow warning below.
+              func_to_host_path_result=""
+            fi
+            ;;
+        esac
+        if test -z "$func_to_host_path_result" ; then
+          func_error "Could not determine host path corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback:
+          func_to_host_path_result="$1"
+        fi
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_path
+
+# func_to_host_pathlist arg
+#
+# Convert pathlists to host format when used with build tools.
+# See func_to_host_path(), above. This function supports the
+# following $build/$host combinations (but does no harm for
+# combinations not listed here):
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+#
+# Path separators are also converted from $build format to
+# $host format. If ARG begins or ends with a path separator
+# character, it is preserved (but converted to $host format)
+# on output.
+#
+# ARG is a pathlist (on $build) that should be converted to
+# the proper representation on $host. The result is stored
+# in $func_to_host_pathlist_result.
+func_to_host_pathlist ()
+{
+  func_to_host_pathlist_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        # Remove leading and trailing path separator characters from
+        # ARG. msys behavior is inconsistent here, cygpath turns them
+        # into '.;' and ';.', and winepath ignores them completely.
+        func_to_host_pathlist_tmp2="$1"
+        # Once set for this call, this variable should not be
+        # reassigned. It is used in tha fallback case.
+        func_to_host_pathlist_tmp1=`echo "$func_to_host_pathlist_tmp2" |\
+          $SED -e 's|^:*||' -e 's|:*$||'`
+        case $build in
+          *mingw* ) # Actually, msys.
+            # Awkward: cmd appends spaces to result.
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_pathlist_tmp2=`( cmd //c echo "$func_to_host_pathlist_tmp1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_pathlist_tmp2=`cygpath -w -p "$func_to_host_pathlist_tmp1"`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # unfortunately, winepath doesn't convert pathlists
+            func_to_host_pathlist_result=""
+            func_to_host_pathlist_oldIFS=$IFS
+            IFS=:
+            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do
+              IFS=$func_to_host_pathlist_oldIFS
+              if test -n "$func_to_host_pathlist_f" ; then
+                func_to_host_path "$func_to_host_pathlist_f"
+                if test -n "$func_to_host_path_result" ; then
+                  if test -z "$func_to_host_pathlist_result" ; then
+                    func_to_host_pathlist_result="$func_to_host_path_result"
+                  else
+                    func_to_host_pathlist_result="$func_to_host_pathlist_result;$func_to_host_path_result"
+                  fi
+                fi
+              fi
+              IFS=:
+            done
+            IFS=$func_to_host_pathlist_oldIFS
+            ;;
+        esac
+        if test -z "$func_to_host_pathlist_result" ; then
+          func_error "Could not determine the host path(s) corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback. This may break if $1 contains DOS-style drive
+          # specifications. The fix is not to complicate the expression
+          # below, but for the user to provide a working wine installation
+          # with winepath so that path translation in the cross-to-mingw
+          # case works properly.
+          lt_replace_pathsep_nix_to_dos="s|:|;|g"
+          func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp1" |\
+            $SED -e "$lt_replace_pathsep_nix_to_dos"`
+        fi
+        # Now, add the leading and trailing path separators back
+        case "$1" in
+          :* ) func_to_host_pathlist_result=";$func_to_host_pathlist_result"
+            ;;
+        esac
+        case "$1" in
+          *: ) func_to_host_pathlist_result="$func_to_host_pathlist_result;"
+            ;;
+        esac
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_pathlist
+
+# func_emit_cwrapperexe_src
+# emit the source code for a wrapper executable on stdout
+# Must ONLY be called from within func_mode_link because
+# it depends on a number of variable set therein.
+func_emit_cwrapperexe_src ()
+{
+	cat <<EOF
+
+/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
+   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+
+   The $output program cannot be directly executed until all the libtool
+   libraries that it depends on are installed.
+
+   This wrapper executable should never be moved out of the build directory.
+   If it is, it will not operate correctly.
+
+   Currently, it simply execs the wrapper *script* "$SHELL $output",
+   but could eventually absorb all of the scripts functionality and
+   exec $objdir/$outputname directly.
+*/
+EOF
+	    cat <<"EOF"
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef _MSC_VER
+# include <direct.h>
+# include <process.h>
+# include <io.h>
+# define setmode _setmode
+#else
+# include <unistd.h>
+# include <stdint.h>
+# ifdef __CYGWIN__
+#  include <io.h>
+#  define HAVE_SETENV
+#  ifdef __STRICT_ANSI__
+char *realpath (const char *, char *);
+int putenv (char *);
+int setenv (const char *, const char *, int);
+#  endif
+# endif
+#endif
+#include <malloc.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#if defined(PATH_MAX)
+# define LT_PATHMAX PATH_MAX
+#elif defined(MAXPATHLEN)
+# define LT_PATHMAX MAXPATHLEN
+#else
+# define LT_PATHMAX 1024
+#endif
+
+#ifndef S_IXOTH
+# define S_IXOTH 0
+#endif
+#ifndef S_IXGRP
+# define S_IXGRP 0
+#endif
+
+#ifdef _MSC_VER
+# define S_IXUSR _S_IEXEC
+# define stat _stat
+# ifndef _INTPTR_T_DEFINED
+#  define intptr_t int
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR
+# define DIR_SEPARATOR '/'
+# define PATH_SEPARATOR ':'
+#endif
+
+#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
+  defined (__OS2__)
+# define HAVE_DOS_BASED_FILE_SYSTEM
+# define FOPEN_WB "wb"
+# ifndef DIR_SEPARATOR_2
+#  define DIR_SEPARATOR_2 '\\'
+# endif
+# ifndef PATH_SEPARATOR_2
+#  define PATH_SEPARATOR_2 ';'
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR_2
+# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#else /* DIR_SEPARATOR_2 */
+# define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#endif /* DIR_SEPARATOR_2 */
+
+#ifndef PATH_SEPARATOR_2
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)
+#else /* PATH_SEPARATOR_2 */
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)
+#endif /* PATH_SEPARATOR_2 */
+
+#ifdef __CYGWIN__
+# define FOPEN_WB "wb"
+#endif
+
+#ifndef FOPEN_WB
+# define FOPEN_WB "w"
+#endif
+#ifndef _O_BINARY
+# define _O_BINARY 0
+#endif
+
+#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
+#define XFREE(stale) do { \
+  if (stale) { free ((void *) stale); stale = 0; } \
+} while (0)
+
+#undef LTWRAPPER_DEBUGPRINTF
+#if defined DEBUGWRAPPER
+# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args
+static void
+ltwrapper_debugprintf (const char *fmt, ...)
+{
+    va_list args;
+    va_start (args, fmt);
+    (void) vfprintf (stderr, fmt, args);
+    va_end (args);
+}
+#else
+# define LTWRAPPER_DEBUGPRINTF(args)
+#endif
+
+const char *program_name = NULL;
+
+void *xmalloc (size_t num);
+char *xstrdup (const char *string);
+const char *base_name (const char *name);
+char *find_executable (const char *wrapper);
+char *chase_symlinks (const char *pathspec);
+int make_executable (const char *path);
+int check_executable (const char *path);
+char *strendzap (char *str, const char *pat);
+void lt_fatal (const char *message, ...);
+void lt_setenv (const char *name, const char *value);
+char *lt_extend_str (const char *orig_value, const char *add, int to_end);
+void lt_opt_process_env_set (const char *arg);
+void lt_opt_process_env_prepend (const char *arg);
+void lt_opt_process_env_append (const char *arg);
+int lt_split_name_value (const char *arg, char** name, char** value);
+void lt_update_exe_path (const char *name, const char *value);
+void lt_update_lib_path (const char *name, const char *value);
+
+static const char *script_text_part1 =
+EOF
+
+	    func_emit_wrapper_part1 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+	    cat <<EOF
+
+static const char *script_text_part2 =
+EOF
+	    func_emit_wrapper_part2 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+
+	    cat <<EOF
+const char * MAGIC_EXE = "$magic_exe";
+const char * LIB_PATH_VARNAME = "$shlibpath_var";
+EOF
+
+	    if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+              func_to_host_pathlist "$temp_rpath"
+	      cat <<EOF
+const char * LIB_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * LIB_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test -n "$dllsearchpath"; then
+              func_to_host_pathlist "$dllsearchpath:"
+	      cat <<EOF
+const char * EXE_PATH_VARNAME = "PATH";
+const char * EXE_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * EXE_PATH_VARNAME = "";
+const char * EXE_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test "$fast_install" = yes; then
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
+EOF
+	    else
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "$outputname"; /* hopefully, no .exe */
+EOF
+	    fi
+
+
+	    cat <<"EOF"
+
+#define LTWRAPPER_OPTION_PREFIX         "--lt-"
+#define LTWRAPPER_OPTION_PREFIX_LENGTH  5
+
+static const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;
+static const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;
+
+static const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX "dump-script";
+
+static const size_t env_set_opt_len     = LTWRAPPER_OPTION_PREFIX_LENGTH + 7;
+static const char *env_set_opt          = LTWRAPPER_OPTION_PREFIX "env-set";
+  /* argument is putenv-style "foo=bar", value of foo is set to bar */
+
+static const size_t env_prepend_opt_len = LTWRAPPER_OPTION_PREFIX_LENGTH + 11;
+static const char *env_prepend_opt      = LTWRAPPER_OPTION_PREFIX "env-prepend";
+  /* argument is putenv-style "foo=bar", new value of foo is bar${foo} */
+
+static const size_t env_append_opt_len  = LTWRAPPER_OPTION_PREFIX_LENGTH + 10;
+static const char *env_append_opt       = LTWRAPPER_OPTION_PREFIX "env-append";
+  /* argument is putenv-style "foo=bar", new value of foo is ${foo}bar */
+
+int
+main (int argc, char *argv[])
+{
+  char **newargz;
+  int  newargc;
+  char *tmp_pathspec;
+  char *actual_cwrapper_path;
+  char *actual_cwrapper_name;
+  char *target_name;
+  char *lt_argv_zero;
+  intptr_t rval = 127;
+
+  int i;
+
+  program_name = (char *) xstrdup (base_name (argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) argv[0]      : %s\n", argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) program_name : %s\n", program_name));
+
+  /* very simple arg parsing; don't want to rely on getopt */
+  for (i = 1; i < argc; i++)
+    {
+      if (strcmp (argv[i], dumpscript_opt) == 0)
+	{
+EOF
+	    case "$host" in
+	      *mingw* | *cygwin* )
+		# make stdout use "unix" line endings
+		echo "          setmode(1,_O_BINARY);"
+		;;
+	      esac
+
+	    cat <<"EOF"
+	  printf ("%s", script_text_part1);
+	  printf ("%s", script_text_part2);
+	  return 0;
+	}
+    }
+
+  newargz = XMALLOC (char *, argc + 1);
+  tmp_pathspec = find_executable (argv[0]);
+  if (tmp_pathspec == NULL)
+    lt_fatal ("Couldn't find %s", argv[0]);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (before symlink chase) at : %s\n",
+			  tmp_pathspec));
+
+  actual_cwrapper_path = chase_symlinks (tmp_pathspec);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (after symlink chase) at : %s\n",
+			  actual_cwrapper_path));
+  XFREE (tmp_pathspec);
+
+  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));
+  strendzap (actual_cwrapper_path, actual_cwrapper_name);
+
+  /* wrapper name transforms */
+  strendzap (actual_cwrapper_name, ".exe");
+  tmp_pathspec = lt_extend_str (actual_cwrapper_name, ".exe", 1);
+  XFREE (actual_cwrapper_name);
+  actual_cwrapper_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  /* target_name transforms -- use actual target program name; might have lt- prefix */
+  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));
+  strendzap (target_name, ".exe");
+  tmp_pathspec = lt_extend_str (target_name, ".exe", 1);
+  XFREE (target_name);
+  target_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  LTWRAPPER_DEBUGPRINTF (("(main) libtool target name: %s\n",
+			  target_name));
+EOF
+
+	    cat <<EOF
+  newargz[0] =
+    XMALLOC (char, (strlen (actual_cwrapper_path) +
+		    strlen ("$objdir") + 1 + strlen (actual_cwrapper_name) + 1));
+  strcpy (newargz[0], actual_cwrapper_path);
+  strcat (newargz[0], "$objdir");
+  strcat (newargz[0], "/");
+EOF
+
+	    cat <<"EOF"
+  /* stop here, and copy so we don't have to do this twice */
+  tmp_pathspec = xstrdup (newargz[0]);
+
+  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */
+  strcat (newargz[0], actual_cwrapper_name);
+
+  /* DO want the lt- prefix here if it exists, so use target_name */
+  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);
+  XFREE (tmp_pathspec);
+  tmp_pathspec = NULL;
+EOF
+
+	    case $host_os in
+	      mingw*)
+	    cat <<"EOF"
+  {
+    char* p;
+    while ((p = strchr (newargz[0], '\\')) != NULL)
+      {
+	*p = '/';
+      }
+    while ((p = strchr (lt_argv_zero, '\\')) != NULL)
+      {
+	*p = '/';
+      }
+  }
+EOF
+	    ;;
+	    esac
+
+	    cat <<"EOF"
+  XFREE (target_name);
+  XFREE (actual_cwrapper_path);
+  XFREE (actual_cwrapper_name);
+
+  lt_setenv ("BIN_SH", "xpg4"); /* for Tru64 */
+  lt_setenv ("DUALCASE", "1");  /* for MSK sh */
+  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);
+  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);
+
+  newargc=0;
+  for (i = 1; i < argc; i++)
+    {
+      if (strncmp (argv[i], env_set_opt, env_set_opt_len) == 0)
+        {
+          if (argv[i][env_set_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_set_opt_len + 1;
+              lt_opt_process_env_set (p);
+            }
+          else if (argv[i][env_set_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_set (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_set_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_prepend_opt, env_prepend_opt_len) == 0)
+        {
+          if (argv[i][env_prepend_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_prepend_opt_len + 1;
+              lt_opt_process_env_prepend (p);
+            }
+          else if (argv[i][env_prepend_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_prepend (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_prepend_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_append_opt, env_append_opt_len) == 0)
+        {
+          if (argv[i][env_append_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_append_opt_len + 1;
+              lt_opt_process_env_append (p);
+            }
+          else if (argv[i][env_append_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_append (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_append_opt);
+          continue;
+        }
+      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)
+        {
+          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX
+             namespace, but it is not one of the ones we know about and
+             have already dealt with, above (inluding dump-script), then
+             report an error. Otherwise, targets might begin to believe
+             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX
+             namespace. The first time any user complains about this, we'll
+             need to make LTWRAPPER_OPTION_PREFIX a configure-time option
+             or a configure.ac-settable value.
+           */
+          lt_fatal ("Unrecognized option in %s namespace: '%s'",
+                    ltwrapper_option_prefix, argv[i]);
+        }
+      /* otherwise ... */
+      newargz[++newargc] = xstrdup (argv[i]);
+    }
+  newargz[++newargc] = NULL;
+
+  LTWRAPPER_DEBUGPRINTF     (("(main) lt_argv_zero : %s\n", (lt_argv_zero ? lt_argv_zero : "<NULL>")));
+  for (i = 0; i < newargc; i++)
+    {
+      LTWRAPPER_DEBUGPRINTF (("(main) newargz[%d]   : %s\n", i, (newargz[i] ? newargz[i] : "<NULL>")));
+    }
+
+EOF
+
+	    case $host_os in
+	      mingw*)
+		cat <<"EOF"
+  /* execv doesn't actually work on mingw as expected on unix */
+  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
+  if (rval == -1)
+    {
+      /* failed to start process */
+      LTWRAPPER_DEBUGPRINTF (("(main) failed to launch target \"%s\": errno = %d\n", lt_argv_zero, errno));
+      return 127;
+    }
+  return rval;
+EOF
+		;;
+	      *)
+		cat <<"EOF"
+  execv (lt_argv_zero, newargz);
+  return rval; /* =127, but avoids unused variable warning */
+EOF
+		;;
+	    esac
+
+	    cat <<"EOF"
+}
+
+void *
+xmalloc (size_t num)
+{
+  void *p = (void *) malloc (num);
+  if (!p)
+    lt_fatal ("Memory exhausted");
+
+  return p;
+}
+
+char *
+xstrdup (const char *string)
+{
+  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),
+			  string) : NULL;
+}
+
+const char *
+base_name (const char *name)
+{
+  const char *base;
+
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Skip over the disk name in MSDOS pathnames. */
+  if (isalpha ((unsigned char) name[0]) && name[1] == ':')
+    name += 2;
+#endif
+
+  for (base = name; *name; name++)
+    if (IS_DIR_SEPARATOR (*name))
+      base = name + 1;
+  return base;
+}
+
+int
+check_executable (const char *path)
+{
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(check_executable)  : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if ((stat (path, &st) >= 0)
+      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))
+    return 1;
+  else
+    return 0;
+}
+
+int
+make_executable (const char *path)
+{
+  int rval = 0;
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(make_executable)   : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if (stat (path, &st) >= 0)
+    {
+      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);
+    }
+  return rval;
+}
+
+/* Searches for the full path of the wrapper.  Returns
+   newly allocated full path name if found, NULL otherwise
+   Does not chase symlinks, even on platforms that support them.
+*/
+char *
+find_executable (const char *wrapper)
+{
+  int has_slash = 0;
+  const char *p;
+  const char *p_next;
+  /* static buffer for getcwd */
+  char tmp[LT_PATHMAX + 1];
+  int tmp_len;
+  char *concat_name;
+
+  LTWRAPPER_DEBUGPRINTF (("(find_executable)   : %s\n",
+			  wrapper ? (*wrapper ? wrapper : "EMPTY!") : "NULL!"));
+
+  if ((wrapper == NULL) || (*wrapper == '\0'))
+    return NULL;
+
+  /* Absolute path? */
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')
+    {
+      concat_name = xstrdup (wrapper);
+      if (check_executable (concat_name))
+	return concat_name;
+      XFREE (concat_name);
+    }
+  else
+    {
+#endif
+      if (IS_DIR_SEPARATOR (wrapper[0]))
+	{
+	  concat_name = xstrdup (wrapper);
+	  if (check_executable (concat_name))
+	    return concat_name;
+	  XFREE (concat_name);
+	}
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+    }
+#endif
+
+  for (p = wrapper; *p; p++)
+    if (*p == '/')
+      {
+	has_slash = 1;
+	break;
+      }
+  if (!has_slash)
+    {
+      /* no slashes; search PATH */
+      const char *path = getenv ("PATH");
+      if (path != NULL)
+	{
+	  for (p = path; *p; p = p_next)
+	    {
+	      const char *q;
+	      size_t p_len;
+	      for (q = p; *q; q++)
+		if (IS_PATH_SEPARATOR (*q))
+		  break;
+	      p_len = q - p;
+	      p_next = (*q == '\0' ? q : q + 1);
+	      if (p_len == 0)
+		{
+		  /* empty path: current directory */
+		  if (getcwd (tmp, LT_PATHMAX) == NULL)
+		    lt_fatal ("getcwd failed");
+		  tmp_len = strlen (tmp);
+		  concat_name =
+		    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, tmp, tmp_len);
+		  concat_name[tmp_len] = '/';
+		  strcpy (concat_name + tmp_len + 1, wrapper);
+		}
+	      else
+		{
+		  concat_name =
+		    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, p, p_len);
+		  concat_name[p_len] = '/';
+		  strcpy (concat_name + p_len + 1, wrapper);
+		}
+	      if (check_executable (concat_name))
+		return concat_name;
+	      XFREE (concat_name);
+	    }
+	}
+      /* not found in PATH; assume curdir */
+    }
+  /* Relative path | not found in path: prepend cwd */
+  if (getcwd (tmp, LT_PATHMAX) == NULL)
+    lt_fatal ("getcwd failed");
+  tmp_len = strlen (tmp);
+  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+  memcpy (concat_name, tmp, tmp_len);
+  concat_name[tmp_len] = '/';
+  strcpy (concat_name + tmp_len + 1, wrapper);
+
+  if (check_executable (concat_name))
+    return concat_name;
+  XFREE (concat_name);
+  return NULL;
+}
+
+char *
+chase_symlinks (const char *pathspec)
+{
+#ifndef S_ISLNK
+  return xstrdup (pathspec);
+#else
+  char buf[LT_PATHMAX];
+  struct stat s;
+  char *tmp_pathspec = xstrdup (pathspec);
+  char *p;
+  int has_symlinks = 0;
+  while (strlen (tmp_pathspec) && !has_symlinks)
+    {
+      LTWRAPPER_DEBUGPRINTF (("checking path component for symlinks: %s\n",
+			      tmp_pathspec));
+      if (lstat (tmp_pathspec, &s) == 0)
+	{
+	  if (S_ISLNK (s.st_mode) != 0)
+	    {
+	      has_symlinks = 1;
+	      break;
+	    }
+
+	  /* search backwards for last DIR_SEPARATOR */
+	  p = tmp_pathspec + strlen (tmp_pathspec) - 1;
+	  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    p--;
+	  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    {
+	      /* no more DIR_SEPARATORS left */
+	      break;
+	    }
+	  *p = '\0';
+	}
+      else
+	{
+	  char *errstr = strerror (errno);
+	  lt_fatal ("Error accessing file %s (%s)", tmp_pathspec, errstr);
+	}
+    }
+  XFREE (tmp_pathspec);
+
+  if (!has_symlinks)
+    {
+      return xstrdup (pathspec);
+    }
+
+  tmp_pathspec = realpath (pathspec, buf);
+  if (tmp_pathspec == 0)
+    {
+      lt_fatal ("Could not follow symlinks for %s", pathspec);
+    }
+  return xstrdup (tmp_pathspec);
+#endif
+}
+
+char *
+strendzap (char *str, const char *pat)
+{
+  size_t len, patlen;
+
+  assert (str != NULL);
+  assert (pat != NULL);
+
+  len = strlen (str);
+  patlen = strlen (pat);
+
+  if (patlen <= len)
+    {
+      str += len - patlen;
+      if (strcmp (str, pat) == 0)
+	*str = '\0';
+    }
+  return str;
+}
+
+static void
+lt_error_core (int exit_status, const char *mode,
+	       const char *message, va_list ap)
+{
+  fprintf (stderr, "%s: %s: ", program_name, mode);
+  vfprintf (stderr, message, ap);
+  fprintf (stderr, ".\n");
+
+  if (exit_status >= 0)
+    exit (exit_status);
+}
+
+void
+lt_fatal (const char *message, ...)
+{
+  va_list ap;
+  va_start (ap, message);
+  lt_error_core (EXIT_FAILURE, "FATAL", message, ap);
+  va_end (ap);
+}
+
+void
+lt_setenv (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_setenv) setting '%s' to '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+  {
+#ifdef HAVE_SETENV
+    /* always make a copy, for consistency with !HAVE_SETENV */
+    char *str = xstrdup (value);
+    setenv (name, str, 1);
+#else
+    int len = strlen (name) + 1 + strlen (value) + 1;
+    char *str = XMALLOC (char, len);
+    sprintf (str, "%s=%s", name, value);
+    if (putenv (str) != EXIT_SUCCESS)
+      {
+        XFREE (str);
+      }
+#endif
+  }
+}
+
+char *
+lt_extend_str (const char *orig_value, const char *add, int to_end)
+{
+  char *new_value;
+  if (orig_value && *orig_value)
+    {
+      int orig_value_len = strlen (orig_value);
+      int add_len = strlen (add);
+      new_value = XMALLOC (char, add_len + orig_value_len + 1);
+      if (to_end)
+        {
+          strcpy (new_value, orig_value);
+          strcpy (new_value + orig_value_len, add);
+        }
+      else
+        {
+          strcpy (new_value, add);
+          strcpy (new_value + add_len, orig_value);
+        }
+    }
+  else
+    {
+      new_value = xstrdup (add);
+    }
+  return new_value;
+}
+
+int
+lt_split_name_value (const char *arg, char** name, char** value)
+{
+  const char *p;
+  int len;
+  if (!arg || !*arg)
+    return 1;
+
+  p = strchr (arg, (int)'=');
+
+  if (!p)
+    return 1;
+
+  *value = xstrdup (++p);
+
+  len = strlen (arg) - strlen (*value);
+  *name = XMALLOC (char, len);
+  strncpy (*name, arg, len-1);
+  (*name)[len - 1] = '\0';
+
+  return 0;
+}
+
+void
+lt_opt_process_env_set (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_set_opt, arg);
+    }
+
+  lt_setenv (name, value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_prepend (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_prepend_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 0);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_append (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_append_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 1);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_update_exe_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_exe_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      /* some systems can't cope with a ':'-terminated path #' */
+      int len = strlen (new_value);
+      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))
+        {
+          new_value[len-1] = '\0';
+        }
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+void
+lt_update_lib_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_lib_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+
+EOF
+}
+# end: func_emit_cwrapperexe_src
+
+# func_mode_link arg...
+func_mode_link ()
+{
+    $opt_debug
+    case $host in
+    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+      # It is impossible to link a dll without this setting, and
+      # we shouldn't force the makefile maintainer to figure out
+      # which system we are compiling for in order to pass an extra
+      # flag for every libtool invocation.
+      # allow_undefined=no
+
+      # FIXME: Unfortunately, there are problems with the above when trying
+      # to make a dll which has undefined symbols, in which case not
+      # even a static library is built.  For now, we need to specify
+      # -no-undefined on the libtool link line when we can be certain
+      # that all symbols are satisfied, otherwise we get a static library.
+      allow_undefined=yes
+      ;;
+    *)
+      allow_undefined=yes
+      ;;
+    esac
+    libtool_args=$nonopt
+    base_compile="$nonopt $@"
+    compile_command=$nonopt
+    finalize_command=$nonopt
+
+    compile_rpath=
+    finalize_rpath=
+    compile_shlibpath=
+    finalize_shlibpath=
+    convenience=
+    old_convenience=
+    deplibs=
+    old_deplibs=
+    compiler_flags=
+    linker_flags=
+    dllsearchpath=
+    lib_search_path=`pwd`
+    inst_prefix_dir=
+    new_inherited_linker_flags=
+
+    avoid_version=no
+    dlfiles=
+    dlprefiles=
+    dlself=no
+    export_dynamic=no
+    export_symbols=
+    export_symbols_regex=
+    generated=
+    libobjs=
+    ltlibs=
+    module=no
+    no_install=no
+    objs=
+    non_pic_objects=
+    precious_files_regex=
+    prefer_static_libs=no
+    preload=no
+    prev=
+    prevarg=
+    release=
+    rpath=
+    xrpath=
+    perm_rpath=
+    temp_rpath=
+    thread_safe=no
+    vinfo=
+    vinfo_number=no
+    weak_libs=
+    single_module="${wl}-single_module"
+    func_infer_tag $base_compile
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	break
+	;;
+      -all-static | -static | -static-libtool-libs)
+	case $arg in
+	-all-static)
+	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	    func_warning "complete static linking is impossible in this configuration"
+	  fi
+	  if test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	-static)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=built
+	  ;;
+	-static-libtool-libs)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	esac
+	build_libtool_libs=no
+	build_old_libs=yes
+	break
+	;;
+      esac
+    done
+
+    # See if our shared archives depend on static archives.
+    test -n "$old_archive_from_new_cmds" && build_old_libs=yes
+
+    # Go through the arguments, transforming them on the way.
+    while test "$#" -gt 0; do
+      arg="$1"
+      shift
+      func_quote_for_eval "$arg"
+      qarg=$func_quote_for_eval_unquoted_result
+      func_append libtool_args " $func_quote_for_eval_result"
+
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case $prev in
+	output)
+	  func_append compile_command " @OUTPUT@"
+	  func_append finalize_command " @OUTPUT@"
+	  ;;
+	esac
+
+	case $prev in
+	dlfiles|dlprefiles)
+	  if test "$preload" = no; then
+	    # Add the symbol object into the linking commands.
+	    func_append compile_command " @SYMFILE@"
+	    func_append finalize_command " @SYMFILE@"
+	    preload=yes
+	  fi
+	  case $arg in
+	  *.la | *.lo) ;;  # We handle these cases below.
+	  force)
+	    if test "$dlself" = no; then
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  self)
+	    if test "$prev" = dlprefiles; then
+	      dlself=yes
+	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	      dlself=yes
+	    else
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  *)
+	    if test "$prev" = dlfiles; then
+	      dlfiles="$dlfiles $arg"
+	    else
+	      dlprefiles="$dlprefiles $arg"
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  esac
+	  ;;
+	expsyms)
+	  export_symbols="$arg"
+	  test -f "$arg" \
+	    || func_fatal_error "symbol file \`$arg' does not exist"
+	  prev=
+	  continue
+	  ;;
+	expsyms_regex)
+	  export_symbols_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	framework)
+	  case $host in
+	    *-*-darwin*)
+	      case "$deplibs " in
+		*" $qarg.ltframework "*) ;;
+		*) deplibs="$deplibs $qarg.ltframework" # this is fixed later
+		   ;;
+	      esac
+	      ;;
+	  esac
+	  prev=
+	  continue
+	  ;;
+	inst_prefix)
+	  inst_prefix_dir="$arg"
+	  prev=
+	  continue
+	  ;;
+	objectlist)
+	  if test -f "$arg"; then
+	    save_arg=$arg
+	    moreargs=
+	    for fil in `cat "$save_arg"`
+	    do
+#	      moreargs="$moreargs $fil"
+	      arg=$fil
+	      # A libtool-controlled object.
+
+	      # Check to see that this really is a libtool object.
+	      if func_lalib_unsafe_p "$arg"; then
+		pic_object=
+		non_pic_object=
+
+		# Read the .lo file
+		func_source "$arg"
+
+		if test -z "$pic_object" ||
+		   test -z "$non_pic_object" ||
+		   test "$pic_object" = none &&
+		   test "$non_pic_object" = none; then
+		  func_fatal_error "cannot find name of object for \`$arg'"
+		fi
+
+		# Extract subdirectory from the argument.
+		func_dirname "$arg" "/" ""
+		xdir="$func_dirname_result"
+
+		if test "$pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  pic_object="$xdir$pic_object"
+
+		  if test "$prev" = dlfiles; then
+		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		      dlfiles="$dlfiles $pic_object"
+		      prev=
+		      continue
+		    else
+		      # If libtool objects are unsupported, then we need to preload.
+		      prev=dlprefiles
+		    fi
+		  fi
+
+		  # CHECK ME:  I think I busted this.  -Ossama
+		  if test "$prev" = dlprefiles; then
+		    # Preload the old-style object.
+		    dlprefiles="$dlprefiles $pic_object"
+		    prev=
+		  fi
+
+		  # A PIC object.
+		  func_append libobjs " $pic_object"
+		  arg="$pic_object"
+		fi
+
+		# Non-PIC object.
+		if test "$non_pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  non_pic_object="$xdir$non_pic_object"
+
+		  # A standard non-PIC object
+		  func_append non_pic_objects " $non_pic_object"
+		  if test -z "$pic_object" || test "$pic_object" = none ; then
+		    arg="$non_pic_object"
+		  fi
+		else
+		  # If the PIC object exists, use it instead.
+		  # $xdir was prepended to $pic_object above.
+		  non_pic_object="$pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+		fi
+	      else
+		# Only an error if not doing a dry-run.
+		if $opt_dry_run; then
+		  # Extract subdirectory from the argument.
+		  func_dirname "$arg" "/" ""
+		  xdir="$func_dirname_result"
+
+		  func_lo2o "$arg"
+		  pic_object=$xdir$objdir/$func_lo2o_result
+		  non_pic_object=$xdir$func_lo2o_result
+		  func_append libobjs " $pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+	        else
+		  func_fatal_error "\`$arg' is not a valid libtool object"
+		fi
+	      fi
+	    done
+	  else
+	    func_fatal_error "link input file \`$arg' does not exist"
+	  fi
+	  arg=$save_arg
+	  prev=
+	  continue
+	  ;;
+	precious_regex)
+	  precious_files_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	release)
+	  release="-$arg"
+	  prev=
+	  continue
+	  ;;
+	rpath | xrpath)
+	  # We need an absolute path.
+	  case $arg in
+	  [\\/]* | [A-Za-z]:[\\/]*) ;;
+	  *)
+	    func_fatal_error "only absolute run-paths are allowed"
+	    ;;
+	  esac
+	  if test "$prev" = rpath; then
+	    case "$rpath " in
+	    *" $arg "*) ;;
+	    *) rpath="$rpath $arg" ;;
+	    esac
+	  else
+	    case "$xrpath " in
+	    *" $arg "*) ;;
+	    *) xrpath="$xrpath $arg" ;;
+	    esac
+	  fi
+	  prev=
+	  continue
+	  ;;
+	shrext)
+	  shrext_cmds="$arg"
+	  prev=
+	  continue
+	  ;;
+	weak)
+	  weak_libs="$weak_libs $arg"
+	  prev=
+	  continue
+	  ;;
+	xcclinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xcompiler)
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xlinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $wl$qarg"
+	  prev=
+	  func_append compile_command " $wl$qarg"
+	  func_append finalize_command " $wl$qarg"
+	  continue
+	  ;;
+	*)
+	  eval "$prev=\"\$arg\""
+	  prev=
+	  continue
+	  ;;
+	esac
+      fi # test -n "$prev"
+
+      prevarg="$arg"
+
+      case $arg in
+      -all-static)
+	if test -n "$link_static_flag"; then
+	  # See comment for -static flag below, for more details.
+	  func_append compile_command " $link_static_flag"
+	  func_append finalize_command " $link_static_flag"
+	fi
+	continue
+	;;
+
+      -allow-undefined)
+	# FIXME: remove this flag sometime in the future.
+	func_fatal_error "\`-allow-undefined' must not be used because it is the default"
+	;;
+
+      -avoid-version)
+	avoid_version=yes
+	continue
+	;;
+
+      -dlopen)
+	prev=dlfiles
+	continue
+	;;
+
+      -dlpreopen)
+	prev=dlprefiles
+	continue
+	;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	continue
+	;;
+
+      -export-symbols | -export-symbols-regex)
+	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	  func_fatal_error "more than one -exported-symbols argument is not allowed"
+	fi
+	if test "X$arg" = "X-export-symbols"; then
+	  prev=expsyms
+	else
+	  prev=expsyms_regex
+	fi
+	continue
+	;;
+
+      -framework)
+	prev=framework
+	continue
+	;;
+
+      -inst-prefix-dir)
+	prev=inst_prefix
+	continue
+	;;
+
+      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*
+      # so, if we see these flags be careful not to treat them like -L
+      -L[A-Z][A-Z]*:*)
+	case $with_gcc/$host in
+	no/*-*-irix* | /*-*-irix*)
+	  func_append compile_command " $arg"
+	  func_append finalize_command " $arg"
+	  ;;
+	esac
+	continue
+	;;
+
+      -L*)
+	func_stripname '-L' '' "$arg"
+	dir=$func_stripname_result
+	if test -z "$dir"; then
+	  if test "$#" -gt 0; then
+	    func_fatal_error "require no space between \`-L' and \`$1'"
+	  else
+	    func_fatal_error "need path for \`-L' option"
+	  fi
+	fi
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  absdir=`cd "$dir" && pwd`
+	  test -z "$absdir" && \
+	    func_fatal_error "cannot determine absolute directory name of \`$dir'"
+	  dir="$absdir"
+	  ;;
+	esac
+	case "$deplibs " in
+	*" -L$dir "*) ;;
+	*)
+	  deplibs="$deplibs -L$dir"
+	  lib_search_path="$lib_search_path $dir"
+	  ;;
+	esac
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`$ECHO "X$dir" | $Xsed -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$dir:"*) ;;
+	  ::) dllsearchpath=$dir;;
+	  *) dllsearchpath="$dllsearchpath:$dir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+	continue
+	;;
+
+      -l*)
+	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc*)
+	    # These systems don't actually have a C or math library (as such)
+	    continue
+	    ;;
+	  *-*-os2*)
+	    # These systems don't actually have a C library (as such)
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C and math libraries are in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    continue
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  esac
+	elif test "X$arg" = "X-lc_r"; then
+	 case $host in
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	   # Do not include libc_r directly, use -pthread flag.
+	   continue
+	   ;;
+	 esac
+	fi
+	deplibs="$deplibs $arg"
+	continue
+	;;
+
+      -module)
+	module=yes
+	continue
+	;;
+
+      # Tru64 UNIX uses -model [arg] to determine the layout of C++
+      # classes, name mangling, and exception handling.
+      # Darwin uses the -arch flag to determine output architecture.
+      -model|-arch|-isysroot)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	prev=xcompiler
+	continue
+	;;
+
+      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	case "$new_inherited_linker_flags " in
+	    *" $arg "*) ;;
+	    * ) new_inherited_linker_flags="$new_inherited_linker_flags $arg" ;;
+	esac
+	continue
+	;;
+
+      -multi_module)
+	single_module="${wl}-multi_module"
+	continue
+	;;
+
+      -no-fast-install)
+	fast_install=no
+	continue
+	;;
+
+      -no-install)
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)
+	  # The PATH hackery in wrapper scripts is required on Windows
+	  # and Darwin in order for the loader to find any dlls it needs.
+	  func_warning "\`-no-install' is ignored for $host"
+	  func_warning "assuming \`-no-fast-install' instead"
+	  fast_install=no
+	  ;;
+	*) no_install=yes ;;
+	esac
+	continue
+	;;
+
+      -no-undefined)
+	allow_undefined=no
+	continue
+	;;
+
+      -objectlist)
+	prev=objectlist
+	continue
+	;;
+
+      -o) prev=output ;;
+
+      -precious-files-regex)
+	prev=precious_regex
+	continue
+	;;
+
+      -release)
+	prev=release
+	continue
+	;;
+
+      -rpath)
+	prev=rpath
+	continue
+	;;
+
+      -R)
+	prev=xrpath
+	continue
+	;;
+
+      -R*)
+	func_stripname '-R' '' "$arg"
+	dir=$func_stripname_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  func_fatal_error "only absolute run-paths are allowed"
+	  ;;
+	esac
+	case "$xrpath " in
+	*" $dir "*) ;;
+	*) xrpath="$xrpath $dir" ;;
+	esac
+	continue
+	;;
+
+      -shared)
+	# The effects of -shared are defined in a previous loop.
+	continue
+	;;
+
+      -shrext)
+	prev=shrext
+	continue
+	;;
+
+      -static | -static-libtool-libs)
+	# The effects of -static are defined in a previous loop.
+	# We used to do the same as -all-static on platforms that
+	# didn't have a PIC flag, but the assumption that the effects
+	# would be equivalent was wrong.  It would break on at least
+	# Digital Unix and AIX.
+	continue
+	;;
+
+      -thread-safe)
+	thread_safe=yes
+	continue
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+
+      -version-number)
+	prev=vinfo
+	vinfo_number=yes
+	continue
+	;;
+
+      -weak)
+        prev=weak
+	continue
+	;;
+
+      -Wc,*)
+	func_stripname '-Wc,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Wl,*)
+	func_stripname '-Wl,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $wl$func_quote_for_eval_result"
+	  linker_flags="$linker_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Xcompiler)
+	prev=xcompiler
+	continue
+	;;
+
+      -Xlinker)
+	prev=xlinker
+	continue
+	;;
+
+      -XCClinker)
+	prev=xcclinker
+	continue
+	;;
+
+      # -msg_* for osf cc
+      -msg_*)
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler
+      # -r[0-9][0-9]* specifies the processor on the SGI compiler
+      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler
+      # +DA*, +DD* enable 64-bit mode on the HP compiler
+      # -q* pass through compiler args for the IBM compiler
+      # -m*, -t[45]*, -txscale* pass through architecture-specific
+      # compiler args for GCC
+      # -F/path gives path to uninstalled frameworks, gcc on darwin
+      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC
+      # @file GCC response files
+      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
+      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+        func_append compile_command " $arg"
+        func_append finalize_command " $arg"
+        compiler_flags="$compiler_flags $arg"
+        continue
+        ;;
+
+      # Some other compiler flag.
+      -* | +*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      *.$objext)
+	# A standard object.
+	objs="$objs $arg"
+	;;
+
+      *.lo)
+	# A libtool-controlled object.
+
+	# Check to see that this really is a libtool object.
+	if func_lalib_unsafe_p "$arg"; then
+	  pic_object=
+	  non_pic_object=
+
+	  # Read the .lo file
+	  func_source "$arg"
+
+	  if test -z "$pic_object" ||
+	     test -z "$non_pic_object" ||
+	     test "$pic_object" = none &&
+	     test "$non_pic_object" = none; then
+	    func_fatal_error "cannot find name of object for \`$arg'"
+	  fi
+
+	  # Extract subdirectory from the argument.
+	  func_dirname "$arg" "/" ""
+	  xdir="$func_dirname_result"
+
+	  if test "$pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    pic_object="$xdir$pic_object"
+
+	    if test "$prev" = dlfiles; then
+	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		dlfiles="$dlfiles $pic_object"
+		prev=
+		continue
+	      else
+		# If libtool objects are unsupported, then we need to preload.
+		prev=dlprefiles
+	      fi
+	    fi
+
+	    # CHECK ME:  I think I busted this.  -Ossama
+	    if test "$prev" = dlprefiles; then
+	      # Preload the old-style object.
+	      dlprefiles="$dlprefiles $pic_object"
+	      prev=
+	    fi
+
+	    # A PIC object.
+	    func_append libobjs " $pic_object"
+	    arg="$pic_object"
+	  fi
+
+	  # Non-PIC object.
+	  if test "$non_pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    non_pic_object="$xdir$non_pic_object"
+
+	    # A standard non-PIC object
+	    func_append non_pic_objects " $non_pic_object"
+	    if test -z "$pic_object" || test "$pic_object" = none ; then
+	      arg="$non_pic_object"
+	    fi
+	  else
+	    # If the PIC object exists, use it instead.
+	    # $xdir was prepended to $pic_object above.
+	    non_pic_object="$pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  fi
+	else
+	  # Only an error if not doing a dry-run.
+	  if $opt_dry_run; then
+	    # Extract subdirectory from the argument.
+	    func_dirname "$arg" "/" ""
+	    xdir="$func_dirname_result"
+
+	    func_lo2o "$arg"
+	    pic_object=$xdir$objdir/$func_lo2o_result
+	    non_pic_object=$xdir$func_lo2o_result
+	    func_append libobjs " $pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  else
+	    func_fatal_error "\`$arg' is not a valid libtool object"
+	  fi
+	fi
+	;;
+
+      *.$libext)
+	# An archive.
+	deplibs="$deplibs $arg"
+	old_deplibs="$old_deplibs $arg"
+	continue
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	if test "$prev" = dlfiles; then
+	  # This library was specified with -dlopen.
+	  dlfiles="$dlfiles $arg"
+	  prev=
+	elif test "$prev" = dlprefiles; then
+	  # The library was specified with -dlpreopen.
+	  dlprefiles="$dlprefiles $arg"
+	  prev=
+	else
+	  deplibs="$deplibs $arg"
+	fi
+	continue
+	;;
+
+      # Some other compiler argument.
+      *)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+      esac # arg
+
+      # Now actually substitute the argument into the commands.
+      if test -n "$arg"; then
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+      fi
+    done # argument parsing loop
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prevarg' option requires an argument"
+
+    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+      eval arg=\"$export_dynamic_flag_spec\"
+      func_append compile_command " $arg"
+      func_append finalize_command " $arg"
+    fi
+
+    oldlibs=
+    # calculate the name of the file, without its directory
+    func_basename "$output"
+    outputname="$func_basename_result"
+    libobjs_save="$libobjs"
+
+    if test -n "$shlibpath_var"; then
+      # get the directories listed in $shlibpath_var
+      eval shlib_search_path=\`\$ECHO \"X\${$shlibpath_var}\" \| \$Xsed -e \'s/:/ /g\'\`
+    else
+      shlib_search_path=
+    fi
+    eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
+    eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
+
+    func_dirname "$output" "/" ""
+    output_objdir="$func_dirname_result$objdir"
+    # Create the object directory.
+    func_mkdir_p "$output_objdir"
+
+    # Determine the type of output
+    case $output in
+    "")
+      func_fatal_help "you must specify an output file"
+      ;;
+    *.$libext) linkmode=oldlib ;;
+    *.lo | *.$objext) linkmode=obj ;;
+    *.la) linkmode=lib ;;
+    *) linkmode=prog ;; # Anything else should be a program.
+    esac
+
+    specialdeplibs=
+
+    libs=
+    # Find all interdependent deplibs by searching for libraries
+    # that are linked more than once (e.g. -la -lb -la)
+    for deplib in $deplibs; do
+      if $opt_duplicate_deps ; then
+	case "$libs " in
+	*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	esac
+      fi
+      libs="$libs $deplib"
+    done
+
+    if test "$linkmode" = lib; then
+      libs="$predeps $libs $compiler_lib_search_path $postdeps"
+
+      # Compute libraries that are listed more than once in $predeps
+      # $postdeps and mark them as special (i.e., whose duplicates are
+      # not to be eliminated).
+      pre_post_deps=
+      if $opt_duplicate_compiler_generated_deps; then
+	for pre_post_dep in $predeps $postdeps; do
+	  case "$pre_post_deps " in
+	  *" $pre_post_dep "*) specialdeplibs="$specialdeplibs $pre_post_deps" ;;
+	  esac
+	  pre_post_deps="$pre_post_deps $pre_post_dep"
+	done
+      fi
+      pre_post_deps=
+    fi
+
+    deplibs=
+    newdependency_libs=
+    newlib_search_path=
+    need_relink=no # whether we're linking any uninstalled libtool libraries
+    notinst_deplibs= # not-installed libtool libraries
+    notinst_path= # paths that contain not-installed libtool libraries
+
+    case $linkmode in
+    lib)
+	passes="conv dlpreopen link"
+	for file in $dlfiles $dlprefiles; do
+	  case $file in
+	  *.la) ;;
+	  *)
+	    func_fatal_help "libraries can \`-dlopen' only libtool libraries: $file"
+	    ;;
+	  esac
+	done
+	;;
+    prog)
+	compile_deplibs=
+	finalize_deplibs=
+	alldeplibs=no
+	newdlfiles=
+	newdlprefiles=
+	passes="conv scan dlopen dlpreopen link"
+	;;
+    *)  passes="conv"
+	;;
+    esac
+
+    for pass in $passes; do
+      # The preopen pass in lib mode reverses $deplibs; put it back here
+      # so that -L comes before libs that need it for instance...
+      if test "$linkmode,$pass" = "lib,link"; then
+	## FIXME: Find the place where the list is rebuilt in the wrong
+	##        order, and fix it there properly
+        tmp_deplibs=
+	for deplib in $deplibs; do
+	  tmp_deplibs="$deplib $tmp_deplibs"
+	done
+	deplibs="$tmp_deplibs"
+      fi
+
+      if test "$linkmode,$pass" = "lib,link" ||
+	 test "$linkmode,$pass" = "prog,scan"; then
+	libs="$deplibs"
+	deplibs=
+      fi
+      if test "$linkmode" = prog; then
+	case $pass in
+	dlopen) libs="$dlfiles" ;;
+	dlpreopen) libs="$dlprefiles" ;;
+	link)
+	  libs="$deplibs %DEPLIBS%"
+	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
+	  ;;
+	esac
+      fi
+      if test "$linkmode,$pass" = "lib,dlpreopen"; then
+	# Collect and forward deplibs of preopened libtool libs
+	for lib in $dlprefiles; do
+	  # Ignore non-libtool-libs
+	  dependency_libs=
+	  case $lib in
+	  *.la)	func_source "$lib" ;;
+	  esac
+
+	  # Collect preopened libtool deplibs, except any this library
+	  # has declared as weak libs
+	  for deplib in $dependency_libs; do
+            deplib_base=`$ECHO "X$deplib" | $Xsed -e "$basename"`
+	    case " $weak_libs " in
+	    *" $deplib_base "*) ;;
+	    *) deplibs="$deplibs $deplib" ;;
+	    esac
+	  done
+	done
+	libs="$dlprefiles"
+      fi
+      if test "$pass" = dlopen; then
+	# Collect dlpreopened libraries
+	save_deplibs="$deplibs"
+	deplibs=
+      fi
+
+      for deplib in $libs; do
+	lib=
+	found=no
+	case $deplib in
+	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    compiler_flags="$compiler_flags $deplib"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-l*)
+	  if test "$linkmode" != lib && test "$linkmode" != prog; then
+	    func_warning "\`-l' is ignored for archives/objects"
+	    continue
+	  fi
+	  func_stripname '-l' '' "$deplib"
+	  name=$func_stripname_result
+	  if test "$linkmode" = lib; then
+	    searchdirs="$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path"
+	  else
+	    searchdirs="$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path"
+	  fi
+	  for searchdir in $searchdirs; do
+	    for search_ext in .la $std_shrext .so .a; do
+	      # Search the libtool library
+	      lib="$searchdir/lib${name}${search_ext}"
+	      if test -f "$lib"; then
+		if test "$search_ext" = ".la"; then
+		  found=yes
+		else
+		  found=no
+		fi
+		break 2
+	      fi
+	    done
+	  done
+	  if test "$found" != yes; then
+	    # deplib doesn't seem to be a libtool library
+	    if test "$linkmode,$pass" = "prog,link"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
+	  else # deplib is a libtool library
+	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
+	    # We need to do some special things here, and not later.
+	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      case " $predeps $postdeps " in
+	      *" $deplib "*)
+		if func_lalib_p "$lib"; then
+		  library_names=
+		  old_library=
+		  func_source "$lib"
+		  for l in $old_library $library_names; do
+		    ll="$l"
+		  done
+		  if test "X$ll" = "X$old_library" ; then # only static version available
+		    found=no
+		    func_dirname "$lib" "" "."
+		    ladir="$func_dirname_result"
+		    lib=$ladir/$old_library
+		    if test "$linkmode,$pass" = "prog,link"; then
+		      compile_deplibs="$deplib $compile_deplibs"
+		      finalize_deplibs="$deplib $finalize_deplibs"
+		    else
+		      deplibs="$deplib $deplibs"
+		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		    fi
+		    continue
+		  fi
+		fi
+		;;
+	      *) ;;
+	      esac
+	    fi
+	  fi
+	  ;; # -l
+	*.ltframework)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    deplibs="$deplib $deplibs"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-L*)
+	  case $linkmode in
+	  lib)
+	    deplibs="$deplib $deplibs"
+	    test "$pass" = conv && continue
+	    newdependency_libs="$deplib $newdependency_libs"
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  prog)
+	    if test "$pass" = conv; then
+	      deplibs="$deplib $deplibs"
+	      continue
+	    fi
+	    if test "$pass" = scan; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  *)
+	    func_warning "\`-L' is ignored for archives/objects"
+	    ;;
+	  esac # linkmode
+	  continue
+	  ;; # -L
+	-R*)
+	  if test "$pass" = link; then
+	    func_stripname '-R' '' "$deplib"
+	    dir=$func_stripname_result
+	    # Make sure the xrpath contains only unique directories.
+	    case "$xrpath " in
+	    *" $dir "*) ;;
+	    *) xrpath="$xrpath $dir" ;;
+	    esac
+	  fi
+	  deplibs="$deplib $deplibs"
+	  continue
+	  ;;
+	*.la) lib="$deplib" ;;
+	*.$libext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	    continue
+	  fi
+	  case $linkmode in
+	  lib)
+	    # Linking convenience modules into shared libraries is allowed,
+	    # but linking other static libraries is non-portable.
+	    case " $dlpreconveniencelibs " in
+	    *" $deplib "*) ;;
+	    *)
+	      valid_a_lib=no
+	      case $deplibs_check_method in
+		match_pattern*)
+		  set dummy $deplibs_check_method; shift
+		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+		  if eval "\$ECHO \"X$deplib\"" 2>/dev/null | $Xsed -e 10q \
+		    | $EGREP "$match_pattern_regex" > /dev/null; then
+		    valid_a_lib=yes
+		  fi
+		;;
+		pass_all)
+		  valid_a_lib=yes
+		;;
+	      esac
+	      if test "$valid_a_lib" != yes; then
+		$ECHO
+		$ECHO "*** Warning: Trying to link with static lib archive $deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because the file extensions .$libext of this argument makes me believe"
+		$ECHO "*** that it is just a static archive that I should not use here."
+	      else
+		$ECHO
+		$ECHO "*** Warning: Linking the shared library $output against the"
+		$ECHO "*** static library $deplib is not portable!"
+		deplibs="$deplib $deplibs"
+	      fi
+	      ;;
+	    esac
+	    continue
+	    ;;
+	  prog)
+	    if test "$pass" != link; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    continue
+	    ;;
+	  esac # linkmode
+	  ;; # *.$libext
+	*.lo | *.$objext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	  elif test "$linkmode" = prog; then
+	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	      # If there is no dlopen support or we're linking statically,
+	      # we need to preload.
+	      newdlprefiles="$newdlprefiles $deplib"
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      newdlfiles="$newdlfiles $deplib"
+	    fi
+	  fi
+	  continue
+	  ;;
+	%DEPLIBS%)
+	  alldeplibs=yes
+	  continue
+	  ;;
+	esac # case $deplib
+
+	if test "$found" = yes || test -f "$lib"; then :
+	else
+	  func_fatal_error "cannot find the library \`$lib' or unhandled argument \`$deplib'"
+	fi
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$lib" \
+	  || func_fatal_error "\`$lib' is not a valid libtool archive"
+
+	func_dirname "$lib" "" "."
+	ladir="$func_dirname_result"
+
+	dlname=
+	dlopen=
+	dlpreopen=
+	libdir=
+	library_names=
+	old_library=
+	inherited_linker_flags=
+	# If the library was installed with an old release of libtool,
+	# it will not redefine variables installed, or shouldnotlink
+	installed=yes
+	shouldnotlink=no
+	avoidtemprpath=
+
+
+	# Read the .la file
+	func_source "$lib"
+
+	# Convert "-framework foo" to "foo.ltframework"
+	if test -n "$inherited_linker_flags"; then
+	  tmp_inherited_linker_flags=`$ECHO "X$inherited_linker_flags" | $Xsed -e 's/-framework \([^ $]*\)/\1.ltframework/g'`
+	  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do
+	    case " $new_inherited_linker_flags " in
+	      *" $tmp_inherited_linker_flag "*) ;;
+	      *) new_inherited_linker_flags="$new_inherited_linker_flags $tmp_inherited_linker_flag";;
+	    esac
+	  done
+	fi
+	dependency_libs=`$ECHO "X $dependency_libs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	if test "$linkmode,$pass" = "lib,link" ||
+	   test "$linkmode,$pass" = "prog,scan" ||
+	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	  test -n "$dlopen" && dlfiles="$dlfiles $dlopen"
+	  test -n "$dlpreopen" && dlprefiles="$dlprefiles $dlpreopen"
+	fi
+
+	if test "$pass" = conv; then
+	  # Only check for convenience libraries
+	  deplibs="$lib $deplibs"
+	  if test -z "$libdir"; then
+	    if test -z "$old_library"; then
+	      func_fatal_error "cannot find name of link library for \`$lib'"
+	    fi
+	    # It is a libtool convenience library, so add in its objects.
+	    convenience="$convenience $ladir/$objdir/$old_library"
+	    old_convenience="$old_convenience $ladir/$objdir/$old_library"
+	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
+	    func_fatal_error "\`$lib' is not a convenience library"
+	  fi
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    deplibs="$deplib $deplibs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+	  continue
+	fi # $pass = conv
+
+
+	# Get the name of the library we link against.
+	linklib=
+	for l in $old_library $library_names; do
+	  linklib="$l"
+	done
+	if test -z "$linklib"; then
+	  func_fatal_error "cannot find name of link library for \`$lib'"
+	fi
+
+	# This library was specified with -dlopen.
+	if test "$pass" = dlopen; then
+	  if test -z "$libdir"; then
+	    func_fatal_error "cannot -dlopen a convenience library: \`$lib'"
+	  fi
+	  if test -z "$dlname" ||
+	     test "$dlopen_support" != yes ||
+	     test "$build_libtool_libs" = no; then
+	    # If there is no dlname, no dlopen support or we're linking
+	    # statically, we need to preload.  We also need to preload any
+	    # dependent libraries so libltdl's deplib preloader doesn't
+	    # bomb out in the load deplibs phase.
+	    dlprefiles="$dlprefiles $lib $dependency_libs"
+	  else
+	    newdlfiles="$newdlfiles $lib"
+	  fi
+	  continue
+	fi # $pass = dlopen
+
+	# We need an absolute path.
+	case $ladir in
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	*)
+	  abs_ladir=`cd "$ladir" && pwd`
+	  if test -z "$abs_ladir"; then
+	    func_warning "cannot determine absolute directory name of \`$ladir'"
+	    func_warning "passing it literally to the linker, although it might fail"
+	    abs_ladir="$ladir"
+	  fi
+	  ;;
+	esac
+	func_basename "$lib"
+	laname="$func_basename_result"
+
+	# Find the relevant object directory and library name.
+	if test "X$installed" = Xyes; then
+	  if test ! -f "$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    func_warning "library \`$lib' was moved."
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    libdir="$abs_ladir"
+	  else
+	    dir="$libdir"
+	    absdir="$libdir"
+	  fi
+	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	else
+	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  else
+	    dir="$ladir/$objdir"
+	    absdir="$abs_ladir/$objdir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  fi
+	fi # $installed = yes
+	func_stripname 'lib' '.la' "$laname"
+	name=$func_stripname_result
+
+	# This library was specified with -dlpreopen.
+	if test "$pass" = dlpreopen; then
+	  if test -z "$libdir" && test "$linkmode" = prog; then
+	    func_fatal_error "only libraries may -dlpreopen a convenience library: \`$lib'"
+	  fi
+	  # Prefer using a static library (so that no silly _DYNAMIC symbols
+	  # are required to link).
+	  if test -n "$old_library"; then
+	    newdlprefiles="$newdlprefiles $dir/$old_library"
+	    # Keep a list of preopened convenience libraries to check
+	    # that they are being used correctly in the link pass.
+	    test -z "$libdir" && \
+		dlpreconveniencelibs="$dlpreconveniencelibs $dir/$old_library"
+	  # Otherwise, use the dlname, so that lt_dlopen finds it.
+	  elif test -n "$dlname"; then
+	    newdlprefiles="$newdlprefiles $dir/$dlname"
+	  else
+	    newdlprefiles="$newdlprefiles $dir/$linklib"
+	  fi
+	fi # $pass = dlpreopen
+
+	if test -z "$libdir"; then
+	  # Link the convenience library
+	  if test "$linkmode" = lib; then
+	    deplibs="$dir/$old_library $deplibs"
+	  elif test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$dir/$old_library $compile_deplibs"
+	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
+	  else
+	    deplibs="$lib $deplibs" # used for prog,scan pass
+	  fi
+	  continue
+	fi
+
+
+	if test "$linkmode" = prog && test "$pass" != link; then
+	  newlib_search_path="$newlib_search_path $ladir"
+	  deplibs="$lib $deplibs"
+
+	  linkalldeplibs=no
+	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
+	     test "$build_libtool_libs" = no; then
+	    linkalldeplibs=yes
+	  fi
+
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    case $deplib in
+	    -L*) func_stripname '-L' '' "$deplib"
+	         newlib_search_path="$newlib_search_path $func_stripname_result"
+		 ;;
+	    esac
+	    # Need to link against all dependency_libs?
+	    if test "$linkalldeplibs" = yes; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      # Need to hardcode shared library paths
+	      # or/and link against static libraries
+	      newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done # for deplib
+	  continue
+	fi # $linkmode = prog...
+
+	if test "$linkmode,$pass" = "prog,link"; then
+	  if test -n "$library_names" &&
+	     { { test "$prefer_static_libs" = no ||
+	         test "$prefer_static_libs,$installed" = "built,yes"; } ||
+	       test -z "$old_library"; }; then
+	    # We need to hardcode the library path
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	      # Make sure the rpath contains only unique directories.
+	      case "$temp_rpath:" in
+	      *"$absdir:"*) ;;
+	      *) temp_rpath="$temp_rpath$absdir:" ;;
+	      esac
+	    fi
+
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi # $linkmode,$pass = prog,link...
+
+	  if test "$alldeplibs" = yes &&
+	     { test "$deplibs_check_method" = pass_all ||
+	       { test "$build_libtool_libs" = yes &&
+		 test -n "$library_names"; }; }; then
+	    # We only need to search for static libraries
+	    continue
+	  fi
+	fi
+
+	link_static=no # Whether the deplib will be linked statically
+	use_static_libs=$prefer_static_libs
+	if test "$use_static_libs" = built && test "$installed" = yes; then
+	  use_static_libs=no
+	fi
+	if test -n "$library_names" &&
+	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc*)
+	      # No point in relinking DLLs because paths are not encoded
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=no
+	    ;;
+	  *)
+	    if test "$installed" = no; then
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=yes
+	    fi
+	    ;;
+	  esac
+	  # This is a shared library
+
+	  # Warn about portability, can't link against -module's on some
+	  # systems (darwin).  Don't bleat about dlopened modules though!
+	  dlopenmodule=""
+	  for dlpremoduletest in $dlprefiles; do
+	    if test "X$dlpremoduletest" = "X$lib"; then
+	      dlopenmodule="$dlpremoduletest"
+	      break
+	    fi
+	  done
+	  if test -z "$dlopenmodule" && test "$shouldnotlink" = yes && test "$pass" = link; then
+	    $ECHO
+	    if test "$linkmode" = prog; then
+	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
+	    else
+	      $ECHO "*** Warning: Linking the shared library $output against the loadable module"
+	    fi
+	    $ECHO "*** $linklib is not portable!"
+	  fi
+	  if test "$linkmode" = lib &&
+	     test "$hardcode_into_libs" = yes; then
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi
+
+	  if test -n "$old_archive_from_expsyms_cmds"; then
+	    # figure out the soname
+	    set dummy $library_names
+	    shift
+	    realname="$1"
+	    shift
+	    libname=`eval "\\$ECHO \"$libname_spec\""`
+	    # use dlname if we got it. it's perfectly good, no?
+	    if test -n "$dlname"; then
+	      soname="$dlname"
+	    elif test -n "$soname_spec"; then
+	      # bleh windows
+	      case $host in
+	      *cygwin* | mingw* | *cegcc*)
+	        func_arith $current - $age
+		major=$func_arith_result
+		versuffix="-$major"
+		;;
+	      esac
+	      eval soname=\"$soname_spec\"
+	    else
+	      soname="$realname"
+	    fi
+
+	    # Make a new name for the extract_expsyms_cmds to use
+	    soroot="$soname"
+	    func_basename "$soroot"
+	    soname="$func_basename_result"
+	    func_stripname 'lib' '.dll' "$soname"
+	    newlib=libimp-$func_stripname_result.a
+
+	    # If the library has no export list, then create one now
+	    if test -f "$output_objdir/$soname-def"; then :
+	    else
+	      func_verbose "extracting exported symbol list from \`$soname'"
+	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
+	    fi
+
+	    # Create $newlib
+	    if test -f "$output_objdir/$newlib"; then :; else
+	      func_verbose "generating import library for \`$soname'"
+	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
+	    fi
+	    # make sure the library variables are pointing to the new library
+	    dir=$output_objdir
+	    linklib=$newlib
+	  fi # test -n "$old_archive_from_expsyms_cmds"
+
+	  if test "$linkmode" = prog || test "$mode" != relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    lib_linked=yes
+	    case $hardcode_action in
+	    immediate | unsupported)
+	      if test "$hardcode_direct" = no; then
+		add="$dir/$linklib"
+		case $host in
+		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
+		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
+		    *-*-unixware7*) add_dir="-L$dir" ;;
+		  *-*-darwin* )
+		    # if the lib is a (non-dlopened) module then we can not
+		    # link against it, someone is ignoring the earlier warnings
+		    if /usr/bin/file -L $add 2> /dev/null |
+			 $GREP ": [^:]* bundle" >/dev/null ; then
+		      if test "X$dlopenmodule" != "X$lib"; then
+			$ECHO "*** Warning: lib $linklib is a module, not a shared library"
+			if test -z "$old_library" ; then
+			  $ECHO
+			  $ECHO "*** And there doesn't seem to be a static archive available"
+			  $ECHO "*** The link will probably fail, sorry"
+			else
+			  add="$dir/$old_library"
+			fi
+		      elif test -n "$old_library"; then
+			add="$dir/$old_library"
+		      fi
+		    fi
+		esac
+	      elif test "$hardcode_minus_L" = no; then
+		case $host in
+		*-*-sunos*) add_shlibpath="$dir" ;;
+		esac
+		add_dir="-L$dir"
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = no; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    relink)
+	      if test "$hardcode_direct" = yes &&
+	         test "$hardcode_direct_absolute" = no; then
+		add="$dir/$linklib"
+	      elif test "$hardcode_minus_L" = yes; then
+		add_dir="-L$dir"
+		# Try looking first in the location we're being installed to.
+		if test -n "$inst_prefix_dir"; then
+		  case $libdir in
+		    [\\/]*)
+		      add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		      ;;
+		  esac
+		fi
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = yes; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    *) lib_linked=no ;;
+	    esac
+
+	    if test "$lib_linked" != yes; then
+	      func_fatal_configuration "unsupported hardcode properties"
+	    fi
+
+	    if test -n "$add_shlibpath"; then
+	      case :$compile_shlibpath: in
+	      *":$add_shlibpath:"*) ;;
+	      *) compile_shlibpath="$compile_shlibpath$add_shlibpath:" ;;
+	      esac
+	    fi
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
+	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	      if test "$hardcode_direct" != yes &&
+		 test "$hardcode_minus_L" != yes &&
+		 test "$hardcode_shlibpath_var" = yes; then
+		case :$finalize_shlibpath: in
+		*":$libdir:"*) ;;
+		*) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+		esac
+	      fi
+	    fi
+	  fi
+
+	  if test "$linkmode" = prog || test "$mode" = relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    # Finalize command for both is simple: just hardcode it.
+	    if test "$hardcode_direct" = yes &&
+	       test "$hardcode_direct_absolute" = no; then
+	      add="$libdir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      add_dir="-L$libdir"
+	      add="-l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      case :$finalize_shlibpath: in
+	      *":$libdir:"*) ;;
+	      *) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+	      esac
+	      add="-l$name"
+	    elif test "$hardcode_automatic" = yes; then
+	      if test -n "$inst_prefix_dir" &&
+		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
+		add="$inst_prefix_dir$libdir/$linklib"
+	      else
+		add="$libdir/$linklib"
+	      fi
+	    else
+	      # We cannot seem to hardcode it, guess we'll fake it.
+	      add_dir="-L$libdir"
+	      # Try looking first in the location we're being installed to.
+	      if test -n "$inst_prefix_dir"; then
+		case $libdir in
+		  [\\/]*)
+		    add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		    ;;
+		esac
+	      fi
+	      add="-l$name"
+	    fi
+
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
+	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	    fi
+	  fi
+	elif test "$linkmode" = prog; then
+	  # Here we assume that one of hardcode_direct or hardcode_minus_L
+	  # is not unsupported.  This is valid on all known static and
+	  # shared platforms.
+	  if test "$hardcode_direct" != unsupported; then
+	    test -n "$old_library" && linklib="$old_library"
+	    compile_deplibs="$dir/$linklib $compile_deplibs"
+	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
+	  else
+	    compile_deplibs="-l$name -L$dir $compile_deplibs"
+	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
+	  fi
+	elif test "$build_libtool_libs" = yes; then
+	  # Not a shared library
+	  if test "$deplibs_check_method" != pass_all; then
+	    # We're trying link a shared library against a static one
+	    # but the system doesn't support it.
+
+	    # Just print a warning and add the library to dependency_libs so
+	    # that the program can be linked against the static library.
+	    $ECHO
+	    $ECHO "*** Warning: This system can not link to static lib archive $lib."
+	    $ECHO "*** I have the capability to make that library automatically link in when"
+	    $ECHO "*** you link to this library.  But I can only do this if you have a"
+	    $ECHO "*** shared version of the library, which you do not appear to have."
+	    if test "$module" = yes; then
+	      $ECHO "*** But as you try to build a module library, libtool will still create "
+	      $ECHO "*** a static module, that should work as long as the dlopening application"
+	      $ECHO "*** is linked with the -dlopen flag to resolve symbols at runtime."
+	      if test -z "$global_symbol_pipe"; then
+		$ECHO
+		$ECHO "*** However, this would only work if libtool was able to extract symbol"
+		$ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		$ECHO "*** not find such a program.  So, this module is probably useless."
+		$ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	      fi
+	      if test "$build_old_libs" = no; then
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  else
+	    deplibs="$dir/$old_library $deplibs"
+	    link_static=yes
+	  fi
+	fi # link shared/static library?
+
+	if test "$linkmode" = lib; then
+	  if test -n "$dependency_libs" &&
+	     { test "$hardcode_into_libs" != yes ||
+	       test "$build_old_libs" = yes ||
+	       test "$link_static" = yes; }; then
+	    # Extract -R from dependency_libs
+	    temp_deplibs=
+	    for libdir in $dependency_libs; do
+	      case $libdir in
+	      -R*) func_stripname '-R' '' "$libdir"
+	           temp_xrpath=$func_stripname_result
+		   case " $xrpath " in
+		   *" $temp_xrpath "*) ;;
+		   *) xrpath="$xrpath $temp_xrpath";;
+		   esac;;
+	      *) temp_deplibs="$temp_deplibs $libdir";;
+	      esac
+	    done
+	    dependency_libs="$temp_deplibs"
+	  fi
+
+	  newlib_search_path="$newlib_search_path $absdir"
+	  # Link against this library
+	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  # ... and its dependency_libs
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    newdependency_libs="$deplib $newdependency_libs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+
+	  if test "$link_all_deplibs" != no; then
+	    # Add the search paths of all dependency libraries
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      -L*) path="$deplib" ;;
+	      *.la)
+	        func_dirname "$deplib" "" "."
+		dir="$func_dirname_result"
+		# We need an absolute path.
+		case $dir in
+		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		*)
+		  absdir=`cd "$dir" && pwd`
+		  if test -z "$absdir"; then
+		    func_warning "cannot determine absolute directory name of \`$dir'"
+		    absdir="$dir"
+		  fi
+		  ;;
+		esac
+		if $GREP "^installed=no" $deplib > /dev/null; then
+		case $host in
+		*-*-darwin*)
+		  depdepl=
+		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names" ; then
+		    for tmp in $deplibrary_names ; do
+		      depdepl=$tmp
+		    done
+		    if test -f "$absdir/$objdir/$depdepl" ; then
+		      depdepl="$absdir/$objdir/$depdepl"
+		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
+                      if test -z "$darwin_install_name"; then
+                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
+                      fi
+		      compiler_flags="$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}"
+		      linker_flags="$linker_flags -dylib_file ${darwin_install_name}:${depdepl}"
+		      path=
+		    fi
+		  fi
+		  ;;
+		*)
+		  path="-L$absdir/$objdir"
+		  ;;
+		esac
+		else
+		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  test -z "$libdir" && \
+		    func_fatal_error "\`$deplib' is not a valid libtool archive"
+		  test "$absdir" != "$libdir" && \
+		    func_warning "\`$deplib' seems to be moved"
+
+		  path="-L$absdir"
+		fi
+		;;
+	      esac
+	      case " $deplibs " in
+	      *" $path "*) ;;
+	      *) deplibs="$path $deplibs" ;;
+	      esac
+	    done
+	  fi # link_all_deplibs != no
+	fi # linkmode = lib
+      done # for deplib in $libs
+      if test "$pass" = link; then
+	if test "$linkmode" = "prog"; then
+	  compile_deplibs="$new_inherited_linker_flags $compile_deplibs"
+	  finalize_deplibs="$new_inherited_linker_flags $finalize_deplibs"
+	else
+	  compiler_flags="$compiler_flags "`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	fi
+      fi
+      dependency_libs="$newdependency_libs"
+      if test "$pass" = dlpreopen; then
+	# Link the dlpreopened libraries before other libraries
+	for deplib in $save_deplibs; do
+	  deplibs="$deplib $deplibs"
+	done
+      fi
+      if test "$pass" != dlopen; then
+	if test "$pass" != conv; then
+	  # Make sure lib_search_path contains only unique directories.
+	  lib_search_path=
+	  for dir in $newlib_search_path; do
+	    case "$lib_search_path " in
+	    *" $dir "*) ;;
+	    *) lib_search_path="$lib_search_path $dir" ;;
+	    esac
+	  done
+	  newlib_search_path=
+	fi
+
+	if test "$linkmode,$pass" != "prog,link"; then
+	  vars="deplibs"
+	else
+	  vars="compile_deplibs finalize_deplibs"
+	fi
+	for var in $vars dependency_libs; do
+	  # Add libraries to $var in reverse order
+	  eval tmp_libs=\"\$$var\"
+	  new_libs=
+	  for deplib in $tmp_libs; do
+	    # FIXME: Pedantically, this is the right thing to do, so
+	    #        that some nasty dependency loop isn't accidentally
+	    #        broken:
+	    #new_libs="$deplib $new_libs"
+	    # Pragmatically, this seems to cause very few problems in
+	    # practice:
+	    case $deplib in
+	    -L*) new_libs="$deplib $new_libs" ;;
+	    -R*) ;;
+	    *)
+	      # And here is the reason: when a library appears more
+	      # than once as an explicit dependence of a library, or
+	      # is implicitly linked in more than once by the
+	      # compiler, it is considered special, and multiple
+	      # occurrences thereof are not removed.  Compare this
+	      # with having the same library being listed as a
+	      # dependency of multiple other libraries: in this case,
+	      # we know (pedantically, we assume) the library does not
+	      # need to be listed more than once, so we keep only the
+	      # last copy.  This is not always right, but it is rare
+	      # enough that we require users that really mean to play
+	      # such unportable linking tricks to link the library
+	      # using -Wl,-lname, so that libtool does not consider it
+	      # for duplicate removal.
+	      case " $specialdeplibs " in
+	      *" $deplib "*) new_libs="$deplib $new_libs" ;;
+	      *)
+		case " $new_libs " in
+		*" $deplib "*) ;;
+		*) new_libs="$deplib $new_libs" ;;
+		esac
+		;;
+	      esac
+	      ;;
+	    esac
+	  done
+	  tmp_libs=
+	  for deplib in $new_libs; do
+	    case $deplib in
+	    -L*)
+	      case " $tmp_libs " in
+	      *" $deplib "*) ;;
+	      *) tmp_libs="$tmp_libs $deplib" ;;
+	      esac
+	      ;;
+	    *) tmp_libs="$tmp_libs $deplib" ;;
+	    esac
+	  done
+	  eval $var=\"$tmp_libs\"
+	done # for var
+      fi
+      # Last step: remove runtime libs from dependency_libs
+      # (they stay in deplibs)
+      tmp_libs=
+      for i in $dependency_libs ; do
+	case " $predeps $postdeps $compiler_lib_search_path " in
+	*" $i "*)
+	  i=""
+	  ;;
+	esac
+	if test -n "$i" ; then
+	  tmp_libs="$tmp_libs $i"
+	fi
+      done
+      dependency_libs=$tmp_libs
+    done # for pass
+    if test "$linkmode" = prog; then
+      dlfiles="$newdlfiles"
+    fi
+    if test "$linkmode" = prog || test "$linkmode" = lib; then
+      dlprefiles="$newdlprefiles"
+    fi
+
+    case $linkmode in
+    oldlib)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for archives"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for archives" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for archives"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for archives"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info/-version-number' is ignored for archives"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for archives"
+
+      test -n "$export_symbols$export_symbols_regex" && \
+	func_warning "\`-export-symbols' is ignored for archives"
+
+      # Now set the variables for building old libraries.
+      build_libtool_libs=no
+      oldlibs="$output"
+      objs="$objs$old_deplibs"
+      ;;
+
+    lib)
+      # Make sure we only generate libraries of the form `libNAME.la'.
+      case $outputname in
+      lib*)
+	func_stripname 'lib' '.la' "$outputname"
+	name=$func_stripname_result
+	eval shared_ext=\"$shrext_cmds\"
+	eval libname=\"$libname_spec\"
+	;;
+      *)
+	test "$module" = no && \
+	  func_fatal_help "libtool library \`$output' must begin with \`lib'"
+
+	if test "$need_lib_prefix" != no; then
+	  # Add the "lib" prefix for modules if required
+	  func_stripname '' '.la' "$outputname"
+	  name=$func_stripname_result
+	  eval shared_ext=\"$shrext_cmds\"
+	  eval libname=\"$libname_spec\"
+	else
+	  func_stripname '' '.la' "$outputname"
+	  libname=$func_stripname_result
+	fi
+	;;
+      esac
+
+      if test -n "$objs"; then
+	if test "$deplibs_check_method" != pass_all; then
+	  func_fatal_error "cannot build libtool library \`$output' from non-libtool objects on this host:$objs"
+	else
+	  $ECHO
+	  $ECHO "*** Warning: Linking the shared library $output against the non-libtool"
+	  $ECHO "*** objects $objs is not portable!"
+	  libobjs="$libobjs $objs"
+	fi
+      fi
+
+      test "$dlself" != no && \
+	func_warning "\`-dlopen self' is ignored for libtool libraries"
+
+      set dummy $rpath
+      shift
+      test "$#" -gt 1 && \
+	func_warning "ignoring multiple \`-rpath's for a libtool library"
+
+      install_libdir="$1"
+
+      oldlibs=
+      if test -z "$rpath"; then
+	if test "$build_libtool_libs" = yes; then
+	  # Building a libtool convenience library.
+	  # Some compilers have problems with a `.al' extension so
+	  # convenience libraries should have the same extension an
+	  # archive normally would.
+	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
+	  build_libtool_libs=convenience
+	  build_old_libs=yes
+	fi
+
+	test -n "$vinfo" && \
+	  func_warning "\`-version-info/-version-number' is ignored for convenience libraries"
+
+	test -n "$release" && \
+	  func_warning "\`-release' is ignored for convenience libraries"
+      else
+
+	# Parse the version information argument.
+	save_ifs="$IFS"; IFS=':'
+	set dummy $vinfo 0 0 0
+	shift
+	IFS="$save_ifs"
+
+	test -n "$7" && \
+	  func_fatal_help "too many parameters to \`-version-info'"
+
+	# convert absolute version numbers to libtool ages
+	# this retains compatibility with .la files and attempts
+	# to make the code below a bit more comprehensible
+
+	case $vinfo_number in
+	yes)
+	  number_major="$1"
+	  number_minor="$2"
+	  number_revision="$3"
+	  #
+	  # There are really only two kinds -- those that
+	  # use the current revision as the major version
+	  # and those that subtract age and use age as
+	  # a minor version.  But, then there is irix
+	  # which has an extra 1 added just for fun
+	  #
+	  case $version_type in
+	  darwin|linux|osf|windows|none)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_revision"
+	    ;;
+	  freebsd-aout|freebsd-elf|sunos)
+	    current="$number_major"
+	    revision="$number_minor"
+	    age="0"
+	    ;;
+	  irix|nonstopux)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_minor"
+	    lt_irix_increment=no
+	    ;;
+	  *)
+	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    ;;
+	  esac
+	  ;;
+	no)
+	  current="$1"
+	  revision="$2"
+	  age="$3"
+	  ;;
+	esac
+
+	# Check that each of the things are valid numbers.
+	case $current in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "CURRENT \`$current' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $revision in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "REVISION \`$revision' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $age in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "AGE \`$age' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	if test "$age" -gt "$current"; then
+	  func_error "AGE \`$age' is greater than the current interface number \`$current'"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	fi
+
+	# Calculate the version variables.
+	major=
+	versuffix=
+	verstring=
+	case $version_type in
+	none) ;;
+
+	darwin)
+	  # Like Linux, but with the current version available in
+	  # verstring for coding it into the library header
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  # Darwin ld doesn't like 0 for these options...
+	  func_arith $current + 1
+	  minor_current=$func_arith_result
+	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
+	  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+	  ;;
+
+	freebsd-aout)
+	  major=".$current"
+	  versuffix=".$current.$revision";
+	  ;;
+
+	freebsd-elf)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	irix | nonstopux)
+	  if test "X$lt_irix_increment" = "Xno"; then
+	    func_arith $current - $age
+	  else
+	    func_arith $current - $age + 1
+	  fi
+	  major=$func_arith_result
+
+	  case $version_type in
+	    nonstopux) verstring_prefix=nonstopux ;;
+	    *)         verstring_prefix=sgi ;;
+	  esac
+	  verstring="$verstring_prefix$major.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$revision
+	  while test "$loop" -ne 0; do
+	    func_arith $revision - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring_prefix$major.$iface:$verstring"
+	  done
+
+	  # Before this point, $major must not contain `.'.
+	  major=.$major
+	  versuffix="$major.$revision"
+	  ;;
+
+	linux)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  ;;
+
+	osf)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix=".$current.$age.$revision"
+	  verstring="$current.$age.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$age
+	  while test "$loop" -ne 0; do
+	    func_arith $current - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring:${iface}.0"
+	  done
+
+	  # Make executables depend on our current version.
+	  verstring="$verstring:${current}.0"
+	  ;;
+
+	qnx)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	sunos)
+	  major=".$current"
+	  versuffix=".$current.$revision"
+	  ;;
+
+	windows)
+	  # Use '-' rather than '.', since we only want one
+	  # extension on DOS 8.3 filesystems.
+	  func_arith $current - $age
+	  major=$func_arith_result
+	  versuffix="-$major"
+	  ;;
+
+	*)
+	  func_fatal_configuration "unknown library version type \`$version_type'"
+	  ;;
+	esac
+
+	# Clear the version info if we defaulted, and they specified a release.
+	if test -z "$vinfo" && test -n "$release"; then
+	  major=
+	  case $version_type in
+	  darwin)
+	    # we can't check for "0.0" in archive_cmds due to quoting
+	    # problems, so we reset it completely
+	    verstring=
+	    ;;
+	  *)
+	    verstring="0.0"
+	    ;;
+	  esac
+	  if test "$need_version" = no; then
+	    versuffix=
+	  else
+	    versuffix=".0.0"
+	  fi
+	fi
+
+	# Remove version info from name if versioning should be avoided
+	if test "$avoid_version" = yes && test "$need_version" = no; then
+	  major=
+	  versuffix=
+	  verstring=""
+	fi
+
+	# Check to see if the archive will have undefined symbols.
+	if test "$allow_undefined" = yes; then
+	  if test "$allow_undefined_flag" = unsupported; then
+	    func_warning "undefined symbols not allowed in $host shared libraries"
+	    build_libtool_libs=no
+	    build_old_libs=yes
+	  fi
+	else
+	  # Don't allow undefined symbols.
+	  allow_undefined_flag="$no_undefined_flag"
+	fi
+
+      fi
+
+      func_generate_dlsyms "$libname" "$libname" "yes"
+      libobjs="$libobjs $symfileobj"
+      test "X$libobjs" = "X " && libobjs=
+
+      if test "$mode" != relink; then
+	# Remove our outputs, but don't remove object files since they
+	# may have been created when compiling PIC objects.
+	removelist=
+	tempremovelist=`$ECHO "$output_objdir/*"`
+	for p in $tempremovelist; do
+	  case $p in
+	    *.$objext | *.gcno)
+	       ;;
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
+	       if test "X$precious_files_regex" != "X"; then
+		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
+		 then
+		   continue
+		 fi
+	       fi
+	       removelist="$removelist $p"
+	       ;;
+	    *) ;;
+	  esac
+	done
+	test -n "$removelist" && \
+	  func_show_eval "${RM}r \$removelist"
+      fi
+
+      # Now set the variables for building old libraries.
+      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+	oldlibs="$oldlibs $output_objdir/$libname.$libext"
+
+	# Transform .lo files to .o files.
+	oldobjs="$objs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}'$/d' -e "$lo2o" | $NL2SP`
+      fi
+
+      # Eliminate all temporary directories.
+      #for path in $notinst_path; do
+      #	lib_search_path=`$ECHO "X$lib_search_path " | $Xsed -e "s% $path % %g"`
+      #	deplibs=`$ECHO "X$deplibs " | $Xsed -e "s% -L$path % %g"`
+      #	dependency_libs=`$ECHO "X$dependency_libs " | $Xsed -e "s% -L$path % %g"`
+      #done
+
+      if test -n "$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	temp_xrpath=
+	for libdir in $xrpath; do
+	  temp_xrpath="$temp_xrpath -R$libdir"
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	  dependency_libs="$temp_xrpath $dependency_libs"
+	fi
+      fi
+
+      # Make sure dlfiles contains only unique files that won't be dlpreopened
+      old_dlfiles="$dlfiles"
+      dlfiles=
+      for lib in $old_dlfiles; do
+	case " $dlprefiles $dlfiles " in
+	*" $lib "*) ;;
+	*) dlfiles="$dlfiles $lib" ;;
+	esac
+      done
+
+      # Make sure dlprefiles contains only unique files
+      old_dlprefiles="$dlprefiles"
+      dlprefiles=
+      for lib in $old_dlprefiles; do
+	case "$dlprefiles " in
+	*" $lib "*) ;;
+	*) dlprefiles="$dlprefiles $lib" ;;
+	esac
+      done
+
+      if test "$build_libtool_libs" = yes; then
+	if test -n "$rpath"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc*)
+	    # these systems don't actually have a c library (as such)!
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C library is in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    ;;
+	  *-*-netbsd*)
+	    # Don't link with libc until the a.out ld.so is fixed.
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    ;;
+	  *)
+	    # Add libc to deplibs on all other systems if necessary.
+	    if test "$build_libtool_need_lc" = "yes"; then
+	      deplibs="$deplibs -lc"
+	    fi
+	    ;;
+	  esac
+	fi
+
+	# Transform deplibs into only deplibs that can be linked in shared.
+	name_save=$name
+	libname_save=$libname
+	release_save=$release
+	versuffix_save=$versuffix
+	major_save=$major
+	# I'm not sure if I'm treating the release correctly.  I think
+	# release should show up in the -l (ie -lgmp5) so we don't want to
+	# add it in twice.  Is that correct?
+	release=""
+	versuffix=""
+	major=""
+	newdeplibs=
+	droppeddeps=no
+	case $deplibs_check_method in
+	pass_all)
+	  # Don't check for shared/static.  Everything works.
+	  # This might be a little naive.  We might want to check
+	  # whether the library exists or not.  But this is on
+	  # osf3 & osf4 and I'm not really sure... Just
+	  # implementing what was already the behavior.
+	  newdeplibs=$deplibs
+	  ;;
+	test_compile)
+	  # This code stresses the "libraries are programs" paradigm to its
+	  # limits. Maybe even breaks it.  We compile a program, linking it
+	  # against the deplibs as a proxy for the library.  Then we can check
+	  # whether they linked in statically or dynamically with ldd.
+	  $opt_dry_run || $RM conftest.c
+	  cat > conftest.c <<EOF
+	  int main() { return 0; }
+EOF
+	  $opt_dry_run || $RM conftest
+	  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then
+	    ldd_output=`ldd conftest`
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  case " $predeps $postdeps " in
+		  *" $i "*)
+		    newdeplibs="$newdeplibs $i"
+		    i=""
+		    ;;
+		  esac
+		fi
+		if test -n "$i" ; then
+		  libname=`eval "\\$ECHO \"$libname_spec\""`
+		  deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		  set dummy $deplib_matches; shift
+		  deplib_match=$1
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    newdeplibs="$newdeplibs $i"
+		  else
+		    droppeddeps=yes
+		    $ECHO
+		    $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		    $ECHO "*** I have the capability to make that library automatically link in when"
+		    $ECHO "*** you link to this library.  But I can only do this if you have a"
+		    $ECHO "*** shared version of the library, which I believe you do not have"
+		    $ECHO "*** because a test_compile did reveal that the linker did not use it for"
+		    $ECHO "*** its dynamic dependency list that programs get resolved with at runtime."
+		  fi
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  else
+	    # Error occurred in the first compile.  Let's try to salvage
+	    # the situation: Compile a separate program for each library.
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		$opt_dry_run || $RM conftest
+		if $LTCC $LTCFLAGS -o conftest conftest.c $i; then
+		  ldd_output=`ldd conftest`
+		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		    case " $predeps $postdeps " in
+		    *" $i "*)
+		      newdeplibs="$newdeplibs $i"
+		      i=""
+		      ;;
+		    esac
+		  fi
+		  if test -n "$i" ; then
+		    libname=`eval "\\$ECHO \"$libname_spec\""`
+		    deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		    set dummy $deplib_matches; shift
+		    deplib_match=$1
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		      newdeplibs="$newdeplibs $i"
+		    else
+		      droppeddeps=yes
+		      $ECHO
+		      $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		      $ECHO "*** I have the capability to make that library automatically link in when"
+		      $ECHO "*** you link to this library.  But I can only do this if you have a"
+		      $ECHO "*** shared version of the library, which you do not appear to have"
+		      $ECHO "*** because a test_compile did reveal that the linker did not use this one"
+		      $ECHO "*** as a dynamic dependency that programs can get resolved with at runtime."
+		    fi
+		  fi
+		else
+		  droppeddeps=yes
+		  $ECHO
+		  $ECHO "*** Warning!  Library $i is needed by this library but I was not able to"
+		  $ECHO "*** make it link in!  You will probably need to install it or some"
+		  $ECHO "*** library that it depends on before this library will be fully"
+		  $ECHO "*** functional.  Installing it before continuing would be even better."
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  fi
+	  ;;
+	file_magic*)
+	  set dummy $deplibs_check_method; shift
+	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		      # Follow soft links.
+		      if ls -lLd "$potent_lib" 2>/dev/null |
+			 $GREP " -> " >/dev/null; then
+			continue
+		      fi
+		      # The statement above tries to avoid entering an
+		      # endless loop below, in case of cyclic links.
+		      # We might still enter an endless loop, since a link
+		      # loop can be closed while we follow links,
+		      # but so what?
+		      potlib="$potent_lib"
+		      while test -h "$potlib" 2>/dev/null; do
+			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			case $potliblink in
+			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
+			*) potlib=`$ECHO "X$potlib" | $Xsed -e 's,[^/]*$,,'`"$potliblink";;
+			esac
+		      done
+		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null |
+			 $SED -e 10q |
+			 $EGREP "$file_magic_regex" > /dev/null; then
+			newdeplibs="$newdeplibs $a_deplib"
+			a_deplib=""
+			break 2
+		      fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for file magic test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a file magic. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	match_pattern*)
+	  set dummy $deplibs_check_method; shift
+	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    if eval "\$ECHO \"X$potent_lib\"" 2>/dev/null | $Xsed -e 10q | \
+		       $EGREP "$match_pattern_regex" > /dev/null; then
+		      newdeplibs="$newdeplibs $a_deplib"
+		      a_deplib=""
+		      break 2
+		    fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	none | unknown | *)
+	  newdeplibs=""
+	  tmp_deplibs=`$ECHO "X $deplibs" | $Xsed \
+	      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`
+	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    for i in $predeps $postdeps ; do
+	      # can't use Xsed below, because $i might contain '/'
+	      tmp_deplibs=`$ECHO "X $tmp_deplibs" | $Xsed -e "s,$i,,"`
+	    done
+	  fi
+	  if $ECHO "X $tmp_deplibs" | $Xsed -e 's/[	 ]//g' |
+	     $GREP . >/dev/null; then
+	    $ECHO
+	    if test "X$deplibs_check_method" = "Xnone"; then
+	      $ECHO "*** Warning: inter-library dependencies are not supported in this platform."
+	    else
+	      $ECHO "*** Warning: inter-library dependencies are not known to be supported."
+	    fi
+	    $ECHO "*** All declared inter-library dependencies are being dropped."
+	    droppeddeps=yes
+	  fi
+	  ;;
+	esac
+	versuffix=$versuffix_save
+	major=$major_save
+	release=$release_save
+	libname=$libname_save
+	name=$name_save
+
+	case $host in
+	*-*-rhapsody* | *-*-darwin1.[012])
+	  # On Rhapsody replace the C library with the System framework
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	  ;;
+	esac
+
+	if test "$droppeddeps" = yes; then
+	  if test "$module" = yes; then
+	    $ECHO
+	    $ECHO "*** Warning: libtool could not satisfy all declared inter-library"
+	    $ECHO "*** dependencies of module $libname.  Therefore, libtool will create"
+	    $ECHO "*** a static module, that should work as long as the dlopening"
+	    $ECHO "*** application is linked with the -dlopen flag."
+	    if test -z "$global_symbol_pipe"; then
+	      $ECHO
+	      $ECHO "*** However, this would only work if libtool was able to extract symbol"
+	      $ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      $ECHO "*** not find such a program.  So, this module is probably useless."
+	      $ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	    fi
+	    if test "$build_old_libs" = no; then
+	      oldlibs="$output_objdir/$libname.$libext"
+	      build_libtool_libs=module
+	      build_old_libs=yes
+	    else
+	      build_libtool_libs=no
+	    fi
+	  else
+	    $ECHO "*** The inter-library dependencies that have been dropped here will be"
+	    $ECHO "*** automatically added whenever a program is linked with this library"
+	    $ECHO "*** or is declared to -dlopen it."
+
+	    if test "$allow_undefined" = no; then
+	      $ECHO
+	      $ECHO "*** Since this library must not contain undefined symbols,"
+	      $ECHO "*** because either the platform does not support them or"
+	      $ECHO "*** it was explicitly requested with -no-undefined,"
+	      $ECHO "*** libtool will only create a static version of it."
+	      if test "$build_old_libs" = no; then
+		oldlibs="$output_objdir/$libname.$libext"
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  fi
+	fi
+	# Done checking deplibs!
+	deplibs=$newdeplibs
+      fi
+      # Time to change all our "foo.ltframework" stuff back to "-framework foo"
+      case $host in
+	*-*-darwin*)
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  new_inherited_linker_flags=`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  deplibs=`$ECHO "X $deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  ;;
+      esac
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      deplibs="$new_libs"
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+
+      # Test again, we may have decided not to build it any more
+      if test "$build_libtool_libs" = yes; then
+	if test "$hardcode_into_libs" = yes; then
+	  # Hardcode the library paths
+	  hardcode_libdirs=
+	  dep_rpath=
+	  rpath="$finalize_rpath"
+	  test "$mode" != relink && rpath="$compile_rpath$rpath"
+	  for libdir in $rpath; do
+	    if test -n "$hardcode_libdir_flag_spec"; then
+	      if test -n "$hardcode_libdir_separator"; then
+		if test -z "$hardcode_libdirs"; then
+		  hardcode_libdirs="$libdir"
+		else
+		  # Just accumulate the unique libdirs.
+		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+		  *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		    ;;
+		  *)
+		    hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		    ;;
+		  esac
+		fi
+	      else
+		eval flag=\"$hardcode_libdir_flag_spec\"
+		dep_rpath="$dep_rpath $flag"
+	      fi
+	    elif test -n "$runpath_var"; then
+	      case "$perm_rpath " in
+	      *" $libdir "*) ;;
+	      *) perm_rpath="$perm_rpath $libdir" ;;
+	      esac
+	    fi
+	  done
+	  # Substitute the hardcoded libdirs into the rpath.
+	  if test -n "$hardcode_libdir_separator" &&
+	     test -n "$hardcode_libdirs"; then
+	    libdir="$hardcode_libdirs"
+	    if test -n "$hardcode_libdir_flag_spec_ld"; then
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec_ld\"
+	    else
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec\"
+	    fi
+	  fi
+	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
+	    # We should set the runpath_var.
+	    rpath=
+	    for dir in $perm_rpath; do
+	      rpath="$rpath$dir:"
+	    done
+	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
+	  fi
+	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
+	fi
+
+	shlibpath="$finalize_shlibpath"
+	test "$mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	if test -n "$shlibpath"; then
+	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
+	fi
+
+	# Get the real and link names of the library.
+	eval shared_ext=\"$shrext_cmds\"
+	eval library_names=\"$library_names_spec\"
+	set dummy $library_names
+	shift
+	realname="$1"
+	shift
+
+	if test -n "$soname_spec"; then
+	  eval soname=\"$soname_spec\"
+	else
+	  soname="$realname"
+	fi
+	if test -z "$dlname"; then
+	  dlname=$soname
+	fi
+
+	lib="$output_objdir/$realname"
+	linknames=
+	for link
+	do
+	  linknames="$linknames $link"
+	done
+
+	# Use standard objects if they are pic
+	test -z "$pic_flag" && libobjs=`$ECHO "X$libobjs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	test "X$libobjs" = "X " && libobjs=
+
+	delfiles=
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
+	  export_symbols="$output_objdir/$libname.uexp"
+	  delfiles="$delfiles $export_symbols"
+	fi
+
+	orig_export_symbols=
+	case $host_os in
+	cygwin* | mingw* | cegcc*)
+	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
+	    # exporting using user supplied symfile
+	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
+	      # and it's NOT already a .def file. Must figure out
+	      # which of the given symbols are data symbols and tag
+	      # them as such. So, trigger use of export_symbols_cmds.
+	      # export_symbols gets reassigned inside the "prepare
+	      # the list of exported symbols" if statement, so the
+	      # include_expsyms logic still works.
+	      orig_export_symbols="$export_symbols"
+	      export_symbols=
+	      always_export_symbols=yes
+	    fi
+	  fi
+	  ;;
+	esac
+
+	# Prepare the list of exported symbols
+	if test -z "$export_symbols"; then
+	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
+	    func_verbose "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $opt_dry_run || $RM $export_symbols
+	    cmds=$export_symbols_cmds
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $cmds; do
+	      IFS="$save_ifs"
+	      eval cmd=\"$cmd\"
+	      func_len " $cmd"
+	      len=$func_len_result
+	      if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+		func_show_eval "$cmd" 'exit $?'
+		skipped_export=false
+	      else
+		# The command line is too long to execute in one step.
+		func_verbose "using reloadable object file for export list..."
+		skipped_export=:
+		# Break out early, otherwise skipped_export may be
+		# set to false by a later but shorter cmd.
+		break
+	      fi
+	    done
+	    IFS="$save_ifs"
+	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+	fi
+
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  tmp_export_symbols="$export_symbols"
+	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	  $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	fi
+
+	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
+	  # The given exports_symbols file has to be filtered, so filter it.
+	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	  # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	  # 's' commands which not all seds can handle. GNU sed should be fine
+	  # though. Also, the filter scales superlinearly with the number of
+	  # global variables. join(1) would be nice here, but unfortunately
+	  # isn't a blessed tool.
+	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	  delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	  export_symbols=$output_objdir/$libname.def
+	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	fi
+
+	tmp_deplibs=
+	for test_deplib in $deplibs; do
+	  case " $convenience " in
+	  *" $test_deplib "*) ;;
+	  *)
+	    tmp_deplibs="$tmp_deplibs $test_deplib"
+	    ;;
+	  esac
+	done
+	deplibs="$tmp_deplibs"
+
+	if test -n "$convenience"; then
+	  if test -n "$whole_archive_flag_spec" &&
+	    test "$compiler_needs_object" = yes &&
+	    test -z "$libobjs"; then
+	    # extract the archives, so we have objects to list.
+	    # TODO: could optimize this to just extract one archive.
+	    whole_archive_flag_spec=
+	  fi
+	  if test -n "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  else
+	    gentop="$output_objdir/${outputname}x"
+	    generated="$generated $gentop"
+
+	    func_extract_archives $gentop $convenience
+	    libobjs="$libobjs $func_extract_archives_result"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	fi
+
+	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	  eval flag=\"$thread_safe_flag_spec\"
+	  linker_flags="$linker_flags $flag"
+	fi
+
+	# Make a backup of the uninstalled library when relinking
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
+	fi
+
+	# Do each of the archive commands.
+	if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	    eval test_cmds=\"$module_expsym_cmds\"
+	    cmds=$module_expsym_cmds
+	  else
+	    eval test_cmds=\"$module_cmds\"
+	    cmds=$module_cmds
+	  fi
+	else
+	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	    eval test_cmds=\"$archive_expsym_cmds\"
+	    cmds=$archive_expsym_cmds
+	  else
+	    eval test_cmds=\"$archive_cmds\"
+	    cmds=$archive_cmds
+	  fi
+	fi
+
+	if test "X$skipped_export" != "X:" &&
+	   func_len " $test_cmds" &&
+	   len=$func_len_result &&
+	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  :
+	else
+	  # The command line is too long to link in one step, link piecewise
+	  # or, if using GNU ld and skipped_export is not :, use a linker
+	  # script.
+
+	  # Save the value of $output and $libobjs because we want to
+	  # use them later.  If we have whole_archive_flag_spec, we
+	  # want to use save_libobjs as it was before
+	  # whole_archive_flag_spec was expanded, because we can't
+	  # assume the linker understands whole_archive_flag_spec.
+	  # This may have to be revisited, in case too many
+	  # convenience libraries get linked in and end up exceeding
+	  # the spec.
+	  if test -z "$convenience" || test -z "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	  fi
+	  save_output=$output
+	  output_la=`$ECHO "X$output" | $Xsed -e "$basename"`
+
+	  # Clear the reloadable object creation command queue and
+	  # initialize k to one.
+	  test_cmds=
+	  concat_cmds=
+	  objlist=
+	  last_robj=
+	  k=1
+
+	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
+	    output=${output_objdir}/${output_la}.lnkscript
+	    func_verbose "creating GNU ld script: $output"
+	    $ECHO 'INPUT (' > $output
+	    for obj in $save_libobjs
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    $ECHO ')' >> $output
+	    delfiles="$delfiles $output"
+	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
+	    output=${output_objdir}/${output_la}.lnk
+	    func_verbose "creating linker input file list: $output"
+	    : > $output
+	    set x $save_libobjs
+	    shift
+	    firstobj=
+	    if test "$compiler_needs_object" = yes; then
+	      firstobj="$1 "
+	      shift
+	    fi
+	    for obj
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    delfiles="$delfiles $output"
+	    output=$firstobj\"$file_list_spec$output\"
+	  else
+	    if test -n "$save_libobjs"; then
+	      func_verbose "creating reloadable object files..."
+	      output=$output_objdir/$output_la-${k}.$objext
+	      eval test_cmds=\"$reload_cmds\"
+	      func_len " $test_cmds"
+	      len0=$func_len_result
+	      len=$len0
+
+	      # Loop over the list of objects to be linked.
+	      for obj in $save_libobjs
+	      do
+		func_len " $obj"
+		func_arith $len + $func_len_result
+		len=$func_arith_result
+		if test "X$objlist" = X ||
+		   test "$len" -lt "$max_cmd_len"; then
+		  func_append objlist " $obj"
+		else
+		  # The command $test_cmds is almost too long, add a
+		  # command to the queue.
+		  if test "$k" -eq 1 ; then
+		    # The first file doesn't have a previous command to add.
+		    eval concat_cmds=\"$reload_cmds $objlist $last_robj\"
+		  else
+		    # All subsequent reloadable object files will link in
+		    # the last one created.
+		    eval concat_cmds=\"\$concat_cmds~$reload_cmds $objlist $last_robj~\$RM $last_robj\"
+		  fi
+		  last_robj=$output_objdir/$output_la-${k}.$objext
+		  func_arith $k + 1
+		  k=$func_arith_result
+		  output=$output_objdir/$output_la-${k}.$objext
+		  objlist=$obj
+		  func_len " $last_robj"
+		  func_arith $len0 + $func_len_result
+		  len=$func_arith_result
+		fi
+	      done
+	      # Handle the remaining objects by creating one last
+	      # reloadable object file.  All subsequent reloadable object
+	      # files will link in the last one created.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$reload_cmds $objlist $last_robj\"
+	      if test -n "$last_robj"; then
+	        eval concat_cmds=\"\${concat_cmds}~\$RM $last_robj\"
+	      fi
+	      delfiles="$delfiles $output"
+
+	    else
+	      output=
+	    fi
+
+	    if ${skipped_export-false}; then
+	      func_verbose "generating symbol list for \`$libname.la'"
+	      export_symbols="$output_objdir/$libname.exp"
+	      $opt_dry_run || $RM $export_symbols
+	      libobjs=$output
+	      # Append the command to create the export file.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
+	      if test -n "$last_robj"; then
+		eval concat_cmds=\"\$concat_cmds~\$RM $last_robj\"
+	      fi
+	    fi
+
+	    test -n "$save_libobjs" &&
+	      func_verbose "creating a temporary reloadable object file: $output"
+
+	    # Loop through the commands generated above and execute them.
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $concat_cmds; do
+	      IFS="$save_ifs"
+	      $opt_silent || {
+		  func_quote_for_expand "$cmd"
+		  eval "func_echo $func_quote_for_expand_result"
+	      }
+	      $opt_dry_run || eval "$cmd" || {
+		lt_exit=$?
+
+		# Restore the uninstalled library and exit
+		if test "$mode" = relink; then
+		  ( cd "$output_objdir" && \
+		    $RM "${realname}T" && \
+		    $MV "${realname}U" "$realname" )
+		fi
+
+		exit $lt_exit
+	      }
+	    done
+	    IFS="$save_ifs"
+
+	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+
+          if ${skipped_export-false}; then
+	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	      tmp_export_symbols="$export_symbols"
+	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	      $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	    fi
+
+	    if test -n "$orig_export_symbols"; then
+	      # The given exports_symbols file has to be filtered, so filter it.
+	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	      # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	      # 's' commands which not all seds can handle. GNU sed should be fine
+	      # though. Also, the filter scales superlinearly with the number of
+	      # global variables. join(1) would be nice here, but unfortunately
+	      # isn't a blessed tool.
+	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	      delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	      export_symbols=$output_objdir/$libname.def
+	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	    fi
+	  fi
+
+	  libobjs=$output
+	  # Restore the value of output.
+	  output=$save_output
+
+	  if test -n "$convenience" && test -n "$whole_archive_flag_spec"; then
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	  # Expand the library linking commands again to reset the
+	  # value of $libobjs for piecewise linking.
+
+	  # Do each of the archive commands.
+	  if test "$module" = yes && test -n "$module_cmds" ; then
+	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	      cmds=$module_expsym_cmds
+	    else
+	      cmds=$module_cmds
+	    fi
+	  else
+	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	      cmds=$archive_expsym_cmds
+	    else
+	      cmds=$archive_cmds
+	    fi
+	  fi
+	fi
+
+	if test -n "$delfiles"; then
+	  # Append the command to remove temporary files to $cmds.
+	  eval cmds=\"\$cmds~\$RM $delfiles\"
+	fi
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  libobjs="$libobjs $func_extract_archives_result"
+	  test "X$libobjs" = "X " && libobjs=
+	fi
+
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $opt_silent || {
+	    func_quote_for_expand "$cmd"
+	    eval "func_echo $func_quote_for_expand_result"
+	  }
+	  $opt_dry_run || eval "$cmd" || {
+	    lt_exit=$?
+
+	    # Restore the uninstalled library and exit
+	    if test "$mode" = relink; then
+	      ( cd "$output_objdir" && \
+	        $RM "${realname}T" && \
+		$MV "${realname}U" "$realname" )
+	    fi
+
+	    exit $lt_exit
+	  }
+	done
+	IFS="$save_ifs"
+
+	# Restore the uninstalled library and exit
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
+
+	  if test -n "$convenience"; then
+	    if test -z "$whole_archive_flag_spec"; then
+	      func_show_eval '${RM}r "$gentop"'
+	    fi
+	  fi
+
+	  exit $EXIT_SUCCESS
+	fi
+
+	# Create links to the real library.
+	for linkname in $linknames; do
+	  if test "$realname" != "$linkname"; then
+	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
+	  fi
+	done
+
+	# If -module or -export-dynamic was specified, set the dlname.
+	if test "$module" = yes || test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    obj)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for objects"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for objects" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for objects"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for objects"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for objects"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for objects"
+
+      case $output in
+      *.lo)
+	test -n "$objs$old_deplibs" && \
+	  func_fatal_error "cannot build library object \`$output' from non-libtool objects"
+
+	libobj=$output
+	func_lo2o "$libobj"
+	obj=$func_lo2o_result
+	;;
+      *)
+	libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $opt_dry_run || $RM $obj $libobj
+
+      # Objects from convenience libraries.  This assumes
+      # single-version convenience libraries.  Whenever we create
+      # different ones for PIC/non-PIC, this we'll have to duplicate
+      # the extraction.
+      reload_conv_objs=
+      gentop=
+      # reload_cmds runs $LD directly, so let us get rid of
+      # -Wl from whole_archive_flag_spec and hope we can get by with
+      # turning comma into space..
+      wl=
+
+      if test -n "$convenience"; then
+	if test -n "$whole_archive_flag_spec"; then
+	  eval tmp_whole_archive_flags=\"$whole_archive_flag_spec\"
+	  reload_conv_objs=$reload_objs\ `$ECHO "X$tmp_whole_archive_flags" | $Xsed -e 's|,| |g'`
+	else
+	  gentop="$output_objdir/${obj}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $convenience
+	  reload_conv_objs="$reload_objs $func_extract_archives_result"
+	fi
+      fi
+
+      # Create the old-style object.
+      reload_objs="$objs$old_deplibs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}$'/d' -e '/\.lib$/d' -e "$lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+
+      output="$obj"
+      func_execute_cmds "$reload_cmds" 'exit $?'
+
+      # Exit if we aren't doing a library object file.
+      if test -z "$libobj"; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$build_libtool_libs" != yes; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	# Create an invalid libtool object if no PIC, so that we don't
+	# accidentally link it into a program.
+	# $show "echo timestamp > $libobj"
+	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test -n "$pic_flag" || test "$pic_mode" != default; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs $reload_conv_objs"
+	output="$libobj"
+	func_execute_cmds "$reload_cmds" 'exit $?'
+      fi
+
+      if test -n "$gentop"; then
+	func_show_eval '${RM}r "$gentop"'
+      fi
+
+      exit $EXIT_SUCCESS
+      ;;
+
+    prog)
+      case $host in
+	*cygwin*) func_stripname '' '.exe' "$output"
+	          output=$func_stripname_result.exe;;
+      esac
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for programs"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for programs"
+
+      test "$preload" = yes \
+        && test "$dlopen_support" = unknown \
+	&& test "$dlopen_self" = unknown \
+	&& test "$dlopen_self_static" = unknown && \
+	  func_warning "\`LT_INIT([dlopen])' not used. Assuming no dlopen support."
+
+      case $host in
+      *-*-rhapsody* | *-*-darwin1.[012])
+	# On Rhapsody replace the C library is the System framework
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	;;
+      esac
+
+      case $host in
+      *-*-darwin*)
+	# Don't allow lazy linking, it breaks C++ global constructors
+	# But is supposedly fixed on 10.4 or later (yay!).
+	if test "$tagname" = CXX ; then
+	  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in
+	    10.[0123])
+	      compile_command="$compile_command ${wl}-bind_at_load"
+	      finalize_command="$finalize_command ${wl}-bind_at_load"
+	    ;;
+	  esac
+	fi
+	# Time to change all our "foo.ltframework" stuff back to "-framework foo"
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	;;
+      esac
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $compile_deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $compile_deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      compile_deplibs="$new_libs"
+
+
+      compile_command="$compile_command $compile_deplibs"
+      finalize_command="$finalize_command $finalize_deplibs"
+
+      if test -n "$rpath$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	for libdir in $rpath $xrpath; do
+	  # This is the magic to use -rpath.
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+      fi
+
+      # Now hardcode the library paths
+      rpath=
+      hardcode_libdirs=
+      for libdir in $compile_rpath $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) perm_rpath="$perm_rpath $libdir" ;;
+	  esac
+	fi
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`${ECHO} "$libdir" | ${SED} -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$libdir:"*) ;;
+	  ::) dllsearchpath=$libdir;;
+	  *) dllsearchpath="$dllsearchpath:$libdir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      compile_rpath="$rpath"
+
+      rpath=
+      hardcode_libdirs=
+      for libdir in $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$finalize_perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_perm_rpath="$finalize_perm_rpath $libdir" ;;
+	  esac
+	fi
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      finalize_rpath="$rpath"
+
+      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+	# Transform all the library objects into standard objects.
+	compile_command=`$ECHO "X$compile_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	finalize_command=`$ECHO "X$finalize_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+      fi
+
+      func_generate_dlsyms "$outputname" "@PROGRAM@" "no"
+
+      # template prelinking step
+      if test -n "$prelink_cmds"; then
+	func_execute_cmds "$prelink_cmds" 'exit $?'
+      fi
+
+      wrappers_required=yes
+      case $host in
+      *cygwin* | *mingw* )
+        if test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      *cegcc)
+        # Disable wrappers for cegcc, we are cross compiling anyway.
+        wrappers_required=no
+        ;;
+      *)
+        if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      esac
+      if test "$wrappers_required" = no; then
+	# Replace the output file specification.
+	compile_command=`$ECHO "X$compile_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	link_command="$compile_command$compile_rpath"
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	exit_status=0
+	func_show_eval "$link_command" 'exit_status=$?'
+
+	# Delete the generated files.
+	if test -f "$output_objdir/${outputname}S.${objext}"; then
+	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
+	fi
+
+	exit $exit_status
+      fi
+
+      if test -n "$compile_shlibpath$finalize_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      compile_var=
+      finalize_var=
+      if test -n "$runpath_var"; then
+	if test -n "$perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  compile_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+	if test -n "$finalize_perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $finalize_perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  finalize_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+      fi
+
+      if test "$no_install" = yes; then
+	# We don't need to create a wrapper script.
+	link_command="$compile_var$compile_command$compile_rpath"
+	# Replace the output file specification.
+	link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	# Delete the old output file.
+	$opt_dry_run || $RM $output
+	# Link the executable and exit
+	func_show_eval "$link_command" 'exit $?'
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$hardcode_action" = relink; then
+	# Fast installation is not supported
+	link_command="$compile_var$compile_command$compile_rpath"
+	relink_command="$finalize_var$finalize_command$finalize_rpath"
+
+	func_warning "this platform does not like uninstalled shared libraries"
+	func_warning "\`$output' will be relinked during installation"
+      else
+	if test "$fast_install" != no; then
+	  link_command="$finalize_var$compile_command$finalize_rpath"
+	  if test "$fast_install" = yes; then
+	    relink_command=`$ECHO "X$compile_var$compile_command$compile_rpath" | $Xsed -e 's%@OUTPUT@%\$progdir/\$file%g'`
+	  else
+	    # fast_install is set to needless
+	    relink_command=
+	  fi
+	else
+	  link_command="$compile_var$compile_command$compile_rpath"
+	  relink_command="$finalize_var$finalize_command$finalize_rpath"
+	fi
+      fi
+
+      # Replace the output file specification.
+      link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
+
+      # Delete the old output files.
+      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname
+
+      func_show_eval "$link_command" 'exit $?'
+
+      # Now create the wrapper script.
+      func_verbose "creating $output"
+
+      # Quote the relink command for shipping.
+      if test -n "$relink_command"; then
+	# Preserve any variables that may affect compiler behavior
+	for var in $variables_saved_for_relink; do
+	  if eval test -z \"\${$var+set}\"; then
+	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	  elif eval var_value=\$$var; test -z "$var_value"; then
+	    relink_command="$var=; export $var; $relink_command"
+	  else
+	    func_quote_for_eval "$var_value"
+	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	  fi
+	done
+	relink_command="(cd `pwd`; $relink_command)"
+	relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Quote $ECHO for shipping.
+      if test "X$ECHO" = "X$SHELL $progpath --fallback-echo"; then
+	case $progpath in
+	[\\/]* | [A-Za-z]:[\\/]*) qecho="$SHELL $progpath --fallback-echo";;
+	*) qecho="$SHELL `pwd`/$progpath --fallback-echo";;
+	esac
+	qecho=`$ECHO "X$qecho" | $Xsed -e "$sed_quote_subst"`
+      else
+	qecho=`$ECHO "X$ECHO" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Only actually do things if not in dry run mode.
+      $opt_dry_run || {
+	# win32 will think the script is a binary if it has
+	# a .exe suffix, so we strip it off here.
+	case $output in
+	  *.exe) func_stripname '' '.exe' "$output"
+	         output=$func_stripname_result ;;
+	esac
+	# test for cygwin because mv fails w/o .exe extensions
+	case $host in
+	  *cygwin*)
+	    exeext=.exe
+	    func_stripname '' '.exe' "$outputname"
+	    outputname=$func_stripname_result ;;
+	  *) exeext= ;;
+	esac
+	case $host in
+	  *cygwin* | *mingw* )
+	    func_dirname_and_basename "$output" "" "."
+	    output_name=$func_basename_result
+	    output_path=$func_dirname_result
+	    cwrappersource="$output_path/$objdir/lt-$output_name.c"
+	    cwrapper="$output_path/$output_name.exe"
+	    $RM $cwrappersource $cwrapper
+	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_cwrapperexe_src > $cwrappersource
+
+	    # The wrapper executable is built using the $host compiler,
+	    # because it contains $host paths and files. If cross-
+	    # compiling, it, like the target executable, must be
+	    # executed on the $host or under an emulation environment.
+	    $opt_dry_run || {
+	      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource
+	      $STRIP $cwrapper
+	    }
+
+	    # Now, create the wrapper script for func_source use:
+	    func_ltwrapper_scriptname $cwrapper
+	    $RM $func_ltwrapper_scriptname_result
+	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
+	    $opt_dry_run || {
+	      # note: this script will not be executed, so do not chmod.
+	      if test "x$build" = "x$host" ; then
+		$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result
+	      else
+		func_emit_wrapper no > $func_ltwrapper_scriptname_result
+	      fi
+	    }
+	  ;;
+	  * )
+	    $RM $output
+	    trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_wrapper no > $output
+	    chmod +x $output
+	  ;;
+	esac
+      }
+      exit $EXIT_SUCCESS
+      ;;
+    esac
+
+    # See if we need to build an old-fashioned archive.
+    for oldlib in $oldlibs; do
+
+      if test "$build_libtool_libs" = convenience; then
+	oldobjs="$libobjs_save $symfileobj"
+	addlibs="$convenience"
+	build_libtool_libs=no
+      else
+	if test "$build_libtool_libs" = module; then
+	  oldobjs="$libobjs_save"
+	  build_libtool_libs=no
+	else
+	  oldobjs="$old_deplibs $non_pic_objects"
+	  if test "$preload" = yes && test -f "$symfileobj"; then
+	    oldobjs="$oldobjs $symfileobj"
+	  fi
+	fi
+	addlibs="$old_convenience"
+      fi
+
+      if test -n "$addlibs"; then
+	gentop="$output_objdir/${outputname}x"
+	generated="$generated $gentop"
+
+	func_extract_archives $gentop $addlibs
+	oldobjs="$oldobjs $func_extract_archives_result"
+      fi
+
+      # Do each command in the archive commands.
+      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+	cmds=$old_archive_from_new_cmds
+      else
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  oldobjs="$oldobjs $func_extract_archives_result"
+	fi
+
+	# POSIX demands no paths to be encoded in archives.  We have
+	# to avoid creating archives with duplicate basenames if we
+	# might have to extract them afterwards, e.g., when creating a
+	# static archive out of a convenience library, or when linking
+	# the entirety of a libtool archive into another (currently
+	# not supported by libtool).
+	if (for obj in $oldobjs
+	    do
+	      func_basename "$obj"
+	      $ECHO "$func_basename_result"
+	    done | sort | sort -uc >/dev/null 2>&1); then
+	  :
+	else
+	  $ECHO "copying selected object files to avoid basename conflicts..."
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+	  func_mkdir_p "$gentop"
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  counter=1
+	  for obj in $save_oldobjs
+	  do
+	    func_basename "$obj"
+	    objbase="$func_basename_result"
+	    case " $oldobjs " in
+	    " ") oldobjs=$obj ;;
+	    *[\ /]"$objbase "*)
+	      while :; do
+		# Make sure we don't pick an alternate name that also
+		# overlaps.
+		newobj=lt$counter-$objbase
+		func_arith $counter + 1
+		counter=$func_arith_result
+		case " $oldobjs " in
+		*[\ /]"$newobj "*) ;;
+		*) if test ! -f "$gentop/$newobj"; then break; fi ;;
+		esac
+	      done
+	      func_show_eval "ln $obj $gentop/$newobj || cp $obj $gentop/$newobj"
+	      oldobjs="$oldobjs $gentop/$newobj"
+	      ;;
+	    *) oldobjs="$oldobjs $obj" ;;
+	    esac
+	  done
+	fi
+	eval cmds=\"$old_archive_cmds\"
+
+	func_len " $cmds"
+	len=$func_len_result
+	if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  cmds=$old_archive_cmds
+	else
+	  # the command line is too long to link in one step, link in parts
+	  func_verbose "using piecewise archive linking..."
+	  save_RANLIB=$RANLIB
+	  RANLIB=:
+	  objlist=
+	  concat_cmds=
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  # Is there a better way of finding the last object in the list?
+	  for obj in $save_oldobjs
+	  do
+	    last_oldobj=$obj
+	  done
+	  eval test_cmds=\"$old_archive_cmds\"
+	  func_len " $test_cmds"
+	  len0=$func_len_result
+	  len=$len0
+	  for obj in $save_oldobjs
+	  do
+	    func_len " $obj"
+	    func_arith $len + $func_len_result
+	    len=$func_arith_result
+	    func_append objlist " $obj"
+	    if test "$len" -lt "$max_cmd_len"; then
+	      :
+	    else
+	      # the above command should be used before it gets too long
+	      oldobjs=$objlist
+	      if test "$obj" = "$last_oldobj" ; then
+		RANLIB=$save_RANLIB
+	      fi
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      objlist=
+	      len=$len0
+	    fi
+	  done
+	  RANLIB=$save_RANLIB
+	  oldobjs=$objlist
+	  if test "X$oldobjs" = "X" ; then
+	    eval cmds=\"\$concat_cmds\"
+	  else
+	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
+	  fi
+	fi
+      fi
+      func_execute_cmds "$cmds" 'exit $?'
+    done
+
+    test -n "$generated" && \
+      func_show_eval "${RM}r$generated"
+
+    # Now create the libtool archive.
+    case $output in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      func_verbose "creating $output"
+
+      # Preserve any variables that may affect compiler behavior
+      for var in $variables_saved_for_relink; do
+	if eval test -z \"\${$var+set}\"; then
+	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	elif eval var_value=\$$var; test -z "$var_value"; then
+	  relink_command="$var=; export $var; $relink_command"
+	else
+	  func_quote_for_eval "$var_value"
+	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	fi
+      done
+      # Quote the link command for shipping.
+      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      if test "$hardcode_automatic" = yes ; then
+	relink_command=
+      fi
+
+      # Only create the output if not a dry run.
+      $opt_dry_run || {
+	for installed in no yes; do
+	  if test "$installed" = yes; then
+	    if test -z "$install_libdir"; then
+	      break
+	    fi
+	    output="$output_objdir/$outputname"i
+	    # Replace all uninstalled libtool libraries with the installed ones
+	    newdependency_libs=
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      *.la)
+		func_basename "$deplib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$deplib' is not a valid libtool archive"
+		newdependency_libs="$newdependency_libs $libdir/$name"
+		;;
+	      *) newdependency_libs="$newdependency_libs $deplib" ;;
+	      esac
+	    done
+	    dependency_libs="$newdependency_libs"
+	    newdlfiles=
+
+	    for lib in $dlfiles; do
+	      case $lib in
+	      *.la)
+	        func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlfiles="$newdlfiles $libdir/$name"
+		;;
+	      *) newdlfiles="$newdlfiles $lib" ;;
+	      esac
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+	      *.la)
+		# Only pass preopened files to the pseudo-archive (for
+		# eventual linking with the app. that links it) if we
+		# didn't already link the preopened objects directly into
+		# the library:
+		func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlprefiles="$newdlprefiles $libdir/$name"
+		;;
+	      esac
+	    done
+	    dlprefiles="$newdlprefiles"
+	  else
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlfiles="$newdlfiles $abs"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlprefiles="$newdlprefiles $abs"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  fi
+	  $RM $output
+	  # place dlname in correct position for cygwin
+	  tdlname=$dlname
+	  case $host,$output,$installed,$module,$dlname in
+	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;
+	  esac
+	  $ECHO > $output "\
+# $outputname - a libtool library file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='$tdlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Linker flags that can not go in dependency_libs.
+inherited_linker_flags='$new_inherited_linker_flags'
+
+# Libraries that this one depends upon.
+dependency_libs='$dependency_libs'
+
+# Names of additional weak libraries provided by this library
+weak_library_names='$weak_libs'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Is this an already installed library?
+installed=$installed
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=$module
+
+# Files to dlopen/dlpreopen
+dlopen='$dlfiles'
+dlpreopen='$dlprefiles'
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'"
+	  if test "$installed" = no && test "$need_relink" = yes; then
+	    $ECHO >> $output "\
+relink_command=\"$relink_command\""
+	  fi
+	done
+      }
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
+      ;;
+    esac
+    exit $EXIT_SUCCESS
+}
+
+{ test "$mode" = link || test "$mode" = relink; } &&
+    func_mode_link ${1+"$@"}
+
+
+# func_mode_uninstall arg...
+func_mode_uninstall ()
+{
+    $opt_debug
+    RM="$nonopt"
+    files=
+    rmforce=
+    exit_status=0
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    for arg
+    do
+      case $arg in
+      -f) RM="$RM $arg"; rmforce=yes ;;
+      -*) RM="$RM $arg" ;;
+      *) files="$files $arg" ;;
+      esac
+    done
+
+    test -z "$RM" && \
+      func_fatal_help "you must specify an RM program"
+
+    rmdirs=
+
+    origobjdir="$objdir"
+    for file in $files; do
+      func_dirname "$file" "" "."
+      dir="$func_dirname_result"
+      if test "X$dir" = X.; then
+	objdir="$origobjdir"
+      else
+	objdir="$dir/$origobjdir"
+      fi
+      func_basename "$file"
+      name="$func_basename_result"
+      test "$mode" = uninstall && objdir="$dir"
+
+      # Remember objdir for removal later, being careful to avoid duplicates
+      if test "$mode" = clean; then
+	case " $rmdirs " in
+	  *" $objdir "*) ;;
+	  *) rmdirs="$rmdirs $objdir" ;;
+	esac
+      fi
+
+      # Don't error if the file doesn't exist and rm -f was used.
+      if { test -L "$file"; } >/dev/null 2>&1 ||
+	 { test -h "$file"; } >/dev/null 2>&1 ||
+	 test -f "$file"; then
+	:
+      elif test -d "$file"; then
+	exit_status=1
+	continue
+      elif test "$rmforce" = yes; then
+	continue
+      fi
+
+      rmfiles="$file"
+
+      case $name in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if func_lalib_p "$file"; then
+	  func_source $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    rmfiles="$rmfiles $objdir/$n"
+	  done
+	  test -n "$old_library" && rmfiles="$rmfiles $objdir/$old_library"
+
+	  case "$mode" in
+	  clean)
+	    case "  $library_names " in
+	    # "  " in the beginning catches empty $dlname
+	    *" $dlname "*) ;;
+	    *) rmfiles="$rmfiles $objdir/$dlname" ;;
+	    esac
+	    test -n "$libdir" && rmfiles="$rmfiles $objdir/$name $objdir/${name}i"
+	    ;;
+	  uninstall)
+	    if test -n "$library_names"; then
+	      # Do each command in the postuninstall commands.
+	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+
+	    if test -n "$old_library"; then
+	      # Do each command in the old_postuninstall commands.
+	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+	    # FIXME: should reinstall the best remaining shared library.
+	    ;;
+	  esac
+	fi
+	;;
+
+      *.lo)
+	# Possibly a libtool object, so verify it.
+	if func_lalib_p "$file"; then
+
+	  # Read the .lo file
+	  func_source $dir/$name
+
+	  # Add PIC object to the list of files to remove.
+	  if test -n "$pic_object" &&
+	     test "$pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$pic_object"
+	  fi
+
+	  # Add non-PIC object to the list of files to remove.
+	  if test -n "$non_pic_object" &&
+	     test "$non_pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$non_pic_object"
+	  fi
+	fi
+	;;
+
+      *)
+	if test "$mode" = clean ; then
+	  noexename=$name
+	  case $file in
+	  *.exe)
+	    func_stripname '' '.exe' "$file"
+	    file=$func_stripname_result
+	    func_stripname '' '.exe' "$name"
+	    noexename=$func_stripname_result
+	    # $file with .exe has already been added to rmfiles,
+	    # add $file without .exe
+	    rmfiles="$rmfiles $file"
+	    ;;
+	  esac
+	  # Do a test to see if this is a libtool program.
+	  if func_ltwrapper_p "$file"; then
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      relink_command=
+	      func_source $func_ltwrapper_scriptname_result
+	      rmfiles="$rmfiles $func_ltwrapper_scriptname_result"
+	    else
+	      relink_command=
+	      func_source $dir/$noexename
+	    fi
+
+	    # note $name still contains .exe if it was in $file originally
+	    # as does the version of $file that was added into $rmfiles
+	    rmfiles="$rmfiles $objdir/$name $objdir/${name}S.${objext}"
+	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	      rmfiles="$rmfiles $objdir/lt-$name"
+	    fi
+	    if test "X$noexename" != "X$name" ; then
+	      rmfiles="$rmfiles $objdir/lt-${noexename}.c"
+	    fi
+	  fi
+	fi
+	;;
+      esac
+      func_show_eval "$RM $rmfiles" 'exit_status=1'
+    done
+    objdir="$origobjdir"
+
+    # Try to remove the ${objdir}s in the directories where we deleted files
+    for dir in $rmdirs; do
+      if test -d "$dir"; then
+	func_show_eval "rmdir $dir >/dev/null 2>&1"
+      fi
+    done
+
+    exit $exit_status
+}
+
+{ test "$mode" = uninstall || test "$mode" = clean; } &&
+    func_mode_uninstall ${1+"$@"}
+
+test -z "$mode" && {
+  help="$generic_help"
+  func_fatal_help "you must specify a MODE"
+}
+
+test -z "$exec_cmd" && \
+  func_fatal_help "invalid operation mode \`$mode'"
+
+if test -n "$exec_cmd"; then
+  eval exec "$exec_cmd"
+  exit $EXIT_FAILURE
+fi
+
+exit $exit_status
+
+
+# The TAGs below are defined such that we never get into a situation
+# in which we disable both kinds of libraries.  Given conflicting
+# choices, we go for a static library, that is the most portable,
+# since we can't tell whether shared libraries were disabled because
+# the user asked for that or because the platform doesn't support
+# them.  This is particularly important on AIX, because we don't
+# support having both static and shared libraries enabled at the same
+# time on that platform, so we default to a shared-only configuration.
+# If a disable-shared tag is given, we'll fallback to a static-only
+# configuration.  But we'll never go from static-only to shared-only.
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-shared
+build_libtool_libs=no
+build_old_libs=yes
+# ### END LIBTOOL TAG CONFIG: disable-shared
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-static
+build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
+# ### END LIBTOOL TAG CONFIG: disable-static
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
+# vi:sw=2
+
+
+# ### BEGIN LIBTOOL TAG CONFIG: CXX
+
+# The linker used to build libraries.
+LD="/usr/bin/ld -m elf_x86_64"
+
+# Commands used to build an old-style archive.
+old_archive_cmds="\$AR \$AR_FLAGS \$oldlib\$oldobjs~\$RANLIB \$oldlib"
+
+# A language specific compiler.
+CC="g++"
+
+# Is the compiler the GNU compiler?
+with_gcc=yes
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=" -fno-builtin"
+
+# How to pass a linker flag through the compiler.
+wl="-Wl,"
+
+# Additional compiler flags for building library objects.
+pic_flag=" -fPIC -DPIC"
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag="-static"
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o="yes"
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=no
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=no
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec="\${wl}--export-dynamic"
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec="\${wl}--whole-archive\$convenience \${wl}--no-whole-archive"
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object="no"
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=""
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=""
+
+# Commands used to build a shared archive.
+archive_cmds="\$CC -shared -nostdlib \$predep_objects \$libobjs \$deplibs \$postdep_objects \$compiler_flags \${wl}-soname \$wl\$soname -o \$lib"
+archive_expsym_cmds="\$CC -shared -nostdlib \$predep_objects \$libobjs \$deplibs \$postdep_objects \$compiler_flags \${wl}-soname \$wl\$soname \${wl}-retain-symbols-file \$wl\$export_symbols -o \$lib"
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=""
+module_expsym_cmds=""
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld="yes"
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=""
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=""
+
+# Flag to hardcode $libdir into a binary during linking.
+# This must work even if $libdir does not exist
+hardcode_libdir_flag_spec="\${wl}-rpath \${wl}\$libdir"
+
+# If ld is used when linking, flag to hardcode $libdir into a binary
+# during linking.  This must work even if $libdir does not exist.
+hardcode_libdir_flag_spec_ld=""
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=""
+
+# Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=no
+
+# Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting ${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=no
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=no
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=unsupported
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=no
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=no
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=no
+
+# Fix the shell variable $srcfile for the compiler.
+fix_srcfile_path=""
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=no
+
+# The commands to list exported symbols.
+export_symbols_cmds="\$NM \$libobjs \$convenience | \$global_symbol_pipe | \$SED 's/.* //' | sort | uniq > \$export_symbols"
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms="_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*"
+
+# Symbols that must always be exported.
+include_expsyms=""
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=""
+
+# Specify filename containing input files.
+file_list_spec=""
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=immediate
+
+# The directories searched by this compiler when creating a shared library.
+compiler_lib_search_dirs="/usr/lib/gcc/x86_64-linux-gnu/4.3.3 /usr/lib/gcc/x86_64-linux-gnu/4.3.3 /usr/lib/gcc/x86_64-linux-gnu/4.3.3/../../../../lib /lib/../lib /usr/lib/../lib /usr/lib/gcc/x86_64-linux-gnu/4.3.3/../../.."
+
+# Dependencies to place before and after the objects being linked to
+# create a shared library.
+predep_objects="/usr/lib/gcc/x86_64-linux-gnu/4.3.3/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.3.3/crtbeginS.o"
+postdep_objects="/usr/lib/gcc/x86_64-linux-gnu/4.3.3/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/4.3.3/../../../../lib/crtn.o"
+predeps=""
+postdeps="-lstdc++ -lm -lgcc_s -lc -lgcc_s"
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path="-L/usr/lib/gcc/x86_64-linux-gnu/4.3.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.3.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.3.3/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.3.3/../../.."
+
+# ### END LIBTOOL TAG CONFIG: CXX
diff --git a/ltmain.sh b/ltmain.sh
new file mode 100755
index 0000000..b612e9a
--- /dev/null
+++ b/ltmain.sh
@@ -0,0 +1,8412 @@
+# Generated from ltmain.m4sh.
+
+# ltmain.sh (GNU libtool) 2.2.6
+# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 2008 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# GNU Libtool is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html,
+# or obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+# Usage: $progname [OPTION]... [MODE-ARG]...
+#
+# Provide generalized library-building support services.
+#
+#     --config             show all configuration variables
+#     --debug              enable verbose shell tracing
+# -n, --dry-run            display commands without modifying any files
+#     --features           display basic configuration information and exit
+#     --mode=MODE          use operation mode MODE
+#     --preserve-dup-deps  don't remove duplicate dependency libraries
+#     --quiet, --silent    don't print informational messages
+#     --tag=TAG            use configuration variables from tag TAG
+# -v, --verbose            print informational messages (default)
+#     --version            print version information
+# -h, --help               print short or long help message
+#
+# MODE must be one of the following:
+#
+#       clean              remove files from the build directory
+#       compile            compile a source file into a libtool object
+#       execute            automatically set library path, then run a program
+#       finish             complete the installation of libtool libraries
+#       install            install libraries or executables
+#       link               create a library or an executable
+#       uninstall          remove libraries from an installed directory
+#
+# MODE-ARGS vary depending on the MODE.
+# Try `$progname --help --mode=MODE' for a more detailed description of MODE.
+#
+# When reporting a bug, please describe a test case to reproduce it and
+# include the following information:
+#
+#       host-triplet:	$host
+#       shell:		$SHELL
+#       compiler:		$LTCC
+#       compiler flags:		$LTCFLAGS
+#       linker:		$LD (gnu? $with_gnu_ld)
+#       $progname:		(GNU libtool) 2.2.6 Debian-2.2.6a-1ubuntu1
+#       automake:		$automake_version
+#       autoconf:		$autoconf_version
+#
+# Report bugs to <bug-libtool@gnu.org>.
+
+PROGRAM=ltmain.sh
+PACKAGE=libtool
+VERSION="2.2.6 Debian-2.2.6a-1ubuntu1"
+TIMESTAMP=""
+package_revision=1.3012
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# NLS nuisances: We save the old values to restore during execute mode.
+# Only set LANG and LC_ALL to C if already set.
+# These must not be set unconditionally because not all systems understand
+# e.g. LANG=C (notably SCO).
+lt_user_locale=
+lt_safe_locale=
+for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+do
+  eval "if test \"\${$lt_var+set}\" = set; then
+          save_$lt_var=\$$lt_var
+          $lt_var=C
+	  export $lt_var
+	  lt_user_locale=\"$lt_var=\\\$save_\$lt_var; \$lt_user_locale\"
+	  lt_safe_locale=\"$lt_var=C; \$lt_safe_locale\"
+	fi"
+done
+
+$lt_unset CDPATH
+
+
+
+
+
+: ${CP="cp -f"}
+: ${ECHO="echo"}
+: ${EGREP="/bin/grep -E"}
+: ${FGREP="/bin/grep -F"}
+: ${GREP="/bin/grep"}
+: ${LN_S="ln -s"}
+: ${MAKE="make"}
+: ${MKDIR="mkdir"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+: ${SED="/bin/sed"}
+: ${SHELL="${CONFIG_SHELL-/bin/sh}"}
+: ${Xsed="$SED -e 1s/^X//"}
+
+# Global variables:
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
+EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
+
+exit_status=$EXIT_SUCCESS
+
+# Make sure IFS has a sensible default
+lt_nl='
+'
+IFS=" 	$lt_nl"
+
+dirname="s,/[^/]*$,,"
+basename="s,^.*/,,"
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+# Generated shell functions inserted here.
+
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath="$0"
+
+# The name of this program:
+# In the unlikely event $progname began with a '-', it would play havoc with
+# func_echo (imagine progname=-n), so we prepend ./ in that case:
+func_dirname_and_basename "$progpath"
+progname=$func_basename_result
+case $progname in
+  -*) progname=./$progname ;;
+esac
+
+# Make sure we have an absolute path for reexecution:
+case $progpath in
+  [\\/]*|[A-Za-z]:\\*) ;;
+  *[\\/]*)
+     progdir=$func_dirname_result
+     progdir=`cd "$progdir" && pwd`
+     progpath="$progdir/$progname"
+     ;;
+  *)
+     save_IFS="$IFS"
+     IFS=:
+     for progdir in $PATH; do
+       IFS="$save_IFS"
+       test -x "$progdir/$progname" && break
+     done
+     IFS="$save_IFS"
+     test -n "$progdir" || progdir=`pwd`
+     progpath="$progdir/$progname"
+     ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed="${SED}"' -e 1s/^X//'
+sed_quote_subst='s/\([`"$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Re-`\' parameter expansions in output of double_quote_subst that were
+# `\'-ed in input to the same.  If an odd number of `\' preceded a '$'
+# in input to double_quote_subst, that '$' was protected from expansion.
+# Since each input `\' is now two `\'s, look for any number of runs of
+# four `\'s followed by two `\'s and then a '$'.  `\' that '$'.
+bs='\\'
+bs2='\\\\'
+bs4='\\\\\\\\'
+dollar='\$'
+sed_double_backslash="\
+  s/$bs4/&\\
+/g
+  s/^$bs2$dollar/$bs&/
+  s/\\([^$bs]\\)$bs2$dollar/\\1$bs2$bs$dollar/g
+  s/\n//g"
+
+# Standard options:
+opt_dry_run=false
+opt_help=false
+opt_quiet=false
+opt_verbose=false
+opt_warning=:
+
+# func_echo arg...
+# Echo program name prefixed message, along with the current mode
+# name if it has been set yet.
+func_echo ()
+{
+    $ECHO "$progname${mode+: }$mode: $*"
+}
+
+# func_verbose arg...
+# Echo program name prefixed message in verbose mode only.
+func_verbose ()
+{
+    $opt_verbose && func_echo ${1+"$@"}
+
+    # A bug in bash halts the script if the last line of a function
+    # fails when set -e is in force, so we need another command to
+    # work around that:
+    :
+}
+
+# func_error arg...
+# Echo program name prefixed message to standard error.
+func_error ()
+{
+    $ECHO "$progname${mode+: }$mode: "${1+"$@"} 1>&2
+}
+
+# func_warning arg...
+# Echo program name prefixed warning message to standard error.
+func_warning ()
+{
+    $opt_warning && $ECHO "$progname${mode+: }$mode: warning: "${1+"$@"} 1>&2
+
+    # bash bug again:
+    :
+}
+
+# func_fatal_error arg...
+# Echo program name prefixed message to standard error, and exit.
+func_fatal_error ()
+{
+    func_error ${1+"$@"}
+    exit $EXIT_FAILURE
+}
+
+# func_fatal_help arg...
+# Echo program name prefixed message to standard error, followed by
+# a help hint, and exit.
+func_fatal_help ()
+{
+    func_error ${1+"$@"}
+    func_fatal_error "$help"
+}
+help="Try \`$progname --help' for more information."  ## default
+
+
+# func_grep expression filename
+# Check whether EXPRESSION matches any line of FILENAME, without output.
+func_grep ()
+{
+    $GREP "$1" "$2" >/dev/null 2>&1
+}
+
+
+# func_mkdir_p directory-path
+# Make sure the entire path to DIRECTORY-PATH is available.
+func_mkdir_p ()
+{
+    my_directory_path="$1"
+    my_dir_list=
+
+    if test -n "$my_directory_path" && test "$opt_dry_run" != ":"; then
+
+      # Protect directory names starting with `-'
+      case $my_directory_path in
+        -*) my_directory_path="./$my_directory_path" ;;
+      esac
+
+      # While some portion of DIR does not yet exist...
+      while test ! -d "$my_directory_path"; do
+        # ...make a list in topmost first order.  Use a colon delimited
+	# list incase some portion of path contains whitespace.
+        my_dir_list="$my_directory_path:$my_dir_list"
+
+        # If the last portion added has no slash in it, the list is done
+        case $my_directory_path in */*) ;; *) break ;; esac
+
+        # ...otherwise throw away the child directory and loop
+        my_directory_path=`$ECHO "X$my_directory_path" | $Xsed -e "$dirname"`
+      done
+      my_dir_list=`$ECHO "X$my_dir_list" | $Xsed -e 's,:*$,,'`
+
+      save_mkdir_p_IFS="$IFS"; IFS=':'
+      for my_dir in $my_dir_list; do
+	IFS="$save_mkdir_p_IFS"
+        # mkdir can fail with a `File exist' error if two processes
+        # try to create one of the directories concurrently.  Don't
+        # stop in that case!
+        $MKDIR "$my_dir" 2>/dev/null || :
+      done
+      IFS="$save_mkdir_p_IFS"
+
+      # Bail out if we (or some other process) failed to create a directory.
+      test -d "$my_directory_path" || \
+        func_fatal_error "Failed to create \`$1'"
+    fi
+}
+
+
+# func_mktempdir [string]
+# Make a temporary directory that won't clash with other running
+# libtool processes, and avoids race conditions if possible.  If
+# given, STRING is the basename for that directory.
+func_mktempdir ()
+{
+    my_template="${TMPDIR-/tmp}/${1-$progname}"
+
+    if test "$opt_dry_run" = ":"; then
+      # Return a directory name, but don't create it in dry-run mode
+      my_tmpdir="${my_template}-$$"
+    else
+
+      # If mktemp works, use that first and foremost
+      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+
+      if test ! -d "$my_tmpdir"; then
+        # Failing that, at least try and use $RANDOM to avoid a race
+        my_tmpdir="${my_template}-${RANDOM-0}$$"
+
+        save_mktempdir_umask=`umask`
+        umask 0077
+        $MKDIR "$my_tmpdir"
+        umask $save_mktempdir_umask
+      fi
+
+      # If we're not in dry-run mode, bomb out on failure
+      test -d "$my_tmpdir" || \
+        func_fatal_error "cannot create temporary directory \`$my_tmpdir'"
+    fi
+
+    $ECHO "X$my_tmpdir" | $Xsed
+}
+
+
+# func_quote_for_eval arg
+# Aesthetically quote ARG to be evaled later.
+# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT
+# is double-quoted, suitable for a subsequent eval, whereas
+# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters
+# which are still active within double quotes backslashified.
+func_quote_for_eval ()
+{
+    case $1 in
+      *[\\\`\"\$]*)
+	func_quote_for_eval_unquoted_result=`$ECHO "X$1" | $Xsed -e "$sed_quote_subst"` ;;
+      *)
+        func_quote_for_eval_unquoted_result="$1" ;;
+    esac
+
+    case $func_quote_for_eval_unquoted_result in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting, command substitution and and variable
+      # expansion for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        func_quote_for_eval_result="\"$func_quote_for_eval_unquoted_result\""
+        ;;
+      *)
+        func_quote_for_eval_result="$func_quote_for_eval_unquoted_result"
+    esac
+}
+
+
+# func_quote_for_expand arg
+# Aesthetically quote ARG to be evaled later; same as above,
+# but do not quote variable references.
+func_quote_for_expand ()
+{
+    case $1 in
+      *[\\\`\"]*)
+	my_arg=`$ECHO "X$1" | $Xsed \
+	    -e "$double_quote_subst" -e "$sed_double_backslash"` ;;
+      *)
+        my_arg="$1" ;;
+    esac
+
+    case $my_arg in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting and command substitution for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        my_arg="\"$my_arg\""
+        ;;
+    esac
+
+    func_quote_for_expand_result="$my_arg"
+}
+
+
+# func_show_eval cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.
+func_show_eval ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$my_cmd"
+      my_status=$?
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+# func_show_eval_locale cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.  Use the saved locale for evaluation.
+func_show_eval_locale ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$lt_user_locale
+	    $my_cmd"
+      my_status=$?
+      eval "$lt_safe_locale"
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+
+
+
+# func_version
+# Echo version message to standard output and exit.
+func_version ()
+{
+    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {
+        s/^# //
+	s/^# *$//
+        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
+        p
+     }' < "$progpath"
+     exit $?
+}
+
+# func_usage
+# Echo short help message to standard output and exit.
+func_usage ()
+{
+    $SED -n '/^# Usage:/,/# -h/ {
+        s/^# //
+	s/^# *$//
+	s/\$progname/'$progname'/
+	p
+    }' < "$progpath"
+    $ECHO
+    $ECHO "run \`$progname --help | more' for full usage"
+    exit $?
+}
+
+# func_help
+# Echo long help message to standard output and exit.
+func_help ()
+{
+    $SED -n '/^# Usage:/,/# Report bugs to/ {
+        s/^# //
+	s/^# *$//
+	s*\$progname*'$progname'*
+	s*\$host*'"$host"'*
+	s*\$SHELL*'"$SHELL"'*
+	s*\$LTCC*'"$LTCC"'*
+	s*\$LTCFLAGS*'"$LTCFLAGS"'*
+	s*\$LD*'"$LD"'*
+	s/\$with_gnu_ld/'"$with_gnu_ld"'/
+	s/\$automake_version/'"`(automake --version) 2>/dev/null |$SED 1q`"'/
+	s/\$autoconf_version/'"`(autoconf --version) 2>/dev/null |$SED 1q`"'/
+	p
+     }' < "$progpath"
+    exit $?
+}
+
+# func_missing_arg argname
+# Echo program name prefixed message to standard error and set global
+# exit_cmd.
+func_missing_arg ()
+{
+    func_error "missing argument for $1"
+    exit_cmd=exit
+}
+
+exit_cmd=:
+
+
+
+
+
+# Check that we have a working $ECHO.
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t'; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell, and then maybe $ECHO will work.
+  exec $SHELL "$progpath" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+$*
+EOF
+  exit $EXIT_SUCCESS
+fi
+
+magic="%%%MAGIC variable%%%"
+magic_exe="%%%MAGIC EXE variable%%%"
+
+# Global variables.
+# $mode is unset
+nonopt=
+execute_dlfiles=
+preserve_args=
+lo2o="s/\\.lo\$/.${objext}/"
+o2lo="s/\\.${objext}\$/.lo/"
+extracted_archives=
+extracted_serial=0
+
+opt_dry_run=false
+opt_duplicate_deps=false
+opt_silent=false
+opt_debug=:
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+# func_fatal_configuration arg...
+# Echo program name prefixed message to standard error, followed by
+# a configuration failure hint, and exit.
+func_fatal_configuration ()
+{
+    func_error ${1+"$@"}
+    func_error "See the $PACKAGE documentation for more information."
+    func_fatal_error "Fatal configuration error."
+}
+
+
+# func_config
+# Display the configuration for all the tags in this script.
+func_config ()
+{
+    re_begincf='^# ### BEGIN LIBTOOL'
+    re_endcf='^# ### END LIBTOOL'
+
+    # Default configuration.
+    $SED "1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\$d" < "$progpath"
+
+    # Now print the configurations for the tags.
+    for tagname in $taglist; do
+      $SED -n "/$re_begincf TAG CONFIG: $tagname\$/,/$re_endcf TAG CONFIG: $tagname\$/p" < "$progpath"
+    done
+
+    exit $?
+}
+
+# func_features
+# Display the features supported by this script.
+func_features ()
+{
+    $ECHO "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      $ECHO "enable shared libraries"
+    else
+      $ECHO "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      $ECHO "enable static libraries"
+    else
+      $ECHO "disable static libraries"
+    fi
+
+    exit $?
+}
+
+# func_enable_tag tagname
+# Verify that TAGNAME is valid, and either flag an error and exit, or
+# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist
+# variable here.
+func_enable_tag ()
+{
+  # Global variable:
+  tagname="$1"
+
+  re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
+  re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
+  sed_extractcf="/$re_begincf/,/$re_endcf/p"
+
+  # Validate tagname.
+  case $tagname in
+    *[!-_A-Za-z0-9,/]*)
+      func_fatal_error "invalid tag name: $tagname"
+      ;;
+  esac
+
+  # Don't test for the "default" C tag, as we know it's
+  # there but not specially marked.
+  case $tagname in
+    CC) ;;
+    *)
+      if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
+	taglist="$taglist $tagname"
+
+	# Evaluate the configuration.  Be careful to quote the path
+	# and the sed script, to avoid splitting on whitespace, but
+	# also don't use non-portable quotes within backquotes within
+	# quotes we have to do it in 2 steps:
+	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
+	eval "$extractedcf"
+      else
+	func_error "ignoring unknown tag $tagname"
+      fi
+      ;;
+  esac
+}
+
+# Parse options once, thoroughly.  This comes as soon as possible in
+# the script to make things like `libtool --version' happen quickly.
+{
+
+  # Shorthand for --mode=foo, only valid as the first argument
+  case $1 in
+  clean|clea|cle|cl)
+    shift; set dummy --mode clean ${1+"$@"}; shift
+    ;;
+  compile|compil|compi|comp|com|co|c)
+    shift; set dummy --mode compile ${1+"$@"}; shift
+    ;;
+  execute|execut|execu|exec|exe|ex|e)
+    shift; set dummy --mode execute ${1+"$@"}; shift
+    ;;
+  finish|finis|fini|fin|fi|f)
+    shift; set dummy --mode finish ${1+"$@"}; shift
+    ;;
+  install|instal|insta|inst|ins|in|i)
+    shift; set dummy --mode install ${1+"$@"}; shift
+    ;;
+  link|lin|li|l)
+    shift; set dummy --mode link ${1+"$@"}; shift
+    ;;
+  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
+    shift; set dummy --mode uninstall ${1+"$@"}; shift
+    ;;
+  esac
+
+  # Parse non-mode specific arguments:
+  while test "$#" -gt 0; do
+    opt="$1"
+    shift
+
+    case $opt in
+      --config)		func_config					;;
+
+      --debug)		preserve_args="$preserve_args $opt"
+			func_echo "enabling shell trace mode"
+			opt_debug='set -x'
+			$opt_debug
+			;;
+
+      -dlopen)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			execute_dlfiles="$execute_dlfiles $1"
+			shift
+			;;
+
+      --dry-run | -n)	opt_dry_run=:					;;
+      --features)       func_features					;;
+      --finish)		mode="finish"					;;
+
+      --mode)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			case $1 in
+			  # Valid mode arguments:
+			  clean)	;;
+			  compile)	;;
+			  execute)	;;
+			  finish)	;;
+			  install)	;;
+			  link)		;;
+			  relink)	;;
+			  uninstall)	;;
+
+			  # Catch anything else as an error
+			  *) func_error "invalid argument for $opt"
+			     exit_cmd=exit
+			     break
+			     ;;
+		        esac
+
+			mode="$1"
+			shift
+			;;
+
+      --preserve-dup-deps)
+			opt_duplicate_deps=:				;;
+
+      --quiet|--silent)	preserve_args="$preserve_args $opt"
+			opt_silent=:
+			;;
+
+      --verbose| -v)	preserve_args="$preserve_args $opt"
+			opt_silent=false
+			;;
+
+      --tag)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			preserve_args="$preserve_args $opt $1"
+			func_enable_tag "$1"	# tagname is set here
+			shift
+			;;
+
+      # Separate optargs to long options:
+      -dlopen=*|--mode=*|--tag=*)
+			func_opt_split "$opt"
+			set dummy "$func_opt_split_opt" "$func_opt_split_arg" ${1+"$@"}
+			shift
+			;;
+
+      -\?|-h)		func_usage					;;
+      --help)		opt_help=:					;;
+      --version)	func_version					;;
+
+      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
+
+      *)		nonopt="$opt"
+			break
+			;;
+    esac
+  done
+
+
+  case $host in
+    *cygwin* | *mingw* | *pw32* | *cegcc*)
+      # don't eliminate duplications in $postdeps and $predeps
+      opt_duplicate_compiler_generated_deps=:
+      ;;
+    *)
+      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps
+      ;;
+  esac
+
+  # Having warned about all mis-specified options, bail out if
+  # anything was wrong.
+  $exit_cmd $EXIT_FAILURE
+}
+
+# func_check_version_match
+# Ensure that we are using m4 macros, and libtool script from the same
+# release of libtool.
+func_check_version_match ()
+{
+  if test "$package_revision" != "$macro_revision"; then
+    if test "$VERSION" != "$macro_version"; then
+      if test -z "$macro_version"; then
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from an older release.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      else
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      fi
+    else
+      cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,
+$progname: but the definition of this LT_INIT comes from revision $macro_revision.
+$progname: You should recreate aclocal.m4 with macros from revision $package_revision
+$progname: of $PACKAGE $VERSION and run autoconf again.
+_LT_EOF
+    fi
+
+    exit $EXIT_MISMATCH
+  fi
+}
+
+
+## ----------- ##
+##    Main.    ##
+## ----------- ##
+
+$opt_help || {
+  # Sanity checks first:
+  func_check_version_match
+
+  if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+    func_fatal_configuration "not configured to build any kind of library"
+  fi
+
+  test -z "$mode" && func_fatal_error "error: you must specify a MODE."
+
+
+  # Darwin sucks
+  eval std_shrext=\"$shrext_cmds\"
+
+
+  # Only execute mode is allowed to have -dlopen flags.
+  if test -n "$execute_dlfiles" && test "$mode" != execute; then
+    func_error "unrecognized option \`-dlopen'"
+    $ECHO "$help" 1>&2
+    exit $EXIT_FAILURE
+  fi
+
+  # Change the help message to a mode-specific one.
+  generic_help="$help"
+  help="Try \`$progname --help --mode=$mode' for more information."
+}
+
+
+# func_lalib_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_lalib_p ()
+{
+    test -f "$1" &&
+      $SED -e 4q "$1" 2>/dev/null \
+        | $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+}
+
+# func_lalib_unsafe_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function implements the same check as func_lalib_p without
+# resorting to external programs.  To this end, it redirects stdin and
+# closes it afterwards, without saving the original file descriptor.
+# As a safety measure, use it only where a negative result would be
+# fatal anyway.  Works if `file' does not exist.
+func_lalib_unsafe_p ()
+{
+    lalib_p=no
+    if test -f "$1" && test -r "$1" && exec 5<&0 <"$1"; then
+	for lalib_p_l in 1 2 3 4
+	do
+	    read lalib_p_line
+	    case "$lalib_p_line" in
+		\#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
+	    esac
+	done
+	exec 0<&5 5<&-
+    fi
+    test "$lalib_p" = yes
+}
+
+# func_ltwrapper_script_p file
+# True iff FILE is a libtool wrapper script
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_script_p ()
+{
+    func_lalib_p "$1"
+}
+
+# func_ltwrapper_executable_p file
+# True iff FILE is a libtool wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_executable_p ()
+{
+    func_ltwrapper_exec_suffix=
+    case $1 in
+    *.exe) ;;
+    *) func_ltwrapper_exec_suffix=.exe ;;
+    esac
+    $GREP "$magic_exe" "$1$func_ltwrapper_exec_suffix" >/dev/null 2>&1
+}
+
+# func_ltwrapper_scriptname file
+# Assumes file is an ltwrapper_executable
+# uses $file to determine the appropriate filename for a
+# temporary ltwrapper_script.
+func_ltwrapper_scriptname ()
+{
+    func_ltwrapper_scriptname_result=""
+    if func_ltwrapper_executable_p "$1"; then
+	func_dirname_and_basename "$1" "" "."
+	func_stripname '' '.exe' "$func_basename_result"
+	func_ltwrapper_scriptname_result="$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper"
+    fi
+}
+
+# func_ltwrapper_p file
+# True iff FILE is a libtool wrapper script or wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_p ()
+{
+    func_ltwrapper_script_p "$1" || func_ltwrapper_executable_p "$1"
+}
+
+
+# func_execute_cmds commands fail_cmd
+# Execute tilde-delimited COMMANDS.
+# If FAIL_CMD is given, eval that upon failure.
+# FAIL_CMD may read-access the current command in variable CMD!
+func_execute_cmds ()
+{
+    $opt_debug
+    save_ifs=$IFS; IFS='~'
+    for cmd in $1; do
+      IFS=$save_ifs
+      eval cmd=\"$cmd\"
+      func_show_eval "$cmd" "${2-:}"
+    done
+    IFS=$save_ifs
+}
+
+
+# func_source file
+# Source FILE, adding directory component if necessary.
+# Note that it is not necessary on cygwin/mingw to append a dot to
+# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
+# behavior happens only for exec(3), not for open(2)!  Also, sourcing
+# `FILE.' does not work on cygwin managed mounts.
+func_source ()
+{
+    $opt_debug
+    case $1 in
+    */* | *\\*)	. "$1" ;;
+    *)		. "./$1" ;;
+    esac
+}
+
+
+# func_infer_tag arg
+# Infer tagged configuration to use if any are available and
+# if one wasn't chosen via the "--tag" command line option.
+# Only attempt this if the compiler in the base compile
+# command doesn't match the default compiler.
+# arg is usually of the form 'gcc ...'
+func_infer_tag ()
+{
+    $opt_debug
+    if test -n "$available_tags" && test -z "$tagname"; then
+      CC_quoted=
+      for arg in $CC; do
+        func_quote_for_eval "$arg"
+	CC_quoted="$CC_quoted $func_quote_for_eval_result"
+      done
+      case $@ in
+      # Blanks in the command may have been stripped by the calling shell,
+      # but not from the CC environment variable when configure was run.
+      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*) ;;
+      # Blanks at the start of $base_compile will cause this to fail
+      # if we don't check for them as well.
+      *)
+	for z in $available_tags; do
+	  if $GREP "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
+	    # Evaluate the configuration.
+	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    CC_quoted=
+	    for arg in $CC; do
+	      # Double-quote args containing other shell metacharacters.
+	      func_quote_for_eval "$arg"
+	      CC_quoted="$CC_quoted $func_quote_for_eval_result"
+	    done
+	    case "$@ " in
+	      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*)
+	      # The compiler in the base compile command matches
+	      # the one in the tagged configuration.
+	      # Assume this is the tagged configuration we want.
+	      tagname=$z
+	      break
+	      ;;
+	    esac
+	  fi
+	done
+	# If $tagname still isn't set, then no tagged configuration
+	# was found and let the user know that the "--tag" command
+	# line option must be used.
+	if test -z "$tagname"; then
+	  func_echo "unable to infer tagged configuration"
+	  func_fatal_error "specify a tag with \`--tag'"
+#	else
+#	  func_verbose "using $tagname tagged configuration"
+	fi
+	;;
+      esac
+    fi
+}
+
+
+
+# func_write_libtool_object output_name pic_name nonpic_name
+# Create a libtool object file (analogous to a ".la" file),
+# but don't create it if we're doing a dry run.
+func_write_libtool_object ()
+{
+    write_libobj=${1}
+    if test "$build_libtool_libs" = yes; then
+      write_lobj=\'${2}\'
+    else
+      write_lobj=none
+    fi
+
+    if test "$build_old_libs" = yes; then
+      write_oldobj=\'${3}\'
+    else
+      write_oldobj=none
+    fi
+
+    $opt_dry_run || {
+      cat >${write_libobj}T <<EOF
+# $write_libobj - a libtool object file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# Name of the PIC object.
+pic_object=$write_lobj
+
+# Name of the non-PIC object
+non_pic_object=$write_oldobj
+
+EOF
+      $MV "${write_libobj}T" "${write_libobj}"
+    }
+}
+
+# func_mode_compile arg...
+func_mode_compile ()
+{
+    $opt_debug
+    # Get the compilation command and the source file.
+    base_compile=
+    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    suppress_opt=yes
+    suppress_output=
+    arg_mode=normal
+    libobj=
+    later=
+    pie_flag=
+
+    for arg
+    do
+      case $arg_mode in
+      arg  )
+	# do not "continue".  Instead, add this to base_compile
+	lastarg="$arg"
+	arg_mode=normal
+	;;
+
+      target )
+	libobj="$arg"
+	arg_mode=normal
+	continue
+	;;
+
+      normal )
+	# Accept any command-line options.
+	case $arg in
+	-o)
+	  test -n "$libobj" && \
+	    func_fatal_error "you cannot specify \`-o' more than once"
+	  arg_mode=target
+	  continue
+	  ;;
+
+	-pie | -fpie | -fPIE)
+          pie_flag="$pie_flag $arg"
+	  continue
+	  ;;
+
+	-shared | -static | -prefer-pic | -prefer-non-pic)
+	  later="$later $arg"
+	  continue
+	  ;;
+
+	-no-suppress)
+	  suppress_opt=no
+	  continue
+	  ;;
+
+	-Xcompiler)
+	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
+	  continue      #  The current "srcfile" will either be retained or
+	  ;;            #  replaced later.  I would guess that would be a bug.
+
+	-Wc,*)
+	  func_stripname '-Wc,' '' "$arg"
+	  args=$func_stripname_result
+	  lastarg=
+	  save_ifs="$IFS"; IFS=','
+	  for arg in $args; do
+	    IFS="$save_ifs"
+	    func_quote_for_eval "$arg"
+	    lastarg="$lastarg $func_quote_for_eval_result"
+	  done
+	  IFS="$save_ifs"
+	  func_stripname ' ' '' "$lastarg"
+	  lastarg=$func_stripname_result
+
+	  # Add the arguments to base_compile.
+	  base_compile="$base_compile $lastarg"
+	  continue
+	  ;;
+
+	*)
+	  # Accept the current argument as the source file.
+	  # The previous "srcfile" becomes the current argument.
+	  #
+	  lastarg="$srcfile"
+	  srcfile="$arg"
+	  ;;
+	esac  #  case $arg
+	;;
+      esac    #  case $arg_mode
+
+      # Aesthetically quote the previous argument.
+      func_quote_for_eval "$lastarg"
+      base_compile="$base_compile $func_quote_for_eval_result"
+    done # for arg
+
+    case $arg_mode in
+    arg)
+      func_fatal_error "you must specify an argument for -Xcompile"
+      ;;
+    target)
+      func_fatal_error "you must specify a target with \`-o'"
+      ;;
+    *)
+      # Get the name of the library object.
+      test -z "$libobj" && {
+	func_basename "$srcfile"
+	libobj="$func_basename_result"
+      }
+      ;;
+    esac
+
+    # Recognize several different file suffixes.
+    # If the user specifies -o file.o, it is replaced with file.lo
+    case $libobj in
+    *.[cCFSifmso] | \
+    *.ada | *.adb | *.ads | *.asm | \
+    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \
+    *.[fF][09]? | *.for | *.java | *.obj | *.sx)
+      func_xform "$libobj"
+      libobj=$func_xform_result
+      ;;
+    esac
+
+    case $libobj in
+    *.lo) func_lo2o "$libobj"; obj=$func_lo2o_result ;;
+    *)
+      func_fatal_error "cannot determine name of library object from \`$libobj'"
+      ;;
+    esac
+
+    func_infer_tag $base_compile
+
+    for arg in $later; do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	continue
+	;;
+
+      -static)
+	build_libtool_libs=no
+	build_old_libs=yes
+	continue
+	;;
+
+      -prefer-pic)
+	pic_mode=yes
+	continue
+	;;
+
+      -prefer-non-pic)
+	pic_mode=no
+	continue
+	;;
+      esac
+    done
+
+    func_quote_for_eval "$libobj"
+    test "X$libobj" != "X$func_quote_for_eval_result" \
+      && $ECHO "X$libobj" | $GREP '[]~#^*{};<>?"'"'"'	 &()|`$[]' \
+      && func_warning "libobj name \`$libobj' may not contain shell special characters."
+    func_dirname_and_basename "$obj" "/" ""
+    objname="$func_basename_result"
+    xdir="$func_dirname_result"
+    lobj=${xdir}$objdir/$objname
+
+    test -z "$base_compile" && \
+      func_fatal_help "you must specify a compilation command"
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      removelist="$obj $lobj $libobj ${libobj}T"
+    else
+      removelist="$lobj $libobj ${libobj}T"
+    fi
+
+    # On Cygwin there's no "real" PIC flag so we must build both object types
+    case $host_os in
+    cygwin* | mingw* | pw32* | os2* | cegcc*)
+      pic_mode=default
+      ;;
+    esac
+    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+      # non-PIC code in shared libraries is not supported
+      pic_mode=default
+    fi
+
+    # Calculate the filename of the output object if compiler does
+    # not support -o with -c
+    if test "$compiler_c_o" = no; then
+      output_obj=`$ECHO "X$srcfile" | $Xsed -e 's%^.*/%%' -e 's%\.[^.]*$%%'`.${objext}
+      lockfile="$output_obj.lock"
+    else
+      output_obj=
+      need_locks=no
+      lockfile=
+    fi
+
+    # Lock this critical section if it is needed
+    # We use this script file to make the link, it avoids creating a new file
+    if test "$need_locks" = yes; then
+      until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
+	func_echo "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    elif test "$need_locks" = warn; then
+      if test -f "$lockfile"; then
+	$ECHO "\
+*** ERROR, $lockfile exists and contains:
+`cat $lockfile 2>/dev/null`
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+      removelist="$removelist $output_obj"
+      $ECHO "$srcfile" > "$lockfile"
+    fi
+
+    $opt_dry_run || $RM $removelist
+    removelist="$removelist $lockfile"
+    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15
+
+    if test -n "$fix_srcfile_path"; then
+      eval srcfile=\"$fix_srcfile_path\"
+    fi
+    func_quote_for_eval "$srcfile"
+    qsrcfile=$func_quote_for_eval_result
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # Without this assignment, base_compile gets emptied.
+      fbsd_hideous_sh_bug=$base_compile
+
+      if test "$pic_mode" != no; then
+	command="$base_compile $qsrcfile $pic_flag"
+      else
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      fi
+
+      func_mkdir_p "$xdir$objdir"
+
+      if test -z "$output_obj"; then
+	# Place PIC objects in $objdir
+	command="$command -o $lobj"
+      fi
+
+      func_show_eval_locale "$command"	\
+          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed, then go on to compile the next one
+      if test -n "$output_obj" && test "X$output_obj" != "X$lobj"; then
+	func_show_eval '$MV "$output_obj" "$lobj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+
+      # Allow error messages only from the first compilation.
+      if test "$suppress_opt" = yes; then
+	suppress_output=' >/dev/null 2>&1'
+      fi
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      if test "$pic_mode" != yes; then
+	# Don't build PIC code
+	command="$base_compile $qsrcfile$pie_flag"
+      else
+	command="$base_compile $qsrcfile $pic_flag"
+      fi
+      if test "$compiler_c_o" = yes; then
+	command="$command -o $obj"
+      fi
+
+      # Suppress compiler output if we already did a PIC compilation.
+      command="$command$suppress_output"
+      func_show_eval_locale "$command" \
+        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed
+      if test -n "$output_obj" && test "X$output_obj" != "X$obj"; then
+	func_show_eval '$MV "$output_obj" "$obj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+    fi
+
+    $opt_dry_run || {
+      func_write_libtool_object "$libobj" "$objdir/$objname" "$objname"
+
+      # Unlock the critical section if it was locked
+      if test "$need_locks" != no; then
+	removelist=$lockfile
+        $RM "$lockfile"
+      fi
+    }
+
+    exit $EXIT_SUCCESS
+}
+
+$opt_help || {
+test "$mode" = compile && func_mode_compile ${1+"$@"}
+}
+
+func_mode_help ()
+{
+    # We need to display help for each of the modes.
+    case $mode in
+      "")
+        # Generic help is extracted from the usage comments
+        # at the start of this file.
+        func_help
+        ;;
+
+      clean)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...
+
+Remove files from the build directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, object or program, all the files associated
+with it are deleted. Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      compile)
+      $ECHO \
+"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+This mode accepts the following additional options:
+
+  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE
+  -no-suppress      do not suppress compiler output for multiple passes
+  -prefer-pic       try to building PIC objects only
+  -prefer-non-pic   try to building non-PIC objects only
+  -shared           do not build a \`.o' file suitable for static linking
+  -static           only build a \`.o' file suitable for static linking
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'."
+        ;;
+
+      execute)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
+
+Automatically set library path, then run a program.
+
+This mode accepts the following additional options:
+
+  -dlopen FILE      add the directory containing FILE to the library path
+
+This mode sets the library path environment variable according to \`-dlopen'
+flags.
+
+If any of the ARGS are libtool executable wrappers, then they are translated
+into their corresponding uninstalled binary, and any of their required library
+directories are added to the library path.
+
+Then, COMMAND is executed, with ARGS as arguments."
+        ;;
+
+      finish)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed."
+        ;;
+
+      install)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The following components of INSTALL-COMMAND are treated specially:
+
+  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized)."
+        ;;
+
+      link)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -all-static       do not do any dynamic linking at all
+  -avoid-version    do not add a version suffix if possible
+  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -export-symbols SYMFILE
+                    try to export only the symbols listed in SYMFILE
+  -export-symbols-regex REGEX
+                    try to export only the symbols matching REGEX
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -module           build a library that can dlopened
+  -no-fast-install  disable the fast-install mode
+  -no-install       link a not-installable executable
+  -no-undefined     declare that a library does not refer to external symbols
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -precious-files-regex REGEX
+                    don't remove output files matching REGEX
+  -release RELEASE  specify package release information
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries
+  -shared           only do dynamic linking of libtool libraries
+  -shrext SUFFIX    override the standard shared library file extension
+  -static           do not do any dynamic linking of uninstalled libtool libraries
+  -static-libtool-libs
+                    do not do any dynamic linking of libtool libraries
+  -version-info CURRENT[:REVISION[:AGE]]
+                    specify library version info [each variable defaults to 0]
+  -weak LIBNAME     declare that the target provides the LIBNAME interface
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
+only library objects (\`.lo' files) may be specified, and \`-rpath' is
+required, except when creating a convenience library.
+
+If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
+using \`ar' and \`ranlib', or on Windows using \`lib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+is created, otherwise an executable program is created."
+        ;;
+
+      uninstall)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      *)
+        func_fatal_help "invalid operation mode \`$mode'"
+        ;;
+    esac
+
+    $ECHO
+    $ECHO "Try \`$progname --help' for more information about other modes."
+
+    exit $?
+}
+
+  # Now that we've collected a possible --mode arg, show help if necessary
+  $opt_help && func_mode_help
+
+
+# func_mode_execute arg...
+func_mode_execute ()
+{
+    $opt_debug
+    # The first argument is the command name.
+    cmd="$nonopt"
+    test -z "$cmd" && \
+      func_fatal_help "you must specify a COMMAND"
+
+    # Handle -dlopen flags immediately.
+    for file in $execute_dlfiles; do
+      test -f "$file" \
+	|| func_fatal_help "\`$file' is not a file"
+
+      dir=
+      case $file in
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$lib' is not a valid libtool archive"
+
+	# Read the libtool library.
+	dlname=
+	library_names=
+	func_source "$file"
+
+	# Skip this library if it cannot be dlopened.
+	if test -z "$dlname"; then
+	  # Warn if it was a shared library.
+	  test -n "$library_names" && \
+	    func_warning "\`$file' was not linked with \`-export-dynamic'"
+	  continue
+	fi
+
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+
+	if test -f "$dir/$objdir/$dlname"; then
+	  dir="$dir/$objdir"
+	else
+	  if test ! -f "$dir/$dlname"; then
+	    func_fatal_error "cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'"
+	  fi
+	fi
+	;;
+
+      *.lo)
+	# Just add the directory containing the .lo file.
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+	;;
+
+      *)
+	func_warning "\`-dlopen' is ignored for non-libtool libraries and objects"
+	continue
+	;;
+      esac
+
+      # Get the absolute pathname.
+      absdir=`cd "$dir" && pwd`
+      test -n "$absdir" && dir="$absdir"
+
+      # Now add the directory to shlibpath_var.
+      if eval "test -z \"\$$shlibpath_var\""; then
+	eval "$shlibpath_var=\"\$dir\""
+      else
+	eval "$shlibpath_var=\"\$dir:\$$shlibpath_var\""
+      fi
+    done
+
+    # This variable tells wrapper scripts just to set shlibpath_var
+    # rather than running their programs.
+    libtool_execute_magic="$magic"
+
+    # Check if any of the arguments is a wrapper script.
+    args=
+    for file
+    do
+      case $file in
+      -*) ;;
+      *)
+	# Do a test to see if this is really a libtool program.
+	if func_ltwrapper_script_p "$file"; then
+	  func_source "$file"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	elif func_ltwrapper_executable_p "$file"; then
+	  func_ltwrapper_scriptname "$file"
+	  func_source "$func_ltwrapper_scriptname_result"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	fi
+	;;
+      esac
+      # Quote arguments (to preserve shell metacharacters).
+      func_quote_for_eval "$file"
+      args="$args $func_quote_for_eval_result"
+    done
+
+    if test "X$opt_dry_run" = Xfalse; then
+      if test -n "$shlibpath_var"; then
+	# Export the shlibpath_var.
+	eval "export $shlibpath_var"
+      fi
+
+      # Restore saved environment variables
+      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+      do
+	eval "if test \"\${save_$lt_var+set}\" = set; then
+                $lt_var=\$save_$lt_var; export $lt_var
+	      else
+		$lt_unset $lt_var
+	      fi"
+      done
+
+      # Now prepare to actually exec the command.
+      exec_cmd="\$cmd$args"
+    else
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
+	$ECHO "export $shlibpath_var"
+      fi
+      $ECHO "$cmd$args"
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = execute && func_mode_execute ${1+"$@"}
+
+
+# func_mode_finish arg...
+func_mode_finish ()
+{
+    $opt_debug
+    libdirs="$nonopt"
+    admincmds=
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      for dir
+      do
+	libdirs="$libdirs $dir"
+      done
+
+      for libdir in $libdirs; do
+	if test -n "$finish_cmds"; then
+	  # Do each command in the finish commands.
+	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
+'"$cmd"'"'
+	fi
+	if test -n "$finish_eval"; then
+	  # Do the single finish_eval.
+	  eval cmds=\"$finish_eval\"
+	  $opt_dry_run || eval "$cmds" || admincmds="$admincmds
+       $cmds"
+	fi
+      done
+    fi
+
+    # Exit here if they wanted silent mode.
+    $opt_silent && exit $EXIT_SUCCESS
+
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    $ECHO "Libraries have been installed in:"
+    for libdir in $libdirs; do
+      $ECHO "   $libdir"
+    done
+    $ECHO
+    $ECHO "If you ever happen to want to link against installed libraries"
+    $ECHO "in a given directory, LIBDIR, you must either use libtool, and"
+    $ECHO "specify the full pathname of the library, or use the \`-LLIBDIR'"
+    $ECHO "flag during linking and do at least one of the following:"
+    if test -n "$shlibpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+      $ECHO "     during execution"
+    fi
+    if test -n "$runpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$runpath_var' environment variable"
+      $ECHO "     during linking"
+    fi
+    if test -n "$hardcode_libdir_flag_spec"; then
+      libdir=LIBDIR
+      eval flag=\"$hardcode_libdir_flag_spec\"
+
+      $ECHO "   - use the \`$flag' linker flag"
+    fi
+    if test -n "$admincmds"; then
+      $ECHO "   - have your system administrator run these commands:$admincmds"
+    fi
+    if test -f /etc/ld.so.conf; then
+      $ECHO "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+    fi
+    $ECHO
+
+    $ECHO "See any operating system documentation about shared libraries for"
+    case $host in
+      solaris2.[6789]|solaris2.1[0-9])
+        $ECHO "more information, such as the ld(1), crle(1) and ld.so(8) manual"
+	$ECHO "pages."
+	;;
+      *)
+        $ECHO "more information, such as the ld(1) and ld.so(8) manual pages."
+        ;;
+    esac
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    exit $EXIT_SUCCESS
+}
+
+test "$mode" = finish && func_mode_finish ${1+"$@"}
+
+
+# func_mode_install arg...
+func_mode_install ()
+{
+    $opt_debug
+    # There may be an optional sh(1) argument at the beginning of
+    # install_prog (especially on Windows NT).
+    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+       # Allow the use of GNU shtool's install command.
+       $ECHO "X$nonopt" | $GREP shtool >/dev/null; then
+      # Aesthetically quote it.
+      func_quote_for_eval "$nonopt"
+      install_prog="$func_quote_for_eval_result "
+      arg=$1
+      shift
+    else
+      install_prog=
+      arg=$nonopt
+    fi
+
+    # The real first argument should be the name of the installation program.
+    # Aesthetically quote it.
+    func_quote_for_eval "$arg"
+    install_prog="$install_prog$func_quote_for_eval_result"
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=no
+    stripme=
+    for arg
+    do
+      if test -n "$dest"; then
+	files="$files $dest"
+	dest=$arg
+	continue
+      fi
+
+      case $arg in
+      -d) isdir=yes ;;
+      -f)
+	case " $install_prog " in
+	*[\\\ /]cp\ *) ;;
+	*) prev=$arg ;;
+	esac
+	;;
+      -g | -m | -o)
+	prev=$arg
+	;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*)
+	;;
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  prev=
+	else
+	  dest=$arg
+	  continue
+	fi
+	;;
+      esac
+
+      # Aesthetically quote the argument.
+      func_quote_for_eval "$arg"
+      install_prog="$install_prog $func_quote_for_eval_result"
+    done
+
+    test -z "$install_prog" && \
+      func_fatal_help "you must specify an install program"
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prev' option requires an argument"
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+	func_fatal_help "no file or destination specified"
+      else
+	func_fatal_help "you must specify a destination"
+      fi
+    fi
+
+    # Strip any trailing slash from the destination.
+    func_stripname '' '/' "$dest"
+    dest=$func_stripname_result
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test "$isdir" = yes; then
+      destdir="$dest"
+      destname=
+    else
+      func_dirname_and_basename "$dest" "" "."
+      destdir="$func_dirname_result"
+      destname="$func_basename_result"
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files; shift
+      test "$#" -gt 1 && \
+	func_fatal_help "\`$dest' is not a directory"
+    fi
+    case $destdir in
+    [\\/]* | [A-Za-z]:[\\/]*) ;;
+    *)
+      for file in $files; do
+	case $file in
+	*.lo) ;;
+	*)
+	  func_fatal_help "\`$destdir' must be an absolute directory name"
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case $file in
+      *.$libext)
+	# Do the static libraries later.
+	staticlibs="$staticlibs $file"
+	;;
+
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$file' is not a valid libtool archive"
+
+	library_names=
+	old_library=
+	relink_command=
+	func_source "$file"
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "X$destdir" = "X$libdir"; then
+	  case "$current_libdirs " in
+	  *" $libdir "*) ;;
+	  *) current_libdirs="$current_libdirs $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  *" $libdir "*) ;;
+	  *) future_libdirs="$future_libdirs $libdir" ;;
+	  esac
+	fi
+
+	func_dirname "$file" "/" ""
+	dir="$func_dirname_result"
+	dir="$dir$objdir"
+
+	if test -n "$relink_command"; then
+	  # Determine the prefix the user has applied to our future dir.
+	  inst_prefix_dir=`$ECHO "X$destdir" | $Xsed -e "s%$libdir\$%%"`
+
+	  # Don't allow the user to place us outside of our expected
+	  # location b/c this prevents finding dependent libraries that
+	  # are installed to the same prefix.
+	  # At present, this check doesn't affect windows .dll's that
+	  # are installed into $libdir/../bin (currently, that works fine)
+	  # but it's something to keep an eye on.
+	  test "$inst_prefix_dir" = "$destdir" && \
+	    func_fatal_error "error: cannot install \`$file' to a directory not ending in $libdir"
+
+	  if test -n "$inst_prefix_dir"; then
+	    # Stick the inst_prefix_dir data into the link command.
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
+	  else
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%%"`
+	  fi
+
+	  func_warning "relinking \`$file'"
+	  func_show_eval "$relink_command" \
+	    'func_fatal_error "error: relink \`$file'\'' with the above command before installing it"'
+	fi
+
+	# See the names of the shared library.
+	set dummy $library_names; shift
+	if test -n "$1"; then
+	  realname="$1"
+	  shift
+
+	  srcname="$realname"
+	  test -n "$relink_command" && srcname="$realname"T
+
+	  # Install the shared library and build the symlinks.
+	  func_show_eval "$install_prog $dir/$srcname $destdir/$realname" \
+	      'exit $?'
+	  tstripme="$stripme"
+	  case $host_os in
+	  cygwin* | mingw* | pw32* | cegcc*)
+	    case $realname in
+	    *.dll.a)
+	      tstripme=""
+	      ;;
+	    esac
+	    ;;
+	  esac
+	  if test -n "$tstripme" && test -n "$striplib"; then
+	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
+	  fi
+
+	  if test "$#" -gt 0; then
+	    # Delete the old symlinks, and create new ones.
+	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
+	    # so we also need to try rm && ln -s.
+	    for linkname
+	    do
+	      test "$linkname" != "$realname" \
+		&& func_show_eval "(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })"
+	    done
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  func_execute_cmds "$postinstall_cmds" 'exit $?'
+	fi
+
+	# Install the pseudo-library for information purposes.
+	func_basename "$file"
+	name="$func_basename_result"
+	instname="$dir/$name"i
+	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && staticlibs="$staticlibs $dir/$old_library"
+	;;
+
+      *.lo)
+	# Install (i.e. copy) a libtool object.
+
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# Deduce the name of the destination old-style object file.
+	case $destfile in
+	*.lo)
+	  func_lo2o "$destfile"
+	  staticdest=$func_lo2o_result
+	  ;;
+	*.$objext)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  func_fatal_help "cannot copy a libtool object to \`$destfile'"
+	  ;;
+	esac
+
+	# Install the libtool object if requested.
+	test -n "$destfile" && \
+	  func_show_eval "$install_prog $file $destfile" 'exit $?'
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  func_lo2o "$file"
+	  staticobj=$func_lo2o_result
+	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
+	fi
+	exit $EXIT_SUCCESS
+	;;
+
+      *)
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# If the file is missing, and there is a .exe on the end, strip it
+	# because it is most likely a libtool script we actually want to
+	# install
+	stripped_ext=""
+	case $file in
+	  *.exe)
+	    if test ! -f "$file"; then
+	      func_stripname '' '.exe' "$file"
+	      file=$func_stripname_result
+	      stripped_ext=".exe"
+	    fi
+	    ;;
+	esac
+
+	# Do a test to see if this is really a libtool program.
+	case $host in
+	*cygwin* | *mingw*)
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      wrapper=$func_ltwrapper_scriptname_result
+	    else
+	      func_stripname '' '.exe' "$file"
+	      wrapper=$func_stripname_result
+	    fi
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if func_ltwrapper_script_p "$wrapper"; then
+	  notinst_deplibs=
+	  relink_command=
+
+	  func_source "$wrapper"
+
+	  # Check the variables that should have been set.
+	  test -z "$generated_by_libtool_version" && \
+	    func_fatal_error "invalid libtool wrapper script \`$wrapper'"
+
+	  finalize=yes
+	  for lib in $notinst_deplibs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      func_source "$lib"
+	    fi
+	    libfile="$libdir/"`$ECHO "X$lib" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    if test -n "$libdir" && test ! -f "$libfile"; then
+	      func_warning "\`$lib' has not been installed in \`$libdir'"
+	      finalize=no
+	    fi
+	  done
+
+	  relink_command=
+	  func_source "$wrapper"
+
+	  outputname=
+	  if test "$fast_install" = no && test -n "$relink_command"; then
+	    $opt_dry_run || {
+	      if test "$finalize" = yes; then
+	        tmpdir=`func_mktempdir`
+		func_basename "$file$stripped_ext"
+		file="$func_basename_result"
+	        outputname="$tmpdir/$file"
+	        # Replace the output file specification.
+	        relink_command=`$ECHO "X$relink_command" | $Xsed -e 's%@OUTPUT@%'"$outputname"'%g'`
+
+	        $opt_silent || {
+	          func_quote_for_expand "$relink_command"
+		  eval "func_echo $func_quote_for_expand_result"
+	        }
+	        if eval "$relink_command"; then :
+	          else
+		  func_error "error: relink \`$file' with the above command before installing it"
+		  $opt_dry_run || ${RM}r "$tmpdir"
+		  continue
+	        fi
+	        file="$outputname"
+	      else
+	        func_warning "cannot relink \`$file'"
+	      fi
+	    }
+	  else
+	    # Install the binary that we compiled earlier.
+	    file=`$ECHO "X$file$stripped_ext" | $Xsed -e "s%\([^/]*\)$%$objdir/\1%"`
+	  fi
+	fi
+
+	# remove .exe since cygwin /usr/bin/install will append another
+	# one anyway
+	case $install_prog,$host in
+	*/usr/bin/install*,*cygwin*)
+	  case $file:$destfile in
+	  *.exe:*.exe)
+	    # this is ok
+	    ;;
+	  *.exe:*)
+	    destfile=$destfile.exe
+	    ;;
+	  *:*.exe)
+	    func_stripname '' '.exe' "$destfile"
+	    destfile=$func_stripname_result
+	    ;;
+	  esac
+	  ;;
+	esac
+	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
+	$opt_dry_run || if test -n "$outputname"; then
+	  ${RM}r "$tmpdir"
+	fi
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      func_basename "$file"
+      name="$func_basename_result"
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+
+      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
+
+      if test -n "$stripme" && test -n "$old_striplib"; then
+	func_show_eval "$old_striplib $oldlib" 'exit $?'
+      fi
+
+      # Do each command in the postinstall commands.
+      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
+    done
+
+    test -n "$future_libdirs" && \
+      func_warning "remember to run \`$progname --finish$future_libdirs'"
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      $opt_dry_run && current_libdirs=" -n$current_libdirs"
+      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+    else
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = install && func_mode_install ${1+"$@"}
+
+
+# func_generate_dlsyms outputname originator pic_p
+# Extract symbols from dlprefiles and create ${outputname}S.o with
+# a dlpreopen symbol table.
+func_generate_dlsyms ()
+{
+    $opt_debug
+    my_outputname="$1"
+    my_originator="$2"
+    my_pic_p="${3-no}"
+    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
+    my_dlsyms=
+
+    if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+      if test -n "$NM" && test -n "$global_symbol_pipe"; then
+	my_dlsyms="${my_outputname}S.c"
+      else
+	func_error "not configured to extract global symbols from dlpreopened files"
+      fi
+    fi
+
+    if test -n "$my_dlsyms"; then
+      case $my_dlsyms in
+      "") ;;
+      *.c)
+	# Discover the nlist of each of the dlfiles.
+	nlist="$output_objdir/${my_outputname}.nm"
+
+	func_show_eval "$RM $nlist ${nlist}S ${nlist}T"
+
+	# Parse the name list into a source file.
+	func_verbose "creating $output_objdir/$my_dlsyms"
+
+	$opt_dry_run || $ECHO > "$output_objdir/$my_dlsyms" "\
+/* $my_dlsyms - symbol resolution table for \`$my_outputname' dlsym emulation. */
+/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */
+
+#ifdef __cplusplus
+extern \"C\" {
+#endif
+
+/* External symbol declarations for the compiler. */\
+"
+
+	if test "$dlself" = yes; then
+	  func_verbose "generating symbol list for \`$output'"
+
+	  $opt_dry_run || echo ': @PROGRAM@ ' > "$nlist"
+
+	  # Add our own program objects to the symbol list.
+	  progfiles=`$ECHO "X$objs$old_deplibs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	  for progfile in $progfiles; do
+	    func_verbose "extracting global C symbols from \`$progfile'"
+	    $opt_dry_run || eval "$NM $progfile | $global_symbol_pipe >> '$nlist'"
+	  done
+
+	  if test -n "$exclude_expsyms"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  if test -n "$export_symbols_regex"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  # Prepare the list of exported symbols
+	  if test -z "$export_symbols"; then
+	    export_symbols="$output_objdir/$outputname.exp"
+	    $opt_dry_run || {
+	      $RM $export_symbols
+	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+	      case $host in
+	      *cygwin* | *mingw* | *cegcc* )
+                eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
+	        ;;
+	      esac
+	    }
+	  else
+	    $opt_dry_run || {
+	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	      case $host in
+	        *cygwin | *mingw* | *cegcc* )
+	          eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+	          eval 'cat "$nlist" >> "$output_objdir/$outputname.def"'
+	          ;;
+	      esac
+	    }
+	  fi
+	fi
+
+	for dlprefile in $dlprefiles; do
+	  func_verbose "extracting global C symbols from \`$dlprefile'"
+	  func_basename "$dlprefile"
+	  name="$func_basename_result"
+	  $opt_dry_run || {
+	    eval '$ECHO ": $name " >> "$nlist"'
+	    eval "$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'"
+	  }
+	done
+
+	$opt_dry_run || {
+	  # Make sure we have at least an empty file.
+	  test -f "$nlist" || : > "$nlist"
+
+	  if test -n "$exclude_expsyms"; then
+	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
+	    $MV "$nlist"T "$nlist"
+	  fi
+
+	  # Try sorting and uniquifying the output.
+	  if $GREP -v "^: " < "$nlist" |
+	      if sort -k 3 </dev/null >/dev/null 2>&1; then
+		sort -k 3
+	      else
+		sort +2
+	      fi |
+	      uniq > "$nlist"S; then
+	    :
+	  else
+	    $GREP -v "^: " < "$nlist" > "$nlist"S
+	  fi
+
+	  if test -f "$nlist"S; then
+	    eval "$global_symbol_to_cdecl"' < "$nlist"S >> "$output_objdir/$my_dlsyms"'
+	  else
+	    $ECHO '/* NONE */' >> "$output_objdir/$my_dlsyms"
+	  fi
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+
+/* The mapping between symbol names and symbols.  */
+typedef struct {
+  const char *name;
+  void *address;
+} lt_dlsymlist;
+"
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc* )
+	    $ECHO >> "$output_objdir/$my_dlsyms" "\
+/* DATA imports from DLLs on WIN32 con't be const, because
+   runtime relocations are performed -- see ld's documentation
+   on pseudo-relocs.  */"
+	    lt_dlsym_const= ;;
+	  *osf5*)
+	    echo >> "$output_objdir/$my_dlsyms" "\
+/* This system does not cope well with relocations in const data */"
+	    lt_dlsym_const= ;;
+	  *)
+	    lt_dlsym_const=const ;;
+	  esac
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+extern $lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[];
+$lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[] =
+{\
+  { \"$my_originator\", (void *) 0 },"
+
+	  case $need_lib_prefix in
+	  no)
+	    eval "$global_symbol_to_c_name_address" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  *)
+	    eval "$global_symbol_to_c_name_address_lib_prefix" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  esac
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt_${my_prefix}_LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif\
+"
+	} # !$opt_dry_run
+
+	pic_flag_for_symtable=
+	case "$compile_command " in
+	*" -static "*) ;;
+	*)
+	  case $host in
+	  # compiling the symbol table file with pic_flag works around
+	  # a FreeBSD bug that causes programs to crash when -lm is
+	  # linked before any other PIC object.  But we must not use
+	  # pic_flag when linking with -static.  The problem exists in
+	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
+	  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)
+	    pic_flag_for_symtable=" $pic_flag -DFREEBSD_WORKAROUND" ;;
+	  *-*-hpux*)
+	    pic_flag_for_symtable=" $pic_flag"  ;;
+	  *)
+	    if test "X$my_pic_p" != Xno; then
+	      pic_flag_for_symtable=" $pic_flag"
+	    fi
+	    ;;
+	  esac
+	  ;;
+	esac
+	symtab_cflags=
+	for arg in $LTCFLAGS; do
+	  case $arg in
+	  -pie | -fpie | -fPIE) ;;
+	  *) symtab_cflags="$symtab_cflags $arg" ;;
+	  esac
+	done
+
+	# Now compile the dynamic symbol file.
+	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
+
+	# Clean up the generated files.
+	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T"'
+
+	# Transform the symbol file into the correct name.
+	symfileobj="$output_objdir/${my_outputname}S.$objext"
+	case $host in
+	*cygwin* | *mingw* | *cegcc* )
+	  if test -f "$output_objdir/$my_outputname.def"; then
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	  else
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  fi
+	  ;;
+	*)
+	  compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  ;;
+	esac
+	;;
+      *)
+	func_fatal_error "unknown suffix for \`$my_dlsyms'"
+	;;
+      esac
+    else
+      # We keep going just in case the user didn't refer to
+      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe
+      # really was required.
+
+      # Nullify the symbol file.
+      compile_command=`$ECHO "X$compile_command" | $Xsed -e "s% @SYMFILE@%%"`
+      finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s% @SYMFILE@%%"`
+    fi
+}
+
+# func_win32_libid arg
+# return the library type of file 'arg'
+#
+# Need a lot of goo to handle *both* DLLs and import libs
+# Has to be a shell function in order to 'eat' the argument
+# that is supplied when $file_magic_command is called.
+func_win32_libid ()
+{
+  $opt_debug
+  win32_libid_type="unknown"
+  win32_fileres=`file -L $1 2>/dev/null`
+  case $win32_fileres in
+  *ar\ archive\ import\ library*) # definitely import
+    win32_libid_type="x86 archive import"
+    ;;
+  *ar\ archive*) # could be an import, or static
+    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |
+       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then
+      win32_nmres=`eval $NM -f posix -A $1 |
+	$SED -n -e '
+	    1,100{
+		/ I /{
+		    s,.*,import,
+		    p
+		    q
+		}
+	    }'`
+      case $win32_nmres in
+      import*)  win32_libid_type="x86 archive import";;
+      *)        win32_libid_type="x86 archive static";;
+      esac
+    fi
+    ;;
+  *DLL*)
+    win32_libid_type="x86 DLL"
+    ;;
+  *executable*) # but shell scripts are "executable" too...
+    case $win32_fileres in
+    *MS\ Windows\ PE\ Intel*)
+      win32_libid_type="x86 DLL"
+      ;;
+    esac
+    ;;
+  esac
+  $ECHO "$win32_libid_type"
+}
+
+
+
+# func_extract_an_archive dir oldlib
+func_extract_an_archive ()
+{
+    $opt_debug
+    f_ex_an_ar_dir="$1"; shift
+    f_ex_an_ar_oldlib="$1"
+    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" 'exit $?'
+    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
+     :
+    else
+      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
+    fi
+}
+
+
+# func_extract_archives gentop oldlib ...
+func_extract_archives ()
+{
+    $opt_debug
+    my_gentop="$1"; shift
+    my_oldlibs=${1+"$@"}
+    my_oldobjs=""
+    my_xlib=""
+    my_xabs=""
+    my_xdir=""
+
+    for my_xlib in $my_oldlibs; do
+      # Extract the objects.
+      case $my_xlib in
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	*) my_xabs=`pwd`"/$my_xlib" ;;
+      esac
+      func_basename "$my_xlib"
+      my_xlib="$func_basename_result"
+      my_xlib_u=$my_xlib
+      while :; do
+        case " $extracted_archives " in
+	*" $my_xlib_u "*)
+	  func_arith $extracted_serial + 1
+	  extracted_serial=$func_arith_result
+	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
+	*) break ;;
+	esac
+      done
+      extracted_archives="$extracted_archives $my_xlib_u"
+      my_xdir="$my_gentop/$my_xlib_u"
+
+      func_mkdir_p "$my_xdir"
+
+      case $host in
+      *-darwin*)
+	func_verbose "Extracting $my_xabs"
+	# Do not bother doing anything if just a dry run
+	$opt_dry_run || {
+	  darwin_orig_dir=`pwd`
+	  cd $my_xdir || exit $?
+	  darwin_archive=$my_xabs
+	  darwin_curdir=`pwd`
+	  darwin_base_archive=`basename "$darwin_archive"`
+	  darwin_arches=`$LIPO -info "$darwin_archive" 2>/dev/null | $GREP Architectures 2>/dev/null || true`
+	  if test -n "$darwin_arches"; then
+	    darwin_arches=`$ECHO "$darwin_arches" | $SED -e 's/.*are://'`
+	    darwin_arch=
+	    func_verbose "$darwin_base_archive has multiple architectures $darwin_arches"
+	    for darwin_arch in  $darwin_arches ; do
+	      func_mkdir_p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      $LIPO -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
+	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	      cd "$darwin_curdir"
+	      $RM "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	    done # $darwin_arches
+            ## Okay now we've a bunch of thin objects, gotta fatten them up :)
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print | $SED -e "$basename" | sort -u`
+	    darwin_file=
+	    darwin_files=
+	    for darwin_file in $darwin_filelist; do
+	      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`
+	      $LIPO -create -output "$darwin_file" $darwin_files
+	    done # $darwin_filelist
+	    $RM -rf unfat-$$
+	    cd "$darwin_orig_dir"
+	  else
+	    cd $darwin_orig_dir
+	    func_extract_an_archive "$my_xdir" "$my_xabs"
+	  fi # $darwin_arches
+	} # !$opt_dry_run
+	;;
+      *)
+        func_extract_an_archive "$my_xdir" "$my_xabs"
+	;;
+      esac
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | $NL2SP`
+    done
+
+    func_extract_archives_result="$my_oldobjs"
+}
+
+
+
+# func_emit_wrapper_part1 [arg=no]
+#
+# Emit the first part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part1 ()
+{
+	func_emit_wrapper_part1_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part1_arg1=$1
+	fi
+
+	$ECHO "\
+#! $SHELL
+
+# $output - temporary wrapper script for $objdir/$outputname
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of the build directory.
+# If it is, it will not operate correctly.
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='${SED} -e 1s/^X//'
+sed_quote_subst='$sed_quote_subst'
+
+# Be Bourne compatible
+if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+relink_command=\"$relink_command\"
+
+# This environment variable determines our operation mode.
+if test \"\$libtool_install_magic\" = \"$magic\"; then
+  # install mode needs the following variables:
+  generated_by_libtool_version='$macro_version'
+  notinst_deplibs='$notinst_deplibs'
+else
+  # When we are sourced in execute mode, \$file and \$ECHO are already set.
+  if test \"\$libtool_execute_magic\" != \"$magic\"; then
+    ECHO=\"$qecho\"
+    file=\"\$0\"
+    # Make sure echo works.
+    if test \"X\$1\" = X--no-reexec; then
+      # Discard the --no-reexec flag, and continue.
+      shift
+    elif test \"X\`{ \$ECHO '\t'; } 2>/dev/null\`\" = 'X\t'; then
+      # Yippee, \$ECHO works!
+      :
+    else
+      # Restart under the correct shell, and then maybe \$ECHO will work.
+      exec $SHELL \"\$0\" --no-reexec \${1+\"\$@\"}
+    fi
+  fi\
+"
+	$ECHO "\
+
+  # Find the directory that this script lives in.
+  thisdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*$%%'\`
+  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
+
+  # Follow symbolic links until we get to the real thisdir.
+  file=\`ls -ld \"\$file\" | ${SED} -n 's/.*-> //p'\`
+  while test -n \"\$file\"; do
+    destdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*\$%%'\`
+
+    # If there was a directory component, then change thisdir.
+    if test \"x\$destdir\" != \"x\$file\"; then
+      case \"\$destdir\" in
+      [\\\\/]* | [A-Za-z]:[\\\\/]*) thisdir=\"\$destdir\" ;;
+      *) thisdir=\"\$thisdir/\$destdir\" ;;
+      esac
+    fi
+
+    file=\`\$ECHO \"X\$file\" | \$Xsed -e 's%^.*/%%'\`
+    file=\`ls -ld \"\$thisdir/\$file\" | ${SED} -n 's/.*-> //p'\`
+  done
+"
+}
+# end: func_emit_wrapper_part1
+
+# func_emit_wrapper_part2 [arg=no]
+#
+# Emit the second part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part2 ()
+{
+	func_emit_wrapper_part2_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part2_arg1=$1
+	fi
+
+	$ECHO "\
+
+  # Usually 'no', except on cygwin/mingw when embedded into
+  # the cwrapper.
+  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_part2_arg1
+  if test \"\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\" = \"yes\"; then
+    # special case for '.'
+    if test \"\$thisdir\" = \".\"; then
+      thisdir=\`pwd\`
+    fi
+    # remove .libs from thisdir
+    case \"\$thisdir\" in
+    *[\\\\/]$objdir ) thisdir=\`\$ECHO \"X\$thisdir\" | \$Xsed -e 's%[\\\\/][^\\\\/]*$%%'\` ;;
+    $objdir )   thisdir=. ;;
+    esac
+  fi
+
+  # Try to get the absolute directory name.
+  absdir=\`cd \"\$thisdir\" && pwd\`
+  test -n \"\$absdir\" && thisdir=\"\$absdir\"
+"
+
+	if test "$fast_install" = yes; then
+	  $ECHO "\
+  program=lt-'$outputname'$exeext
+  progdir=\"\$thisdir/$objdir\"
+
+  if test ! -f \"\$progdir/\$program\" ||
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+       test \"X\$file\" != \"X\$progdir/\$program\"; }; then
+
+    file=\"\$\$-\$program\"
+
+    if test ! -d \"\$progdir\"; then
+      $MKDIR \"\$progdir\"
+    else
+      $RM \"\$progdir/\$file\"
+    fi"
+
+	  $ECHO "\
+
+    # relink executable if necessary
+    if test -n \"\$relink_command\"; then
+      if relink_command_output=\`eval \$relink_command 2>&1\`; then :
+      else
+	$ECHO \"\$relink_command_output\" >&2
+	$RM \"\$progdir/\$file\"
+	exit 1
+      fi
+    fi
+
+    $MV \"\$progdir/\$file\" \"\$progdir/\$program\" 2>/dev/null ||
+    { $RM \"\$progdir/\$program\";
+      $MV \"\$progdir/\$file\" \"\$progdir/\$program\"; }
+    $RM \"\$progdir/\$file\"
+  fi"
+	else
+	  $ECHO "\
+  program='$outputname'
+  progdir=\"\$thisdir/$objdir\"
+"
+	fi
+
+	$ECHO "\
+
+  if test -f \"\$progdir/\$program\"; then"
+
+	# Export our shlibpath_var if we have one.
+	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  $ECHO "\
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    # The second colon is a workaround for a bug in BeOS R4 sed
+    $shlibpath_var=\`\$ECHO \"X\$$shlibpath_var\" | \$Xsed -e 's/::*\$//'\`
+
+    export $shlibpath_var
+"
+	fi
+
+	# fixup the dll searchpath if we need to.
+	if test -n "$dllsearchpath"; then
+	  $ECHO "\
+    # Add the dll search path components to the executable PATH
+    PATH=$dllsearchpath:\$PATH
+"
+	fi
+
+	$ECHO "\
+    if test \"\$libtool_execute_magic\" != \"$magic\"; then
+      # Run the actual program with our arguments.
+"
+	case $host in
+	# Backslashes separate directories on plain windows
+	*-*-mingw | *-*-os2* | *-cegcc*)
+	  $ECHO "\
+      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
+"
+	  ;;
+
+	*)
+	  $ECHO "\
+      exec \"\$progdir/\$program\" \${1+\"\$@\"}
+"
+	  ;;
+	esac
+	$ECHO "\
+      \$ECHO \"\$0: cannot exec \$program \$*\" 1>&2
+      exit 1
+    fi
+  else
+    # The program doesn't exist.
+    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$ECHO \"This script is just a wrapper for \$program.\" 1>&2
+    $ECHO \"See the $PACKAGE documentation for more information.\" 1>&2
+    exit 1
+  fi
+fi\
+"
+}
+# end: func_emit_wrapper_part2
+
+
+# func_emit_wrapper [arg=no]
+#
+# Emit a libtool wrapper script on stdout.
+# Don't directly open a file because we may want to
+# incorporate the script contents within a cygwin/mingw
+# wrapper executable.  Must ONLY be called from within
+# func_mode_link because it depends on a number of variables
+# set therein.
+#
+# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR
+# variable will take.  If 'yes', then the emitted script
+# will assume that the directory in which it is stored is
+# the $objdir directory.  This is a cygwin/mingw-specific
+# behavior.
+func_emit_wrapper ()
+{
+	func_emit_wrapper_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_arg1=$1
+	fi
+
+	# split this up so that func_emit_cwrapperexe_src
+	# can call each part independently.
+	func_emit_wrapper_part1 "${func_emit_wrapper_arg1}"
+	func_emit_wrapper_part2 "${func_emit_wrapper_arg1}"
+}
+
+
+# func_to_host_path arg
+#
+# Convert paths to host format when used with build tools.
+# Intended for use with "native" mingw (where libtool itself
+# is running under the msys shell), or in the following cross-
+# build environments:
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+# where wine is equipped with the `winepath' executable.
+# In the native mingw case, the (msys) shell automatically
+# converts paths for any non-msys applications it launches,
+# but that facility isn't available from inside the cwrapper.
+# Similar accommodations are necessary for $host mingw and
+# $build cygwin.  Calling this function does no harm for other
+# $host/$build combinations not listed above.
+#
+# ARG is the path (on $build) that should be converted to
+# the proper representation for $host. The result is stored
+# in $func_to_host_path_result.
+func_to_host_path ()
+{
+  func_to_host_path_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        case $build in
+          *mingw* ) # actually, msys
+            # awkward: cmd appends spaces to result
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_path_tmp1=`( cmd //c echo "$1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_path_tmp1=`cygpath -w "$1"`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # Unfortunately, winepath does not exit with a non-zero
+            # error code, so we are forced to check the contents of
+            # stdout. On the other hand, if the command is not
+            # found, the shell will set an exit code of 127 and print
+            # *an error message* to stdout. So we must check for both
+            # error code of zero AND non-empty stdout, which explains
+            # the odd construction:
+            func_to_host_path_tmp1=`winepath -w "$1" 2>/dev/null`
+            if test "$?" -eq 0 && test -n "${func_to_host_path_tmp1}"; then
+              func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+                $SED -e "$lt_sed_naive_backslashify"`
+            else
+              # Allow warning below.
+              func_to_host_path_result=""
+            fi
+            ;;
+        esac
+        if test -z "$func_to_host_path_result" ; then
+          func_error "Could not determine host path corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback:
+          func_to_host_path_result="$1"
+        fi
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_path
+
+# func_to_host_pathlist arg
+#
+# Convert pathlists to host format when used with build tools.
+# See func_to_host_path(), above. This function supports the
+# following $build/$host combinations (but does no harm for
+# combinations not listed here):
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+#
+# Path separators are also converted from $build format to
+# $host format. If ARG begins or ends with a path separator
+# character, it is preserved (but converted to $host format)
+# on output.
+#
+# ARG is a pathlist (on $build) that should be converted to
+# the proper representation on $host. The result is stored
+# in $func_to_host_pathlist_result.
+func_to_host_pathlist ()
+{
+  func_to_host_pathlist_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        # Remove leading and trailing path separator characters from
+        # ARG. msys behavior is inconsistent here, cygpath turns them
+        # into '.;' and ';.', and winepath ignores them completely.
+        func_to_host_pathlist_tmp2="$1"
+        # Once set for this call, this variable should not be
+        # reassigned. It is used in tha fallback case.
+        func_to_host_pathlist_tmp1=`echo "$func_to_host_pathlist_tmp2" |\
+          $SED -e 's|^:*||' -e 's|:*$||'`
+        case $build in
+          *mingw* ) # Actually, msys.
+            # Awkward: cmd appends spaces to result.
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_pathlist_tmp2=`( cmd //c echo "$func_to_host_pathlist_tmp1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_pathlist_tmp2=`cygpath -w -p "$func_to_host_pathlist_tmp1"`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # unfortunately, winepath doesn't convert pathlists
+            func_to_host_pathlist_result=""
+            func_to_host_pathlist_oldIFS=$IFS
+            IFS=:
+            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do
+              IFS=$func_to_host_pathlist_oldIFS
+              if test -n "$func_to_host_pathlist_f" ; then
+                func_to_host_path "$func_to_host_pathlist_f"
+                if test -n "$func_to_host_path_result" ; then
+                  if test -z "$func_to_host_pathlist_result" ; then
+                    func_to_host_pathlist_result="$func_to_host_path_result"
+                  else
+                    func_to_host_pathlist_result="$func_to_host_pathlist_result;$func_to_host_path_result"
+                  fi
+                fi
+              fi
+              IFS=:
+            done
+            IFS=$func_to_host_pathlist_oldIFS
+            ;;
+        esac
+        if test -z "$func_to_host_pathlist_result" ; then
+          func_error "Could not determine the host path(s) corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback. This may break if $1 contains DOS-style drive
+          # specifications. The fix is not to complicate the expression
+          # below, but for the user to provide a working wine installation
+          # with winepath so that path translation in the cross-to-mingw
+          # case works properly.
+          lt_replace_pathsep_nix_to_dos="s|:|;|g"
+          func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp1" |\
+            $SED -e "$lt_replace_pathsep_nix_to_dos"`
+        fi
+        # Now, add the leading and trailing path separators back
+        case "$1" in
+          :* ) func_to_host_pathlist_result=";$func_to_host_pathlist_result"
+            ;;
+        esac
+        case "$1" in
+          *: ) func_to_host_pathlist_result="$func_to_host_pathlist_result;"
+            ;;
+        esac
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_pathlist
+
+# func_emit_cwrapperexe_src
+# emit the source code for a wrapper executable on stdout
+# Must ONLY be called from within func_mode_link because
+# it depends on a number of variable set therein.
+func_emit_cwrapperexe_src ()
+{
+	cat <<EOF
+
+/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
+   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+
+   The $output program cannot be directly executed until all the libtool
+   libraries that it depends on are installed.
+
+   This wrapper executable should never be moved out of the build directory.
+   If it is, it will not operate correctly.
+
+   Currently, it simply execs the wrapper *script* "$SHELL $output",
+   but could eventually absorb all of the scripts functionality and
+   exec $objdir/$outputname directly.
+*/
+EOF
+	    cat <<"EOF"
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef _MSC_VER
+# include <direct.h>
+# include <process.h>
+# include <io.h>
+# define setmode _setmode
+#else
+# include <unistd.h>
+# include <stdint.h>
+# ifdef __CYGWIN__
+#  include <io.h>
+#  define HAVE_SETENV
+#  ifdef __STRICT_ANSI__
+char *realpath (const char *, char *);
+int putenv (char *);
+int setenv (const char *, const char *, int);
+#  endif
+# endif
+#endif
+#include <malloc.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#if defined(PATH_MAX)
+# define LT_PATHMAX PATH_MAX
+#elif defined(MAXPATHLEN)
+# define LT_PATHMAX MAXPATHLEN
+#else
+# define LT_PATHMAX 1024
+#endif
+
+#ifndef S_IXOTH
+# define S_IXOTH 0
+#endif
+#ifndef S_IXGRP
+# define S_IXGRP 0
+#endif
+
+#ifdef _MSC_VER
+# define S_IXUSR _S_IEXEC
+# define stat _stat
+# ifndef _INTPTR_T_DEFINED
+#  define intptr_t int
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR
+# define DIR_SEPARATOR '/'
+# define PATH_SEPARATOR ':'
+#endif
+
+#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
+  defined (__OS2__)
+# define HAVE_DOS_BASED_FILE_SYSTEM
+# define FOPEN_WB "wb"
+# ifndef DIR_SEPARATOR_2
+#  define DIR_SEPARATOR_2 '\\'
+# endif
+# ifndef PATH_SEPARATOR_2
+#  define PATH_SEPARATOR_2 ';'
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR_2
+# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#else /* DIR_SEPARATOR_2 */
+# define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#endif /* DIR_SEPARATOR_2 */
+
+#ifndef PATH_SEPARATOR_2
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)
+#else /* PATH_SEPARATOR_2 */
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)
+#endif /* PATH_SEPARATOR_2 */
+
+#ifdef __CYGWIN__
+# define FOPEN_WB "wb"
+#endif
+
+#ifndef FOPEN_WB
+# define FOPEN_WB "w"
+#endif
+#ifndef _O_BINARY
+# define _O_BINARY 0
+#endif
+
+#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
+#define XFREE(stale) do { \
+  if (stale) { free ((void *) stale); stale = 0; } \
+} while (0)
+
+#undef LTWRAPPER_DEBUGPRINTF
+#if defined DEBUGWRAPPER
+# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args
+static void
+ltwrapper_debugprintf (const char *fmt, ...)
+{
+    va_list args;
+    va_start (args, fmt);
+    (void) vfprintf (stderr, fmt, args);
+    va_end (args);
+}
+#else
+# define LTWRAPPER_DEBUGPRINTF(args)
+#endif
+
+const char *program_name = NULL;
+
+void *xmalloc (size_t num);
+char *xstrdup (const char *string);
+const char *base_name (const char *name);
+char *find_executable (const char *wrapper);
+char *chase_symlinks (const char *pathspec);
+int make_executable (const char *path);
+int check_executable (const char *path);
+char *strendzap (char *str, const char *pat);
+void lt_fatal (const char *message, ...);
+void lt_setenv (const char *name, const char *value);
+char *lt_extend_str (const char *orig_value, const char *add, int to_end);
+void lt_opt_process_env_set (const char *arg);
+void lt_opt_process_env_prepend (const char *arg);
+void lt_opt_process_env_append (const char *arg);
+int lt_split_name_value (const char *arg, char** name, char** value);
+void lt_update_exe_path (const char *name, const char *value);
+void lt_update_lib_path (const char *name, const char *value);
+
+static const char *script_text_part1 =
+EOF
+
+	    func_emit_wrapper_part1 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+	    cat <<EOF
+
+static const char *script_text_part2 =
+EOF
+	    func_emit_wrapper_part2 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+
+	    cat <<EOF
+const char * MAGIC_EXE = "$magic_exe";
+const char * LIB_PATH_VARNAME = "$shlibpath_var";
+EOF
+
+	    if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+              func_to_host_pathlist "$temp_rpath"
+	      cat <<EOF
+const char * LIB_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * LIB_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test -n "$dllsearchpath"; then
+              func_to_host_pathlist "$dllsearchpath:"
+	      cat <<EOF
+const char * EXE_PATH_VARNAME = "PATH";
+const char * EXE_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * EXE_PATH_VARNAME = "";
+const char * EXE_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test "$fast_install" = yes; then
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
+EOF
+	    else
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "$outputname"; /* hopefully, no .exe */
+EOF
+	    fi
+
+
+	    cat <<"EOF"
+
+#define LTWRAPPER_OPTION_PREFIX         "--lt-"
+#define LTWRAPPER_OPTION_PREFIX_LENGTH  5
+
+static const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;
+static const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;
+
+static const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX "dump-script";
+
+static const size_t env_set_opt_len     = LTWRAPPER_OPTION_PREFIX_LENGTH + 7;
+static const char *env_set_opt          = LTWRAPPER_OPTION_PREFIX "env-set";
+  /* argument is putenv-style "foo=bar", value of foo is set to bar */
+
+static const size_t env_prepend_opt_len = LTWRAPPER_OPTION_PREFIX_LENGTH + 11;
+static const char *env_prepend_opt      = LTWRAPPER_OPTION_PREFIX "env-prepend";
+  /* argument is putenv-style "foo=bar", new value of foo is bar${foo} */
+
+static const size_t env_append_opt_len  = LTWRAPPER_OPTION_PREFIX_LENGTH + 10;
+static const char *env_append_opt       = LTWRAPPER_OPTION_PREFIX "env-append";
+  /* argument is putenv-style "foo=bar", new value of foo is ${foo}bar */
+
+int
+main (int argc, char *argv[])
+{
+  char **newargz;
+  int  newargc;
+  char *tmp_pathspec;
+  char *actual_cwrapper_path;
+  char *actual_cwrapper_name;
+  char *target_name;
+  char *lt_argv_zero;
+  intptr_t rval = 127;
+
+  int i;
+
+  program_name = (char *) xstrdup (base_name (argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) argv[0]      : %s\n", argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) program_name : %s\n", program_name));
+
+  /* very simple arg parsing; don't want to rely on getopt */
+  for (i = 1; i < argc; i++)
+    {
+      if (strcmp (argv[i], dumpscript_opt) == 0)
+	{
+EOF
+	    case "$host" in
+	      *mingw* | *cygwin* )
+		# make stdout use "unix" line endings
+		echo "          setmode(1,_O_BINARY);"
+		;;
+	      esac
+
+	    cat <<"EOF"
+	  printf ("%s", script_text_part1);
+	  printf ("%s", script_text_part2);
+	  return 0;
+	}
+    }
+
+  newargz = XMALLOC (char *, argc + 1);
+  tmp_pathspec = find_executable (argv[0]);
+  if (tmp_pathspec == NULL)
+    lt_fatal ("Couldn't find %s", argv[0]);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (before symlink chase) at : %s\n",
+			  tmp_pathspec));
+
+  actual_cwrapper_path = chase_symlinks (tmp_pathspec);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (after symlink chase) at : %s\n",
+			  actual_cwrapper_path));
+  XFREE (tmp_pathspec);
+
+  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));
+  strendzap (actual_cwrapper_path, actual_cwrapper_name);
+
+  /* wrapper name transforms */
+  strendzap (actual_cwrapper_name, ".exe");
+  tmp_pathspec = lt_extend_str (actual_cwrapper_name, ".exe", 1);
+  XFREE (actual_cwrapper_name);
+  actual_cwrapper_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  /* target_name transforms -- use actual target program name; might have lt- prefix */
+  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));
+  strendzap (target_name, ".exe");
+  tmp_pathspec = lt_extend_str (target_name, ".exe", 1);
+  XFREE (target_name);
+  target_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  LTWRAPPER_DEBUGPRINTF (("(main) libtool target name: %s\n",
+			  target_name));
+EOF
+
+	    cat <<EOF
+  newargz[0] =
+    XMALLOC (char, (strlen (actual_cwrapper_path) +
+		    strlen ("$objdir") + 1 + strlen (actual_cwrapper_name) + 1));
+  strcpy (newargz[0], actual_cwrapper_path);
+  strcat (newargz[0], "$objdir");
+  strcat (newargz[0], "/");
+EOF
+
+	    cat <<"EOF"
+  /* stop here, and copy so we don't have to do this twice */
+  tmp_pathspec = xstrdup (newargz[0]);
+
+  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */
+  strcat (newargz[0], actual_cwrapper_name);
+
+  /* DO want the lt- prefix here if it exists, so use target_name */
+  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);
+  XFREE (tmp_pathspec);
+  tmp_pathspec = NULL;
+EOF
+
+	    case $host_os in
+	      mingw*)
+	    cat <<"EOF"
+  {
+    char* p;
+    while ((p = strchr (newargz[0], '\\')) != NULL)
+      {
+	*p = '/';
+      }
+    while ((p = strchr (lt_argv_zero, '\\')) != NULL)
+      {
+	*p = '/';
+      }
+  }
+EOF
+	    ;;
+	    esac
+
+	    cat <<"EOF"
+  XFREE (target_name);
+  XFREE (actual_cwrapper_path);
+  XFREE (actual_cwrapper_name);
+
+  lt_setenv ("BIN_SH", "xpg4"); /* for Tru64 */
+  lt_setenv ("DUALCASE", "1");  /* for MSK sh */
+  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);
+  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);
+
+  newargc=0;
+  for (i = 1; i < argc; i++)
+    {
+      if (strncmp (argv[i], env_set_opt, env_set_opt_len) == 0)
+        {
+          if (argv[i][env_set_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_set_opt_len + 1;
+              lt_opt_process_env_set (p);
+            }
+          else if (argv[i][env_set_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_set (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_set_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_prepend_opt, env_prepend_opt_len) == 0)
+        {
+          if (argv[i][env_prepend_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_prepend_opt_len + 1;
+              lt_opt_process_env_prepend (p);
+            }
+          else if (argv[i][env_prepend_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_prepend (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_prepend_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_append_opt, env_append_opt_len) == 0)
+        {
+          if (argv[i][env_append_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_append_opt_len + 1;
+              lt_opt_process_env_append (p);
+            }
+          else if (argv[i][env_append_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_append (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_append_opt);
+          continue;
+        }
+      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)
+        {
+          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX
+             namespace, but it is not one of the ones we know about and
+             have already dealt with, above (inluding dump-script), then
+             report an error. Otherwise, targets might begin to believe
+             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX
+             namespace. The first time any user complains about this, we'll
+             need to make LTWRAPPER_OPTION_PREFIX a configure-time option
+             or a configure.ac-settable value.
+           */
+          lt_fatal ("Unrecognized option in %s namespace: '%s'",
+                    ltwrapper_option_prefix, argv[i]);
+        }
+      /* otherwise ... */
+      newargz[++newargc] = xstrdup (argv[i]);
+    }
+  newargz[++newargc] = NULL;
+
+  LTWRAPPER_DEBUGPRINTF     (("(main) lt_argv_zero : %s\n", (lt_argv_zero ? lt_argv_zero : "<NULL>")));
+  for (i = 0; i < newargc; i++)
+    {
+      LTWRAPPER_DEBUGPRINTF (("(main) newargz[%d]   : %s\n", i, (newargz[i] ? newargz[i] : "<NULL>")));
+    }
+
+EOF
+
+	    case $host_os in
+	      mingw*)
+		cat <<"EOF"
+  /* execv doesn't actually work on mingw as expected on unix */
+  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
+  if (rval == -1)
+    {
+      /* failed to start process */
+      LTWRAPPER_DEBUGPRINTF (("(main) failed to launch target \"%s\": errno = %d\n", lt_argv_zero, errno));
+      return 127;
+    }
+  return rval;
+EOF
+		;;
+	      *)
+		cat <<"EOF"
+  execv (lt_argv_zero, newargz);
+  return rval; /* =127, but avoids unused variable warning */
+EOF
+		;;
+	    esac
+
+	    cat <<"EOF"
+}
+
+void *
+xmalloc (size_t num)
+{
+  void *p = (void *) malloc (num);
+  if (!p)
+    lt_fatal ("Memory exhausted");
+
+  return p;
+}
+
+char *
+xstrdup (const char *string)
+{
+  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),
+			  string) : NULL;
+}
+
+const char *
+base_name (const char *name)
+{
+  const char *base;
+
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Skip over the disk name in MSDOS pathnames. */
+  if (isalpha ((unsigned char) name[0]) && name[1] == ':')
+    name += 2;
+#endif
+
+  for (base = name; *name; name++)
+    if (IS_DIR_SEPARATOR (*name))
+      base = name + 1;
+  return base;
+}
+
+int
+check_executable (const char *path)
+{
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(check_executable)  : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if ((stat (path, &st) >= 0)
+      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))
+    return 1;
+  else
+    return 0;
+}
+
+int
+make_executable (const char *path)
+{
+  int rval = 0;
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(make_executable)   : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if (stat (path, &st) >= 0)
+    {
+      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);
+    }
+  return rval;
+}
+
+/* Searches for the full path of the wrapper.  Returns
+   newly allocated full path name if found, NULL otherwise
+   Does not chase symlinks, even on platforms that support them.
+*/
+char *
+find_executable (const char *wrapper)
+{
+  int has_slash = 0;
+  const char *p;
+  const char *p_next;
+  /* static buffer for getcwd */
+  char tmp[LT_PATHMAX + 1];
+  int tmp_len;
+  char *concat_name;
+
+  LTWRAPPER_DEBUGPRINTF (("(find_executable)   : %s\n",
+			  wrapper ? (*wrapper ? wrapper : "EMPTY!") : "NULL!"));
+
+  if ((wrapper == NULL) || (*wrapper == '\0'))
+    return NULL;
+
+  /* Absolute path? */
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')
+    {
+      concat_name = xstrdup (wrapper);
+      if (check_executable (concat_name))
+	return concat_name;
+      XFREE (concat_name);
+    }
+  else
+    {
+#endif
+      if (IS_DIR_SEPARATOR (wrapper[0]))
+	{
+	  concat_name = xstrdup (wrapper);
+	  if (check_executable (concat_name))
+	    return concat_name;
+	  XFREE (concat_name);
+	}
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+    }
+#endif
+
+  for (p = wrapper; *p; p++)
+    if (*p == '/')
+      {
+	has_slash = 1;
+	break;
+      }
+  if (!has_slash)
+    {
+      /* no slashes; search PATH */
+      const char *path = getenv ("PATH");
+      if (path != NULL)
+	{
+	  for (p = path; *p; p = p_next)
+	    {
+	      const char *q;
+	      size_t p_len;
+	      for (q = p; *q; q++)
+		if (IS_PATH_SEPARATOR (*q))
+		  break;
+	      p_len = q - p;
+	      p_next = (*q == '\0' ? q : q + 1);
+	      if (p_len == 0)
+		{
+		  /* empty path: current directory */
+		  if (getcwd (tmp, LT_PATHMAX) == NULL)
+		    lt_fatal ("getcwd failed");
+		  tmp_len = strlen (tmp);
+		  concat_name =
+		    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, tmp, tmp_len);
+		  concat_name[tmp_len] = '/';
+		  strcpy (concat_name + tmp_len + 1, wrapper);
+		}
+	      else
+		{
+		  concat_name =
+		    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, p, p_len);
+		  concat_name[p_len] = '/';
+		  strcpy (concat_name + p_len + 1, wrapper);
+		}
+	      if (check_executable (concat_name))
+		return concat_name;
+	      XFREE (concat_name);
+	    }
+	}
+      /* not found in PATH; assume curdir */
+    }
+  /* Relative path | not found in path: prepend cwd */
+  if (getcwd (tmp, LT_PATHMAX) == NULL)
+    lt_fatal ("getcwd failed");
+  tmp_len = strlen (tmp);
+  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+  memcpy (concat_name, tmp, tmp_len);
+  concat_name[tmp_len] = '/';
+  strcpy (concat_name + tmp_len + 1, wrapper);
+
+  if (check_executable (concat_name))
+    return concat_name;
+  XFREE (concat_name);
+  return NULL;
+}
+
+char *
+chase_symlinks (const char *pathspec)
+{
+#ifndef S_ISLNK
+  return xstrdup (pathspec);
+#else
+  char buf[LT_PATHMAX];
+  struct stat s;
+  char *tmp_pathspec = xstrdup (pathspec);
+  char *p;
+  int has_symlinks = 0;
+  while (strlen (tmp_pathspec) && !has_symlinks)
+    {
+      LTWRAPPER_DEBUGPRINTF (("checking path component for symlinks: %s\n",
+			      tmp_pathspec));
+      if (lstat (tmp_pathspec, &s) == 0)
+	{
+	  if (S_ISLNK (s.st_mode) != 0)
+	    {
+	      has_symlinks = 1;
+	      break;
+	    }
+
+	  /* search backwards for last DIR_SEPARATOR */
+	  p = tmp_pathspec + strlen (tmp_pathspec) - 1;
+	  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    p--;
+	  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    {
+	      /* no more DIR_SEPARATORS left */
+	      break;
+	    }
+	  *p = '\0';
+	}
+      else
+	{
+	  char *errstr = strerror (errno);
+	  lt_fatal ("Error accessing file %s (%s)", tmp_pathspec, errstr);
+	}
+    }
+  XFREE (tmp_pathspec);
+
+  if (!has_symlinks)
+    {
+      return xstrdup (pathspec);
+    }
+
+  tmp_pathspec = realpath (pathspec, buf);
+  if (tmp_pathspec == 0)
+    {
+      lt_fatal ("Could not follow symlinks for %s", pathspec);
+    }
+  return xstrdup (tmp_pathspec);
+#endif
+}
+
+char *
+strendzap (char *str, const char *pat)
+{
+  size_t len, patlen;
+
+  assert (str != NULL);
+  assert (pat != NULL);
+
+  len = strlen (str);
+  patlen = strlen (pat);
+
+  if (patlen <= len)
+    {
+      str += len - patlen;
+      if (strcmp (str, pat) == 0)
+	*str = '\0';
+    }
+  return str;
+}
+
+static void
+lt_error_core (int exit_status, const char *mode,
+	       const char *message, va_list ap)
+{
+  fprintf (stderr, "%s: %s: ", program_name, mode);
+  vfprintf (stderr, message, ap);
+  fprintf (stderr, ".\n");
+
+  if (exit_status >= 0)
+    exit (exit_status);
+}
+
+void
+lt_fatal (const char *message, ...)
+{
+  va_list ap;
+  va_start (ap, message);
+  lt_error_core (EXIT_FAILURE, "FATAL", message, ap);
+  va_end (ap);
+}
+
+void
+lt_setenv (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_setenv) setting '%s' to '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+  {
+#ifdef HAVE_SETENV
+    /* always make a copy, for consistency with !HAVE_SETENV */
+    char *str = xstrdup (value);
+    setenv (name, str, 1);
+#else
+    int len = strlen (name) + 1 + strlen (value) + 1;
+    char *str = XMALLOC (char, len);
+    sprintf (str, "%s=%s", name, value);
+    if (putenv (str) != EXIT_SUCCESS)
+      {
+        XFREE (str);
+      }
+#endif
+  }
+}
+
+char *
+lt_extend_str (const char *orig_value, const char *add, int to_end)
+{
+  char *new_value;
+  if (orig_value && *orig_value)
+    {
+      int orig_value_len = strlen (orig_value);
+      int add_len = strlen (add);
+      new_value = XMALLOC (char, add_len + orig_value_len + 1);
+      if (to_end)
+        {
+          strcpy (new_value, orig_value);
+          strcpy (new_value + orig_value_len, add);
+        }
+      else
+        {
+          strcpy (new_value, add);
+          strcpy (new_value + add_len, orig_value);
+        }
+    }
+  else
+    {
+      new_value = xstrdup (add);
+    }
+  return new_value;
+}
+
+int
+lt_split_name_value (const char *arg, char** name, char** value)
+{
+  const char *p;
+  int len;
+  if (!arg || !*arg)
+    return 1;
+
+  p = strchr (arg, (int)'=');
+
+  if (!p)
+    return 1;
+
+  *value = xstrdup (++p);
+
+  len = strlen (arg) - strlen (*value);
+  *name = XMALLOC (char, len);
+  strncpy (*name, arg, len-1);
+  (*name)[len - 1] = '\0';
+
+  return 0;
+}
+
+void
+lt_opt_process_env_set (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_set_opt, arg);
+    }
+
+  lt_setenv (name, value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_prepend (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_prepend_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 0);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_append (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_append_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 1);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_update_exe_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_exe_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      /* some systems can't cope with a ':'-terminated path #' */
+      int len = strlen (new_value);
+      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))
+        {
+          new_value[len-1] = '\0';
+        }
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+void
+lt_update_lib_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_lib_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+
+EOF
+}
+# end: func_emit_cwrapperexe_src
+
+# func_mode_link arg...
+func_mode_link ()
+{
+    $opt_debug
+    case $host in
+    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+      # It is impossible to link a dll without this setting, and
+      # we shouldn't force the makefile maintainer to figure out
+      # which system we are compiling for in order to pass an extra
+      # flag for every libtool invocation.
+      # allow_undefined=no
+
+      # FIXME: Unfortunately, there are problems with the above when trying
+      # to make a dll which has undefined symbols, in which case not
+      # even a static library is built.  For now, we need to specify
+      # -no-undefined on the libtool link line when we can be certain
+      # that all symbols are satisfied, otherwise we get a static library.
+      allow_undefined=yes
+      ;;
+    *)
+      allow_undefined=yes
+      ;;
+    esac
+    libtool_args=$nonopt
+    base_compile="$nonopt $@"
+    compile_command=$nonopt
+    finalize_command=$nonopt
+
+    compile_rpath=
+    finalize_rpath=
+    compile_shlibpath=
+    finalize_shlibpath=
+    convenience=
+    old_convenience=
+    deplibs=
+    old_deplibs=
+    compiler_flags=
+    linker_flags=
+    dllsearchpath=
+    lib_search_path=`pwd`
+    inst_prefix_dir=
+    new_inherited_linker_flags=
+
+    avoid_version=no
+    dlfiles=
+    dlprefiles=
+    dlself=no
+    export_dynamic=no
+    export_symbols=
+    export_symbols_regex=
+    generated=
+    libobjs=
+    ltlibs=
+    module=no
+    no_install=no
+    objs=
+    non_pic_objects=
+    precious_files_regex=
+    prefer_static_libs=no
+    preload=no
+    prev=
+    prevarg=
+    release=
+    rpath=
+    xrpath=
+    perm_rpath=
+    temp_rpath=
+    thread_safe=no
+    vinfo=
+    vinfo_number=no
+    weak_libs=
+    single_module="${wl}-single_module"
+    func_infer_tag $base_compile
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	break
+	;;
+      -all-static | -static | -static-libtool-libs)
+	case $arg in
+	-all-static)
+	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	    func_warning "complete static linking is impossible in this configuration"
+	  fi
+	  if test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	-static)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=built
+	  ;;
+	-static-libtool-libs)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	esac
+	build_libtool_libs=no
+	build_old_libs=yes
+	break
+	;;
+      esac
+    done
+
+    # See if our shared archives depend on static archives.
+    test -n "$old_archive_from_new_cmds" && build_old_libs=yes
+
+    # Go through the arguments, transforming them on the way.
+    while test "$#" -gt 0; do
+      arg="$1"
+      shift
+      func_quote_for_eval "$arg"
+      qarg=$func_quote_for_eval_unquoted_result
+      func_append libtool_args " $func_quote_for_eval_result"
+
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case $prev in
+	output)
+	  func_append compile_command " @OUTPUT@"
+	  func_append finalize_command " @OUTPUT@"
+	  ;;
+	esac
+
+	case $prev in
+	dlfiles|dlprefiles)
+	  if test "$preload" = no; then
+	    # Add the symbol object into the linking commands.
+	    func_append compile_command " @SYMFILE@"
+	    func_append finalize_command " @SYMFILE@"
+	    preload=yes
+	  fi
+	  case $arg in
+	  *.la | *.lo) ;;  # We handle these cases below.
+	  force)
+	    if test "$dlself" = no; then
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  self)
+	    if test "$prev" = dlprefiles; then
+	      dlself=yes
+	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	      dlself=yes
+	    else
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  *)
+	    if test "$prev" = dlfiles; then
+	      dlfiles="$dlfiles $arg"
+	    else
+	      dlprefiles="$dlprefiles $arg"
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  esac
+	  ;;
+	expsyms)
+	  export_symbols="$arg"
+	  test -f "$arg" \
+	    || func_fatal_error "symbol file \`$arg' does not exist"
+	  prev=
+	  continue
+	  ;;
+	expsyms_regex)
+	  export_symbols_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	framework)
+	  case $host in
+	    *-*-darwin*)
+	      case "$deplibs " in
+		*" $qarg.ltframework "*) ;;
+		*) deplibs="$deplibs $qarg.ltframework" # this is fixed later
+		   ;;
+	      esac
+	      ;;
+	  esac
+	  prev=
+	  continue
+	  ;;
+	inst_prefix)
+	  inst_prefix_dir="$arg"
+	  prev=
+	  continue
+	  ;;
+	objectlist)
+	  if test -f "$arg"; then
+	    save_arg=$arg
+	    moreargs=
+	    for fil in `cat "$save_arg"`
+	    do
+#	      moreargs="$moreargs $fil"
+	      arg=$fil
+	      # A libtool-controlled object.
+
+	      # Check to see that this really is a libtool object.
+	      if func_lalib_unsafe_p "$arg"; then
+		pic_object=
+		non_pic_object=
+
+		# Read the .lo file
+		func_source "$arg"
+
+		if test -z "$pic_object" ||
+		   test -z "$non_pic_object" ||
+		   test "$pic_object" = none &&
+		   test "$non_pic_object" = none; then
+		  func_fatal_error "cannot find name of object for \`$arg'"
+		fi
+
+		# Extract subdirectory from the argument.
+		func_dirname "$arg" "/" ""
+		xdir="$func_dirname_result"
+
+		if test "$pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  pic_object="$xdir$pic_object"
+
+		  if test "$prev" = dlfiles; then
+		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		      dlfiles="$dlfiles $pic_object"
+		      prev=
+		      continue
+		    else
+		      # If libtool objects are unsupported, then we need to preload.
+		      prev=dlprefiles
+		    fi
+		  fi
+
+		  # CHECK ME:  I think I busted this.  -Ossama
+		  if test "$prev" = dlprefiles; then
+		    # Preload the old-style object.
+		    dlprefiles="$dlprefiles $pic_object"
+		    prev=
+		  fi
+
+		  # A PIC object.
+		  func_append libobjs " $pic_object"
+		  arg="$pic_object"
+		fi
+
+		# Non-PIC object.
+		if test "$non_pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  non_pic_object="$xdir$non_pic_object"
+
+		  # A standard non-PIC object
+		  func_append non_pic_objects " $non_pic_object"
+		  if test -z "$pic_object" || test "$pic_object" = none ; then
+		    arg="$non_pic_object"
+		  fi
+		else
+		  # If the PIC object exists, use it instead.
+		  # $xdir was prepended to $pic_object above.
+		  non_pic_object="$pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+		fi
+	      else
+		# Only an error if not doing a dry-run.
+		if $opt_dry_run; then
+		  # Extract subdirectory from the argument.
+		  func_dirname "$arg" "/" ""
+		  xdir="$func_dirname_result"
+
+		  func_lo2o "$arg"
+		  pic_object=$xdir$objdir/$func_lo2o_result
+		  non_pic_object=$xdir$func_lo2o_result
+		  func_append libobjs " $pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+	        else
+		  func_fatal_error "\`$arg' is not a valid libtool object"
+		fi
+	      fi
+	    done
+	  else
+	    func_fatal_error "link input file \`$arg' does not exist"
+	  fi
+	  arg=$save_arg
+	  prev=
+	  continue
+	  ;;
+	precious_regex)
+	  precious_files_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	release)
+	  release="-$arg"
+	  prev=
+	  continue
+	  ;;
+	rpath | xrpath)
+	  # We need an absolute path.
+	  case $arg in
+	  [\\/]* | [A-Za-z]:[\\/]*) ;;
+	  *)
+	    func_fatal_error "only absolute run-paths are allowed"
+	    ;;
+	  esac
+	  if test "$prev" = rpath; then
+	    case "$rpath " in
+	    *" $arg "*) ;;
+	    *) rpath="$rpath $arg" ;;
+	    esac
+	  else
+	    case "$xrpath " in
+	    *" $arg "*) ;;
+	    *) xrpath="$xrpath $arg" ;;
+	    esac
+	  fi
+	  prev=
+	  continue
+	  ;;
+	shrext)
+	  shrext_cmds="$arg"
+	  prev=
+	  continue
+	  ;;
+	weak)
+	  weak_libs="$weak_libs $arg"
+	  prev=
+	  continue
+	  ;;
+	xcclinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xcompiler)
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xlinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $wl$qarg"
+	  prev=
+	  func_append compile_command " $wl$qarg"
+	  func_append finalize_command " $wl$qarg"
+	  continue
+	  ;;
+	*)
+	  eval "$prev=\"\$arg\""
+	  prev=
+	  continue
+	  ;;
+	esac
+      fi # test -n "$prev"
+
+      prevarg="$arg"
+
+      case $arg in
+      -all-static)
+	if test -n "$link_static_flag"; then
+	  # See comment for -static flag below, for more details.
+	  func_append compile_command " $link_static_flag"
+	  func_append finalize_command " $link_static_flag"
+	fi
+	continue
+	;;
+
+      -allow-undefined)
+	# FIXME: remove this flag sometime in the future.
+	func_fatal_error "\`-allow-undefined' must not be used because it is the default"
+	;;
+
+      -avoid-version)
+	avoid_version=yes
+	continue
+	;;
+
+      -dlopen)
+	prev=dlfiles
+	continue
+	;;
+
+      -dlpreopen)
+	prev=dlprefiles
+	continue
+	;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	continue
+	;;
+
+      -export-symbols | -export-symbols-regex)
+	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	  func_fatal_error "more than one -exported-symbols argument is not allowed"
+	fi
+	if test "X$arg" = "X-export-symbols"; then
+	  prev=expsyms
+	else
+	  prev=expsyms_regex
+	fi
+	continue
+	;;
+
+      -framework)
+	prev=framework
+	continue
+	;;
+
+      -inst-prefix-dir)
+	prev=inst_prefix
+	continue
+	;;
+
+      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*
+      # so, if we see these flags be careful not to treat them like -L
+      -L[A-Z][A-Z]*:*)
+	case $with_gcc/$host in
+	no/*-*-irix* | /*-*-irix*)
+	  func_append compile_command " $arg"
+	  func_append finalize_command " $arg"
+	  ;;
+	esac
+	continue
+	;;
+
+      -L*)
+	func_stripname '-L' '' "$arg"
+	dir=$func_stripname_result
+	if test -z "$dir"; then
+	  if test "$#" -gt 0; then
+	    func_fatal_error "require no space between \`-L' and \`$1'"
+	  else
+	    func_fatal_error "need path for \`-L' option"
+	  fi
+	fi
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  absdir=`cd "$dir" && pwd`
+	  test -z "$absdir" && \
+	    func_fatal_error "cannot determine absolute directory name of \`$dir'"
+	  dir="$absdir"
+	  ;;
+	esac
+	case "$deplibs " in
+	*" -L$dir "*) ;;
+	*)
+	  deplibs="$deplibs -L$dir"
+	  lib_search_path="$lib_search_path $dir"
+	  ;;
+	esac
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`$ECHO "X$dir" | $Xsed -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$dir:"*) ;;
+	  ::) dllsearchpath=$dir;;
+	  *) dllsearchpath="$dllsearchpath:$dir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+	continue
+	;;
+
+      -l*)
+	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc*)
+	    # These systems don't actually have a C or math library (as such)
+	    continue
+	    ;;
+	  *-*-os2*)
+	    # These systems don't actually have a C library (as such)
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C and math libraries are in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    continue
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  esac
+	elif test "X$arg" = "X-lc_r"; then
+	 case $host in
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	   # Do not include libc_r directly, use -pthread flag.
+	   continue
+	   ;;
+	 esac
+	fi
+	deplibs="$deplibs $arg"
+	continue
+	;;
+
+      -module)
+	module=yes
+	continue
+	;;
+
+      # Tru64 UNIX uses -model [arg] to determine the layout of C++
+      # classes, name mangling, and exception handling.
+      # Darwin uses the -arch flag to determine output architecture.
+      -model|-arch|-isysroot)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	prev=xcompiler
+	continue
+	;;
+
+      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	case "$new_inherited_linker_flags " in
+	    *" $arg "*) ;;
+	    * ) new_inherited_linker_flags="$new_inherited_linker_flags $arg" ;;
+	esac
+	continue
+	;;
+
+      -multi_module)
+	single_module="${wl}-multi_module"
+	continue
+	;;
+
+      -no-fast-install)
+	fast_install=no
+	continue
+	;;
+
+      -no-install)
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)
+	  # The PATH hackery in wrapper scripts is required on Windows
+	  # and Darwin in order for the loader to find any dlls it needs.
+	  func_warning "\`-no-install' is ignored for $host"
+	  func_warning "assuming \`-no-fast-install' instead"
+	  fast_install=no
+	  ;;
+	*) no_install=yes ;;
+	esac
+	continue
+	;;
+
+      -no-undefined)
+	allow_undefined=no
+	continue
+	;;
+
+      -objectlist)
+	prev=objectlist
+	continue
+	;;
+
+      -o) prev=output ;;
+
+      -precious-files-regex)
+	prev=precious_regex
+	continue
+	;;
+
+      -release)
+	prev=release
+	continue
+	;;
+
+      -rpath)
+	prev=rpath
+	continue
+	;;
+
+      -R)
+	prev=xrpath
+	continue
+	;;
+
+      -R*)
+	func_stripname '-R' '' "$arg"
+	dir=$func_stripname_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  func_fatal_error "only absolute run-paths are allowed"
+	  ;;
+	esac
+	case "$xrpath " in
+	*" $dir "*) ;;
+	*) xrpath="$xrpath $dir" ;;
+	esac
+	continue
+	;;
+
+      -shared)
+	# The effects of -shared are defined in a previous loop.
+	continue
+	;;
+
+      -shrext)
+	prev=shrext
+	continue
+	;;
+
+      -static | -static-libtool-libs)
+	# The effects of -static are defined in a previous loop.
+	# We used to do the same as -all-static on platforms that
+	# didn't have a PIC flag, but the assumption that the effects
+	# would be equivalent was wrong.  It would break on at least
+	# Digital Unix and AIX.
+	continue
+	;;
+
+      -thread-safe)
+	thread_safe=yes
+	continue
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+
+      -version-number)
+	prev=vinfo
+	vinfo_number=yes
+	continue
+	;;
+
+      -weak)
+        prev=weak
+	continue
+	;;
+
+      -Wc,*)
+	func_stripname '-Wc,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Wl,*)
+	func_stripname '-Wl,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $wl$func_quote_for_eval_result"
+	  linker_flags="$linker_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Xcompiler)
+	prev=xcompiler
+	continue
+	;;
+
+      -Xlinker)
+	prev=xlinker
+	continue
+	;;
+
+      -XCClinker)
+	prev=xcclinker
+	continue
+	;;
+
+      # -msg_* for osf cc
+      -msg_*)
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler
+      # -r[0-9][0-9]* specifies the processor on the SGI compiler
+      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler
+      # +DA*, +DD* enable 64-bit mode on the HP compiler
+      # -q* pass through compiler args for the IBM compiler
+      # -m*, -t[45]*, -txscale* pass through architecture-specific
+      # compiler args for GCC
+      # -F/path gives path to uninstalled frameworks, gcc on darwin
+      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC
+      # @file GCC response files
+      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
+      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+        func_append compile_command " $arg"
+        func_append finalize_command " $arg"
+        compiler_flags="$compiler_flags $arg"
+        continue
+        ;;
+
+      # Some other compiler flag.
+      -* | +*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      *.$objext)
+	# A standard object.
+	objs="$objs $arg"
+	;;
+
+      *.lo)
+	# A libtool-controlled object.
+
+	# Check to see that this really is a libtool object.
+	if func_lalib_unsafe_p "$arg"; then
+	  pic_object=
+	  non_pic_object=
+
+	  # Read the .lo file
+	  func_source "$arg"
+
+	  if test -z "$pic_object" ||
+	     test -z "$non_pic_object" ||
+	     test "$pic_object" = none &&
+	     test "$non_pic_object" = none; then
+	    func_fatal_error "cannot find name of object for \`$arg'"
+	  fi
+
+	  # Extract subdirectory from the argument.
+	  func_dirname "$arg" "/" ""
+	  xdir="$func_dirname_result"
+
+	  if test "$pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    pic_object="$xdir$pic_object"
+
+	    if test "$prev" = dlfiles; then
+	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		dlfiles="$dlfiles $pic_object"
+		prev=
+		continue
+	      else
+		# If libtool objects are unsupported, then we need to preload.
+		prev=dlprefiles
+	      fi
+	    fi
+
+	    # CHECK ME:  I think I busted this.  -Ossama
+	    if test "$prev" = dlprefiles; then
+	      # Preload the old-style object.
+	      dlprefiles="$dlprefiles $pic_object"
+	      prev=
+	    fi
+
+	    # A PIC object.
+	    func_append libobjs " $pic_object"
+	    arg="$pic_object"
+	  fi
+
+	  # Non-PIC object.
+	  if test "$non_pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    non_pic_object="$xdir$non_pic_object"
+
+	    # A standard non-PIC object
+	    func_append non_pic_objects " $non_pic_object"
+	    if test -z "$pic_object" || test "$pic_object" = none ; then
+	      arg="$non_pic_object"
+	    fi
+	  else
+	    # If the PIC object exists, use it instead.
+	    # $xdir was prepended to $pic_object above.
+	    non_pic_object="$pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  fi
+	else
+	  # Only an error if not doing a dry-run.
+	  if $opt_dry_run; then
+	    # Extract subdirectory from the argument.
+	    func_dirname "$arg" "/" ""
+	    xdir="$func_dirname_result"
+
+	    func_lo2o "$arg"
+	    pic_object=$xdir$objdir/$func_lo2o_result
+	    non_pic_object=$xdir$func_lo2o_result
+	    func_append libobjs " $pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  else
+	    func_fatal_error "\`$arg' is not a valid libtool object"
+	  fi
+	fi
+	;;
+
+      *.$libext)
+	# An archive.
+	deplibs="$deplibs $arg"
+	old_deplibs="$old_deplibs $arg"
+	continue
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	if test "$prev" = dlfiles; then
+	  # This library was specified with -dlopen.
+	  dlfiles="$dlfiles $arg"
+	  prev=
+	elif test "$prev" = dlprefiles; then
+	  # The library was specified with -dlpreopen.
+	  dlprefiles="$dlprefiles $arg"
+	  prev=
+	else
+	  deplibs="$deplibs $arg"
+	fi
+	continue
+	;;
+
+      # Some other compiler argument.
+      *)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+      esac # arg
+
+      # Now actually substitute the argument into the commands.
+      if test -n "$arg"; then
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+      fi
+    done # argument parsing loop
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prevarg' option requires an argument"
+
+    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+      eval arg=\"$export_dynamic_flag_spec\"
+      func_append compile_command " $arg"
+      func_append finalize_command " $arg"
+    fi
+
+    oldlibs=
+    # calculate the name of the file, without its directory
+    func_basename "$output"
+    outputname="$func_basename_result"
+    libobjs_save="$libobjs"
+
+    if test -n "$shlibpath_var"; then
+      # get the directories listed in $shlibpath_var
+      eval shlib_search_path=\`\$ECHO \"X\${$shlibpath_var}\" \| \$Xsed -e \'s/:/ /g\'\`
+    else
+      shlib_search_path=
+    fi
+    eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
+    eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
+
+    func_dirname "$output" "/" ""
+    output_objdir="$func_dirname_result$objdir"
+    # Create the object directory.
+    func_mkdir_p "$output_objdir"
+
+    # Determine the type of output
+    case $output in
+    "")
+      func_fatal_help "you must specify an output file"
+      ;;
+    *.$libext) linkmode=oldlib ;;
+    *.lo | *.$objext) linkmode=obj ;;
+    *.la) linkmode=lib ;;
+    *) linkmode=prog ;; # Anything else should be a program.
+    esac
+
+    specialdeplibs=
+
+    libs=
+    # Find all interdependent deplibs by searching for libraries
+    # that are linked more than once (e.g. -la -lb -la)
+    for deplib in $deplibs; do
+      if $opt_duplicate_deps ; then
+	case "$libs " in
+	*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	esac
+      fi
+      libs="$libs $deplib"
+    done
+
+    if test "$linkmode" = lib; then
+      libs="$predeps $libs $compiler_lib_search_path $postdeps"
+
+      # Compute libraries that are listed more than once in $predeps
+      # $postdeps and mark them as special (i.e., whose duplicates are
+      # not to be eliminated).
+      pre_post_deps=
+      if $opt_duplicate_compiler_generated_deps; then
+	for pre_post_dep in $predeps $postdeps; do
+	  case "$pre_post_deps " in
+	  *" $pre_post_dep "*) specialdeplibs="$specialdeplibs $pre_post_deps" ;;
+	  esac
+	  pre_post_deps="$pre_post_deps $pre_post_dep"
+	done
+      fi
+      pre_post_deps=
+    fi
+
+    deplibs=
+    newdependency_libs=
+    newlib_search_path=
+    need_relink=no # whether we're linking any uninstalled libtool libraries
+    notinst_deplibs= # not-installed libtool libraries
+    notinst_path= # paths that contain not-installed libtool libraries
+
+    case $linkmode in
+    lib)
+	passes="conv dlpreopen link"
+	for file in $dlfiles $dlprefiles; do
+	  case $file in
+	  *.la) ;;
+	  *)
+	    func_fatal_help "libraries can \`-dlopen' only libtool libraries: $file"
+	    ;;
+	  esac
+	done
+	;;
+    prog)
+	compile_deplibs=
+	finalize_deplibs=
+	alldeplibs=no
+	newdlfiles=
+	newdlprefiles=
+	passes="conv scan dlopen dlpreopen link"
+	;;
+    *)  passes="conv"
+	;;
+    esac
+
+    for pass in $passes; do
+      # The preopen pass in lib mode reverses $deplibs; put it back here
+      # so that -L comes before libs that need it for instance...
+      if test "$linkmode,$pass" = "lib,link"; then
+	## FIXME: Find the place where the list is rebuilt in the wrong
+	##        order, and fix it there properly
+        tmp_deplibs=
+	for deplib in $deplibs; do
+	  tmp_deplibs="$deplib $tmp_deplibs"
+	done
+	deplibs="$tmp_deplibs"
+      fi
+
+      if test "$linkmode,$pass" = "lib,link" ||
+	 test "$linkmode,$pass" = "prog,scan"; then
+	libs="$deplibs"
+	deplibs=
+      fi
+      if test "$linkmode" = prog; then
+	case $pass in
+	dlopen) libs="$dlfiles" ;;
+	dlpreopen) libs="$dlprefiles" ;;
+	link)
+	  libs="$deplibs %DEPLIBS%"
+	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
+	  ;;
+	esac
+      fi
+      if test "$linkmode,$pass" = "lib,dlpreopen"; then
+	# Collect and forward deplibs of preopened libtool libs
+	for lib in $dlprefiles; do
+	  # Ignore non-libtool-libs
+	  dependency_libs=
+	  case $lib in
+	  *.la)	func_source "$lib" ;;
+	  esac
+
+	  # Collect preopened libtool deplibs, except any this library
+	  # has declared as weak libs
+	  for deplib in $dependency_libs; do
+            deplib_base=`$ECHO "X$deplib" | $Xsed -e "$basename"`
+	    case " $weak_libs " in
+	    *" $deplib_base "*) ;;
+	    *) deplibs="$deplibs $deplib" ;;
+	    esac
+	  done
+	done
+	libs="$dlprefiles"
+      fi
+      if test "$pass" = dlopen; then
+	# Collect dlpreopened libraries
+	save_deplibs="$deplibs"
+	deplibs=
+      fi
+
+      for deplib in $libs; do
+	lib=
+	found=no
+	case $deplib in
+	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    compiler_flags="$compiler_flags $deplib"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-l*)
+	  if test "$linkmode" != lib && test "$linkmode" != prog; then
+	    func_warning "\`-l' is ignored for archives/objects"
+	    continue
+	  fi
+	  func_stripname '-l' '' "$deplib"
+	  name=$func_stripname_result
+	  if test "$linkmode" = lib; then
+	    searchdirs="$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path"
+	  else
+	    searchdirs="$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path"
+	  fi
+	  for searchdir in $searchdirs; do
+	    for search_ext in .la $std_shrext .so .a; do
+	      # Search the libtool library
+	      lib="$searchdir/lib${name}${search_ext}"
+	      if test -f "$lib"; then
+		if test "$search_ext" = ".la"; then
+		  found=yes
+		else
+		  found=no
+		fi
+		break 2
+	      fi
+	    done
+	  done
+	  if test "$found" != yes; then
+	    # deplib doesn't seem to be a libtool library
+	    if test "$linkmode,$pass" = "prog,link"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
+	  else # deplib is a libtool library
+	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
+	    # We need to do some special things here, and not later.
+	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      case " $predeps $postdeps " in
+	      *" $deplib "*)
+		if func_lalib_p "$lib"; then
+		  library_names=
+		  old_library=
+		  func_source "$lib"
+		  for l in $old_library $library_names; do
+		    ll="$l"
+		  done
+		  if test "X$ll" = "X$old_library" ; then # only static version available
+		    found=no
+		    func_dirname "$lib" "" "."
+		    ladir="$func_dirname_result"
+		    lib=$ladir/$old_library
+		    if test "$linkmode,$pass" = "prog,link"; then
+		      compile_deplibs="$deplib $compile_deplibs"
+		      finalize_deplibs="$deplib $finalize_deplibs"
+		    else
+		      deplibs="$deplib $deplibs"
+		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		    fi
+		    continue
+		  fi
+		fi
+		;;
+	      *) ;;
+	      esac
+	    fi
+	  fi
+	  ;; # -l
+	*.ltframework)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    deplibs="$deplib $deplibs"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-L*)
+	  case $linkmode in
+	  lib)
+	    deplibs="$deplib $deplibs"
+	    test "$pass" = conv && continue
+	    newdependency_libs="$deplib $newdependency_libs"
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  prog)
+	    if test "$pass" = conv; then
+	      deplibs="$deplib $deplibs"
+	      continue
+	    fi
+	    if test "$pass" = scan; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  *)
+	    func_warning "\`-L' is ignored for archives/objects"
+	    ;;
+	  esac # linkmode
+	  continue
+	  ;; # -L
+	-R*)
+	  if test "$pass" = link; then
+	    func_stripname '-R' '' "$deplib"
+	    dir=$func_stripname_result
+	    # Make sure the xrpath contains only unique directories.
+	    case "$xrpath " in
+	    *" $dir "*) ;;
+	    *) xrpath="$xrpath $dir" ;;
+	    esac
+	  fi
+	  deplibs="$deplib $deplibs"
+	  continue
+	  ;;
+	*.la) lib="$deplib" ;;
+	*.$libext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	    continue
+	  fi
+	  case $linkmode in
+	  lib)
+	    # Linking convenience modules into shared libraries is allowed,
+	    # but linking other static libraries is non-portable.
+	    case " $dlpreconveniencelibs " in
+	    *" $deplib "*) ;;
+	    *)
+	      valid_a_lib=no
+	      case $deplibs_check_method in
+		match_pattern*)
+		  set dummy $deplibs_check_method; shift
+		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+		  if eval "\$ECHO \"X$deplib\"" 2>/dev/null | $Xsed -e 10q \
+		    | $EGREP "$match_pattern_regex" > /dev/null; then
+		    valid_a_lib=yes
+		  fi
+		;;
+		pass_all)
+		  valid_a_lib=yes
+		;;
+	      esac
+	      if test "$valid_a_lib" != yes; then
+		$ECHO
+		$ECHO "*** Warning: Trying to link with static lib archive $deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because the file extensions .$libext of this argument makes me believe"
+		$ECHO "*** that it is just a static archive that I should not use here."
+	      else
+		$ECHO
+		$ECHO "*** Warning: Linking the shared library $output against the"
+		$ECHO "*** static library $deplib is not portable!"
+		deplibs="$deplib $deplibs"
+	      fi
+	      ;;
+	    esac
+	    continue
+	    ;;
+	  prog)
+	    if test "$pass" != link; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    continue
+	    ;;
+	  esac # linkmode
+	  ;; # *.$libext
+	*.lo | *.$objext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	  elif test "$linkmode" = prog; then
+	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	      # If there is no dlopen support or we're linking statically,
+	      # we need to preload.
+	      newdlprefiles="$newdlprefiles $deplib"
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      newdlfiles="$newdlfiles $deplib"
+	    fi
+	  fi
+	  continue
+	  ;;
+	%DEPLIBS%)
+	  alldeplibs=yes
+	  continue
+	  ;;
+	esac # case $deplib
+
+	if test "$found" = yes || test -f "$lib"; then :
+	else
+	  func_fatal_error "cannot find the library \`$lib' or unhandled argument \`$deplib'"
+	fi
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$lib" \
+	  || func_fatal_error "\`$lib' is not a valid libtool archive"
+
+	func_dirname "$lib" "" "."
+	ladir="$func_dirname_result"
+
+	dlname=
+	dlopen=
+	dlpreopen=
+	libdir=
+	library_names=
+	old_library=
+	inherited_linker_flags=
+	# If the library was installed with an old release of libtool,
+	# it will not redefine variables installed, or shouldnotlink
+	installed=yes
+	shouldnotlink=no
+	avoidtemprpath=
+
+
+	# Read the .la file
+	func_source "$lib"
+
+	# Convert "-framework foo" to "foo.ltframework"
+	if test -n "$inherited_linker_flags"; then
+	  tmp_inherited_linker_flags=`$ECHO "X$inherited_linker_flags" | $Xsed -e 's/-framework \([^ $]*\)/\1.ltframework/g'`
+	  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do
+	    case " $new_inherited_linker_flags " in
+	      *" $tmp_inherited_linker_flag "*) ;;
+	      *) new_inherited_linker_flags="$new_inherited_linker_flags $tmp_inherited_linker_flag";;
+	    esac
+	  done
+	fi
+	dependency_libs=`$ECHO "X $dependency_libs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	if test "$linkmode,$pass" = "lib,link" ||
+	   test "$linkmode,$pass" = "prog,scan" ||
+	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	  test -n "$dlopen" && dlfiles="$dlfiles $dlopen"
+	  test -n "$dlpreopen" && dlprefiles="$dlprefiles $dlpreopen"
+	fi
+
+	if test "$pass" = conv; then
+	  # Only check for convenience libraries
+	  deplibs="$lib $deplibs"
+	  if test -z "$libdir"; then
+	    if test -z "$old_library"; then
+	      func_fatal_error "cannot find name of link library for \`$lib'"
+	    fi
+	    # It is a libtool convenience library, so add in its objects.
+	    convenience="$convenience $ladir/$objdir/$old_library"
+	    old_convenience="$old_convenience $ladir/$objdir/$old_library"
+	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
+	    func_fatal_error "\`$lib' is not a convenience library"
+	  fi
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    deplibs="$deplib $deplibs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+	  continue
+	fi # $pass = conv
+
+
+	# Get the name of the library we link against.
+	linklib=
+	for l in $old_library $library_names; do
+	  linklib="$l"
+	done
+	if test -z "$linklib"; then
+	  func_fatal_error "cannot find name of link library for \`$lib'"
+	fi
+
+	# This library was specified with -dlopen.
+	if test "$pass" = dlopen; then
+	  if test -z "$libdir"; then
+	    func_fatal_error "cannot -dlopen a convenience library: \`$lib'"
+	  fi
+	  if test -z "$dlname" ||
+	     test "$dlopen_support" != yes ||
+	     test "$build_libtool_libs" = no; then
+	    # If there is no dlname, no dlopen support or we're linking
+	    # statically, we need to preload.  We also need to preload any
+	    # dependent libraries so libltdl's deplib preloader doesn't
+	    # bomb out in the load deplibs phase.
+	    dlprefiles="$dlprefiles $lib $dependency_libs"
+	  else
+	    newdlfiles="$newdlfiles $lib"
+	  fi
+	  continue
+	fi # $pass = dlopen
+
+	# We need an absolute path.
+	case $ladir in
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	*)
+	  abs_ladir=`cd "$ladir" && pwd`
+	  if test -z "$abs_ladir"; then
+	    func_warning "cannot determine absolute directory name of \`$ladir'"
+	    func_warning "passing it literally to the linker, although it might fail"
+	    abs_ladir="$ladir"
+	  fi
+	  ;;
+	esac
+	func_basename "$lib"
+	laname="$func_basename_result"
+
+	# Find the relevant object directory and library name.
+	if test "X$installed" = Xyes; then
+	  if test ! -f "$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    func_warning "library \`$lib' was moved."
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    libdir="$abs_ladir"
+	  else
+	    dir="$libdir"
+	    absdir="$libdir"
+	  fi
+	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	else
+	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  else
+	    dir="$ladir/$objdir"
+	    absdir="$abs_ladir/$objdir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  fi
+	fi # $installed = yes
+	func_stripname 'lib' '.la' "$laname"
+	name=$func_stripname_result
+
+	# This library was specified with -dlpreopen.
+	if test "$pass" = dlpreopen; then
+	  if test -z "$libdir" && test "$linkmode" = prog; then
+	    func_fatal_error "only libraries may -dlpreopen a convenience library: \`$lib'"
+	  fi
+	  # Prefer using a static library (so that no silly _DYNAMIC symbols
+	  # are required to link).
+	  if test -n "$old_library"; then
+	    newdlprefiles="$newdlprefiles $dir/$old_library"
+	    # Keep a list of preopened convenience libraries to check
+	    # that they are being used correctly in the link pass.
+	    test -z "$libdir" && \
+		dlpreconveniencelibs="$dlpreconveniencelibs $dir/$old_library"
+	  # Otherwise, use the dlname, so that lt_dlopen finds it.
+	  elif test -n "$dlname"; then
+	    newdlprefiles="$newdlprefiles $dir/$dlname"
+	  else
+	    newdlprefiles="$newdlprefiles $dir/$linklib"
+	  fi
+	fi # $pass = dlpreopen
+
+	if test -z "$libdir"; then
+	  # Link the convenience library
+	  if test "$linkmode" = lib; then
+	    deplibs="$dir/$old_library $deplibs"
+	  elif test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$dir/$old_library $compile_deplibs"
+	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
+	  else
+	    deplibs="$lib $deplibs" # used for prog,scan pass
+	  fi
+	  continue
+	fi
+
+
+	if test "$linkmode" = prog && test "$pass" != link; then
+	  newlib_search_path="$newlib_search_path $ladir"
+	  deplibs="$lib $deplibs"
+
+	  linkalldeplibs=no
+	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
+	     test "$build_libtool_libs" = no; then
+	    linkalldeplibs=yes
+	  fi
+
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    case $deplib in
+	    -L*) func_stripname '-L' '' "$deplib"
+	         newlib_search_path="$newlib_search_path $func_stripname_result"
+		 ;;
+	    esac
+	    # Need to link against all dependency_libs?
+	    if test "$linkalldeplibs" = yes; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      # Need to hardcode shared library paths
+	      # or/and link against static libraries
+	      newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done # for deplib
+	  continue
+	fi # $linkmode = prog...
+
+	if test "$linkmode,$pass" = "prog,link"; then
+	  if test -n "$library_names" &&
+	     { { test "$prefer_static_libs" = no ||
+	         test "$prefer_static_libs,$installed" = "built,yes"; } ||
+	       test -z "$old_library"; }; then
+	    # We need to hardcode the library path
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	      # Make sure the rpath contains only unique directories.
+	      case "$temp_rpath:" in
+	      *"$absdir:"*) ;;
+	      *) temp_rpath="$temp_rpath$absdir:" ;;
+	      esac
+	    fi
+
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi # $linkmode,$pass = prog,link...
+
+	  if test "$alldeplibs" = yes &&
+	     { test "$deplibs_check_method" = pass_all ||
+	       { test "$build_libtool_libs" = yes &&
+		 test -n "$library_names"; }; }; then
+	    # We only need to search for static libraries
+	    continue
+	  fi
+	fi
+
+	link_static=no # Whether the deplib will be linked statically
+	use_static_libs=$prefer_static_libs
+	if test "$use_static_libs" = built && test "$installed" = yes; then
+	  use_static_libs=no
+	fi
+	if test -n "$library_names" &&
+	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc*)
+	      # No point in relinking DLLs because paths are not encoded
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=no
+	    ;;
+	  *)
+	    if test "$installed" = no; then
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=yes
+	    fi
+	    ;;
+	  esac
+	  # This is a shared library
+
+	  # Warn about portability, can't link against -module's on some
+	  # systems (darwin).  Don't bleat about dlopened modules though!
+	  dlopenmodule=""
+	  for dlpremoduletest in $dlprefiles; do
+	    if test "X$dlpremoduletest" = "X$lib"; then
+	      dlopenmodule="$dlpremoduletest"
+	      break
+	    fi
+	  done
+	  if test -z "$dlopenmodule" && test "$shouldnotlink" = yes && test "$pass" = link; then
+	    $ECHO
+	    if test "$linkmode" = prog; then
+	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
+	    else
+	      $ECHO "*** Warning: Linking the shared library $output against the loadable module"
+	    fi
+	    $ECHO "*** $linklib is not portable!"
+	  fi
+	  if test "$linkmode" = lib &&
+	     test "$hardcode_into_libs" = yes; then
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi
+
+	  if test -n "$old_archive_from_expsyms_cmds"; then
+	    # figure out the soname
+	    set dummy $library_names
+	    shift
+	    realname="$1"
+	    shift
+	    libname=`eval "\\$ECHO \"$libname_spec\""`
+	    # use dlname if we got it. it's perfectly good, no?
+	    if test -n "$dlname"; then
+	      soname="$dlname"
+	    elif test -n "$soname_spec"; then
+	      # bleh windows
+	      case $host in
+	      *cygwin* | mingw* | *cegcc*)
+	        func_arith $current - $age
+		major=$func_arith_result
+		versuffix="-$major"
+		;;
+	      esac
+	      eval soname=\"$soname_spec\"
+	    else
+	      soname="$realname"
+	    fi
+
+	    # Make a new name for the extract_expsyms_cmds to use
+	    soroot="$soname"
+	    func_basename "$soroot"
+	    soname="$func_basename_result"
+	    func_stripname 'lib' '.dll' "$soname"
+	    newlib=libimp-$func_stripname_result.a
+
+	    # If the library has no export list, then create one now
+	    if test -f "$output_objdir/$soname-def"; then :
+	    else
+	      func_verbose "extracting exported symbol list from \`$soname'"
+	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
+	    fi
+
+	    # Create $newlib
+	    if test -f "$output_objdir/$newlib"; then :; else
+	      func_verbose "generating import library for \`$soname'"
+	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
+	    fi
+	    # make sure the library variables are pointing to the new library
+	    dir=$output_objdir
+	    linklib=$newlib
+	  fi # test -n "$old_archive_from_expsyms_cmds"
+
+	  if test "$linkmode" = prog || test "$mode" != relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    lib_linked=yes
+	    case $hardcode_action in
+	    immediate | unsupported)
+	      if test "$hardcode_direct" = no; then
+		add="$dir/$linklib"
+		case $host in
+		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
+		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
+		    *-*-unixware7*) add_dir="-L$dir" ;;
+		  *-*-darwin* )
+		    # if the lib is a (non-dlopened) module then we can not
+		    # link against it, someone is ignoring the earlier warnings
+		    if /usr/bin/file -L $add 2> /dev/null |
+			 $GREP ": [^:]* bundle" >/dev/null ; then
+		      if test "X$dlopenmodule" != "X$lib"; then
+			$ECHO "*** Warning: lib $linklib is a module, not a shared library"
+			if test -z "$old_library" ; then
+			  $ECHO
+			  $ECHO "*** And there doesn't seem to be a static archive available"
+			  $ECHO "*** The link will probably fail, sorry"
+			else
+			  add="$dir/$old_library"
+			fi
+		      elif test -n "$old_library"; then
+			add="$dir/$old_library"
+		      fi
+		    fi
+		esac
+	      elif test "$hardcode_minus_L" = no; then
+		case $host in
+		*-*-sunos*) add_shlibpath="$dir" ;;
+		esac
+		add_dir="-L$dir"
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = no; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    relink)
+	      if test "$hardcode_direct" = yes &&
+	         test "$hardcode_direct_absolute" = no; then
+		add="$dir/$linklib"
+	      elif test "$hardcode_minus_L" = yes; then
+		add_dir="-L$dir"
+		# Try looking first in the location we're being installed to.
+		if test -n "$inst_prefix_dir"; then
+		  case $libdir in
+		    [\\/]*)
+		      add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		      ;;
+		  esac
+		fi
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = yes; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    *) lib_linked=no ;;
+	    esac
+
+	    if test "$lib_linked" != yes; then
+	      func_fatal_configuration "unsupported hardcode properties"
+	    fi
+
+	    if test -n "$add_shlibpath"; then
+	      case :$compile_shlibpath: in
+	      *":$add_shlibpath:"*) ;;
+	      *) compile_shlibpath="$compile_shlibpath$add_shlibpath:" ;;
+	      esac
+	    fi
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
+	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	      if test "$hardcode_direct" != yes &&
+		 test "$hardcode_minus_L" != yes &&
+		 test "$hardcode_shlibpath_var" = yes; then
+		case :$finalize_shlibpath: in
+		*":$libdir:"*) ;;
+		*) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+		esac
+	      fi
+	    fi
+	  fi
+
+	  if test "$linkmode" = prog || test "$mode" = relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    # Finalize command for both is simple: just hardcode it.
+	    if test "$hardcode_direct" = yes &&
+	       test "$hardcode_direct_absolute" = no; then
+	      add="$libdir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      add_dir="-L$libdir"
+	      add="-l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      case :$finalize_shlibpath: in
+	      *":$libdir:"*) ;;
+	      *) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+	      esac
+	      add="-l$name"
+	    elif test "$hardcode_automatic" = yes; then
+	      if test -n "$inst_prefix_dir" &&
+		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
+		add="$inst_prefix_dir$libdir/$linklib"
+	      else
+		add="$libdir/$linklib"
+	      fi
+	    else
+	      # We cannot seem to hardcode it, guess we'll fake it.
+	      add_dir="-L$libdir"
+	      # Try looking first in the location we're being installed to.
+	      if test -n "$inst_prefix_dir"; then
+		case $libdir in
+		  [\\/]*)
+		    add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		    ;;
+		esac
+	      fi
+	      add="-l$name"
+	    fi
+
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
+	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	    fi
+	  fi
+	elif test "$linkmode" = prog; then
+	  # Here we assume that one of hardcode_direct or hardcode_minus_L
+	  # is not unsupported.  This is valid on all known static and
+	  # shared platforms.
+	  if test "$hardcode_direct" != unsupported; then
+	    test -n "$old_library" && linklib="$old_library"
+	    compile_deplibs="$dir/$linklib $compile_deplibs"
+	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
+	  else
+	    compile_deplibs="-l$name -L$dir $compile_deplibs"
+	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
+	  fi
+	elif test "$build_libtool_libs" = yes; then
+	  # Not a shared library
+	  if test "$deplibs_check_method" != pass_all; then
+	    # We're trying link a shared library against a static one
+	    # but the system doesn't support it.
+
+	    # Just print a warning and add the library to dependency_libs so
+	    # that the program can be linked against the static library.
+	    $ECHO
+	    $ECHO "*** Warning: This system can not link to static lib archive $lib."
+	    $ECHO "*** I have the capability to make that library automatically link in when"
+	    $ECHO "*** you link to this library.  But I can only do this if you have a"
+	    $ECHO "*** shared version of the library, which you do not appear to have."
+	    if test "$module" = yes; then
+	      $ECHO "*** But as you try to build a module library, libtool will still create "
+	      $ECHO "*** a static module, that should work as long as the dlopening application"
+	      $ECHO "*** is linked with the -dlopen flag to resolve symbols at runtime."
+	      if test -z "$global_symbol_pipe"; then
+		$ECHO
+		$ECHO "*** However, this would only work if libtool was able to extract symbol"
+		$ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		$ECHO "*** not find such a program.  So, this module is probably useless."
+		$ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	      fi
+	      if test "$build_old_libs" = no; then
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  else
+	    deplibs="$dir/$old_library $deplibs"
+	    link_static=yes
+	  fi
+	fi # link shared/static library?
+
+	if test "$linkmode" = lib; then
+	  if test -n "$dependency_libs" &&
+	     { test "$hardcode_into_libs" != yes ||
+	       test "$build_old_libs" = yes ||
+	       test "$link_static" = yes; }; then
+	    # Extract -R from dependency_libs
+	    temp_deplibs=
+	    for libdir in $dependency_libs; do
+	      case $libdir in
+	      -R*) func_stripname '-R' '' "$libdir"
+	           temp_xrpath=$func_stripname_result
+		   case " $xrpath " in
+		   *" $temp_xrpath "*) ;;
+		   *) xrpath="$xrpath $temp_xrpath";;
+		   esac;;
+	      *) temp_deplibs="$temp_deplibs $libdir";;
+	      esac
+	    done
+	    dependency_libs="$temp_deplibs"
+	  fi
+
+	  newlib_search_path="$newlib_search_path $absdir"
+	  # Link against this library
+	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  # ... and its dependency_libs
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    newdependency_libs="$deplib $newdependency_libs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+
+	  if test "$link_all_deplibs" != no; then
+	    # Add the search paths of all dependency libraries
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      -L*) path="$deplib" ;;
+	      *.la)
+	        func_dirname "$deplib" "" "."
+		dir="$func_dirname_result"
+		# We need an absolute path.
+		case $dir in
+		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		*)
+		  absdir=`cd "$dir" && pwd`
+		  if test -z "$absdir"; then
+		    func_warning "cannot determine absolute directory name of \`$dir'"
+		    absdir="$dir"
+		  fi
+		  ;;
+		esac
+		if $GREP "^installed=no" $deplib > /dev/null; then
+		case $host in
+		*-*-darwin*)
+		  depdepl=
+		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names" ; then
+		    for tmp in $deplibrary_names ; do
+		      depdepl=$tmp
+		    done
+		    if test -f "$absdir/$objdir/$depdepl" ; then
+		      depdepl="$absdir/$objdir/$depdepl"
+		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
+                      if test -z "$darwin_install_name"; then
+                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
+                      fi
+		      compiler_flags="$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}"
+		      linker_flags="$linker_flags -dylib_file ${darwin_install_name}:${depdepl}"
+		      path=
+		    fi
+		  fi
+		  ;;
+		*)
+		  path="-L$absdir/$objdir"
+		  ;;
+		esac
+		else
+		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  test -z "$libdir" && \
+		    func_fatal_error "\`$deplib' is not a valid libtool archive"
+		  test "$absdir" != "$libdir" && \
+		    func_warning "\`$deplib' seems to be moved"
+
+		  path="-L$absdir"
+		fi
+		;;
+	      esac
+	      case " $deplibs " in
+	      *" $path "*) ;;
+	      *) deplibs="$path $deplibs" ;;
+	      esac
+	    done
+	  fi # link_all_deplibs != no
+	fi # linkmode = lib
+      done # for deplib in $libs
+      if test "$pass" = link; then
+	if test "$linkmode" = "prog"; then
+	  compile_deplibs="$new_inherited_linker_flags $compile_deplibs"
+	  finalize_deplibs="$new_inherited_linker_flags $finalize_deplibs"
+	else
+	  compiler_flags="$compiler_flags "`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	fi
+      fi
+      dependency_libs="$newdependency_libs"
+      if test "$pass" = dlpreopen; then
+	# Link the dlpreopened libraries before other libraries
+	for deplib in $save_deplibs; do
+	  deplibs="$deplib $deplibs"
+	done
+      fi
+      if test "$pass" != dlopen; then
+	if test "$pass" != conv; then
+	  # Make sure lib_search_path contains only unique directories.
+	  lib_search_path=
+	  for dir in $newlib_search_path; do
+	    case "$lib_search_path " in
+	    *" $dir "*) ;;
+	    *) lib_search_path="$lib_search_path $dir" ;;
+	    esac
+	  done
+	  newlib_search_path=
+	fi
+
+	if test "$linkmode,$pass" != "prog,link"; then
+	  vars="deplibs"
+	else
+	  vars="compile_deplibs finalize_deplibs"
+	fi
+	for var in $vars dependency_libs; do
+	  # Add libraries to $var in reverse order
+	  eval tmp_libs=\"\$$var\"
+	  new_libs=
+	  for deplib in $tmp_libs; do
+	    # FIXME: Pedantically, this is the right thing to do, so
+	    #        that some nasty dependency loop isn't accidentally
+	    #        broken:
+	    #new_libs="$deplib $new_libs"
+	    # Pragmatically, this seems to cause very few problems in
+	    # practice:
+	    case $deplib in
+	    -L*) new_libs="$deplib $new_libs" ;;
+	    -R*) ;;
+	    *)
+	      # And here is the reason: when a library appears more
+	      # than once as an explicit dependence of a library, or
+	      # is implicitly linked in more than once by the
+	      # compiler, it is considered special, and multiple
+	      # occurrences thereof are not removed.  Compare this
+	      # with having the same library being listed as a
+	      # dependency of multiple other libraries: in this case,
+	      # we know (pedantically, we assume) the library does not
+	      # need to be listed more than once, so we keep only the
+	      # last copy.  This is not always right, but it is rare
+	      # enough that we require users that really mean to play
+	      # such unportable linking tricks to link the library
+	      # using -Wl,-lname, so that libtool does not consider it
+	      # for duplicate removal.
+	      case " $specialdeplibs " in
+	      *" $deplib "*) new_libs="$deplib $new_libs" ;;
+	      *)
+		case " $new_libs " in
+		*" $deplib "*) ;;
+		*) new_libs="$deplib $new_libs" ;;
+		esac
+		;;
+	      esac
+	      ;;
+	    esac
+	  done
+	  tmp_libs=
+	  for deplib in $new_libs; do
+	    case $deplib in
+	    -L*)
+	      case " $tmp_libs " in
+	      *" $deplib "*) ;;
+	      *) tmp_libs="$tmp_libs $deplib" ;;
+	      esac
+	      ;;
+	    *) tmp_libs="$tmp_libs $deplib" ;;
+	    esac
+	  done
+	  eval $var=\"$tmp_libs\"
+	done # for var
+      fi
+      # Last step: remove runtime libs from dependency_libs
+      # (they stay in deplibs)
+      tmp_libs=
+      for i in $dependency_libs ; do
+	case " $predeps $postdeps $compiler_lib_search_path " in
+	*" $i "*)
+	  i=""
+	  ;;
+	esac
+	if test -n "$i" ; then
+	  tmp_libs="$tmp_libs $i"
+	fi
+      done
+      dependency_libs=$tmp_libs
+    done # for pass
+    if test "$linkmode" = prog; then
+      dlfiles="$newdlfiles"
+    fi
+    if test "$linkmode" = prog || test "$linkmode" = lib; then
+      dlprefiles="$newdlprefiles"
+    fi
+
+    case $linkmode in
+    oldlib)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for archives"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for archives" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for archives"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for archives"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info/-version-number' is ignored for archives"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for archives"
+
+      test -n "$export_symbols$export_symbols_regex" && \
+	func_warning "\`-export-symbols' is ignored for archives"
+
+      # Now set the variables for building old libraries.
+      build_libtool_libs=no
+      oldlibs="$output"
+      objs="$objs$old_deplibs"
+      ;;
+
+    lib)
+      # Make sure we only generate libraries of the form `libNAME.la'.
+      case $outputname in
+      lib*)
+	func_stripname 'lib' '.la' "$outputname"
+	name=$func_stripname_result
+	eval shared_ext=\"$shrext_cmds\"
+	eval libname=\"$libname_spec\"
+	;;
+      *)
+	test "$module" = no && \
+	  func_fatal_help "libtool library \`$output' must begin with \`lib'"
+
+	if test "$need_lib_prefix" != no; then
+	  # Add the "lib" prefix for modules if required
+	  func_stripname '' '.la' "$outputname"
+	  name=$func_stripname_result
+	  eval shared_ext=\"$shrext_cmds\"
+	  eval libname=\"$libname_spec\"
+	else
+	  func_stripname '' '.la' "$outputname"
+	  libname=$func_stripname_result
+	fi
+	;;
+      esac
+
+      if test -n "$objs"; then
+	if test "$deplibs_check_method" != pass_all; then
+	  func_fatal_error "cannot build libtool library \`$output' from non-libtool objects on this host:$objs"
+	else
+	  $ECHO
+	  $ECHO "*** Warning: Linking the shared library $output against the non-libtool"
+	  $ECHO "*** objects $objs is not portable!"
+	  libobjs="$libobjs $objs"
+	fi
+      fi
+
+      test "$dlself" != no && \
+	func_warning "\`-dlopen self' is ignored for libtool libraries"
+
+      set dummy $rpath
+      shift
+      test "$#" -gt 1 && \
+	func_warning "ignoring multiple \`-rpath's for a libtool library"
+
+      install_libdir="$1"
+
+      oldlibs=
+      if test -z "$rpath"; then
+	if test "$build_libtool_libs" = yes; then
+	  # Building a libtool convenience library.
+	  # Some compilers have problems with a `.al' extension so
+	  # convenience libraries should have the same extension an
+	  # archive normally would.
+	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
+	  build_libtool_libs=convenience
+	  build_old_libs=yes
+	fi
+
+	test -n "$vinfo" && \
+	  func_warning "\`-version-info/-version-number' is ignored for convenience libraries"
+
+	test -n "$release" && \
+	  func_warning "\`-release' is ignored for convenience libraries"
+      else
+
+	# Parse the version information argument.
+	save_ifs="$IFS"; IFS=':'
+	set dummy $vinfo 0 0 0
+	shift
+	IFS="$save_ifs"
+
+	test -n "$7" && \
+	  func_fatal_help "too many parameters to \`-version-info'"
+
+	# convert absolute version numbers to libtool ages
+	# this retains compatibility with .la files and attempts
+	# to make the code below a bit more comprehensible
+
+	case $vinfo_number in
+	yes)
+	  number_major="$1"
+	  number_minor="$2"
+	  number_revision="$3"
+	  #
+	  # There are really only two kinds -- those that
+	  # use the current revision as the major version
+	  # and those that subtract age and use age as
+	  # a minor version.  But, then there is irix
+	  # which has an extra 1 added just for fun
+	  #
+	  case $version_type in
+	  darwin|linux|osf|windows|none)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_revision"
+	    ;;
+	  freebsd-aout|freebsd-elf|sunos)
+	    current="$number_major"
+	    revision="$number_minor"
+	    age="0"
+	    ;;
+	  irix|nonstopux)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_minor"
+	    lt_irix_increment=no
+	    ;;
+	  *)
+	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    ;;
+	  esac
+	  ;;
+	no)
+	  current="$1"
+	  revision="$2"
+	  age="$3"
+	  ;;
+	esac
+
+	# Check that each of the things are valid numbers.
+	case $current in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "CURRENT \`$current' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $revision in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "REVISION \`$revision' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $age in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "AGE \`$age' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	if test "$age" -gt "$current"; then
+	  func_error "AGE \`$age' is greater than the current interface number \`$current'"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	fi
+
+	# Calculate the version variables.
+	major=
+	versuffix=
+	verstring=
+	case $version_type in
+	none) ;;
+
+	darwin)
+	  # Like Linux, but with the current version available in
+	  # verstring for coding it into the library header
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  # Darwin ld doesn't like 0 for these options...
+	  func_arith $current + 1
+	  minor_current=$func_arith_result
+	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
+	  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+	  ;;
+
+	freebsd-aout)
+	  major=".$current"
+	  versuffix=".$current.$revision";
+	  ;;
+
+	freebsd-elf)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	irix | nonstopux)
+	  if test "X$lt_irix_increment" = "Xno"; then
+	    func_arith $current - $age
+	  else
+	    func_arith $current - $age + 1
+	  fi
+	  major=$func_arith_result
+
+	  case $version_type in
+	    nonstopux) verstring_prefix=nonstopux ;;
+	    *)         verstring_prefix=sgi ;;
+	  esac
+	  verstring="$verstring_prefix$major.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$revision
+	  while test "$loop" -ne 0; do
+	    func_arith $revision - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring_prefix$major.$iface:$verstring"
+	  done
+
+	  # Before this point, $major must not contain `.'.
+	  major=.$major
+	  versuffix="$major.$revision"
+	  ;;
+
+	linux)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  ;;
+
+	osf)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix=".$current.$age.$revision"
+	  verstring="$current.$age.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$age
+	  while test "$loop" -ne 0; do
+	    func_arith $current - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring:${iface}.0"
+	  done
+
+	  # Make executables depend on our current version.
+	  verstring="$verstring:${current}.0"
+	  ;;
+
+	qnx)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	sunos)
+	  major=".$current"
+	  versuffix=".$current.$revision"
+	  ;;
+
+	windows)
+	  # Use '-' rather than '.', since we only want one
+	  # extension on DOS 8.3 filesystems.
+	  func_arith $current - $age
+	  major=$func_arith_result
+	  versuffix="-$major"
+	  ;;
+
+	*)
+	  func_fatal_configuration "unknown library version type \`$version_type'"
+	  ;;
+	esac
+
+	# Clear the version info if we defaulted, and they specified a release.
+	if test -z "$vinfo" && test -n "$release"; then
+	  major=
+	  case $version_type in
+	  darwin)
+	    # we can't check for "0.0" in archive_cmds due to quoting
+	    # problems, so we reset it completely
+	    verstring=
+	    ;;
+	  *)
+	    verstring="0.0"
+	    ;;
+	  esac
+	  if test "$need_version" = no; then
+	    versuffix=
+	  else
+	    versuffix=".0.0"
+	  fi
+	fi
+
+	# Remove version info from name if versioning should be avoided
+	if test "$avoid_version" = yes && test "$need_version" = no; then
+	  major=
+	  versuffix=
+	  verstring=""
+	fi
+
+	# Check to see if the archive will have undefined symbols.
+	if test "$allow_undefined" = yes; then
+	  if test "$allow_undefined_flag" = unsupported; then
+	    func_warning "undefined symbols not allowed in $host shared libraries"
+	    build_libtool_libs=no
+	    build_old_libs=yes
+	  fi
+	else
+	  # Don't allow undefined symbols.
+	  allow_undefined_flag="$no_undefined_flag"
+	fi
+
+      fi
+
+      func_generate_dlsyms "$libname" "$libname" "yes"
+      libobjs="$libobjs $symfileobj"
+      test "X$libobjs" = "X " && libobjs=
+
+      if test "$mode" != relink; then
+	# Remove our outputs, but don't remove object files since they
+	# may have been created when compiling PIC objects.
+	removelist=
+	tempremovelist=`$ECHO "$output_objdir/*"`
+	for p in $tempremovelist; do
+	  case $p in
+	    *.$objext | *.gcno)
+	       ;;
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
+	       if test "X$precious_files_regex" != "X"; then
+		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
+		 then
+		   continue
+		 fi
+	       fi
+	       removelist="$removelist $p"
+	       ;;
+	    *) ;;
+	  esac
+	done
+	test -n "$removelist" && \
+	  func_show_eval "${RM}r \$removelist"
+      fi
+
+      # Now set the variables for building old libraries.
+      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+	oldlibs="$oldlibs $output_objdir/$libname.$libext"
+
+	# Transform .lo files to .o files.
+	oldobjs="$objs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}'$/d' -e "$lo2o" | $NL2SP`
+      fi
+
+      # Eliminate all temporary directories.
+      #for path in $notinst_path; do
+      #	lib_search_path=`$ECHO "X$lib_search_path " | $Xsed -e "s% $path % %g"`
+      #	deplibs=`$ECHO "X$deplibs " | $Xsed -e "s% -L$path % %g"`
+      #	dependency_libs=`$ECHO "X$dependency_libs " | $Xsed -e "s% -L$path % %g"`
+      #done
+
+      if test -n "$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	temp_xrpath=
+	for libdir in $xrpath; do
+	  temp_xrpath="$temp_xrpath -R$libdir"
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	  dependency_libs="$temp_xrpath $dependency_libs"
+	fi
+      fi
+
+      # Make sure dlfiles contains only unique files that won't be dlpreopened
+      old_dlfiles="$dlfiles"
+      dlfiles=
+      for lib in $old_dlfiles; do
+	case " $dlprefiles $dlfiles " in
+	*" $lib "*) ;;
+	*) dlfiles="$dlfiles $lib" ;;
+	esac
+      done
+
+      # Make sure dlprefiles contains only unique files
+      old_dlprefiles="$dlprefiles"
+      dlprefiles=
+      for lib in $old_dlprefiles; do
+	case "$dlprefiles " in
+	*" $lib "*) ;;
+	*) dlprefiles="$dlprefiles $lib" ;;
+	esac
+      done
+
+      if test "$build_libtool_libs" = yes; then
+	if test -n "$rpath"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc*)
+	    # these systems don't actually have a c library (as such)!
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C library is in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    ;;
+	  *-*-netbsd*)
+	    # Don't link with libc until the a.out ld.so is fixed.
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    ;;
+	  *)
+	    # Add libc to deplibs on all other systems if necessary.
+	    if test "$build_libtool_need_lc" = "yes"; then
+	      deplibs="$deplibs -lc"
+	    fi
+	    ;;
+	  esac
+	fi
+
+	# Transform deplibs into only deplibs that can be linked in shared.
+	name_save=$name
+	libname_save=$libname
+	release_save=$release
+	versuffix_save=$versuffix
+	major_save=$major
+	# I'm not sure if I'm treating the release correctly.  I think
+	# release should show up in the -l (ie -lgmp5) so we don't want to
+	# add it in twice.  Is that correct?
+	release=""
+	versuffix=""
+	major=""
+	newdeplibs=
+	droppeddeps=no
+	case $deplibs_check_method in
+	pass_all)
+	  # Don't check for shared/static.  Everything works.
+	  # This might be a little naive.  We might want to check
+	  # whether the library exists or not.  But this is on
+	  # osf3 & osf4 and I'm not really sure... Just
+	  # implementing what was already the behavior.
+	  newdeplibs=$deplibs
+	  ;;
+	test_compile)
+	  # This code stresses the "libraries are programs" paradigm to its
+	  # limits. Maybe even breaks it.  We compile a program, linking it
+	  # against the deplibs as a proxy for the library.  Then we can check
+	  # whether they linked in statically or dynamically with ldd.
+	  $opt_dry_run || $RM conftest.c
+	  cat > conftest.c <<EOF
+	  int main() { return 0; }
+EOF
+	  $opt_dry_run || $RM conftest
+	  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then
+	    ldd_output=`ldd conftest`
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  case " $predeps $postdeps " in
+		  *" $i "*)
+		    newdeplibs="$newdeplibs $i"
+		    i=""
+		    ;;
+		  esac
+		fi
+		if test -n "$i" ; then
+		  libname=`eval "\\$ECHO \"$libname_spec\""`
+		  deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		  set dummy $deplib_matches; shift
+		  deplib_match=$1
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    newdeplibs="$newdeplibs $i"
+		  else
+		    droppeddeps=yes
+		    $ECHO
+		    $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		    $ECHO "*** I have the capability to make that library automatically link in when"
+		    $ECHO "*** you link to this library.  But I can only do this if you have a"
+		    $ECHO "*** shared version of the library, which I believe you do not have"
+		    $ECHO "*** because a test_compile did reveal that the linker did not use it for"
+		    $ECHO "*** its dynamic dependency list that programs get resolved with at runtime."
+		  fi
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  else
+	    # Error occurred in the first compile.  Let's try to salvage
+	    # the situation: Compile a separate program for each library.
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		$opt_dry_run || $RM conftest
+		if $LTCC $LTCFLAGS -o conftest conftest.c $i; then
+		  ldd_output=`ldd conftest`
+		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		    case " $predeps $postdeps " in
+		    *" $i "*)
+		      newdeplibs="$newdeplibs $i"
+		      i=""
+		      ;;
+		    esac
+		  fi
+		  if test -n "$i" ; then
+		    libname=`eval "\\$ECHO \"$libname_spec\""`
+		    deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		    set dummy $deplib_matches; shift
+		    deplib_match=$1
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		      newdeplibs="$newdeplibs $i"
+		    else
+		      droppeddeps=yes
+		      $ECHO
+		      $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		      $ECHO "*** I have the capability to make that library automatically link in when"
+		      $ECHO "*** you link to this library.  But I can only do this if you have a"
+		      $ECHO "*** shared version of the library, which you do not appear to have"
+		      $ECHO "*** because a test_compile did reveal that the linker did not use this one"
+		      $ECHO "*** as a dynamic dependency that programs can get resolved with at runtime."
+		    fi
+		  fi
+		else
+		  droppeddeps=yes
+		  $ECHO
+		  $ECHO "*** Warning!  Library $i is needed by this library but I was not able to"
+		  $ECHO "*** make it link in!  You will probably need to install it or some"
+		  $ECHO "*** library that it depends on before this library will be fully"
+		  $ECHO "*** functional.  Installing it before continuing would be even better."
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  fi
+	  ;;
+	file_magic*)
+	  set dummy $deplibs_check_method; shift
+	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		      # Follow soft links.
+		      if ls -lLd "$potent_lib" 2>/dev/null |
+			 $GREP " -> " >/dev/null; then
+			continue
+		      fi
+		      # The statement above tries to avoid entering an
+		      # endless loop below, in case of cyclic links.
+		      # We might still enter an endless loop, since a link
+		      # loop can be closed while we follow links,
+		      # but so what?
+		      potlib="$potent_lib"
+		      while test -h "$potlib" 2>/dev/null; do
+			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			case $potliblink in
+			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
+			*) potlib=`$ECHO "X$potlib" | $Xsed -e 's,[^/]*$,,'`"$potliblink";;
+			esac
+		      done
+		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null |
+			 $SED -e 10q |
+			 $EGREP "$file_magic_regex" > /dev/null; then
+			newdeplibs="$newdeplibs $a_deplib"
+			a_deplib=""
+			break 2
+		      fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for file magic test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a file magic. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	match_pattern*)
+	  set dummy $deplibs_check_method; shift
+	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    if eval "\$ECHO \"X$potent_lib\"" 2>/dev/null | $Xsed -e 10q | \
+		       $EGREP "$match_pattern_regex" > /dev/null; then
+		      newdeplibs="$newdeplibs $a_deplib"
+		      a_deplib=""
+		      break 2
+		    fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	none | unknown | *)
+	  newdeplibs=""
+	  tmp_deplibs=`$ECHO "X $deplibs" | $Xsed \
+	      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`
+	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    for i in $predeps $postdeps ; do
+	      # can't use Xsed below, because $i might contain '/'
+	      tmp_deplibs=`$ECHO "X $tmp_deplibs" | $Xsed -e "s,$i,,"`
+	    done
+	  fi
+	  if $ECHO "X $tmp_deplibs" | $Xsed -e 's/[	 ]//g' |
+	     $GREP . >/dev/null; then
+	    $ECHO
+	    if test "X$deplibs_check_method" = "Xnone"; then
+	      $ECHO "*** Warning: inter-library dependencies are not supported in this platform."
+	    else
+	      $ECHO "*** Warning: inter-library dependencies are not known to be supported."
+	    fi
+	    $ECHO "*** All declared inter-library dependencies are being dropped."
+	    droppeddeps=yes
+	  fi
+	  ;;
+	esac
+	versuffix=$versuffix_save
+	major=$major_save
+	release=$release_save
+	libname=$libname_save
+	name=$name_save
+
+	case $host in
+	*-*-rhapsody* | *-*-darwin1.[012])
+	  # On Rhapsody replace the C library with the System framework
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	  ;;
+	esac
+
+	if test "$droppeddeps" = yes; then
+	  if test "$module" = yes; then
+	    $ECHO
+	    $ECHO "*** Warning: libtool could not satisfy all declared inter-library"
+	    $ECHO "*** dependencies of module $libname.  Therefore, libtool will create"
+	    $ECHO "*** a static module, that should work as long as the dlopening"
+	    $ECHO "*** application is linked with the -dlopen flag."
+	    if test -z "$global_symbol_pipe"; then
+	      $ECHO
+	      $ECHO "*** However, this would only work if libtool was able to extract symbol"
+	      $ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      $ECHO "*** not find such a program.  So, this module is probably useless."
+	      $ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	    fi
+	    if test "$build_old_libs" = no; then
+	      oldlibs="$output_objdir/$libname.$libext"
+	      build_libtool_libs=module
+	      build_old_libs=yes
+	    else
+	      build_libtool_libs=no
+	    fi
+	  else
+	    $ECHO "*** The inter-library dependencies that have been dropped here will be"
+	    $ECHO "*** automatically added whenever a program is linked with this library"
+	    $ECHO "*** or is declared to -dlopen it."
+
+	    if test "$allow_undefined" = no; then
+	      $ECHO
+	      $ECHO "*** Since this library must not contain undefined symbols,"
+	      $ECHO "*** because either the platform does not support them or"
+	      $ECHO "*** it was explicitly requested with -no-undefined,"
+	      $ECHO "*** libtool will only create a static version of it."
+	      if test "$build_old_libs" = no; then
+		oldlibs="$output_objdir/$libname.$libext"
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  fi
+	fi
+	# Done checking deplibs!
+	deplibs=$newdeplibs
+      fi
+      # Time to change all our "foo.ltframework" stuff back to "-framework foo"
+      case $host in
+	*-*-darwin*)
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  new_inherited_linker_flags=`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  deplibs=`$ECHO "X $deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  ;;
+      esac
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      deplibs="$new_libs"
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+
+      # Test again, we may have decided not to build it any more
+      if test "$build_libtool_libs" = yes; then
+	if test "$hardcode_into_libs" = yes; then
+	  # Hardcode the library paths
+	  hardcode_libdirs=
+	  dep_rpath=
+	  rpath="$finalize_rpath"
+	  test "$mode" != relink && rpath="$compile_rpath$rpath"
+	  for libdir in $rpath; do
+	    if test -n "$hardcode_libdir_flag_spec"; then
+	      if test -n "$hardcode_libdir_separator"; then
+		if test -z "$hardcode_libdirs"; then
+		  hardcode_libdirs="$libdir"
+		else
+		  # Just accumulate the unique libdirs.
+		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+		  *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		    ;;
+		  *)
+		    hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		    ;;
+		  esac
+		fi
+	      else
+		eval flag=\"$hardcode_libdir_flag_spec\"
+		dep_rpath="$dep_rpath $flag"
+	      fi
+	    elif test -n "$runpath_var"; then
+	      case "$perm_rpath " in
+	      *" $libdir "*) ;;
+	      *) perm_rpath="$perm_rpath $libdir" ;;
+	      esac
+	    fi
+	  done
+	  # Substitute the hardcoded libdirs into the rpath.
+	  if test -n "$hardcode_libdir_separator" &&
+	     test -n "$hardcode_libdirs"; then
+	    libdir="$hardcode_libdirs"
+	    if test -n "$hardcode_libdir_flag_spec_ld"; then
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec_ld\"
+	    else
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec\"
+	    fi
+	  fi
+	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
+	    # We should set the runpath_var.
+	    rpath=
+	    for dir in $perm_rpath; do
+	      rpath="$rpath$dir:"
+	    done
+	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
+	  fi
+	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
+	fi
+
+	shlibpath="$finalize_shlibpath"
+	test "$mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	if test -n "$shlibpath"; then
+	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
+	fi
+
+	# Get the real and link names of the library.
+	eval shared_ext=\"$shrext_cmds\"
+	eval library_names=\"$library_names_spec\"
+	set dummy $library_names
+	shift
+	realname="$1"
+	shift
+
+	if test -n "$soname_spec"; then
+	  eval soname=\"$soname_spec\"
+	else
+	  soname="$realname"
+	fi
+	if test -z "$dlname"; then
+	  dlname=$soname
+	fi
+
+	lib="$output_objdir/$realname"
+	linknames=
+	for link
+	do
+	  linknames="$linknames $link"
+	done
+
+	# Use standard objects if they are pic
+	test -z "$pic_flag" && libobjs=`$ECHO "X$libobjs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	test "X$libobjs" = "X " && libobjs=
+
+	delfiles=
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
+	  export_symbols="$output_objdir/$libname.uexp"
+	  delfiles="$delfiles $export_symbols"
+	fi
+
+	orig_export_symbols=
+	case $host_os in
+	cygwin* | mingw* | cegcc*)
+	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
+	    # exporting using user supplied symfile
+	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
+	      # and it's NOT already a .def file. Must figure out
+	      # which of the given symbols are data symbols and tag
+	      # them as such. So, trigger use of export_symbols_cmds.
+	      # export_symbols gets reassigned inside the "prepare
+	      # the list of exported symbols" if statement, so the
+	      # include_expsyms logic still works.
+	      orig_export_symbols="$export_symbols"
+	      export_symbols=
+	      always_export_symbols=yes
+	    fi
+	  fi
+	  ;;
+	esac
+
+	# Prepare the list of exported symbols
+	if test -z "$export_symbols"; then
+	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
+	    func_verbose "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $opt_dry_run || $RM $export_symbols
+	    cmds=$export_symbols_cmds
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $cmds; do
+	      IFS="$save_ifs"
+	      eval cmd=\"$cmd\"
+	      func_len " $cmd"
+	      len=$func_len_result
+	      if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+		func_show_eval "$cmd" 'exit $?'
+		skipped_export=false
+	      else
+		# The command line is too long to execute in one step.
+		func_verbose "using reloadable object file for export list..."
+		skipped_export=:
+		# Break out early, otherwise skipped_export may be
+		# set to false by a later but shorter cmd.
+		break
+	      fi
+	    done
+	    IFS="$save_ifs"
+	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+	fi
+
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  tmp_export_symbols="$export_symbols"
+	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	  $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	fi
+
+	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
+	  # The given exports_symbols file has to be filtered, so filter it.
+	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	  # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	  # 's' commands which not all seds can handle. GNU sed should be fine
+	  # though. Also, the filter scales superlinearly with the number of
+	  # global variables. join(1) would be nice here, but unfortunately
+	  # isn't a blessed tool.
+	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	  delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	  export_symbols=$output_objdir/$libname.def
+	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	fi
+
+	tmp_deplibs=
+	for test_deplib in $deplibs; do
+	  case " $convenience " in
+	  *" $test_deplib "*) ;;
+	  *)
+	    tmp_deplibs="$tmp_deplibs $test_deplib"
+	    ;;
+	  esac
+	done
+	deplibs="$tmp_deplibs"
+
+	if test -n "$convenience"; then
+	  if test -n "$whole_archive_flag_spec" &&
+	    test "$compiler_needs_object" = yes &&
+	    test -z "$libobjs"; then
+	    # extract the archives, so we have objects to list.
+	    # TODO: could optimize this to just extract one archive.
+	    whole_archive_flag_spec=
+	  fi
+	  if test -n "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  else
+	    gentop="$output_objdir/${outputname}x"
+	    generated="$generated $gentop"
+
+	    func_extract_archives $gentop $convenience
+	    libobjs="$libobjs $func_extract_archives_result"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	fi
+
+	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	  eval flag=\"$thread_safe_flag_spec\"
+	  linker_flags="$linker_flags $flag"
+	fi
+
+	# Make a backup of the uninstalled library when relinking
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
+	fi
+
+	# Do each of the archive commands.
+	if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	    eval test_cmds=\"$module_expsym_cmds\"
+	    cmds=$module_expsym_cmds
+	  else
+	    eval test_cmds=\"$module_cmds\"
+	    cmds=$module_cmds
+	  fi
+	else
+	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	    eval test_cmds=\"$archive_expsym_cmds\"
+	    cmds=$archive_expsym_cmds
+	  else
+	    eval test_cmds=\"$archive_cmds\"
+	    cmds=$archive_cmds
+	  fi
+	fi
+
+	if test "X$skipped_export" != "X:" &&
+	   func_len " $test_cmds" &&
+	   len=$func_len_result &&
+	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  :
+	else
+	  # The command line is too long to link in one step, link piecewise
+	  # or, if using GNU ld and skipped_export is not :, use a linker
+	  # script.
+
+	  # Save the value of $output and $libobjs because we want to
+	  # use them later.  If we have whole_archive_flag_spec, we
+	  # want to use save_libobjs as it was before
+	  # whole_archive_flag_spec was expanded, because we can't
+	  # assume the linker understands whole_archive_flag_spec.
+	  # This may have to be revisited, in case too many
+	  # convenience libraries get linked in and end up exceeding
+	  # the spec.
+	  if test -z "$convenience" || test -z "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	  fi
+	  save_output=$output
+	  output_la=`$ECHO "X$output" | $Xsed -e "$basename"`
+
+	  # Clear the reloadable object creation command queue and
+	  # initialize k to one.
+	  test_cmds=
+	  concat_cmds=
+	  objlist=
+	  last_robj=
+	  k=1
+
+	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
+	    output=${output_objdir}/${output_la}.lnkscript
+	    func_verbose "creating GNU ld script: $output"
+	    $ECHO 'INPUT (' > $output
+	    for obj in $save_libobjs
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    $ECHO ')' >> $output
+	    delfiles="$delfiles $output"
+	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
+	    output=${output_objdir}/${output_la}.lnk
+	    func_verbose "creating linker input file list: $output"
+	    : > $output
+	    set x $save_libobjs
+	    shift
+	    firstobj=
+	    if test "$compiler_needs_object" = yes; then
+	      firstobj="$1 "
+	      shift
+	    fi
+	    for obj
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    delfiles="$delfiles $output"
+	    output=$firstobj\"$file_list_spec$output\"
+	  else
+	    if test -n "$save_libobjs"; then
+	      func_verbose "creating reloadable object files..."
+	      output=$output_objdir/$output_la-${k}.$objext
+	      eval test_cmds=\"$reload_cmds\"
+	      func_len " $test_cmds"
+	      len0=$func_len_result
+	      len=$len0
+
+	      # Loop over the list of objects to be linked.
+	      for obj in $save_libobjs
+	      do
+		func_len " $obj"
+		func_arith $len + $func_len_result
+		len=$func_arith_result
+		if test "X$objlist" = X ||
+		   test "$len" -lt "$max_cmd_len"; then
+		  func_append objlist " $obj"
+		else
+		  # The command $test_cmds is almost too long, add a
+		  # command to the queue.
+		  if test "$k" -eq 1 ; then
+		    # The first file doesn't have a previous command to add.
+		    eval concat_cmds=\"$reload_cmds $objlist $last_robj\"
+		  else
+		    # All subsequent reloadable object files will link in
+		    # the last one created.
+		    eval concat_cmds=\"\$concat_cmds~$reload_cmds $objlist $last_robj~\$RM $last_robj\"
+		  fi
+		  last_robj=$output_objdir/$output_la-${k}.$objext
+		  func_arith $k + 1
+		  k=$func_arith_result
+		  output=$output_objdir/$output_la-${k}.$objext
+		  objlist=$obj
+		  func_len " $last_robj"
+		  func_arith $len0 + $func_len_result
+		  len=$func_arith_result
+		fi
+	      done
+	      # Handle the remaining objects by creating one last
+	      # reloadable object file.  All subsequent reloadable object
+	      # files will link in the last one created.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$reload_cmds $objlist $last_robj\"
+	      if test -n "$last_robj"; then
+	        eval concat_cmds=\"\${concat_cmds}~\$RM $last_robj\"
+	      fi
+	      delfiles="$delfiles $output"
+
+	    else
+	      output=
+	    fi
+
+	    if ${skipped_export-false}; then
+	      func_verbose "generating symbol list for \`$libname.la'"
+	      export_symbols="$output_objdir/$libname.exp"
+	      $opt_dry_run || $RM $export_symbols
+	      libobjs=$output
+	      # Append the command to create the export file.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
+	      if test -n "$last_robj"; then
+		eval concat_cmds=\"\$concat_cmds~\$RM $last_robj\"
+	      fi
+	    fi
+
+	    test -n "$save_libobjs" &&
+	      func_verbose "creating a temporary reloadable object file: $output"
+
+	    # Loop through the commands generated above and execute them.
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $concat_cmds; do
+	      IFS="$save_ifs"
+	      $opt_silent || {
+		  func_quote_for_expand "$cmd"
+		  eval "func_echo $func_quote_for_expand_result"
+	      }
+	      $opt_dry_run || eval "$cmd" || {
+		lt_exit=$?
+
+		# Restore the uninstalled library and exit
+		if test "$mode" = relink; then
+		  ( cd "$output_objdir" && \
+		    $RM "${realname}T" && \
+		    $MV "${realname}U" "$realname" )
+		fi
+
+		exit $lt_exit
+	      }
+	    done
+	    IFS="$save_ifs"
+
+	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+
+          if ${skipped_export-false}; then
+	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	      tmp_export_symbols="$export_symbols"
+	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	      $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	    fi
+
+	    if test -n "$orig_export_symbols"; then
+	      # The given exports_symbols file has to be filtered, so filter it.
+	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	      # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	      # 's' commands which not all seds can handle. GNU sed should be fine
+	      # though. Also, the filter scales superlinearly with the number of
+	      # global variables. join(1) would be nice here, but unfortunately
+	      # isn't a blessed tool.
+	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	      delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	      export_symbols=$output_objdir/$libname.def
+	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	    fi
+	  fi
+
+	  libobjs=$output
+	  # Restore the value of output.
+	  output=$save_output
+
+	  if test -n "$convenience" && test -n "$whole_archive_flag_spec"; then
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	  # Expand the library linking commands again to reset the
+	  # value of $libobjs for piecewise linking.
+
+	  # Do each of the archive commands.
+	  if test "$module" = yes && test -n "$module_cmds" ; then
+	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	      cmds=$module_expsym_cmds
+	    else
+	      cmds=$module_cmds
+	    fi
+	  else
+	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	      cmds=$archive_expsym_cmds
+	    else
+	      cmds=$archive_cmds
+	    fi
+	  fi
+	fi
+
+	if test -n "$delfiles"; then
+	  # Append the command to remove temporary files to $cmds.
+	  eval cmds=\"\$cmds~\$RM $delfiles\"
+	fi
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  libobjs="$libobjs $func_extract_archives_result"
+	  test "X$libobjs" = "X " && libobjs=
+	fi
+
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $opt_silent || {
+	    func_quote_for_expand "$cmd"
+	    eval "func_echo $func_quote_for_expand_result"
+	  }
+	  $opt_dry_run || eval "$cmd" || {
+	    lt_exit=$?
+
+	    # Restore the uninstalled library and exit
+	    if test "$mode" = relink; then
+	      ( cd "$output_objdir" && \
+	        $RM "${realname}T" && \
+		$MV "${realname}U" "$realname" )
+	    fi
+
+	    exit $lt_exit
+	  }
+	done
+	IFS="$save_ifs"
+
+	# Restore the uninstalled library and exit
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
+
+	  if test -n "$convenience"; then
+	    if test -z "$whole_archive_flag_spec"; then
+	      func_show_eval '${RM}r "$gentop"'
+	    fi
+	  fi
+
+	  exit $EXIT_SUCCESS
+	fi
+
+	# Create links to the real library.
+	for linkname in $linknames; do
+	  if test "$realname" != "$linkname"; then
+	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
+	  fi
+	done
+
+	# If -module or -export-dynamic was specified, set the dlname.
+	if test "$module" = yes || test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    obj)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for objects"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for objects" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for objects"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for objects"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for objects"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for objects"
+
+      case $output in
+      *.lo)
+	test -n "$objs$old_deplibs" && \
+	  func_fatal_error "cannot build library object \`$output' from non-libtool objects"
+
+	libobj=$output
+	func_lo2o "$libobj"
+	obj=$func_lo2o_result
+	;;
+      *)
+	libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $opt_dry_run || $RM $obj $libobj
+
+      # Objects from convenience libraries.  This assumes
+      # single-version convenience libraries.  Whenever we create
+      # different ones for PIC/non-PIC, this we'll have to duplicate
+      # the extraction.
+      reload_conv_objs=
+      gentop=
+      # reload_cmds runs $LD directly, so let us get rid of
+      # -Wl from whole_archive_flag_spec and hope we can get by with
+      # turning comma into space..
+      wl=
+
+      if test -n "$convenience"; then
+	if test -n "$whole_archive_flag_spec"; then
+	  eval tmp_whole_archive_flags=\"$whole_archive_flag_spec\"
+	  reload_conv_objs=$reload_objs\ `$ECHO "X$tmp_whole_archive_flags" | $Xsed -e 's|,| |g'`
+	else
+	  gentop="$output_objdir/${obj}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $convenience
+	  reload_conv_objs="$reload_objs $func_extract_archives_result"
+	fi
+      fi
+
+      # Create the old-style object.
+      reload_objs="$objs$old_deplibs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}$'/d' -e '/\.lib$/d' -e "$lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+
+      output="$obj"
+      func_execute_cmds "$reload_cmds" 'exit $?'
+
+      # Exit if we aren't doing a library object file.
+      if test -z "$libobj"; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$build_libtool_libs" != yes; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	# Create an invalid libtool object if no PIC, so that we don't
+	# accidentally link it into a program.
+	# $show "echo timestamp > $libobj"
+	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test -n "$pic_flag" || test "$pic_mode" != default; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs $reload_conv_objs"
+	output="$libobj"
+	func_execute_cmds "$reload_cmds" 'exit $?'
+      fi
+
+      if test -n "$gentop"; then
+	func_show_eval '${RM}r "$gentop"'
+      fi
+
+      exit $EXIT_SUCCESS
+      ;;
+
+    prog)
+      case $host in
+	*cygwin*) func_stripname '' '.exe' "$output"
+	          output=$func_stripname_result.exe;;
+      esac
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for programs"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for programs"
+
+      test "$preload" = yes \
+        && test "$dlopen_support" = unknown \
+	&& test "$dlopen_self" = unknown \
+	&& test "$dlopen_self_static" = unknown && \
+	  func_warning "\`LT_INIT([dlopen])' not used. Assuming no dlopen support."
+
+      case $host in
+      *-*-rhapsody* | *-*-darwin1.[012])
+	# On Rhapsody replace the C library is the System framework
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	;;
+      esac
+
+      case $host in
+      *-*-darwin*)
+	# Don't allow lazy linking, it breaks C++ global constructors
+	# But is supposedly fixed on 10.4 or later (yay!).
+	if test "$tagname" = CXX ; then
+	  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in
+	    10.[0123])
+	      compile_command="$compile_command ${wl}-bind_at_load"
+	      finalize_command="$finalize_command ${wl}-bind_at_load"
+	    ;;
+	  esac
+	fi
+	# Time to change all our "foo.ltframework" stuff back to "-framework foo"
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	;;
+      esac
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $compile_deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $compile_deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      compile_deplibs="$new_libs"
+
+
+      compile_command="$compile_command $compile_deplibs"
+      finalize_command="$finalize_command $finalize_deplibs"
+
+      if test -n "$rpath$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	for libdir in $rpath $xrpath; do
+	  # This is the magic to use -rpath.
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+      fi
+
+      # Now hardcode the library paths
+      rpath=
+      hardcode_libdirs=
+      for libdir in $compile_rpath $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) perm_rpath="$perm_rpath $libdir" ;;
+	  esac
+	fi
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`${ECHO} "$libdir" | ${SED} -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$libdir:"*) ;;
+	  ::) dllsearchpath=$libdir;;
+	  *) dllsearchpath="$dllsearchpath:$libdir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      compile_rpath="$rpath"
+
+      rpath=
+      hardcode_libdirs=
+      for libdir in $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$finalize_perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_perm_rpath="$finalize_perm_rpath $libdir" ;;
+	  esac
+	fi
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      finalize_rpath="$rpath"
+
+      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+	# Transform all the library objects into standard objects.
+	compile_command=`$ECHO "X$compile_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	finalize_command=`$ECHO "X$finalize_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+      fi
+
+      func_generate_dlsyms "$outputname" "@PROGRAM@" "no"
+
+      # template prelinking step
+      if test -n "$prelink_cmds"; then
+	func_execute_cmds "$prelink_cmds" 'exit $?'
+      fi
+
+      wrappers_required=yes
+      case $host in
+      *cygwin* | *mingw* )
+        if test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      *cegcc)
+        # Disable wrappers for cegcc, we are cross compiling anyway.
+        wrappers_required=no
+        ;;
+      *)
+        if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      esac
+      if test "$wrappers_required" = no; then
+	# Replace the output file specification.
+	compile_command=`$ECHO "X$compile_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	link_command="$compile_command$compile_rpath"
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	exit_status=0
+	func_show_eval "$link_command" 'exit_status=$?'
+
+	# Delete the generated files.
+	if test -f "$output_objdir/${outputname}S.${objext}"; then
+	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
+	fi
+
+	exit $exit_status
+      fi
+
+      if test -n "$compile_shlibpath$finalize_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      compile_var=
+      finalize_var=
+      if test -n "$runpath_var"; then
+	if test -n "$perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  compile_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+	if test -n "$finalize_perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $finalize_perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  finalize_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+      fi
+
+      if test "$no_install" = yes; then
+	# We don't need to create a wrapper script.
+	link_command="$compile_var$compile_command$compile_rpath"
+	# Replace the output file specification.
+	link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	# Delete the old output file.
+	$opt_dry_run || $RM $output
+	# Link the executable and exit
+	func_show_eval "$link_command" 'exit $?'
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$hardcode_action" = relink; then
+	# Fast installation is not supported
+	link_command="$compile_var$compile_command$compile_rpath"
+	relink_command="$finalize_var$finalize_command$finalize_rpath"
+
+	func_warning "this platform does not like uninstalled shared libraries"
+	func_warning "\`$output' will be relinked during installation"
+      else
+	if test "$fast_install" != no; then
+	  link_command="$finalize_var$compile_command$finalize_rpath"
+	  if test "$fast_install" = yes; then
+	    relink_command=`$ECHO "X$compile_var$compile_command$compile_rpath" | $Xsed -e 's%@OUTPUT@%\$progdir/\$file%g'`
+	  else
+	    # fast_install is set to needless
+	    relink_command=
+	  fi
+	else
+	  link_command="$compile_var$compile_command$compile_rpath"
+	  relink_command="$finalize_var$finalize_command$finalize_rpath"
+	fi
+      fi
+
+      # Replace the output file specification.
+      link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
+
+      # Delete the old output files.
+      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname
+
+      func_show_eval "$link_command" 'exit $?'
+
+      # Now create the wrapper script.
+      func_verbose "creating $output"
+
+      # Quote the relink command for shipping.
+      if test -n "$relink_command"; then
+	# Preserve any variables that may affect compiler behavior
+	for var in $variables_saved_for_relink; do
+	  if eval test -z \"\${$var+set}\"; then
+	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	  elif eval var_value=\$$var; test -z "$var_value"; then
+	    relink_command="$var=; export $var; $relink_command"
+	  else
+	    func_quote_for_eval "$var_value"
+	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	  fi
+	done
+	relink_command="(cd `pwd`; $relink_command)"
+	relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Quote $ECHO for shipping.
+      if test "X$ECHO" = "X$SHELL $progpath --fallback-echo"; then
+	case $progpath in
+	[\\/]* | [A-Za-z]:[\\/]*) qecho="$SHELL $progpath --fallback-echo";;
+	*) qecho="$SHELL `pwd`/$progpath --fallback-echo";;
+	esac
+	qecho=`$ECHO "X$qecho" | $Xsed -e "$sed_quote_subst"`
+      else
+	qecho=`$ECHO "X$ECHO" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Only actually do things if not in dry run mode.
+      $opt_dry_run || {
+	# win32 will think the script is a binary if it has
+	# a .exe suffix, so we strip it off here.
+	case $output in
+	  *.exe) func_stripname '' '.exe' "$output"
+	         output=$func_stripname_result ;;
+	esac
+	# test for cygwin because mv fails w/o .exe extensions
+	case $host in
+	  *cygwin*)
+	    exeext=.exe
+	    func_stripname '' '.exe' "$outputname"
+	    outputname=$func_stripname_result ;;
+	  *) exeext= ;;
+	esac
+	case $host in
+	  *cygwin* | *mingw* )
+	    func_dirname_and_basename "$output" "" "."
+	    output_name=$func_basename_result
+	    output_path=$func_dirname_result
+	    cwrappersource="$output_path/$objdir/lt-$output_name.c"
+	    cwrapper="$output_path/$output_name.exe"
+	    $RM $cwrappersource $cwrapper
+	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_cwrapperexe_src > $cwrappersource
+
+	    # The wrapper executable is built using the $host compiler,
+	    # because it contains $host paths and files. If cross-
+	    # compiling, it, like the target executable, must be
+	    # executed on the $host or under an emulation environment.
+	    $opt_dry_run || {
+	      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource
+	      $STRIP $cwrapper
+	    }
+
+	    # Now, create the wrapper script for func_source use:
+	    func_ltwrapper_scriptname $cwrapper
+	    $RM $func_ltwrapper_scriptname_result
+	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
+	    $opt_dry_run || {
+	      # note: this script will not be executed, so do not chmod.
+	      if test "x$build" = "x$host" ; then
+		$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result
+	      else
+		func_emit_wrapper no > $func_ltwrapper_scriptname_result
+	      fi
+	    }
+	  ;;
+	  * )
+	    $RM $output
+	    trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_wrapper no > $output
+	    chmod +x $output
+	  ;;
+	esac
+      }
+      exit $EXIT_SUCCESS
+      ;;
+    esac
+
+    # See if we need to build an old-fashioned archive.
+    for oldlib in $oldlibs; do
+
+      if test "$build_libtool_libs" = convenience; then
+	oldobjs="$libobjs_save $symfileobj"
+	addlibs="$convenience"
+	build_libtool_libs=no
+      else
+	if test "$build_libtool_libs" = module; then
+	  oldobjs="$libobjs_save"
+	  build_libtool_libs=no
+	else
+	  oldobjs="$old_deplibs $non_pic_objects"
+	  if test "$preload" = yes && test -f "$symfileobj"; then
+	    oldobjs="$oldobjs $symfileobj"
+	  fi
+	fi
+	addlibs="$old_convenience"
+      fi
+
+      if test -n "$addlibs"; then
+	gentop="$output_objdir/${outputname}x"
+	generated="$generated $gentop"
+
+	func_extract_archives $gentop $addlibs
+	oldobjs="$oldobjs $func_extract_archives_result"
+      fi
+
+      # Do each command in the archive commands.
+      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+	cmds=$old_archive_from_new_cmds
+      else
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  oldobjs="$oldobjs $func_extract_archives_result"
+	fi
+
+	# POSIX demands no paths to be encoded in archives.  We have
+	# to avoid creating archives with duplicate basenames if we
+	# might have to extract them afterwards, e.g., when creating a
+	# static archive out of a convenience library, or when linking
+	# the entirety of a libtool archive into another (currently
+	# not supported by libtool).
+	if (for obj in $oldobjs
+	    do
+	      func_basename "$obj"
+	      $ECHO "$func_basename_result"
+	    done | sort | sort -uc >/dev/null 2>&1); then
+	  :
+	else
+	  $ECHO "copying selected object files to avoid basename conflicts..."
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+	  func_mkdir_p "$gentop"
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  counter=1
+	  for obj in $save_oldobjs
+	  do
+	    func_basename "$obj"
+	    objbase="$func_basename_result"
+	    case " $oldobjs " in
+	    " ") oldobjs=$obj ;;
+	    *[\ /]"$objbase "*)
+	      while :; do
+		# Make sure we don't pick an alternate name that also
+		# overlaps.
+		newobj=lt$counter-$objbase
+		func_arith $counter + 1
+		counter=$func_arith_result
+		case " $oldobjs " in
+		*[\ /]"$newobj "*) ;;
+		*) if test ! -f "$gentop/$newobj"; then break; fi ;;
+		esac
+	      done
+	      func_show_eval "ln $obj $gentop/$newobj || cp $obj $gentop/$newobj"
+	      oldobjs="$oldobjs $gentop/$newobj"
+	      ;;
+	    *) oldobjs="$oldobjs $obj" ;;
+	    esac
+	  done
+	fi
+	eval cmds=\"$old_archive_cmds\"
+
+	func_len " $cmds"
+	len=$func_len_result
+	if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  cmds=$old_archive_cmds
+	else
+	  # the command line is too long to link in one step, link in parts
+	  func_verbose "using piecewise archive linking..."
+	  save_RANLIB=$RANLIB
+	  RANLIB=:
+	  objlist=
+	  concat_cmds=
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  # Is there a better way of finding the last object in the list?
+	  for obj in $save_oldobjs
+	  do
+	    last_oldobj=$obj
+	  done
+	  eval test_cmds=\"$old_archive_cmds\"
+	  func_len " $test_cmds"
+	  len0=$func_len_result
+	  len=$len0
+	  for obj in $save_oldobjs
+	  do
+	    func_len " $obj"
+	    func_arith $len + $func_len_result
+	    len=$func_arith_result
+	    func_append objlist " $obj"
+	    if test "$len" -lt "$max_cmd_len"; then
+	      :
+	    else
+	      # the above command should be used before it gets too long
+	      oldobjs=$objlist
+	      if test "$obj" = "$last_oldobj" ; then
+		RANLIB=$save_RANLIB
+	      fi
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      objlist=
+	      len=$len0
+	    fi
+	  done
+	  RANLIB=$save_RANLIB
+	  oldobjs=$objlist
+	  if test "X$oldobjs" = "X" ; then
+	    eval cmds=\"\$concat_cmds\"
+	  else
+	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
+	  fi
+	fi
+      fi
+      func_execute_cmds "$cmds" 'exit $?'
+    done
+
+    test -n "$generated" && \
+      func_show_eval "${RM}r$generated"
+
+    # Now create the libtool archive.
+    case $output in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      func_verbose "creating $output"
+
+      # Preserve any variables that may affect compiler behavior
+      for var in $variables_saved_for_relink; do
+	if eval test -z \"\${$var+set}\"; then
+	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	elif eval var_value=\$$var; test -z "$var_value"; then
+	  relink_command="$var=; export $var; $relink_command"
+	else
+	  func_quote_for_eval "$var_value"
+	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	fi
+      done
+      # Quote the link command for shipping.
+      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      if test "$hardcode_automatic" = yes ; then
+	relink_command=
+      fi
+
+      # Only create the output if not a dry run.
+      $opt_dry_run || {
+	for installed in no yes; do
+	  if test "$installed" = yes; then
+	    if test -z "$install_libdir"; then
+	      break
+	    fi
+	    output="$output_objdir/$outputname"i
+	    # Replace all uninstalled libtool libraries with the installed ones
+	    newdependency_libs=
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      *.la)
+		func_basename "$deplib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$deplib' is not a valid libtool archive"
+		newdependency_libs="$newdependency_libs $libdir/$name"
+		;;
+	      *) newdependency_libs="$newdependency_libs $deplib" ;;
+	      esac
+	    done
+	    dependency_libs="$newdependency_libs"
+	    newdlfiles=
+
+	    for lib in $dlfiles; do
+	      case $lib in
+	      *.la)
+	        func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlfiles="$newdlfiles $libdir/$name"
+		;;
+	      *) newdlfiles="$newdlfiles $lib" ;;
+	      esac
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+	      *.la)
+		# Only pass preopened files to the pseudo-archive (for
+		# eventual linking with the app. that links it) if we
+		# didn't already link the preopened objects directly into
+		# the library:
+		func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlprefiles="$newdlprefiles $libdir/$name"
+		;;
+	      esac
+	    done
+	    dlprefiles="$newdlprefiles"
+	  else
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlfiles="$newdlfiles $abs"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlprefiles="$newdlprefiles $abs"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  fi
+	  $RM $output
+	  # place dlname in correct position for cygwin
+	  tdlname=$dlname
+	  case $host,$output,$installed,$module,$dlname in
+	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;
+	  esac
+	  $ECHO > $output "\
+# $outputname - a libtool library file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='$tdlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Linker flags that can not go in dependency_libs.
+inherited_linker_flags='$new_inherited_linker_flags'
+
+# Libraries that this one depends upon.
+dependency_libs='$dependency_libs'
+
+# Names of additional weak libraries provided by this library
+weak_library_names='$weak_libs'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Is this an already installed library?
+installed=$installed
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=$module
+
+# Files to dlopen/dlpreopen
+dlopen='$dlfiles'
+dlpreopen='$dlprefiles'
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'"
+	  if test "$installed" = no && test "$need_relink" = yes; then
+	    $ECHO >> $output "\
+relink_command=\"$relink_command\""
+	  fi
+	done
+      }
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
+      ;;
+    esac
+    exit $EXIT_SUCCESS
+}
+
+{ test "$mode" = link || test "$mode" = relink; } &&
+    func_mode_link ${1+"$@"}
+
+
+# func_mode_uninstall arg...
+func_mode_uninstall ()
+{
+    $opt_debug
+    RM="$nonopt"
+    files=
+    rmforce=
+    exit_status=0
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    for arg
+    do
+      case $arg in
+      -f) RM="$RM $arg"; rmforce=yes ;;
+      -*) RM="$RM $arg" ;;
+      *) files="$files $arg" ;;
+      esac
+    done
+
+    test -z "$RM" && \
+      func_fatal_help "you must specify an RM program"
+
+    rmdirs=
+
+    origobjdir="$objdir"
+    for file in $files; do
+      func_dirname "$file" "" "."
+      dir="$func_dirname_result"
+      if test "X$dir" = X.; then
+	objdir="$origobjdir"
+      else
+	objdir="$dir/$origobjdir"
+      fi
+      func_basename "$file"
+      name="$func_basename_result"
+      test "$mode" = uninstall && objdir="$dir"
+
+      # Remember objdir for removal later, being careful to avoid duplicates
+      if test "$mode" = clean; then
+	case " $rmdirs " in
+	  *" $objdir "*) ;;
+	  *) rmdirs="$rmdirs $objdir" ;;
+	esac
+      fi
+
+      # Don't error if the file doesn't exist and rm -f was used.
+      if { test -L "$file"; } >/dev/null 2>&1 ||
+	 { test -h "$file"; } >/dev/null 2>&1 ||
+	 test -f "$file"; then
+	:
+      elif test -d "$file"; then
+	exit_status=1
+	continue
+      elif test "$rmforce" = yes; then
+	continue
+      fi
+
+      rmfiles="$file"
+
+      case $name in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if func_lalib_p "$file"; then
+	  func_source $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    rmfiles="$rmfiles $objdir/$n"
+	  done
+	  test -n "$old_library" && rmfiles="$rmfiles $objdir/$old_library"
+
+	  case "$mode" in
+	  clean)
+	    case "  $library_names " in
+	    # "  " in the beginning catches empty $dlname
+	    *" $dlname "*) ;;
+	    *) rmfiles="$rmfiles $objdir/$dlname" ;;
+	    esac
+	    test -n "$libdir" && rmfiles="$rmfiles $objdir/$name $objdir/${name}i"
+	    ;;
+	  uninstall)
+	    if test -n "$library_names"; then
+	      # Do each command in the postuninstall commands.
+	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+
+	    if test -n "$old_library"; then
+	      # Do each command in the old_postuninstall commands.
+	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+	    # FIXME: should reinstall the best remaining shared library.
+	    ;;
+	  esac
+	fi
+	;;
+
+      *.lo)
+	# Possibly a libtool object, so verify it.
+	if func_lalib_p "$file"; then
+
+	  # Read the .lo file
+	  func_source $dir/$name
+
+	  # Add PIC object to the list of files to remove.
+	  if test -n "$pic_object" &&
+	     test "$pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$pic_object"
+	  fi
+
+	  # Add non-PIC object to the list of files to remove.
+	  if test -n "$non_pic_object" &&
+	     test "$non_pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$non_pic_object"
+	  fi
+	fi
+	;;
+
+      *)
+	if test "$mode" = clean ; then
+	  noexename=$name
+	  case $file in
+	  *.exe)
+	    func_stripname '' '.exe' "$file"
+	    file=$func_stripname_result
+	    func_stripname '' '.exe' "$name"
+	    noexename=$func_stripname_result
+	    # $file with .exe has already been added to rmfiles,
+	    # add $file without .exe
+	    rmfiles="$rmfiles $file"
+	    ;;
+	  esac
+	  # Do a test to see if this is a libtool program.
+	  if func_ltwrapper_p "$file"; then
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      relink_command=
+	      func_source $func_ltwrapper_scriptname_result
+	      rmfiles="$rmfiles $func_ltwrapper_scriptname_result"
+	    else
+	      relink_command=
+	      func_source $dir/$noexename
+	    fi
+
+	    # note $name still contains .exe if it was in $file originally
+	    # as does the version of $file that was added into $rmfiles
+	    rmfiles="$rmfiles $objdir/$name $objdir/${name}S.${objext}"
+	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	      rmfiles="$rmfiles $objdir/lt-$name"
+	    fi
+	    if test "X$noexename" != "X$name" ; then
+	      rmfiles="$rmfiles $objdir/lt-${noexename}.c"
+	    fi
+	  fi
+	fi
+	;;
+      esac
+      func_show_eval "$RM $rmfiles" 'exit_status=1'
+    done
+    objdir="$origobjdir"
+
+    # Try to remove the ${objdir}s in the directories where we deleted files
+    for dir in $rmdirs; do
+      if test -d "$dir"; then
+	func_show_eval "rmdir $dir >/dev/null 2>&1"
+      fi
+    done
+
+    exit $exit_status
+}
+
+{ test "$mode" = uninstall || test "$mode" = clean; } &&
+    func_mode_uninstall ${1+"$@"}
+
+test -z "$mode" && {
+  help="$generic_help"
+  func_fatal_help "you must specify a MODE"
+}
+
+test -z "$exec_cmd" && \
+  func_fatal_help "invalid operation mode \`$mode'"
+
+if test -n "$exec_cmd"; then
+  eval exec "$exec_cmd"
+  exit $EXIT_FAILURE
+fi
+
+exit $exit_status
+
+
+# The TAGs below are defined such that we never get into a situation
+# in which we disable both kinds of libraries.  Given conflicting
+# choices, we go for a static library, that is the most portable,
+# since we can't tell whether shared libraries were disabled because
+# the user asked for that or because the platform doesn't support
+# them.  This is particularly important on AIX, because we don't
+# support having both static and shared libraries enabled at the same
+# time on that platform, so we default to a shared-only configuration.
+# If a disable-shared tag is given, we'll fallback to a static-only
+# configuration.  But we'll never go from static-only to shared-only.
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-shared
+build_libtool_libs=no
+build_old_libs=yes
+# ### END LIBTOOL TAG CONFIG: disable-shared
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-static
+build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
+# ### END LIBTOOL TAG CONFIG: disable-static
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
+# vi:sw=2
+
diff --git a/missing b/missing
new file mode 120000
index 0000000..1f0fe88
--- /dev/null
+++ b/missing
@@ -0,0 +1 @@
+/usr/share/automake-1.10/missing
\ No newline at end of file

commit 15ae89bb1c55ca346c0babb3c54f3c0189eeb2b4
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Aug 13 14:31:57 2009 -0400

    Added autotools specific files.

diff --git a/Makefile b/Makefile
deleted file mode 100755
index 0106a18..0000000
--- a/Makefile
+++ /dev/null
@@ -1,21 +0,0 @@
-MD=mkdir -p
-MAKE=-make -C
-PWD=`pwd`
-
-all:	libgtkworkbook gtkworkbookapp
-
-libgtkworkbook:
-	${MD} OBJS/libgtkworkbook
-	${MAKE} gtkworkbook/ all
-
-gtkworkbookapp:
-	${MD} OBJS/realtime OBJS/largefile OBJS/shared
-	$(MAKE) src/ all
-
-clean:
-	${MAKE} gtkworkbook/ clean
-	$(MAKE) src/ clean
-
-install: all
-	${MAKE} gtkworkbook/ install
-	${MAKE} src/ install
diff --git a/Makefile.am b/Makefile.am
new file mode 100644
index 0000000..dc9d4a5
--- /dev/null
+++ b/Makefile.am
@@ -0,0 +1,2 @@
+AUTOMAKE_OPTIONS= foreign
+SUBDIRS= gtkworkbook/OBJS src/OBJS src/largefile/OBJS src/realtime/OBJS
\ No newline at end of file
diff --git a/Makefile.base b/Makefile.base
deleted file mode 100755
index 1208907..0000000
--- a/Makefile.base
+++ /dev/null
@@ -1,40 +0,0 @@
-CC=gcc
-CX=g++
-RM=-rm -f
-MD=-mkdir -p
-LN=-ln
-AR=-ar
-CP=-cp
-
-# These directories below are changed based upon where you want
-# to INSTALL the files to. They are only copied to on `make install` 
-INSLIBDIR=${shell /bin/sed -n '/^INSLIBDIR/s/.*=//p' ~/.gtkworkbook}
-INSBINDIR=${shell /bin/sed -n '/^INSBINDIR/s/.*=//p' ~/.gtkworkbook}
-INSEXTDIR=${shell /bin/sed -n '/^INSEXTDIR/s/.*=//p' ~/.gtkworkbook}
-
-# These are the project directories and dependency directories.
-PROJDIR=${shell /bin/sed -n '/^PROJDIR/s/.*=//p' ~/.gtkworkbook}
-SYSINSPATH=${shell /bin/sed -n '/^SYSINSPATH/s/.*=//p' ~/.gtkworkbook}
-LIBDIR=${SYSINSPATH}/lib
-INCDIR=${SYSINSPATH}/include
-OBJDIR=${PROJDIR}/OBJS
-
-LD_LIBRARY_PATH=${PROJDIR}/lib:${LIBDIR}:/usr/local/lib
-export LD_LIBRARY_PATH
-
-INCS = -I${INCDIR}/gtkextra-2.0
-INCS += -I${PROJDIR}/include
-INCS += -I/usr/local/include/gtkextra-2.0
-INCS += -I${HOME}/include
-INCS += `pkg-config gtk+-2.0 glib-2.0 --cflags`
-
-LIBS = -lpixman-1
-LIBS += -L${PROJDIR}/lib
-LIBS += -Wl,-rpath ${PROJDIR}/lib
-LIBS += -L/usr/local/lib
-LIBS += -L${LIBDIR}
-LIBS += -Wl,-rpath ${LIBDIR}
-LIBS += `pkg-config gtk+-2.0 glib-2.0 --libs`
-
-CCFLAGS=-g -std=c99 -Wall -pthread
-CXFLAGS=-g -Wall -Wno-write-strings
\ No newline at end of file
diff --git a/aclocal.m4 b/aclocal.m4
new file mode 100644
index 0000000..444dc09
--- /dev/null
+++ b/aclocal.m4
@@ -0,0 +1,8841 @@
+# generated automatically by aclocal 1.10.2 -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.63],,
+[m4_warning([this file was generated for autoconf 2.63.
+You have another version of autoconf.  It may work, but is not guaranteed to.
+If you have problems, you may need to regenerate the build system entirely.
+To do so, use the procedure documented by the package, typically `autoreconf'.])])
+
+# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+m4_define([_LT_COPYING], [dnl
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+])
+
+# serial 56 LT_INIT
+
+
+# LT_PREREQ(VERSION)
+# ------------------
+# Complain and exit if this libtool version is less that VERSION.
+m4_defun([LT_PREREQ],
+[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,
+       [m4_default([$3],
+		   [m4_fatal([Libtool version $1 or higher is required],
+		             63)])],
+       [$2])])
+
+
+# _LT_CHECK_BUILDDIR
+# ------------------
+# Complain if the absolute build directory name contains unusual characters
+m4_defun([_LT_CHECK_BUILDDIR],
+[case `pwd` in
+  *\ * | *\	*)
+    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;
+esac
+])
+
+
+# LT_INIT([OPTIONS])
+# ------------------
+AC_DEFUN([LT_INIT],
+[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT
+AC_BEFORE([$0], [LT_LANG])dnl
+AC_BEFORE([$0], [LT_OUTPUT])dnl
+AC_BEFORE([$0], [LTDL_INIT])dnl
+m4_require([_LT_CHECK_BUILDDIR])dnl
+
+dnl Autoconf doesn't catch unexpanded LT_ macros by default:
+m4_pattern_forbid([^_?LT_[A-Z_]+$])dnl
+m4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl
+dnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4
+dnl unless we require an AC_DEFUNed macro:
+AC_REQUIRE([LTOPTIONS_VERSION])dnl
+AC_REQUIRE([LTSUGAR_VERSION])dnl
+AC_REQUIRE([LTVERSION_VERSION])dnl
+AC_REQUIRE([LTOBSOLETE_VERSION])dnl
+m4_require([_LT_PROG_LTMAIN])dnl
+
+dnl Parse OPTIONS
+_LT_SET_OPTIONS([$0], [$1])
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+AC_SUBST(LIBTOOL)dnl
+
+_LT_SETUP
+
+# Only expand once:
+m4_define([LT_INIT])
+])# LT_INIT
+
+# Old names:
+AU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])
+AU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PROG_LIBTOOL], [])
+dnl AC_DEFUN([AM_PROG_LIBTOOL], [])
+
+
+# _LT_CC_BASENAME(CC)
+# -------------------
+# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+m4_defun([_LT_CC_BASENAME],
+[for cc_temp in $1""; do
+  case $cc_temp in
+    compile | *[[\\/]]compile | ccache | *[[\\/]]ccache ) ;;
+    distcc | *[[\\/]]distcc | purify | *[[\\/]]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
+])
+
+
+# _LT_FILEUTILS_DEFAULTS
+# ----------------------
+# It is okay to use these file commands and assume they have been set
+# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.
+m4_defun([_LT_FILEUTILS_DEFAULTS],
+[: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+])# _LT_FILEUTILS_DEFAULTS
+
+
+# _LT_SETUP
+# ---------
+m4_defun([_LT_SETUP],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+_LT_DECL([], [host_alias], [0], [The host system])dnl
+_LT_DECL([], [host], [0])dnl
+_LT_DECL([], [host_os], [0])dnl
+dnl
+_LT_DECL([], [build_alias], [0], [The build system])dnl
+_LT_DECL([], [build], [0])dnl
+_LT_DECL([], [build_os], [0])dnl
+dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+dnl
+AC_REQUIRE([AC_PROG_LN_S])dnl
+test -z "$LN_S" && LN_S="ln -s"
+_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl
+dnl
+AC_REQUIRE([LT_CMD_MAX_LEN])dnl
+_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally "o")])dnl
+_LT_DECL([], [exeext], [0], [Executable file suffix (normally "")])dnl
+dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+m4_require([_LT_CMD_RELOAD])dnl
+m4_require([_LT_CHECK_MAGIC_METHOD])dnl
+m4_require([_LT_CMD_OLD_ARCHIVE])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+
+_LT_CONFIG_LIBTOOL_INIT([
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+])
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+_LT_CHECK_OBJDIR
+
+m4_require([_LT_TAG_COMPILER])dnl
+_LT_PROG_ECHO_BACKSLASH
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+sed_quote_subst='s/\([["`$\\]]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\([["`\\]]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+_LT_CC_BASENAME([$compiler])
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    _LT_PATH_MAGIC
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+LT_SUPPORTED_TAG([CC])
+_LT_LANG_C_CONFIG
+_LT_LANG_DEFAULT_CONFIG
+_LT_CONFIG_COMMANDS
+])# _LT_SETUP
+
+
+# _LT_PROG_LTMAIN
+# ---------------
+# Note that this code is called both from `configure', and `config.status'
+# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,
+# `config.status' has no value for ac_aux_dir unless we are using Automake,
+# so we pass a copy along to make sure it has a sensible value anyway.
+m4_defun([_LT_PROG_LTMAIN],
+[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl
+_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])
+ltmain="$ac_aux_dir/ltmain.sh"
+])# _LT_PROG_LTMAIN
+
+
+
+# So that we can recreate a full libtool script including additional
+# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS
+# in macros and then make a single call at the end using the `libtool'
+# label.
+
+
+# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])
+# ----------------------------------------
+# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL_INIT],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_INIT])
+
+
+# _LT_CONFIG_LIBTOOL([COMMANDS])
+# ------------------------------
+# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])
+
+
+# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])
+# -----------------------------------------------------
+m4_defun([_LT_CONFIG_SAVE_COMMANDS],
+[_LT_CONFIG_LIBTOOL([$1])
+_LT_CONFIG_LIBTOOL_INIT([$2])
+])
+
+
+# _LT_FORMAT_COMMENT([COMMENT])
+# -----------------------------
+# Add leading comment marks to the start of each line, and a trailing
+# full-stop to the whole comment if one is not present already.
+m4_define([_LT_FORMAT_COMMENT],
+[m4_ifval([$1], [
+m4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],
+              [['`$\]], [\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])
+)])
+
+
+
+
+
+# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])
+# -------------------------------------------------------------------
+# CONFIGNAME is the name given to the value in the libtool script.
+# VARNAME is the (base) name used in the configure script.
+# VALUE may be 0, 1 or 2 for a computed quote escaped value based on
+# VARNAME.  Any other value will be used directly.
+m4_define([_LT_DECL],
+[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],
+    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],
+	[m4_ifval([$1], [$1], [$2])])
+    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])
+    m4_ifval([$4],
+	[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])
+    lt_dict_add_subkey([lt_decl_dict], [$2],
+	[tagged?], [m4_ifval([$5], [yes], [no])])])
+])
+
+
+# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])
+# --------------------------------------------------------
+m4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])
+
+
+# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_tag_varnames],
+[_lt_decl_filter([tagged?], [yes], $@)])
+
+
+# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])
+# ---------------------------------------------------------
+m4_define([_lt_decl_filter],
+[m4_case([$#],
+  [0], [m4_fatal([$0: too few arguments: $#])],
+  [1], [m4_fatal([$0: too few arguments: $#: $1])],
+  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],
+  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],
+  [lt_dict_filter([lt_decl_dict], $@)])[]dnl
+])
+
+
+# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])
+# --------------------------------------------------
+m4_define([lt_decl_quote_varnames],
+[_lt_decl_filter([value], [1], $@)])
+
+
+# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_dquote_varnames],
+[_lt_decl_filter([value], [2], $@)])
+
+
+# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_varnames_tagged],
+[m4_assert([$# <= 2])dnl
+_$0(m4_quote(m4_default([$1], [[, ]])),
+    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),
+    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])
+m4_define([_lt_decl_varnames_tagged],
+[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])
+
+
+# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_all_varnames],
+[_$0(m4_quote(m4_default([$1], [[, ]])),
+     m4_if([$2], [],
+	   m4_quote(lt_decl_varnames),
+	m4_quote(m4_shift($@))))[]dnl
+])
+m4_define([_lt_decl_all_varnames],
+[lt_join($@, lt_decl_varnames_tagged([$1],
+			lt_decl_tag_varnames([[, ]], m4_shift($@))))dnl
+])
+
+
+# _LT_CONFIG_STATUS_DECLARE([VARNAME])
+# ------------------------------------
+# Quote a variable value, and forward it to `config.status' so that its
+# declaration there will have the same value as in `configure'.  VARNAME
+# must have a single quote delimited value for this to work.
+m4_define([_LT_CONFIG_STATUS_DECLARE],
+[$1='`$ECHO "X$][$1" | $Xsed -e "$delay_single_quote_subst"`'])
+
+
+# _LT_CONFIG_STATUS_DECLARATIONS
+# ------------------------------
+# We delimit libtool config variables with single quotes, so when
+# we write them to config.status, we have to be sure to quote all
+# embedded single quotes properly.  In configure, this macro expands
+# each variable declared with _LT_DECL (and _LT_TAGDECL) into:
+#
+#    <var>='`$ECHO "X$<var>" | $Xsed -e "$delay_single_quote_subst"`'
+m4_defun([_LT_CONFIG_STATUS_DECLARATIONS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),
+    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAGS
+# ----------------
+# Output comment and list of tags supported by the script
+m4_defun([_LT_LIBTOOL_TAGS],
+[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl
+available_tags="_LT_TAGS"dnl
+])
+
+
+# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])
+# -----------------------------------
+# Extract the dictionary values for VARNAME (optionally with TAG) and
+# expand to a commented shell variable setting:
+#
+#    # Some comment about what VAR is for.
+#    visible_name=$lt_internal_name
+m4_define([_LT_LIBTOOL_DECLARE],
+[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],
+					   [description])))[]dnl
+m4_pushdef([_libtool_name],
+    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl
+m4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),
+    [0], [_libtool_name=[$]$1],
+    [1], [_libtool_name=$lt_[]$1],
+    [2], [_libtool_name=$lt_[]$1],
+    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl
+m4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl
+])
+
+
+# _LT_LIBTOOL_CONFIG_VARS
+# -----------------------
+# Produce commented declarations of non-tagged libtool config variables
+# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'
+# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG
+# section) are produced by _LT_LIBTOOL_TAG_VARS.
+m4_defun([_LT_LIBTOOL_CONFIG_VARS],
+[m4_foreach([_lt_var],
+    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAG_VARS(TAG)
+# -------------------------
+m4_define([_LT_LIBTOOL_TAG_VARS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])
+
+
+# _LT_TAGVAR(VARNAME, [TAGNAME])
+# ------------------------------
+m4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])
+
+
+# _LT_CONFIG_COMMANDS
+# -------------------
+# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of
+# variables for single and double quote escaping we saved from calls
+# to _LT_DECL, we can put quote escaped variables declarations
+# into `config.status', and then the shell code to quote escape them in
+# for loops in `config.status'.  Finally, any additional code accumulated
+# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.
+m4_defun([_LT_CONFIG_COMMANDS],
+[AC_PROVIDE_IFELSE([LT_OUTPUT],
+	dnl If the libtool generation code has been placed in $CONFIG_LT,
+	dnl instead of duplicating it all over again into config.status,
+	dnl then we will have config.status run $CONFIG_LT later, so it
+	dnl needs to know what name is stored there:
+        [AC_CONFIG_COMMANDS([libtool],
+            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],
+    dnl If the libtool generation code is destined for config.status,
+    dnl expand the accumulated commands and init code now:
+    [AC_CONFIG_COMMANDS([libtool],
+        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])
+])#_LT_CONFIG_COMMANDS
+
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],
+[
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+_LT_CONFIG_STATUS_DECLARATIONS
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# Quote evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_quote_varnames); do
+    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_dquote_varnames); do
+    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Fix-up fallback echo if it was mangled by the above quoting rules.
+case \$lt_ECHO in
+*'\\\[$]0 --fallback-echo"')dnl "
+  lt_ECHO=\`\$ECHO "X\$lt_ECHO" | \$Xsed -e 's/\\\\\\\\\\\\\\\[$]0 --fallback-echo"\[$]/\[$]0 --fallback-echo"/'\`
+  ;;
+esac
+
+_LT_OUTPUT_LIBTOOL_INIT
+])
+
+
+# LT_OUTPUT
+# ---------
+# This macro allows early generation of the libtool script (before
+# AC_OUTPUT is called), incase it is used in configure for compilation
+# tests.
+AC_DEFUN([LT_OUTPUT],
+[: ${CONFIG_LT=./config.lt}
+AC_MSG_NOTICE([creating $CONFIG_LT])
+cat >"$CONFIG_LT" <<_LTEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate a libtool stub with the current configuration.
+
+lt_cl_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_LTEOF
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+AS_SHELL_SANITIZE
+_AS_PREPARE
+
+exec AS_MESSAGE_FD>&1
+exec AS_MESSAGE_LOG_FD>>config.log
+{
+  echo
+  AS_BOX([Running $as_me.])
+} >&AS_MESSAGE_LOG_FD
+
+lt_cl_help="\
+\`$as_me' creates a local libtool stub from the current configuration,
+for use in further configure time tests before the real libtool is
+generated.
+
+Usage: $[0] [[OPTIONS]]
+
+  -h, --help      print this help, then exit
+  -V, --version   print version number, then exit
+  -q, --quiet     do not print progress messages
+  -d, --debug     don't remove temporary files
+
+Report bugs to <bug-libtool@gnu.org>."
+
+lt_cl_version="\
+m4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl
+m4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])
+configured by $[0], generated by m4_PACKAGE_STRING.
+
+Copyright (C) 2008 Free Software Foundation, Inc.
+This config.lt script is free software; the Free Software Foundation
+gives unlimited permision to copy, distribute and modify it."
+
+while test $[#] != 0
+do
+  case $[1] in
+    --version | --v* | -V )
+      echo "$lt_cl_version"; exit 0 ;;
+    --help | --h* | -h )
+      echo "$lt_cl_help"; exit 0 ;;
+    --debug | --d* | -d )
+      debug=: ;;
+    --quiet | --q* | --silent | --s* | -q )
+      lt_cl_silent=: ;;
+
+    -*) AC_MSG_ERROR([unrecognized option: $[1]
+Try \`$[0] --help' for more information.]) ;;
+
+    *) AC_MSG_ERROR([unrecognized argument: $[1]
+Try \`$[0] --help' for more information.]) ;;
+  esac
+  shift
+done
+
+if $lt_cl_silent; then
+  exec AS_MESSAGE_FD>/dev/null
+fi
+_LTEOF
+
+cat >>"$CONFIG_LT" <<_LTEOF
+_LT_OUTPUT_LIBTOOL_COMMANDS_INIT
+_LTEOF
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+AC_MSG_NOTICE([creating $ofile])
+_LT_OUTPUT_LIBTOOL_COMMANDS
+AS_EXIT(0)
+_LTEOF
+chmod +x "$CONFIG_LT"
+
+# configure is writing to config.log, but config.lt does its own redirection,
+# appending to config.log, which fails on DOS, as config.log is still kept
+# open by configure.  Here we exec the FD to /dev/null, effectively closing
+# config.log, so it can be properly (re)opened and appended to by config.lt.
+if test "$no_create" != yes; then
+  lt_cl_success=:
+  test "$silent" = yes &&
+    lt_config_lt_args="$lt_config_lt_args --quiet"
+  exec AS_MESSAGE_LOG_FD>/dev/null
+  $SHELL "$CONFIG_LT" $lt_config_lt_args || lt_cl_success=false
+  exec AS_MESSAGE_LOG_FD>>config.log
+  $lt_cl_success || AS_EXIT(1)
+fi
+])# LT_OUTPUT
+
+
+# _LT_CONFIG(TAG)
+# ---------------
+# If TAG is the built-in tag, create an initial libtool script with a
+# default configuration from the untagged config vars.  Otherwise add code
+# to config.status for appending the configuration named by TAG from the
+# matching tagged config vars.
+m4_defun([_LT_CONFIG],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_CONFIG_SAVE_COMMANDS([
+  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl
+  m4_if(_LT_TAG, [C], [
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+_LT_COPYING
+_LT_LIBTOOL_TAGS
+
+# ### BEGIN LIBTOOL CONFIG
+_LT_LIBTOOL_CONFIG_VARS
+_LT_LIBTOOL_TAG_VARS
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+  _LT_PROG_LTMAIN
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  _LT_PROG_XSI_SHELLFNS
+
+  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+],
+[cat <<_LT_EOF >> "$ofile"
+
+dnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded
+dnl in a comment (ie after a #).
+# ### BEGIN LIBTOOL TAG CONFIG: $1
+_LT_LIBTOOL_TAG_VARS(_LT_TAG)
+# ### END LIBTOOL TAG CONFIG: $1
+_LT_EOF
+])dnl /m4_if
+],
+[m4_if([$1], [], [
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'], [])
+])dnl /_LT_CONFIG_SAVE_COMMANDS
+])# _LT_CONFIG
+
+
+# LT_SUPPORTED_TAG(TAG)
+# ---------------------
+# Trace this macro to discover what tags are supported by the libtool
+# --tag option, using:
+#    autoconf --trace 'LT_SUPPORTED_TAG:$1'
+AC_DEFUN([LT_SUPPORTED_TAG], [])
+
+
+# C support is built-in for now
+m4_define([_LT_LANG_C_enabled], [])
+m4_define([_LT_TAGS], [])
+
+
+# LT_LANG(LANG)
+# -------------
+# Enable libtool support for the given language if not already enabled.
+AC_DEFUN([LT_LANG],
+[AC_BEFORE([$0], [LT_OUTPUT])dnl
+m4_case([$1],
+  [C],			[_LT_LANG(C)],
+  [C++],		[_LT_LANG(CXX)],
+  [Java],		[_LT_LANG(GCJ)],
+  [Fortran 77],		[_LT_LANG(F77)],
+  [Fortran],		[_LT_LANG(FC)],
+  [Windows Resource],	[_LT_LANG(RC)],
+  [m4_ifdef([_LT_LANG_]$1[_CONFIG],
+    [_LT_LANG($1)],
+    [m4_fatal([$0: unsupported language: "$1"])])])dnl
+])# LT_LANG
+
+
+# _LT_LANG(LANGNAME)
+# ------------------
+m4_defun([_LT_LANG],
+[m4_ifdef([_LT_LANG_]$1[_enabled], [],
+  [LT_SUPPORTED_TAG([$1])dnl
+  m4_append([_LT_TAGS], [$1 ])dnl
+  m4_define([_LT_LANG_]$1[_enabled], [])dnl
+  _LT_LANG_$1_CONFIG($1)])dnl
+])# _LT_LANG
+
+
+# _LT_LANG_DEFAULT_CONFIG
+# -----------------------
+m4_defun([_LT_LANG_DEFAULT_CONFIG],
+[AC_PROVIDE_IFELSE([AC_PROG_CXX],
+  [LT_LANG(CXX)],
+  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_F77],
+  [LT_LANG(F77)],
+  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_FC],
+  [LT_LANG(FC)],
+  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])
+
+dnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal
+dnl pulling things in needlessly.
+AC_PROVIDE_IFELSE([AC_PROG_GCJ],
+  [LT_LANG(GCJ)],
+  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],
+    [LT_LANG(GCJ)],
+    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],
+      [LT_LANG(GCJ)],
+      [m4_ifdef([AC_PROG_GCJ],
+	[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([A][M_PROG_GCJ],
+	[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([LT_PROG_GCJ],
+	[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])
+
+AC_PROVIDE_IFELSE([LT_PROG_RC],
+  [LT_LANG(RC)],
+  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])
+])# _LT_LANG_DEFAULT_CONFIG
+
+# Obsolete macros:
+AU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])
+AU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])
+AU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])
+AU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_CXX], [])
+dnl AC_DEFUN([AC_LIBTOOL_F77], [])
+dnl AC_DEFUN([AC_LIBTOOL_FC], [])
+dnl AC_DEFUN([AC_LIBTOOL_GCJ], [])
+
+
+# _LT_TAG_COMPILER
+# ----------------
+m4_defun([_LT_TAG_COMPILER],
+[AC_REQUIRE([AC_PROG_CC])dnl
+
+_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl
+_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl
+_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl
+_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+])# _LT_TAG_COMPILER
+
+
+# _LT_COMPILER_BOILERPLATE
+# ------------------------
+# Check for compiler boilerplate output or warnings with
+# the simple compiler test code.
+m4_defun([_LT_COMPILER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+])# _LT_COMPILER_BOILERPLATE
+
+
+# _LT_LINKER_BOILERPLATE
+# ----------------------
+# Check for linker boilerplate output or warnings with
+# the simple link test code.
+m4_defun([_LT_LINKER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+])# _LT_LINKER_BOILERPLATE
+
+# _LT_REQUIRED_DARWIN_CHECKS
+# -------------------------
+m4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[
+  case $host_os in
+    rhapsody* | darwin*)
+    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])
+    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])
+    AC_CHECK_TOOL([LIPO], [lipo], [:])
+    AC_CHECK_TOOL([OTOOL], [otool], [:])
+    AC_CHECK_TOOL([OTOOL64], [otool64], [:])
+    _LT_DECL([], [DSYMUTIL], [1],
+      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])
+    _LT_DECL([], [NMEDIT], [1],
+      [Tool to change global to local symbols on Mac OS X])
+    _LT_DECL([], [LIPO], [1],
+      [Tool to manipulate fat objects and archives on Mac OS X])
+    _LT_DECL([], [OTOOL], [1],
+      [ldd/readelf like tool for Mach-O binaries on Mac OS X])
+    _LT_DECL([], [OTOOL64], [1],
+      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])
+
+    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],
+      [lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&AS_MESSAGE_LOG_FD
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&AS_MESSAGE_LOG_FD
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi])
+    AC_CACHE_CHECK([for -exported_symbols_list linker flag],
+      [lt_cv_ld_exported_symbols_list],
+      [lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+	[lt_cv_ld_exported_symbols_list=yes],
+	[lt_cv_ld_exported_symbols_list=no])
+	LDFLAGS="$save_LDFLAGS"
+    ])
+    case $host_os in
+    rhapsody* | darwin1.[[012]])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[[012]]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+])
+
+
+# _LT_DARWIN_LINKER_FEATURES
+# --------------------------
+# Checks for linker and compiler features on darwin
+m4_defun([_LT_DARWIN_LINKER_FEATURES],
+[
+  m4_require([_LT_REQUIRED_DARWIN_CHECKS])
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_automatic, $1)=yes
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  _LT_TAGVAR(whole_archive_flag_spec, $1)=''
+  _LT_TAGVAR(link_all_deplibs, $1)=yes
+  _LT_TAGVAR(allow_undefined_flag, $1)="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=echo
+    _LT_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    _LT_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    _LT_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+    m4_if([$1], [CXX],
+[   if test "$lt_cv_apple_cc_single_mod" != "yes"; then
+      _LT_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
+      _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+    fi
+],[])
+  else
+  _LT_TAGVAR(ld_shlibs, $1)=no
+  fi
+])
+
+# _LT_SYS_MODULE_PATH_AIX
+# -----------------------
+# Links a minimal program and checks the executable
+# for the system default hardcoded library path. In most cases,
+# this is /usr/lib:/lib, but when the MPI compilers are used
+# the location of the communication and MPI libs are included too.
+# If we don't find anything, use the default library path according
+# to the aix ld manual.
+m4_defun([_LT_SYS_MODULE_PATH_AIX],
+[m4_require([_LT_DECL_SED])dnl
+AC_LINK_IFELSE(AC_LANG_PROGRAM,[
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi],[])
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+])# _LT_SYS_MODULE_PATH_AIX
+
+
+# _LT_SHELL_INIT(ARG)
+# -------------------
+m4_define([_LT_SHELL_INIT],
+[ifdef([AC_DIVERSION_NOTICE],
+	     [AC_DIVERT_PUSH(AC_DIVERSION_NOTICE)],
+	 [AC_DIVERT_PUSH(NOTICE)])
+$1
+AC_DIVERT_POP
+])# _LT_SHELL_INIT
+
+
+# _LT_PROG_ECHO_BACKSLASH
+# -----------------------
+# Add some code to the start of the generated configure script which
+# will find an echo command which doesn't interpret backslashes.
+m4_defun([_LT_PROG_ECHO_BACKSLASH],
+[_LT_SHELL_INIT([
+# Check that we are running under the correct shell.
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+case X$lt_ECHO in
+X*--fallback-echo)
+  # Remove one level of quotation (which was required for Make).
+  ECHO=`echo "$lt_ECHO" | sed 's,\\\\\[$]\\[$]0,'[$]0','`
+  ;;
+esac
+
+ECHO=${lt_ECHO-echo}
+if test "X[$]1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X[$]1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' ; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell.
+  exec $SHELL "[$]0" --no-reexec ${1+"[$]@"}
+fi
+
+if test "X[$]1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<_LT_EOF
+[$]*
+_LT_EOF
+  exit 0
+fi
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test -z "$lt_ECHO"; then
+  if test "X${echo_test_string+set}" != Xset; then
+    # find a string as large as possible, as long as the shell can cope with it
+    for cmd in 'sed 50q "[$]0"' 'sed 20q "[$]0"' 'sed 10q "[$]0"' 'sed 2q "[$]0"' 'echo test'; do
+      # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...
+      if { echo_test_string=`eval $cmd`; } 2>/dev/null &&
+	 { test "X$echo_test_string" = "X$echo_test_string"; } 2>/dev/null
+      then
+        break
+      fi
+    done
+  fi
+
+  if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
+     echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+     test "X$echo_testing_string" = "X$echo_test_string"; then
+    :
+  else
+    # The Solaris, AIX, and Digital Unix default echo programs unquote
+    # backslashes.  This makes it impossible to quote backslashes using
+    #   echo "$something" | sed 's/\\/\\\\/g'
+    #
+    # So, first we look for a working echo in the user's PATH.
+
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for dir in $PATH /usr/ucb; do
+      IFS="$lt_save_ifs"
+      if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&
+         test "X`($dir/echo '\t') 2>/dev/null`" = 'X\t' &&
+         echo_testing_string=`($dir/echo "$echo_test_string") 2>/dev/null` &&
+         test "X$echo_testing_string" = "X$echo_test_string"; then
+        ECHO="$dir/echo"
+        break
+      fi
+    done
+    IFS="$lt_save_ifs"
+
+    if test "X$ECHO" = Xecho; then
+      # We didn't find a better echo, so look for alternatives.
+      if test "X`{ print -r '\t'; } 2>/dev/null`" = 'X\t' &&
+         echo_testing_string=`{ print -r "$echo_test_string"; } 2>/dev/null` &&
+         test "X$echo_testing_string" = "X$echo_test_string"; then
+        # This shell has a builtin print -r that does the trick.
+        ECHO='print -r'
+      elif { test -f /bin/ksh || test -f /bin/ksh$ac_exeext; } &&
+	   test "X$CONFIG_SHELL" != X/bin/ksh; then
+        # If we have ksh, try running configure again with it.
+        ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+        export ORIGINAL_CONFIG_SHELL
+        CONFIG_SHELL=/bin/ksh
+        export CONFIG_SHELL
+        exec $CONFIG_SHELL "[$]0" --no-reexec ${1+"[$]@"}
+      else
+        # Try using printf.
+        ECHO='printf %s\n'
+        if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
+	   echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	  # Cool, printf works
+	  :
+        elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL "[$]0" --fallback-echo '\t') 2>/dev/null` &&
+	     test "X$echo_testing_string" = 'X\t' &&
+	     echo_testing_string=`($ORIGINAL_CONFIG_SHELL "[$]0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	     test "X$echo_testing_string" = "X$echo_test_string"; then
+	  CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL
+	  export CONFIG_SHELL
+	  SHELL="$CONFIG_SHELL"
+	  export SHELL
+	  ECHO="$CONFIG_SHELL [$]0 --fallback-echo"
+        elif echo_testing_string=`($CONFIG_SHELL "[$]0" --fallback-echo '\t') 2>/dev/null` &&
+	     test "X$echo_testing_string" = 'X\t' &&
+	     echo_testing_string=`($CONFIG_SHELL "[$]0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	     test "X$echo_testing_string" = "X$echo_test_string"; then
+	  ECHO="$CONFIG_SHELL [$]0 --fallback-echo"
+        else
+	  # maybe with a smaller string...
+	  prev=:
+
+	  for cmd in 'echo test' 'sed 2q "[$]0"' 'sed 10q "[$]0"' 'sed 20q "[$]0"' 'sed 50q "[$]0"'; do
+	    if { test "X$echo_test_string" = "X`eval $cmd`"; } 2>/dev/null
+	    then
+	      break
+	    fi
+	    prev="$cmd"
+	  done
+
+	  if test "$prev" != 'sed 50q "[$]0"'; then
+	    echo_test_string=`eval $prev`
+	    export echo_test_string
+	    exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} "[$]0" ${1+"[$]@"}
+	  else
+	    # Oops.  We lost completely, so just stick with echo.
+	    ECHO=echo
+	  fi
+        fi
+      fi
+    fi
+  fi
+fi
+
+# Copy echo and quote the copy suitably for passing to libtool from
+# the Makefile, instead of quoting the original, which is used later.
+lt_ECHO=$ECHO
+if test "X$lt_ECHO" = "X$CONFIG_SHELL [$]0 --fallback-echo"; then
+   lt_ECHO="$CONFIG_SHELL \\\$\[$]0 --fallback-echo"
+fi
+
+AC_SUBST(lt_ECHO)
+])
+_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])
+_LT_DECL([], [ECHO], [1],
+    [An echo program that does not interpret backslashes])
+])# _LT_PROG_ECHO_BACKSLASH
+
+
+# _LT_ENABLE_LOCK
+# ---------------
+m4_defun([_LT_ENABLE_LOCK],
+[AC_ARG_ENABLE([libtool-lock],
+  [AS_HELP_STRING([--disable-libtool-lock],
+    [avoid locking (might break parallel builds)])])
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '[#]line __oline__ "configure"' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_i386"
+	    ;;
+	  ppc64-*linux*|powerpc64-*linux*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  ppc*-*linux*|powerpc*-*linux*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,
+    [AC_LANG_PUSH(C)
+     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])
+     AC_LANG_POP])
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+])# _LT_ENABLE_LOCK
+
+
+# _LT_CMD_OLD_ARCHIVE
+# -------------------
+m4_defun([_LT_CMD_OLD_ARCHIVE],
+[AC_CHECK_TOOL(AR, ar, false)
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+_LT_DECL([], [AR], [1], [The archiver])
+_LT_DECL([], [AR_FLAGS], [1])
+
+AC_CHECK_TOOL(STRIP, strip, :)
+test -z "$STRIP" && STRIP=:
+_LT_DECL([], [STRIP], [1], [A symbol stripping program])
+
+AC_CHECK_TOOL(RANLIB, ranlib, :)
+test -z "$RANLIB" && RANLIB=:
+_LT_DECL([], [RANLIB], [1],
+    [Commands used to install an old-style archive])
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+_LT_DECL([], [old_postinstall_cmds], [2])
+_LT_DECL([], [old_postuninstall_cmds], [2])
+_LT_TAGDECL([], [old_archive_cmds], [2],
+    [Commands used to build an old-style archive])
+])# _LT_CMD_OLD_ARCHIVE
+
+
+# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#		[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------------------
+# Check whether the given compiler option works
+AC_DEFUN([_LT_COMPILER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$3"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:__oline__: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:__oline__: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       $2=yes
+     fi
+   fi
+   $RM conftest*
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$5], , :, [$5])
+else
+    m4_if([$6], , :, [$6])
+fi
+])# _LT_COMPILER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])
+
+
+# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#                  [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------
+# Check whether the given linker option works
+AC_DEFUN([_LT_LINKER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $3"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&AS_MESSAGE_LOG_FD
+       $ECHO "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         $2=yes
+       fi
+     else
+       $2=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$4], , :, [$4])
+else
+    m4_if([$5], , :, [$5])
+fi
+])# _LT_LINKER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])
+
+
+# LT_CMD_MAX_LEN
+#---------------
+AC_DEFUN([LT_CMD_MAX_LEN],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# find the maximum length of command line arguments
+AC_MSG_CHECKING([the maximum length of command line arguments])
+AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
+  i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[	 ]]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`$SHELL [$]0 --fallback-echo "X$teststring$teststring" 2>/dev/null` \
+	         = "XX$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+])
+if test -n $lt_cv_sys_max_cmd_len ; then
+  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)
+else
+  AC_MSG_RESULT(none)
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+_LT_DECL([], [max_cmd_len], [0],
+    [What is the maximum length of a command?])
+])# LT_CMD_MAX_LEN
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])
+
+
+# _LT_HEADER_DLFCN
+# ----------------
+m4_defun([_LT_HEADER_DLFCN],
+[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl
+])# _LT_HEADER_DLFCN
+
+
+# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,
+#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)
+# ----------------------------------------------------------------
+m4_defun([_LT_TRY_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "$cross_compiling" = yes; then :
+  [$4]
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+[#line __oline__ "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}]
+_LT_EOF
+  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) $1 ;;
+      x$lt_dlneed_uscore) $2 ;;
+      x$lt_dlunknown|x*) $3 ;;
+    esac
+  else :
+    # compilation failed
+    $3
+  fi
+fi
+rm -fr conftest*
+])# _LT_TRY_DLOPEN_SELF
+
+
+# LT_SYS_DLOPEN_SELF
+# ------------------
+AC_DEFUN([LT_SYS_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],[
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ])
+    ;;
+
+  *)
+    AC_CHECK_FUNC([shl_load],
+	  [lt_cv_dlopen="shl_load"],
+      [AC_CHECK_LIB([dld], [shl_load],
+	    [lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"],
+	[AC_CHECK_FUNC([dlopen],
+	      [lt_cv_dlopen="dlopen"],
+	  [AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],
+	    [AC_CHECK_LIB([svld], [dlopen],
+		  [lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"],
+	      [AC_CHECK_LIB([dld], [dld_link],
+		    [lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"])
+	      ])
+	    ])
+	  ])
+	])
+      ])
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    AC_CACHE_CHECK([whether a program can dlopen itself],
+	  lt_cv_dlopen_self, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,
+	    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)
+    ])
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],
+	  lt_cv_dlopen_self_static, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,
+	    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)
+      ])
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+_LT_DECL([dlopen_support], [enable_dlopen], [0],
+	 [Whether dlopen is supported])
+_LT_DECL([dlopen_self], [enable_dlopen_self], [0],
+	 [Whether dlopen of programs is supported])
+_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],
+	 [Whether dlopen of statically linked programs is supported])
+])# LT_SYS_DLOPEN_SELF
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])
+
+
+# _LT_COMPILER_C_O([TAGNAME])
+# ---------------------------
+# Check to see if options -c and -o are simultaneously supported by compiler.
+# This macro does not hard code the compiler like AC_PROG_CC_C_O.
+m4_defun([_LT_COMPILER_C_O],
+[m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:__oline__: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:__oline__: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+     fi
+   fi
+   chmod u+w . 2>&AS_MESSAGE_LOG_FD
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+])
+_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],
+	[Does compiler simultaneously support -c and -o options?])
+])# _LT_COMPILER_C_O
+
+
+# _LT_COMPILER_FILE_LOCKS([TAGNAME])
+# ----------------------------------
+# Check to see if we can do hard links to lock some files if needed
+m4_defun([_LT_COMPILER_FILE_LOCKS],
+[m4_require([_LT_ENABLE_LOCK])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_COMPILER_C_O([$1])
+
+hard_links="nottested"
+if test "$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  AC_MSG_CHECKING([if we can lock with hard links])
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  AC_MSG_RESULT([$hard_links])
+  if test "$hard_links" = no; then
+    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])
+])# _LT_COMPILER_FILE_LOCKS
+
+
+# _LT_CHECK_OBJDIR
+# ----------------
+m4_defun([_LT_CHECK_OBJDIR],
+[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],
+[rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null])
+objdir=$lt_cv_objdir
+_LT_DECL([], [objdir], [0],
+         [The name of the directory that contains temporary libtool files])dnl
+m4_pattern_allow([LT_OBJDIR])dnl
+AC_DEFINE_UNQUOTED(LT_OBJDIR, "$lt_cv_objdir/",
+  [Define to the sub-directory in which libtool stores uninstalled libraries.])
+])# _LT_CHECK_OBJDIR
+
+
+# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])
+# --------------------------------------
+# Check hardcoding attributes.
+m4_defun([_LT_LINKER_HARDCODE_LIBPATH],
+[AC_MSG_CHECKING([how to hardcode library paths into programs])
+_LT_TAGVAR(hardcode_action, $1)=
+if test -n "$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)" ||
+   test -n "$_LT_TAGVAR(runpath_var, $1)" ||
+   test "X$_LT_TAGVAR(hardcode_automatic, $1)" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$_LT_TAGVAR(hardcode_direct, $1)" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, $1)" != no &&
+     test "$_LT_TAGVAR(hardcode_minus_L, $1)" != no; then
+    # Linking always hardcodes the temporary library directory.
+    _LT_TAGVAR(hardcode_action, $1)=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    _LT_TAGVAR(hardcode_action, $1)=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  _LT_TAGVAR(hardcode_action, $1)=unsupported
+fi
+AC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])
+
+if test "$_LT_TAGVAR(hardcode_action, $1)" = relink ||
+   test "$_LT_TAGVAR(inherit_rpath, $1)" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+_LT_TAGDECL([], [hardcode_action], [0],
+    [How to hardcode a shared library path into an executable])
+])# _LT_LINKER_HARDCODE_LIBPATH
+
+
+# _LT_CMD_STRIPLIB
+# ----------------
+m4_defun([_LT_CMD_STRIPLIB],
+[m4_require([_LT_DECL_EGREP])
+striplib=
+old_striplib=
+AC_MSG_CHECKING([whether stripping libraries is possible])
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  AC_MSG_RESULT([yes])
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      AC_MSG_RESULT([yes])
+    else
+      AC_MSG_RESULT([no])
+    fi
+    ;;
+  *)
+    AC_MSG_RESULT([no])
+    ;;
+  esac
+fi
+_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])
+_LT_DECL([], [striplib], [1])
+])# _LT_CMD_STRIPLIB
+
+
+# _LT_SYS_DYNAMIC_LINKER([TAG])
+# -----------------------------
+# PORTME Fill in your ld.so characteristics
+m4_defun([_LT_SYS_DYNAMIC_LINKER],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_OBJDUMP])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_MSG_CHECKING([dynamic linker characteristics])
+m4_if([$1],
+	[], [
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+  if $ECHO "$lt_search_path_spec" | $GREP ';' >/dev/null ; then
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED -e 's/;/ /g'`
+  else
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+  fi
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO $lt_tmp_lt_search_path_spec | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[[lt_foo]]++; }
+  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }
+}'`
+  sys_lib_search_path_spec=`$ECHO $lt_search_path_spec`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi])
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[[4-9]]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[[01]] | aix4.[[01]].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO "X$lib" | $Xsed -e '\''s%^.*/\([[^/]]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[[45]]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if $ECHO "$sys_lib_search_path_spec" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then
+        # It is most probably a Windows format PATH printed by
+        # mingw gcc, but we are running on Cygwin. Gcc prints its search
+        # path with ; separators, and with drive letters. We can handle the
+        # drive letters (cygwin fileutils understands them), so leave them,
+        # especially as we might pass files found there to a mingw objdump,
+        # which wouldn't understand a cygwinified path. Ahh.
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+m4_if([$1], [],[
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"])
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[[123]]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[[01]]* | freebsdelf3.[[01]]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \
+  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+interix[[3-9]]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # Some binutils ld are patched to set DT_RUNPATH
+  save_LDFLAGS=$LDFLAGS
+  save_libdir=$libdir
+  eval "libdir=/foo; wl=\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\"; \
+       LDFLAGS=\"\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\""
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+    [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null],
+       [shlibpath_overrides_runpath=yes])])
+  LDFLAGS=$save_LDFLAGS
+  libdir=$save_libdir
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[[89]] | openbsd2.[[89]].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+AC_MSG_RESULT([$dynamic_linker])
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+_LT_DECL([], [variables_saved_for_relink], [1],
+    [Variables whose values should be saved in libtool wrapper scripts and
+    restored at link time])
+_LT_DECL([], [need_lib_prefix], [0],
+    [Do we need the "lib" prefix for modules?])
+_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])
+_LT_DECL([], [version_type], [0], [Library versioning type])
+_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])
+_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])
+_LT_DECL([], [shlibpath_overrides_runpath], [0],
+    [Is shlibpath searched before the hard-coded library search path?])
+_LT_DECL([], [libname_spec], [1], [Format of library name prefix])
+_LT_DECL([], [library_names_spec], [1],
+    [[List of archive names.  First name is the real one, the rest are links.
+    The last name is the one that the linker finds with -lNAME]])
+_LT_DECL([], [soname_spec], [1],
+    [[The coded name of the library, if different from the real name]])
+_LT_DECL([], [postinstall_cmds], [2],
+    [Command to use after installation of a shared archive])
+_LT_DECL([], [postuninstall_cmds], [2],
+    [Command to use after uninstallation of a shared archive])
+_LT_DECL([], [finish_cmds], [2],
+    [Commands used to finish a libtool library installation in a directory])
+_LT_DECL([], [finish_eval], [1],
+    [[As "finish_cmds", except a single script fragment to be evaled but
+    not shown]])
+_LT_DECL([], [hardcode_into_libs], [0],
+    [Whether we should hardcode library paths into libraries])
+_LT_DECL([], [sys_lib_search_path_spec], [2],
+    [Compile-time system search path for libraries])
+_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],
+    [Run-time system search path for libraries])
+])# _LT_SYS_DYNAMIC_LINKER
+
+
+# _LT_PATH_TOOL_PREFIX(TOOL)
+# --------------------------
+# find a file program which can recognize shared library
+AC_DEFUN([_LT_PATH_TOOL_PREFIX],
+[m4_require([_LT_DECL_EGREP])dnl
+AC_MSG_CHECKING([for $1])
+AC_CACHE_VAL(lt_cv_path_MAGIC_CMD,
+[case $MAGIC_CMD in
+[[\\/*] |  ?:[\\/]*])
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+dnl $ac_dummy forces splitting on constant user-supplied paths.
+dnl POSIX.2 word splitting is done only on the output of word expansions,
+dnl not every word.  This closes a longstanding sh security hole.
+  ac_dummy="m4_if([$2], , $PATH, [$2])"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$1; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/$1"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac])
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  AC_MSG_RESULT($MAGIC_CMD)
+else
+  AC_MSG_RESULT(no)
+fi
+_LT_DECL([], [MAGIC_CMD], [0],
+	 [Used to examine libraries when file_magic_cmd begins with "file"])dnl
+])# _LT_PATH_TOOL_PREFIX
+
+# Old name:
+AU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])
+
+
+# _LT_PATH_MAGIC
+# --------------
+# find a file program which can recognize a shared library
+m4_defun([_LT_PATH_MAGIC],
+[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)
+  else
+    MAGIC_CMD=:
+  fi
+fi
+])# _LT_PATH_MAGIC
+
+
+# LT_PATH_LD
+# ----------
+# find the pathname to the GNU or non-GNU linker
+AC_DEFUN([LT_PATH_LD],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+
+AC_ARG_WITH([gnu-ld],
+    [AS_HELP_STRING([--with-gnu-ld],
+	[assume the C compiler uses GNU ld @<:@default=no@:>@])],
+    [test "$withval" = no || with_gnu_ld=yes],
+    [with_gnu_ld=no])dnl
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by $CC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]]* | ?:[[\\/]]*)
+      re_direlt='/[[^/]][[^/]]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(lt_cv_path_LD,
+[if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+_LT_PATH_LD_GNU
+AC_SUBST([LD])
+
+_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])
+])# LT_PATH_LD
+
+# Old names:
+AU_ALIAS([AM_PROG_LD], [LT_PATH_LD])
+AU_ALIAS([AC_PROG_LD], [LT_PATH_LD])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_LD], [])
+dnl AC_DEFUN([AC_PROG_LD], [])
+
+
+# _LT_PATH_LD_GNU
+#- --------------
+m4_defun([_LT_PATH_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac])
+with_gnu_ld=$lt_cv_prog_gnu_ld
+])# _LT_PATH_LD_GNU
+
+
+# _LT_CMD_RELOAD
+# --------------
+# find reload flag for linker
+#   -- PORTME Some linkers may need a different reload flag.
+m4_defun([_LT_CMD_RELOAD],
+[AC_CACHE_CHECK([for $LD option to reload object files],
+  lt_cv_ld_reload_flag,
+  [lt_cv_ld_reload_flag='-r'])
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+_LT_DECL([], [reload_flag], [1], [How to create reloadable object files])dnl
+_LT_DECL([], [reload_cmds], [2])dnl
+])# _LT_CMD_RELOAD
+
+
+# _LT_CHECK_MAGIC_METHOD
+# ----------------------
+# how to check for library dependencies
+#  -- PORTME fill in with the dynamic library characteristics
+m4_defun([_LT_CHECK_MAGIC_METHOD],
+[m4_require([_LT_DECL_EGREP])
+m4_require([_LT_DECL_OBJDUMP])
+AC_CACHE_CHECK([how to recognize dependent libraries],
+lt_cv_deplibs_check_method,
+[lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[[4-9]]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[[45]]*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  if ( file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - PA-RISC [0-9].[0-9]']
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]].[[0-9]]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[[3-9]]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd* | netbsdelf*-gnu)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+])
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+_LT_DECL([], [deplibs_check_method], [1],
+    [Method to check whether dependent libraries are shared objects])
+_LT_DECL([], [file_magic_cmd], [1],
+    [Command to use when deplibs_check_method == "file_magic"])
+])# _LT_CHECK_MAGIC_METHOD
+
+
+# LT_PATH_NM
+# ----------
+# find the pathname to a BSD- or MS-compatible name lister
+AC_DEFUN([LT_PATH_NM],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,
+[if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi])
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  AC_CHECK_TOOLS(DUMPBIN, ["dumpbin -symbols" "link -dump -symbols"], :)
+  AC_SUBST([DUMPBIN])
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+AC_SUBST([NM])
+_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl
+
+AC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],
+  [lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:__oline__: $ac_compile\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:__oline__: $NM \\\"conftest.$ac_objext\\\"\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:__oline__: output\"" >&AS_MESSAGE_LOG_FD)
+  cat conftest.out >&AS_MESSAGE_LOG_FD
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*])
+])# LT_PATH_NM
+
+# Old names:
+AU_ALIAS([AM_PROG_NM], [LT_PATH_NM])
+AU_ALIAS([AC_PROG_NM], [LT_PATH_NM])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_NM], [])
+dnl AC_DEFUN([AC_PROG_NM], [])
+
+
+# LT_LIB_M
+# --------
+# check for math library
+AC_DEFUN([LT_LIB_M],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+LIBM=
+case $host in
+*-*-beos* | *-*-cygwin* | *-*-pw32* | *-*-darwin*)
+  # These system don't have libm, or don't need it
+  ;;
+*-ncr-sysv4.3*)
+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM="-lmw")
+  AC_CHECK_LIB(m, cos, LIBM="$LIBM -lm")
+  ;;
+*)
+  AC_CHECK_LIB(m, cos, LIBM="-lm")
+  ;;
+esac
+AC_SUBST([LIBM])
+])# LT_LIB_M
+
+# Old name:
+AU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_CHECK_LIBM], [])
+
+
+# _LT_COMPILER_NO_RTTI([TAGNAME])
+# -------------------------------
+m4_defun([_LT_COMPILER_NO_RTTI],
+[m4_require([_LT_TAG_COMPILER])dnl
+
+_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+
+if test "$GCC" = yes; then
+  _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'
+
+  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],
+    lt_cv_prog_compiler_rtti_exceptions,
+    [-fno-rtti -fno-exceptions], [],
+    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)="$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions"])
+fi
+_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],
+	[Compiler flag to turn off builtin functions])
+])# _LT_COMPILER_NO_RTTI
+
+
+# _LT_CMD_GLOBAL_SYMBOLS
+# ----------------------
+m4_defun([_LT_CMD_GLOBAL_SYMBOLS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+AC_MSG_CHECKING([command to parse $NM output from $compiler object])
+AC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],
+[
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[[BCDEGRST]]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([[_A-Za-z]][[_A-Za-z0-9]]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[[BCDT]]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[[ABCDGISTW]]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[[ABCDEGRST]]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[[BCDEGRST]]'
+  ;;
+osf*)
+  symcode='[[BCDEGQRST]]'
+  ;;
+solaris*)
+  symcode='[[BDRT]]'
+  ;;
+sco3.2v5*)
+  symcode='[[DT]]'
+  ;;
+sysv4.2uw2*)
+  symcode='[[DT]]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[[ABDT]]'
+  ;;
+sysv4)
+  symcode='[[DFNSTU]]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[[ABCDGIRSTW]]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([[^ ]]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([[^ ]]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \(lib[[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK ['"\
+"     {last_section=section; section=\$ 3};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx]"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[[	 ]]\($symcode$symcode*\)[[	 ]][[	 ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if AC_TRY_EVAL(ac_compile); then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+const struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[[]] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_save_LIBS="$LIBS"
+	  lt_save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)"
+	  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$lt_save_LIBS"
+	  CFLAGS="$lt_save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&AS_MESSAGE_LOG_FD
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&AS_MESSAGE_LOG_FD
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&AS_MESSAGE_LOG_FD
+    fi
+  else
+    echo "$progname: failed program was:" >&AS_MESSAGE_LOG_FD
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+])
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  AC_MSG_RESULT(failed)
+else
+  AC_MSG_RESULT(ok)
+fi
+
+_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],
+    [Take the output of nm and produce a listing of raw symbols and C names])
+_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],
+    [Transform the output of nm in a proper C declaration])
+_LT_DECL([global_symbol_to_c_name_address],
+    [lt_cv_sys_global_symbol_to_c_name_address], [1],
+    [Transform the output of nm in a C name address pair])
+_LT_DECL([global_symbol_to_c_name_address_lib_prefix],
+    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],
+    [Transform the output of nm in a C name address pair when lib prefix is needed])
+]) # _LT_CMD_GLOBAL_SYMBOLS
+
+
+# _LT_COMPILER_PIC([TAGNAME])
+# ---------------------------
+m4_defun([_LT_COMPILER_PIC],
+[m4_require([_LT_TAG_COMPILER])dnl
+_LT_TAGVAR(lt_prog_compiler_wl, $1)=
+_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+_LT_TAGVAR(lt_prog_compiler_static, $1)=
+
+AC_MSG_CHECKING([for $compiler option to produce PIC])
+m4_if([$1], [CXX], [
+  # C++ specific cases for pic, static, wl, etc.
+  if test "$GXX" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+    aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    mingw* | cygwin* | os2* | pw32* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+    *djgpp*)
+      # DJGPP does not support shared libraries at all
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+      ;;
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+    *qnx* | *nto*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+  else
+    case $host_os in
+      aix[[4-9]]*)
+	# All AIX code is PIC.
+	if test "$host_cpu" = ia64; then
+	  # AIX 5 now supports IA64 processor
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	else
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+	fi
+	;;
+      chorus*)
+	case $cc_basename in
+	cxch68*)
+	  # Green Hills C++ Compiler
+	  # _LT_TAGVAR(lt_prog_compiler_static, $1)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	  ;;
+	esac
+	;;
+      dgux*)
+	case $cc_basename in
+	  ec++*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  ghcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      freebsd* | dragonfly*)
+	# FreeBSD uses GNU C++
+	;;
+      hpux9* | hpux10* | hpux11*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    if test "$host_cpu" != ia64; then
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	    fi
+	    ;;
+	  aCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    case $host_cpu in
+	    hppa*64*|ia64*)
+	      # +Z the default
+	      ;;
+	    *)
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	      ;;
+	    esac
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      interix*)
+	# This is c89, which is MS Visual C++ (no shared libs)
+	# Anyone wants to do a port?
+	;;
+      irix5* | irix6* | nonstopux*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    # CC pic flag -KPIC is the default.
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      linux* | k*bsd*-gnu)
+	case $cc_basename in
+	  KCC*)
+	    # KAI C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    ;;
+	  ecpc* )
+	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  icpc* )
+	    # Intel C++, used to be incompatible with GCC.
+	    # ICC 10 doesn't accept -KPIC any more.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  pgCC* | pgcpp*)
+	    # Portland Group C++ compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  cxx*)
+	    # Compaq C++
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  xlc* | xlC*)
+	    # IBM XL 8.0 on PPC
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+      lynxos*)
+	;;
+      m88k*)
+	;;
+      mvs*)
+	case $cc_basename in
+	  cxx*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      netbsd* | netbsdelf*-gnu)
+	;;
+      *qnx* | *nto*)
+        # QNX uses GNU C++, but need to define -shared option too, otherwise
+        # it will coredump.
+        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+        ;;
+      osf3* | osf4* | osf5*)
+	case $cc_basename in
+	  KCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    ;;
+	  RCC*)
+	    # Rational C++ 2.4.1
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  cxx*)
+	    # Digital/Compaq C++
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      psos*)
+	;;
+      solaris*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	    ;;
+	  gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sunos4*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.x
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  lcc*)
+	    # Lucid
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	esac
+	;;
+      tandem*)
+	case $cc_basename in
+	  NCC*)
+	    # NonStop-UX NCC 3.20
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      vxworks*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+	;;
+    esac
+  fi
+],
+[
+  if test "$GCC" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      else
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC (with -KPIC) is the default.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+        ;;
+      ccc*)
+        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+        # All Alpha code is PIC.
+        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+        ;;
+      xl*)
+	# IBM XL C 8.0/Fortran 10.1 on PPC
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)
+	  # Sun C 5.9
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  ;;
+	*Sun\ F*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # All OSF/1 code is PIC.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    rdos*)
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    unicos*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+    esac
+  fi
+])
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+    ;;
+  *)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)="$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])"
+    ;;
+esac
+AC_MSG_RESULT([$_LT_TAGVAR(lt_prog_compiler_pic, $1)])
+_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],
+	[How to pass a linker flag through the compiler])
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$_LT_TAGVAR(lt_prog_compiler_pic, $1)"; then
+  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],
+    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],
+    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],
+    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in
+     "" | " "*) ;;
+     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=" $_LT_TAGVAR(lt_prog_compiler_pic, $1)" ;;
+     esac],
+    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])
+fi
+_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],
+	[Additional compiler flags for building library objects])
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\"
+_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],
+  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),
+  $lt_tmp_static_flag,
+  [],
+  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])
+_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],
+	[Compiler flag to prevent dynamic linking])
+])# _LT_COMPILER_PIC
+
+
+# _LT_LINKER_SHLIBS([TAGNAME])
+# ----------------------------
+# See if the linker supports building shared libraries.
+m4_defun([_LT_LINKER_SHLIBS],
+[AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+m4_if([$1], [CXX], [
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  case $host_os in
+  aix[[4-9]]*)
+    # If we're using GNU nm, then we don't want the "-C" option.
+    # -C means demangle to AIX nm, but means don't demangle with GNU nm
+    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    else
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    fi
+    ;;
+  pw32*)
+    _LT_TAGVAR(export_symbols_cmds, $1)="$ltdll_cmds"
+  ;;
+  cygwin* | mingw* | cegcc*)
+    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  linux* | k*bsd*-gnu)
+    _LT_TAGVAR(link_all_deplibs, $1)=no
+  ;;
+  *)
+    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  esac
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+], [
+  runpath_var=
+  _LT_TAGVAR(allow_undefined_flag, $1)=
+  _LT_TAGVAR(always_export_symbols, $1)=no
+  _LT_TAGVAR(archive_cmds, $1)=
+  _LT_TAGVAR(archive_expsym_cmds, $1)=
+  _LT_TAGVAR(compiler_needs_object, $1)=no
+  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+  _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  _LT_TAGVAR(hardcode_automatic, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_direct_absolute, $1)=no
+  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+  _LT_TAGVAR(hardcode_minus_L, $1)=no
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  _LT_TAGVAR(inherit_rpath, $1)=no
+  _LT_TAGVAR(link_all_deplibs, $1)=unknown
+  _LT_TAGVAR(module_cmds, $1)=
+  _LT_TAGVAR(module_expsym_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_new_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=
+  _LT_TAGVAR(thread_safe_flag_spec, $1)=
+  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  _LT_TAGVAR(include_expsyms, $1)=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+dnl Note also adjust exclude_expsyms for C++ above.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
+
+  _LT_TAGVAR(ld_shlibs, $1)=yes
+  if test "$with_gnu_ld" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[[3-9]]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+      # as there is no search path for DLLs.
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=no
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/'\'' | $SED -e '\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\'' | sort | uniq > $export_symbols'
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    interix[[3-9]]*)
+      _LT_TAGVAR(hardcode_direct, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      _LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95*)	# Portland Group f77 and f90 compilers
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+	  tmp_sharedflag='--shared' ;;
+	xl[[cC]]*)			# IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(compiler_needs_object, $1)=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	_LT_TAGVAR(archive_cmds, $1)='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+	  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        _LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.1[[0-5]].*)
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+    esac
+
+    if test "$_LT_TAGVAR(ld_shlibs, $1)" = no; then
+      runpath_var=
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	_LT_TAGVAR(hardcode_direct, $1)=unsupported
+      fi
+      ;;
+
+    aix[[4-9]]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      _LT_TAGVAR(archive_cmds, $1)=''
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[[012]]|aix4.[[012]].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+	_LT_TAGVAR(link_all_deplibs, $1)=no
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	_LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        _LT_SYS_MODULE_PATH_AIX
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	  _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 _LT_SYS_MODULE_PATH_AIX
+	 _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	  # Exported symbols can be pulled into shared objects from archives
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[[45]]*)
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      _LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `$ECHO "X$deplibs" | $Xsed -e '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+      # FIXME: Should let the user specify the lib program.
+      _LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'
+      _LT_TAGVAR(fix_srcfile_path, $1)='`cygpath -w "$srcfile"`'
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      ;;
+
+    darwin* | rhapsody*)
+      _LT_DARWIN_LINKER_FEATURES($1)
+      ;;
+
+    dgux*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    freebsd1*)
+      _LT_TAGVAR(ld_shlibs, $1)=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	_LT_TAGVAR(hardcode_minus_L, $1)=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  ;;
+	*)
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+        AC_LINK_IFELSE(int foo(void) {},
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+        )
+        LDFLAGS="$save_LDFLAGS"
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(inherit_rpath, $1)=yes
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)
+	     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	     ;;
+	   *)
+	     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    os2*)
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$ECHO DATA >> $output_objdir/$libname.def~$ECHO " SINGLE NONSHARED" >> $output_objdir/$libname.def~$ECHO EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      case $host_os in
+      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+        ;;
+	motorola)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4.3*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	_LT_TAGVAR(ld_shlibs, $1)=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      _LT_TAGVAR(ld_shlibs, $1)=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+])
+AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld
+
+_LT_DECL([], [libext], [0], [Old archive suffix (normally "a")])dnl
+_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally ".so")])dnl
+_LT_DECL([], [extract_expsyms_cmds], [2],
+    [The commands to extract the exported symbol list from a shared archive])
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$_LT_TAGVAR(archive_cmds_need_lc, $1)" in
+x|xyes)
+  # Assume -lc should be added
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $_LT_TAGVAR(archive_cmds, $1) in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      AC_MSG_CHECKING([whether -lc should be explicitly linked in])
+      $RM conftest*
+      echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+      if AC_TRY_EVAL(ac_compile) 2>conftest.err; then
+        soname=conftest
+        lib=conftest
+        libobjs=conftest.$ac_objext
+        deplibs=
+        wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)
+	pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)
+        compiler_flags=-v
+        linker_flags=-v
+        verstring=
+        output_objdir=.
+        libname=conftest
+        lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)
+        _LT_TAGVAR(allow_undefined_flag, $1)=
+        if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1)
+        then
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+        else
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+        fi
+        _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag
+      else
+        cat conftest.err 1>&5
+      fi
+      $RM conftest*
+      AC_MSG_RESULT([$_LT_TAGVAR(archive_cmds_need_lc, $1)])
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],
+    [Whether or not to add -lc for building shared libraries])
+_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],
+    [enable_shared_with_static_runtimes], [0],
+    [Whether or not to disallow shared libs when runtime libs are static])
+_LT_TAGDECL([], [export_dynamic_flag_spec], [1],
+    [Compiler flag to allow reflexive dlopens])
+_LT_TAGDECL([], [whole_archive_flag_spec], [1],
+    [Compiler flag to generate shared objects directly from archives])
+_LT_TAGDECL([], [compiler_needs_object], [1],
+    [Whether the compiler copes with passing no objects directly])
+_LT_TAGDECL([], [old_archive_from_new_cmds], [2],
+    [Create an old-style archive from a shared archive])
+_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],
+    [Create a temporary old-style archive to link instead of a shared archive])
+_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])
+_LT_TAGDECL([], [archive_expsym_cmds], [2])
+_LT_TAGDECL([], [module_cmds], [2],
+    [Commands used to build a loadable module if different from building
+    a shared archive.])
+_LT_TAGDECL([], [module_expsym_cmds], [2])
+_LT_TAGDECL([], [with_gnu_ld], [1],
+    [Whether we are building with GNU ld or not])
+_LT_TAGDECL([], [allow_undefined_flag], [1],
+    [Flag that allows shared libraries with undefined symbols to be built])
+_LT_TAGDECL([], [no_undefined_flag], [1],
+    [Flag that enforces no undefined symbols])
+_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],
+    [Flag to hardcode $libdir into a binary during linking.
+    This must work even if $libdir does not exist])
+_LT_TAGDECL([], [hardcode_libdir_flag_spec_ld], [1],
+    [[If ld is used when linking, flag to hardcode $libdir into a binary
+    during linking.  This must work even if $libdir does not exist]])
+_LT_TAGDECL([], [hardcode_libdir_separator], [1],
+    [Whether we need a single "-rpath" flag with a separated argument])
+_LT_TAGDECL([], [hardcode_direct], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary])
+_LT_TAGDECL([], [hardcode_direct_absolute], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary and the resulting library dependency is
+    "absolute", i.e impossible to change by setting ${shlibpath_var} if the
+    library is relocated])
+_LT_TAGDECL([], [hardcode_minus_L], [0],
+    [Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_shlibpath_var], [0],
+    [Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_automatic], [0],
+    [Set to "yes" if building a shared library automatically hardcodes DIR
+    into the library and all subsequent libraries and executables linked
+    against it])
+_LT_TAGDECL([], [inherit_rpath], [0],
+    [Set to yes if linker adds runtime paths of dependent libraries
+    to runtime path list])
+_LT_TAGDECL([], [link_all_deplibs], [0],
+    [Whether libtool must link a program against all its dependency libraries])
+_LT_TAGDECL([], [fix_srcfile_path], [1],
+    [Fix the shell variable $srcfile for the compiler])
+_LT_TAGDECL([], [always_export_symbols], [0],
+    [Set to "yes" if exported symbols are required])
+_LT_TAGDECL([], [export_symbols_cmds], [2],
+    [The commands to list exported symbols])
+_LT_TAGDECL([], [exclude_expsyms], [1],
+    [Symbols that should not be listed in the preloaded symbols])
+_LT_TAGDECL([], [include_expsyms], [1],
+    [Symbols that must always be exported])
+_LT_TAGDECL([], [prelink_cmds], [2],
+    [Commands necessary for linking programs (against libraries) with templates])
+_LT_TAGDECL([], [file_list_spec], [1],
+    [Specify filename containing input files])
+dnl FIXME: Not yet implemented
+dnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],
+dnl    [Compiler flag to generate thread safe objects])
+])# _LT_LINKER_SHLIBS
+
+
+# _LT_LANG_C_CONFIG([TAG])
+# ------------------------
+# Ensure that the configuration variables for a C compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_C_CONFIG],
+[m4_require([_LT_DECL_EGREP])dnl
+lt_save_CC="$CC"
+AC_LANG_PUSH(C)
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+_LT_TAG_COMPILER
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_SYS_DYNAMIC_LINKER($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+  LT_SYS_DLOPEN_SELF
+  _LT_CMD_STRIPLIB
+
+  # Report which library types will actually be built
+  AC_MSG_CHECKING([if libtool supports shared libraries])
+  AC_MSG_RESULT([$can_build_shared])
+
+  AC_MSG_CHECKING([whether to build shared libraries])
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[[4-9]]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  AC_MSG_RESULT([$enable_shared])
+
+  AC_MSG_CHECKING([whether to build static libraries])
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  AC_MSG_RESULT([$enable_static])
+
+  _LT_CONFIG($1)
+fi
+AC_LANG_POP
+CC="$lt_save_CC"
+])# _LT_LANG_C_CONFIG
+
+
+# _LT_PROG_CXX
+# ------------
+# Since AC_PROG_CXX is broken, in that it returns g++ if there is no c++
+# compiler, we have our own version here.
+m4_defun([_LT_PROG_CXX],
+[
+pushdef([AC_MSG_ERROR], [_lt_caught_CXX_error=yes])
+AC_PROG_CXX
+if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+    (test "X$CXX" != "Xg++"))) ; then
+  AC_PROG_CXXCPP
+else
+  _lt_caught_CXX_error=yes
+fi
+popdef([AC_MSG_ERROR])
+])# _LT_PROG_CXX
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([_LT_PROG_CXX], [])
+
+
+# _LT_LANG_CXX_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a C++ compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_CXX_CONFIG],
+[AC_REQUIRE([_LT_PROG_CXX])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+
+AC_LANG_PUSH(C++)
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(compiler_needs_object, $1)=no
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for C++ test sources.
+ac_ext=cpp
+
+# Object file extension for compiled C++ test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the CXX compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_caught_CXX_error" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="int some_variable = 0;"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC=$CC
+  lt_save_LD=$LD
+  lt_save_GCC=$GCC
+  GCC=$GXX
+  lt_save_with_gnu_ld=$with_gnu_ld
+  lt_save_path_LD=$lt_cv_path_LD
+  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
+    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
+  else
+    $as_unset lt_cv_prog_gnu_ld
+  fi
+  if test -n "${lt_cv_path_LDCXX+set}"; then
+    lt_cv_path_LD=$lt_cv_path_LDCXX
+  else
+    $as_unset lt_cv_path_LD
+  fi
+  test -z "${LDCXX+set}" || LD=$LDCXX
+  CC=${CXX-"c++"}
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    # We don't want -fno-exception when compiling C++ code, so set the
+    # no_builtin_flag separately
+    if test "$GXX" = yes; then
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'
+    else
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+    fi
+
+    if test "$GXX" = yes; then
+      # Set up default GNU C++ configuration
+
+      LT_PATH_LD
+
+      # Check if GNU C++ uses GNU ld as the underlying linker, since the
+      # archiving commands below assume that GNU ld is being used.
+      if test "$with_gnu_ld" = yes; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+        # If archive_cmds runs LD, not CC, wlarc should be empty
+        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
+        #     investigate it a little bit more. (MM)
+        wlarc='${wl}'
+
+        # ancient GNU ld didn't support --whole-archive et. al.
+        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
+	  $GREP 'no-whole-archive' > /dev/null; then
+          _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+        else
+          _LT_TAGVAR(whole_archive_flag_spec, $1)=
+        fi
+      else
+        with_gnu_ld=no
+        wlarc=
+
+        # A generic and very simple default shared library creation
+        # command for GNU C++ for the case where it uses the native
+        # linker, instead of GNU ld.  If possible, this setting should
+        # overridden to take advantage of the native linker features on
+        # the platform it is being used on.
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+      fi
+
+      # Commands to make compiler produce verbose output that lists
+      # what "hidden" libraries, object files and flags are used when
+      # linking a shared library.
+      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+
+    else
+      GXX=no
+      with_gnu_ld=no
+      wlarc=
+    fi
+
+    # PORTME: fill in a description of your system's C++ link characteristics
+    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+    _LT_TAGVAR(ld_shlibs, $1)=yes
+    case $host_os in
+      aix3*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+      aix[[4-9]]*)
+        if test "$host_cpu" = ia64; then
+          # On IA64, the linker does run time linking by default, so we don't
+          # have to do anything special.
+          aix_use_runtimelinking=no
+          exp_sym_flag='-Bexport'
+          no_entry_flag=""
+        else
+          aix_use_runtimelinking=no
+
+          # Test if we are trying to use run time linking or normal
+          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+          # need to do runtime linking.
+          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	    for ld_flag in $LDFLAGS; do
+	      case $ld_flag in
+	      *-brtl*)
+	        aix_use_runtimelinking=yes
+	        break
+	        ;;
+	      esac
+	    done
+	    ;;
+          esac
+
+          exp_sym_flag='-bexport'
+          no_entry_flag='-bnoentry'
+        fi
+
+        # When large executables or shared objects are built, AIX ld can
+        # have problems creating the table of contents.  If linking a library
+        # or program results in "error TOC overflow" add -mminimal-toc to
+        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+        _LT_TAGVAR(archive_cmds, $1)=''
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+        _LT_TAGVAR(link_all_deplibs, $1)=yes
+        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+        if test "$GXX" = yes; then
+          case $host_os in aix4.[[012]]|aix4.[[012]].*)
+          # We only want to do this on AIX 4.2 and lower, the check
+          # below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	    # We have reworked collect2
+	    :
+	  else
+	    # We have old collect2
+	    _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	    # It fails to find uninstalled libraries when the uninstalled
+	    # path is not listed in the libpath.  Setting hardcode_minus_L
+	    # to unsupported forces relinking
+	    _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+          esac
+          shared_flag='-shared'
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag="$shared_flag "'${wl}-G'
+	  fi
+        else
+          # not using gcc
+          if test "$host_cpu" = ia64; then
+	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	  # chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+          else
+	    if test "$aix_use_runtimelinking" = yes; then
+	      shared_flag='${wl}-G'
+	    else
+	      shared_flag='${wl}-bM:SRE'
+	    fi
+          fi
+        fi
+
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+        # It seems that -bexpall does not export symbols beginning with
+        # underscore (_), so it is better to generate a list of symbols to
+	# export.
+        _LT_TAGVAR(always_export_symbols, $1)=yes
+        if test "$aix_use_runtimelinking" = yes; then
+          # Warning - without using the other runtime loading flags (-brtl),
+          # -berok will link without error, but may produce a broken library.
+          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+          # Determine the default libpath from the value encoded in an empty
+          # executable.
+          _LT_SYS_MODULE_PATH_AIX
+          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        else
+          if test "$host_cpu" = ia64; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	    _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+          else
+	    # Determine the default libpath from the value encoded in an
+	    # empty executable.
+	    _LT_SYS_MODULE_PATH_AIX
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    # Warning - without using the other run time loading flags,
+	    # -berok will link without error, but may produce a broken library.
+	    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	    # Exported symbols can be pulled into shared objects from archives
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	    # This is similar to how AIX traditionally builds its shared
+	    # libraries.
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+          fi
+        fi
+        ;;
+
+      beos*)
+	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	  # support --undefined.  This deserves some investigation.  FIXME
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      chorus*)
+        case $cc_basename in
+          *)
+	  # FIXME: insert proper C++ library support
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	  ;;
+        esac
+        ;;
+
+      cygwin* | mingw* | pw32* | cegcc*)
+        # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+        # as there is no search path for DLLs.
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+        _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+        _LT_TAGVAR(always_export_symbols, $1)=no
+        _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+
+        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+          # If the export-symbols file already is a .def file (1st line
+          # is EXPORTS), use it as is; otherwise, prepend...
+          _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	    cp $export_symbols $output_objdir/$soname.def;
+          else
+	    echo EXPORTS > $output_objdir/$soname.def;
+	    cat $export_symbols >> $output_objdir/$soname.def;
+          fi~
+          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+        else
+          _LT_TAGVAR(ld_shlibs, $1)=no
+        fi
+        ;;
+      darwin* | rhapsody*)
+        _LT_DARWIN_LINKER_FEATURES($1)
+	;;
+
+      dgux*)
+        case $cc_basename in
+          ec++*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          ghcx*)
+	    # Green Hills C++ Compiler
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      freebsd[[12]]*)
+        # C++ shared libraries reported to be fairly broken before
+	# switch to ELF
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      freebsd-elf*)
+        _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+        ;;
+
+      freebsd* | dragonfly*)
+        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
+        # conventions
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+        ;;
+
+      gnu*)
+        ;;
+
+      hpux9*)
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+				             # but as the default
+				             # location of the library.
+
+        case $cc_basename in
+          CC*)
+            # FIXME: insert proper C++ library support
+            _LT_TAGVAR(ld_shlibs, $1)=no
+            ;;
+          aCC*)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            # Commands to make compiler produce verbose output that lists
+            # what "hidden" libraries, object files and flags are used when
+            # linking a shared library.
+            #
+            # There doesn't appear to be a way to prevent this compiler from
+            # explicitly linking system object files so we need to strip them
+            # from the output so that they don't get included in the library
+            # dependencies.
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+            ;;
+          *)
+            if test "$GXX" = yes; then
+              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            else
+              # FIXME: insert proper C++ library support
+              _LT_TAGVAR(ld_shlibs, $1)=no
+            fi
+            ;;
+        esac
+        ;;
+
+      hpux10*|hpux11*)
+        if test $with_gnu_ld = no; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+          case $host_cpu in
+            hppa*64*|ia64*)
+              ;;
+            *)
+	      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+              ;;
+          esac
+        fi
+        case $host_cpu in
+          hppa*64*|ia64*)
+            _LT_TAGVAR(hardcode_direct, $1)=no
+            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+            ;;
+          *)
+            _LT_TAGVAR(hardcode_direct, $1)=yes
+            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+					         # but as the default
+					         # location of the library.
+            ;;
+        esac
+
+        case $cc_basename in
+          CC*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          aCC*)
+	    case $host_cpu in
+	      hppa*64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      ia64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      *)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	    esac
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test $with_gnu_ld = no; then
+	        case $host_cpu in
+	          hppa*64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          ia64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          *)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	        esac
+	      fi
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      interix[[3-9]]*)
+	_LT_TAGVAR(hardcode_direct, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+	# Instead, shared libraries are loaded at an image base (0x10000000 by
+	# default) and relocated if they conflict, which is a slow very memory
+	# consuming and fragmenting process.  To avoid this, we pick a random,
+	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	;;
+      irix5* | irix6*)
+        case $cc_basename in
+          CC*)
+	    # SGI C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test "$with_gnu_ld" = no; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	      else
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` -o $lib'
+	      fi
+	    fi
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+	    ;;
+        esac
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(inherit_rpath, $1)=yes
+        ;;
+
+      linux* | k*bsd*-gnu)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'
+	    ;;
+	  icpc* | ecpc* )
+	    # Intel C++
+	    with_gnu_ld=yes
+	    # version 8.0 and above of icpc choke on multiply defined symbols
+	    # if we add $predep_objects and $postdep_objects, however 7.1 and
+	    # earlier do not add the objects themselves.
+	    case `$CC -V 2>&1` in
+	      *"Version 7."*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	      *)  # Version 8.0 or newer
+	        tmp_idyn=
+	        case $host_cpu in
+		  ia64*) tmp_idyn=' -i_dynamic';;
+		esac
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	    esac
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    ;;
+          pgCC* | pgcpp*)
+            # Portland Group C++ compiler
+	    case `$CC -V` in
+	    *pgCC\ [[1-5]]* | *pgcpp\ [[1-5]]*)
+	      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+		compile_command="$compile_command `find $tpldir -name \*.o | $NL2SP`"'
+	      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | $NL2SP`~
+		$RANLIB $oldlib'
+	      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    *) # Version 6 will use weak symbols
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+            ;;
+	  cxx*)
+	    # Compaq C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+
+	    runpath_var=LD_RUN_PATH
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`$ECHO "X$templist" | $Xsed -e "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+	  xl*)
+	    # IBM XL 8.0 on PPC, with GNU ld
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    if test "x$supports_anon_versioning" = xyes; then
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+		echo "local: *; };" >> $output_objdir/$libname.ver~
+		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	    fi
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	      _LT_TAGVAR(compiler_needs_object, $1)=yes
+
+	      # Not sure whether something based on
+	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
+	      # would be better.
+	      output_verbose_link_cmd='echo'
+
+	      # Archives containing C++ object files must be created using
+	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	      # necessary to make sure instantiated templates are included
+	      # in the archive.
+	      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+
+      lynxos*)
+        # FIXME: insert proper C++ library support
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      m88k*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      mvs*)
+        case $cc_basename in
+          cxx*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	  *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	esac
+	;;
+
+      netbsd*)
+        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
+	  wlarc=
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	fi
+	# Workaround some broken pre-1.5 toolchains
+	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
+	;;
+
+      *nto* | *qnx*)
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+	;;
+
+      openbsd2*)
+        # C++ shared libraries are fairly broken
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      openbsd*)
+	if test -f /usr/libexec/ld.so; then
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  fi
+	  output_verbose_link_cmd=echo
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      osf3* | osf4* | osf5*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Archives containing C++ object files must be created using
+	    # the KAI C++ compiler.
+	    case $host in
+	      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;
+	      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;
+	    esac
+	    ;;
+          RCC*)
+	    # Rational C++ 2.4.1
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          cxx*)
+	    case $host in
+	      osf3*)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && $ECHO "X${wl}-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+		;;
+	      *)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
+	          echo "-hidden">> $lib.exp~
+	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~
+	          $RM $lib.exp'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+		;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`$ECHO "X$templist" | $Xsed -e "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+	  *)
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	      case $host in
+	        osf3*)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	        *)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	      esac
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	      # Commands to make compiler produce verbose output that lists
+	      # what "hidden" libraries, object files and flags are used when
+	      # linking a shared library.
+	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      psos*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      sunos4*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.x
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          lcc*)
+	    # Lucid
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      solaris*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes
+	    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	    case $host_os in
+	      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+	      *)
+		# The compiler driver will combine and reorder linker options,
+		# but understands `-z linker_flag'.
+	        # Supported since Solaris 2.6 (maybe 2.5.1?)
+		_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	        ;;
+	    esac
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+
+	    output_verbose_link_cmd='echo'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	    ;;
+          gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+
+	    # The C++ compiler must be used to create the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    # GNU C++ compiler with Solaris linker
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'
+	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+	      else
+	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # platform.
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+	      fi
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'
+	      case $host_os in
+		solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+		*)
+		  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  ;;
+	      esac
+	    fi
+	    ;;
+        esac
+        ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      case $cc_basename in
+        CC*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+      esac
+      ;;
+
+      sysv5* | sco3.2v5* | sco5v6*)
+	# Note: We can NOT use -z defs as we might desire, because we do not
+	# link with -lc, and that would cause any symbols used from libc to
+	# always be unresolved, which means just about no library would
+	# ever link correctly.  If we're not using GNU ld we use -z text
+	# though, which does catch some bad symbols but isn't as heavy-handed
+	# as -z defs.
+	_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+	_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+	_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+	_LT_TAGVAR(link_all_deplibs, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+	runpath_var='LD_RUN_PATH'
+
+	case $cc_basename in
+          CC*)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	  *)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	esac
+      ;;
+
+      tandem*)
+        case $cc_basename in
+          NCC*)
+	    # NonStop-UX NCC 3.20
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      vxworks*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      *)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+    esac
+
+    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+    test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+    _LT_TAGVAR(GCC, $1)="$GXX"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  CC=$lt_save_CC
+  LDCXX=$LD
+  LD=$lt_save_LD
+  GCC=$lt_save_GCC
+  with_gnu_ld=$lt_save_with_gnu_ld
+  lt_cv_path_LDCXX=$lt_cv_path_LD
+  lt_cv_path_LD=$lt_save_path_LD
+  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
+  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
+fi # test "$_lt_caught_CXX_error" != yes
+
+AC_LANG_POP
+])# _LT_LANG_CXX_CONFIG
+
+
+# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])
+# ---------------------------------
+# Figure out "hidden" library dependencies from verbose
+# compiler output when linking a shared library.
+# Parse the compiler output and extract the necessary
+# objects, libraries and library flags.
+m4_defun([_LT_SYS_HIDDEN_LIBDEPS],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+# Dependencies to place before and after the object being linked:
+_LT_TAGVAR(predep_objects, $1)=
+_LT_TAGVAR(postdep_objects, $1)=
+_LT_TAGVAR(predeps, $1)=
+_LT_TAGVAR(postdeps, $1)=
+_LT_TAGVAR(compiler_lib_search_path, $1)=
+
+dnl we can't use the lt_simple_compile_test_code here,
+dnl because it contains code intended for an executable,
+dnl not a library.  It's possible we should let each
+dnl tag define a new lt_????_link_test_code variable,
+dnl but it's only used here...
+m4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF
+int a;
+void foo (void) { a = 0; }
+_LT_EOF
+], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF
+class Foo
+{
+public:
+  Foo (void) { a = 0; }
+private:
+  int a;
+};
+_LT_EOF
+], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer*4 a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF
+public class foo {
+  private int a;
+  public void bar (void) {
+    a = 0;
+  }
+};
+_LT_EOF
+])
+dnl Parse the compiler output and extract the necessary
+dnl objects, libraries and library flags.
+if AC_TRY_EVAL(ac_compile); then
+  # Parse the compiler output and extract the necessary
+  # objects, libraries and library flags.
+
+  # Sentinel used to keep track of whether or not we are before
+  # the conftest object file.
+  pre_test_object_deps_done=no
+
+  for p in `eval "$output_verbose_link_cmd"`; do
+    case $p in
+
+    -L* | -R* | -l*)
+       # Some compilers place space between "-{L,R}" and the path.
+       # Remove the space.
+       if test $p = "-L" ||
+          test $p = "-R"; then
+	 prev=$p
+	 continue
+       else
+	 prev=
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 case $p in
+	 -L* | -R*)
+	   # Internal compiler library paths should come after those
+	   # provided the user.  The postdeps already come after the
+	   # user supplied libs so there is no need to process them.
+	   if test -z "$_LT_TAGVAR(compiler_lib_search_path, $1)"; then
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${prev}${p}"
+	   else
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}"
+	   fi
+	   ;;
+	 # The "-l" case would never come before the object being
+	 # linked, so don't bother handling this case.
+	 esac
+       else
+	 if test -z "$_LT_TAGVAR(postdeps, $1)"; then
+	   _LT_TAGVAR(postdeps, $1)="${prev}${p}"
+	 else
+	   _LT_TAGVAR(postdeps, $1)="${_LT_TAGVAR(postdeps, $1)} ${prev}${p}"
+	 fi
+       fi
+       ;;
+
+    *.$objext)
+       # This assumes that the test object file only shows up
+       # once in the compiler output.
+       if test "$p" = "conftest.$objext"; then
+	 pre_test_object_deps_done=yes
+	 continue
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 if test -z "$_LT_TAGVAR(predep_objects, $1)"; then
+	   _LT_TAGVAR(predep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(predep_objects, $1)="$_LT_TAGVAR(predep_objects, $1) $p"
+	 fi
+       else
+	 if test -z "$_LT_TAGVAR(postdep_objects, $1)"; then
+	   _LT_TAGVAR(postdep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(postdep_objects, $1)="$_LT_TAGVAR(postdep_objects, $1) $p"
+	 fi
+       fi
+       ;;
+
+    *) ;; # Ignore the rest.
+
+    esac
+  done
+
+  # Clean up.
+  rm -f a.out a.exe
+else
+  echo "libtool.m4: error: problem compiling $1 test program"
+fi
+
+$RM -f confest.$objext
+
+# PORTME: override above test on systems where it is broken
+m4_if([$1], [CXX],
+[case $host_os in
+interix[[3-9]]*)
+  # Interix 3.5 installs completely hosed .la files for C++, so rather than
+  # hack all around it, let's just trust "g++" to DTRT.
+  _LT_TAGVAR(predep_objects,$1)=
+  _LT_TAGVAR(postdep_objects,$1)=
+  _LT_TAGVAR(postdeps,$1)=
+  ;;
+
+linux*)
+  case `$CC -V 2>&1 | sed 5q` in
+  *Sun\ C*)
+    # Sun C++ 5.9
+
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+
+solaris*)
+  case $cc_basename in
+  CC*)
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    # Adding this requires a known-good setup of shared libraries for
+    # Sun compiler versions before 5.6, else PIC objects from an old
+    # archive will be linked into the output, leading to subtle bugs.
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+esac
+])
+
+case " $_LT_TAGVAR(postdeps, $1) " in
+*" -lc "*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;
+esac
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=
+if test -n "${_LT_TAGVAR(compiler_lib_search_path, $1)}"; then
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo " ${_LT_TAGVAR(compiler_lib_search_path, $1)}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+fi
+_LT_TAGDECL([], [compiler_lib_search_dirs], [1],
+    [The directories searched by this compiler when creating a shared library])
+_LT_TAGDECL([], [predep_objects], [1],
+    [Dependencies to place before and after the objects being linked to
+    create a shared library])
+_LT_TAGDECL([], [postdep_objects], [1])
+_LT_TAGDECL([], [predeps], [1])
+_LT_TAGDECL([], [postdeps], [1])
+_LT_TAGDECL([], [compiler_lib_search_path], [1],
+    [The library search path used internally by the compiler when linking
+    a shared library])
+])# _LT_SYS_HIDDEN_LIBDEPS
+
+
+# _LT_PROG_F77
+# ------------
+# Since AC_PROG_F77 is broken, in that it returns the empty string
+# if there is no fortran compiler, we have our own version here.
+m4_defun([_LT_PROG_F77],
+[
+pushdef([AC_MSG_ERROR], [_lt_disable_F77=yes])
+AC_PROG_F77
+if test -z "$F77" || test "X$F77" = "Xno"; then
+  _lt_disable_F77=yes
+fi
+popdef([AC_MSG_ERROR])
+])# _LT_PROG_F77
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([_LT_PROG_F77], [])
+
+
+# _LT_LANG_F77_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a Fortran 77 compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_F77_CONFIG],
+[AC_REQUIRE([_LT_PROG_F77])dnl
+AC_LANG_PUSH(Fortran 77)
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for f77 test sources.
+ac_ext=f
+
+# Object file extension for compiled f77 test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the F77 compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_F77" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  CC=${F77-"f77"}
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+  GCC=$G77
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$G77"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC="$lt_save_CC"
+fi # test "$_lt_disable_F77" != yes
+
+AC_LANG_POP
+])# _LT_LANG_F77_CONFIG
+
+
+# _LT_PROG_FC
+# -----------
+# Since AC_PROG_FC is broken, in that it returns the empty string
+# if there is no fortran compiler, we have our own version here.
+m4_defun([_LT_PROG_FC],
+[
+pushdef([AC_MSG_ERROR], [_lt_disable_FC=yes])
+AC_PROG_FC
+if test -z "$FC" || test "X$FC" = "Xno"; then
+  _lt_disable_FC=yes
+fi
+popdef([AC_MSG_ERROR])
+])# _LT_PROG_FC
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([_LT_PROG_FC], [])
+
+
+# _LT_LANG_FC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for a Fortran compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_FC_CONFIG],
+[AC_REQUIRE([_LT_PROG_FC])dnl
+AC_LANG_PUSH(Fortran)
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for fc test sources.
+ac_ext=${ac_fc_srcext-f}
+
+# Object file extension for compiled fc test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the FC compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_FC" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  CC=${FC-"f95"}
+  compiler=$CC
+  GCC=$ac_cv_fc_compiler_gnu
+
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$ac_cv_fc_compiler_gnu"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC="$lt_save_CC"
+fi # test "$_lt_disable_FC" != yes
+
+AC_LANG_POP
+])# _LT_LANG_FC_CONFIG
+
+
+# _LT_LANG_GCJ_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for the GNU Java Compiler compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_GCJ_CONFIG],
+[AC_REQUIRE([LT_PROG_GCJ])dnl
+AC_LANG_SAVE
+
+# Source file extension for Java test sources.
+ac_ext=java
+
+# Object file extension for compiled Java test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="class foo {}"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+lt_save_GCC=$GCC
+GCC=yes
+CC=${GCJ-"gcj"}
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_TAGVAR(LD, $1)="$LD"
+_LT_CC_BASENAME([$compiler])
+
+# GCJ did not exist at the time GCC didn't implicitly link libc in.
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+
+  _LT_CONFIG($1)
+fi
+
+AC_LANG_RESTORE
+
+GCC=$lt_save_GCC
+CC="$lt_save_CC"
+])# _LT_LANG_GCJ_CONFIG
+
+
+# _LT_LANG_RC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for the Windows resource compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_RC_CONFIG],
+[AC_REQUIRE([LT_PROG_RC])dnl
+AC_LANG_SAVE
+
+# Source file extension for RC test sources.
+ac_ext=rc
+
+# Object file extension for compiled RC test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code='sample MENU { MENUITEM "&Soup", 100, CHECKED }'
+
+# Code to be used in simple link tests
+lt_simple_link_test_code="$lt_simple_compile_test_code"
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+lt_save_GCC=$GCC
+GCC=
+CC=${RC-"windres"}
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_CC_BASENAME([$compiler])
+_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+
+if test -n "$compiler"; then
+  :
+  _LT_CONFIG($1)
+fi
+
+GCC=$lt_save_GCC
+AC_LANG_RESTORE
+CC="$lt_save_CC"
+])# _LT_LANG_RC_CONFIG
+
+
+# LT_PROG_GCJ
+# -----------
+AC_DEFUN([LT_PROG_GCJ],
+[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],
+  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],
+    [AC_CHECK_TOOL(GCJ, gcj,)
+      test "x${GCJFLAGS+set}" = xset || GCJFLAGS="-g -O2"
+      AC_SUBST(GCJFLAGS)])])[]dnl
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_GCJ], [])
+
+
+# LT_PROG_RC
+# ----------
+AC_DEFUN([LT_PROG_RC],
+[AC_CHECK_TOOL(RC, windres,)
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_RC], [])
+
+
+# _LT_DECL_EGREP
+# --------------
+# If we don't have a new enough Autoconf to choose the best grep
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_EGREP],
+[AC_REQUIRE([AC_PROG_EGREP])dnl
+AC_REQUIRE([AC_PROG_FGREP])dnl
+test -z "$GREP" && GREP=grep
+_LT_DECL([], [GREP], [1], [A grep program that handles long lines])
+_LT_DECL([], [EGREP], [1], [An ERE matcher])
+_LT_DECL([], [FGREP], [1], [A literal string matcher])
+dnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too
+AC_SUBST([GREP])
+])
+
+
+# _LT_DECL_OBJDUMP
+# --------------
+# If we don't have a new enough Autoconf to choose the best objdump
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_OBJDUMP],
+[AC_CHECK_TOOL(OBJDUMP, objdump, false)
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])
+AC_SUBST([OBJDUMP])
+])
+
+
+# _LT_DECL_SED
+# ------------
+# Check for a fully-functional sed program, that truncates
+# as few characters as possible.  Prefer GNU sed if found.
+m4_defun([_LT_DECL_SED],
+[AC_PROG_SED
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+_LT_DECL([], [SED], [1], [A sed program that does not truncate output])
+_LT_DECL([], [Xsed], ["\$SED -e 1s/^X//"],
+    [Sed that helps us avoid accidentally triggering echo(1) options like -n])
+])# _LT_DECL_SED
+
+m4_ifndef([AC_PROG_SED], [
+# NOTE: This macro has been submitted for inclusion into   #
+#  GNU Autoconf as AC_PROG_SED.  When it is available in   #
+#  a released version of Autoconf we should remove this    #
+#  macro and use it instead.                               #
+
+m4_defun([AC_PROG_SED],
+[AC_MSG_CHECKING([for a sed that does not truncate output])
+AC_CACHE_VAL(lt_cv_path_SED,
+[# Loop through the user's path and test for sed and gsed.
+# Then use that list of sed's as ones to test for truncation.
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for lt_ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      if $as_executable_p "$as_dir/$lt_ac_prog$ac_exec_ext"; then
+        lt_ac_sed_list="$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext"
+      fi
+    done
+  done
+done
+IFS=$as_save_IFS
+lt_ac_max=0
+lt_ac_count=0
+# Add /usr/xpg4/bin/sed as it is typically found on Solaris
+# along with /bin/sed that truncates output.
+for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
+  test ! -f $lt_ac_sed && continue
+  cat /dev/null > conftest.in
+  lt_ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >conftest.in
+  # Check for GNU sed and select it if it is found.
+  if "$lt_ac_sed" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then
+    lt_cv_path_SED=$lt_ac_sed
+    break
+  fi
+  while true; do
+    cat conftest.in conftest.in >conftest.tmp
+    mv conftest.tmp conftest.in
+    cp conftest.in conftest.nl
+    echo >>conftest.nl
+    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break
+    cmp -s conftest.out conftest.nl || break
+    # 10000 chars as input seems more than enough
+    test $lt_ac_count -gt 10 && break
+    lt_ac_count=`expr $lt_ac_count + 1`
+    if test $lt_ac_count -gt $lt_ac_max; then
+      lt_ac_max=$lt_ac_count
+      lt_cv_path_SED=$lt_ac_sed
+    fi
+  done
+done
+])
+SED=$lt_cv_path_SED
+AC_SUBST([SED])
+AC_MSG_RESULT([$SED])
+])#AC_PROG_SED
+])#m4_ifndef
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_SED], [])
+
+
+# _LT_CHECK_SHELL_FEATURES
+# ------------------------
+# Find out whether the shell is Bourne or XSI compatible,
+# or has some other useful features.
+m4_defun([_LT_CHECK_SHELL_FEATURES],
+[AC_MSG_CHECKING([whether the shell understands some XSI constructs])
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+AC_MSG_RESULT([$xsi_shell])
+_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])
+
+AC_MSG_CHECKING([whether the shell understands "+="])
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$[1]+=\$[2]" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+AC_MSG_RESULT([$lt_shell_append])
+_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+_LT_DECL([], [lt_unset], [0], [whether the shell understands "unset"])dnl
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl
+_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl
+])# _LT_CHECK_SHELL_FEATURES
+
+
+# _LT_PROG_XSI_SHELLFNS
+# ---------------------
+# Bourne and XSI compatible variants of some useful shell functions.
+m4_defun([_LT_PROG_XSI_SHELLFNS],
+[case $xsi_shell in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $[*] ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+_LT_EOF
+    ;;
+  *) # Bourne compatible functions.
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+dnl func_dirname_and_basename
+dnl A portable version of this function is already defined in general.m4sh
+dnl so there is no need for it here.
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+# func_strip_suffix prefix name
+func_stripname ()
+{
+  case ${2} in
+    .*) func_stripname_result=`$ECHO "X${3}" \
+           | $Xsed -e "s%^${1}%%" -e "s%\\\\${2}\$%%"`;;
+    *)  func_stripname_result=`$ECHO "X${3}" \
+           | $Xsed -e "s%^${1}%%" -e "s%${2}\$%%"`;;
+  esac
+}
+
+# sed scripts:
+my_sed_long_opt='1s/^\(-[[^=]]*\)=.*/\1/;q'
+my_sed_long_arg='1s/^-[[^=]]*=//'
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_opt"`
+  func_opt_split_arg=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_arg"`
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  func_lo2o_result=`$ECHO "X${1}" | $Xsed -e "$lo2o"`
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=`$ECHO "X${1}" | $Xsed -e 's/\.[[^.]]*$/.lo/'`
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=`expr "$[@]"`
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=`expr "$[1]" : ".*" 2>/dev/null || echo $max_cmd_len`
+}
+
+_LT_EOF
+esac
+
+case $lt_shell_append in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$[1]+=\$[2]"
+}
+_LT_EOF
+    ;;
+  *)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$[1]=\$$[1]\$[2]"
+}
+
+_LT_EOF
+    ;;
+  esac
+])
+
+# Helper functions for option handling.                    -*- Autoconf -*-
+#
+#   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 6 ltoptions.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])
+
+
+# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)
+# ------------------------------------------
+m4_define([_LT_MANGLE_OPTION],
+[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])
+
+
+# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)
+# ---------------------------------------
+# Set option OPTION-NAME for macro MACRO-NAME, and if there is a
+# matching handler defined, dispatch to it.  Other OPTION-NAMEs are
+# saved as a flag.
+m4_define([_LT_SET_OPTION],
+[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl
+m4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),
+        _LT_MANGLE_DEFUN([$1], [$2]),
+    [m4_warning([Unknown $1 option `$2'])])[]dnl
+])
+
+
+# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])
+# ------------------------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+m4_define([_LT_IF_OPTION],
+[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])
+
+
+# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)
+# -------------------------------------------------------
+# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME
+# are set.
+m4_define([_LT_UNLESS_OPTIONS],
+[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+	    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),
+		      [m4_define([$0_found])])])[]dnl
+m4_ifdef([$0_found], [m4_undefine([$0_found])], [$3
+])[]dnl
+])
+
+
+# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)
+# ----------------------------------------
+# OPTION-LIST is a space-separated list of Libtool options associated
+# with MACRO-NAME.  If any OPTION has a matching handler declared with
+# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about
+# the unknown option and exit.
+m4_defun([_LT_SET_OPTIONS],
+[# Set options
+m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+    [_LT_SET_OPTION([$1], _LT_Option)])
+
+m4_if([$1],[LT_INIT],[
+  dnl
+  dnl Simply set some default values (i.e off) if boolean options were not
+  dnl specified:
+  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no
+  ])
+  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no
+  ])
+  dnl
+  dnl If no reference was made to various pairs of opposing options, then
+  dnl we run the default mode handler for the pair.  For example, if neither
+  dnl `shared' nor `disable-shared' was passed, we enable building of shared
+  dnl archives by default:
+  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])
+  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],
+  		   [_LT_ENABLE_FAST_INSTALL])
+  ])
+])# _LT_SET_OPTIONS
+
+
+
+# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)
+# -----------------------------------------
+m4_define([_LT_MANGLE_DEFUN],
+[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])
+
+
+# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)
+# -----------------------------------------------
+m4_define([LT_OPTION_DEFINE],
+[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl
+])# LT_OPTION_DEFINE
+
+
+# dlopen
+# ------
+LT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes
+])
+
+AU_DEFUN([AC_LIBTOOL_DLOPEN],
+[_LT_SET_OPTION([LT_INIT], [dlopen])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `dlopen' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])
+
+
+# win32-dll
+# ---------
+# Declare package support for building win32 dll's.
+LT_OPTION_DEFINE([LT_INIT], [win32-dll],
+[enable_win32_dll=yes
+
+case $host in
+*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-cegcc*)
+  AC_CHECK_TOOL(AS, as, false)
+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)
+  AC_CHECK_TOOL(OBJDUMP, objdump, false)
+  ;;
+esac
+
+test -z "$AS" && AS=as
+_LT_DECL([], [AS],      [0], [Assembler program])dnl
+
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+_LT_DECL([], [DLLTOOL], [0], [DLL creation program])dnl
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [0], [Object dumper program])dnl
+])# win32-dll
+
+AU_DEFUN([AC_LIBTOOL_WIN32_DLL],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+_LT_SET_OPTION([LT_INIT], [win32-dll])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `win32-dll' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])
+
+
+# _LT_ENABLE_SHARED([DEFAULT])
+# ----------------------------
+# implement the --enable-shared flag, and supports the `shared' and
+# `disable-shared' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_SHARED],
+[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([shared],
+    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],
+	[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)
+
+    _LT_DECL([build_libtool_libs], [enable_shared], [0],
+	[Whether or not to build shared libraries])
+])# _LT_ENABLE_SHARED
+
+LT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])
+])
+
+AC_DEFUN([AC_DISABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], [disable-shared])
+])
+
+AU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])
+AU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_SHARED], [])
+dnl AC_DEFUN([AM_DISABLE_SHARED], [])
+
+
+
+# _LT_ENABLE_STATIC([DEFAULT])
+# ----------------------------
+# implement the --enable-static flag, and support the `static' and
+# `disable-static' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_STATIC],
+[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([static],
+    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],
+	[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)
+
+    _LT_DECL([build_old_libs], [enable_static], [0],
+	[Whether or not to build static libraries])
+])# _LT_ENABLE_STATIC
+
+LT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])
+])
+
+AC_DEFUN([AC_DISABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], [disable-static])
+])
+
+AU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])
+AU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_STATIC], [])
+dnl AC_DEFUN([AM_DISABLE_STATIC], [])
+
+
+
+# _LT_ENABLE_FAST_INSTALL([DEFAULT])
+# ----------------------------------
+# implement the --enable-fast-install flag, and support the `fast-install'
+# and `disable-fast-install' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_FAST_INSTALL],
+[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([fast-install],
+    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],
+    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)
+
+_LT_DECL([fast_install], [enable_fast_install], [0],
+	 [Whether or not to optimize for fast installation])dnl
+])# _LT_ENABLE_FAST_INSTALL
+
+LT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])
+
+# Old names:
+AU_DEFUN([AC_ENABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `fast-install' option into LT_INIT's first parameter.])
+])
+
+AU_DEFUN([AC_DISABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], [disable-fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `disable-fast-install' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])
+dnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])
+
+
+# _LT_WITH_PIC([MODE])
+# --------------------
+# implement the --with-pic flag, and support the `pic-only' and `no-pic'
+# LT_INIT options.
+# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.
+m4_define([_LT_WITH_PIC],
+[AC_ARG_WITH([pic],
+    [AS_HELP_STRING([--with-pic],
+	[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],
+    [pic_mode="$withval"],
+    [pic_mode=default])
+
+test -z "$pic_mode" && pic_mode=m4_default([$1], [default])
+
+_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl
+])# _LT_WITH_PIC
+
+LT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])
+
+# Old name:
+AU_DEFUN([AC_LIBTOOL_PICMODE],
+[_LT_SET_OPTION([LT_INIT], [pic-only])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `pic-only' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])
+
+
+m4_define([_LTDL_MODE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],
+		 [m4_define([_LTDL_MODE], [nonrecursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [recursive],
+		 [m4_define([_LTDL_MODE], [recursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [subproject],
+		 [m4_define([_LTDL_MODE], [subproject])])
+
+m4_define([_LTDL_TYPE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [installable],
+		 [m4_define([_LTDL_TYPE], [installable])])
+LT_OPTION_DEFINE([LTDL_INIT], [convenience],
+		 [m4_define([_LTDL_TYPE], [convenience])])
+
+# ltsugar.m4 -- libtool m4 base layer.                         -*-Autoconf-*-
+#
+# Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+# Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 6 ltsugar.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTSUGAR_VERSION], [m4_if([0.1])])
+
+
+# lt_join(SEP, ARG1, [ARG2...])
+# -----------------------------
+# Produce ARG1SEPARG2...SEPARGn, omitting [] arguments and their
+# associated separator.
+# Needed until we can rely on m4_join from Autoconf 2.62, since all earlier
+# versions in m4sugar had bugs.
+m4_define([lt_join],
+[m4_if([$#], [1], [],
+       [$#], [2], [[$2]],
+       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift(m4_shift($@)))])])
+m4_define([_lt_join],
+[m4_if([$#$2], [2], [],
+       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift(m4_shift($@)))])])
+
+
+# lt_car(LIST)
+# lt_cdr(LIST)
+# ------------
+# Manipulate m4 lists.
+# These macros are necessary as long as will still need to support
+# Autoconf-2.59 which quotes differently.
+m4_define([lt_car], [[$1]])
+m4_define([lt_cdr],
+[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
+       [$#], 1, [],
+       [m4_dquote(m4_shift($@))])])
+m4_define([lt_unquote], $1)
+
+
+# lt_append(MACRO-NAME, STRING, [SEPARATOR])
+# ------------------------------------------
+# Redefine MACRO-NAME to hold its former content plus `SEPARATOR'`STRING'.
+# Note that neither SEPARATOR nor STRING are expanded; they are appended
+# to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).
+# No SEPARATOR is output if MACRO-NAME was previously undefined (different
+# than defined and empty).
+#
+# This macro is needed until we can rely on Autoconf 2.62, since earlier
+# versions of m4sugar mistakenly expanded SEPARATOR but not STRING.
+m4_define([lt_append],
+[m4_define([$1],
+	   m4_ifdef([$1], [m4_defn([$1])[$3]])[$2])])
+
+
+
+# lt_combine(SEP, PREFIX-LIST, INFIX, SUFFIX1, [SUFFIX2...])
+# ----------------------------------------------------------
+# Produce a SEP delimited list of all paired combinations of elements of
+# PREFIX-LIST with SUFFIX1 through SUFFIXn.  Each element of the list
+# has the form PREFIXmINFIXSUFFIXn.
+# Needed until we can rely on m4_combine added in Autoconf 2.62.
+m4_define([lt_combine],
+[m4_if(m4_eval([$# > 3]), [1],
+       [m4_pushdef([_Lt_sep], [m4_define([_Lt_sep], m4_defn([lt_car]))])]]dnl
+[[m4_foreach([_Lt_prefix], [$2],
+	     [m4_foreach([_Lt_suffix],
+		]m4_dquote(m4_dquote(m4_shift(m4_shift(m4_shift($@)))))[,
+	[_Lt_sep([$1])[]m4_defn([_Lt_prefix])[$3]m4_defn([_Lt_suffix])])])])])
+
+
+# lt_if_append_uniq(MACRO-NAME, VARNAME, [SEPARATOR], [UNIQ], [NOT-UNIQ])
+# -----------------------------------------------------------------------
+# Iff MACRO-NAME does not yet contain VARNAME, then append it (delimited
+# by SEPARATOR if supplied) and expand UNIQ, else NOT-UNIQ.
+m4_define([lt_if_append_uniq],
+[m4_ifdef([$1],
+	  [m4_if(m4_index([$3]m4_defn([$1])[$3], [$3$2$3]), [-1],
+		 [lt_append([$1], [$2], [$3])$4],
+		 [$5])],
+	  [lt_append([$1], [$2], [$3])$4])])
+
+
+# lt_dict_add(DICT, KEY, VALUE)
+# -----------------------------
+m4_define([lt_dict_add],
+[m4_define([$1($2)], [$3])])
+
+
+# lt_dict_add_subkey(DICT, KEY, SUBKEY, VALUE)
+# --------------------------------------------
+m4_define([lt_dict_add_subkey],
+[m4_define([$1($2:$3)], [$4])])
+
+
+# lt_dict_fetch(DICT, KEY, [SUBKEY])
+# ----------------------------------
+m4_define([lt_dict_fetch],
+[m4_ifval([$3],
+	m4_ifdef([$1($2:$3)], [m4_defn([$1($2:$3)])]),
+    m4_ifdef([$1($2)], [m4_defn([$1($2)])]))])
+
+
+# lt_if_dict_fetch(DICT, KEY, [SUBKEY], VALUE, IF-TRUE, [IF-FALSE])
+# -----------------------------------------------------------------
+m4_define([lt_if_dict_fetch],
+[m4_if(lt_dict_fetch([$1], [$2], [$3]), [$4],
+	[$5],
+    [$6])])
+
+
+# lt_dict_filter(DICT, [SUBKEY], VALUE, [SEPARATOR], KEY, [...])
+# --------------------------------------------------------------
+m4_define([lt_dict_filter],
+[m4_if([$5], [], [],
+  [lt_join(m4_quote(m4_default([$4], [[, ]])),
+           lt_unquote(m4_split(m4_normalize(m4_foreach(_Lt_key, lt_car([m4_shiftn(4, $@)]),
+		      [lt_if_dict_fetch([$1], _Lt_key, [$2], [$3], [_Lt_key ])])))))])[]dnl
+])
+
+# ltversion.m4 -- version numbers			-*- Autoconf -*-
+#
+#   Copyright (C) 2004 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# Generated from ltversion.in.
+
+# serial 3012 ltversion.m4
+# This file is part of GNU Libtool
+
+m4_define([LT_PACKAGE_VERSION], [2.2.6])
+m4_define([LT_PACKAGE_REVISION], [1.3012])
+
+AC_DEFUN([LTVERSION_VERSION],
+[macro_version='2.2.6'
+macro_revision='1.3012'
+_LT_DECL(, macro_version, 0, [Which release of libtool.m4 was used?])
+_LT_DECL(, macro_revision, 0)
+])
+
+# lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-
+#
+#   Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004.
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 4 lt~obsolete.m4
+
+# These exist entirely to fool aclocal when bootstrapping libtool.
+#
+# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)
+# which have later been changed to m4_define as they aren't part of the
+# exported API, or moved to Autoconf or Automake where they belong.
+#
+# The trouble is, aclocal is a bit thick.  It'll see the old AC_DEFUN
+# in /usr/share/aclocal/libtool.m4 and remember it, then when it sees us
+# using a macro with the same name in our local m4/libtool.m4 it'll
+# pull the old libtool.m4 in (it doesn't see our shiny new m4_define
+# and doesn't know about Autoconf macros at all.)
+#
+# So we provide this file, which has a silly filename so it's always
+# included after everything else.  This provides aclocal with the
+# AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything
+# because those macros already exist, or will be overwritten later.
+# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6. 
+#
+# Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.
+# Yes, that means every name once taken will need to remain here until
+# we give up compatibility with versions before 1.7, at which point
+# we need to keep only those names which we still refer to.
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOBSOLETE_VERSION], [m4_if([1])])
+
+m4_ifndef([AC_LIBTOOL_LINKER_OPTION],	[AC_DEFUN([AC_LIBTOOL_LINKER_OPTION])])
+m4_ifndef([AC_PROG_EGREP],		[AC_DEFUN([AC_PROG_EGREP])])
+m4_ifndef([_LT_AC_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH])])
+m4_ifndef([_LT_AC_SHELL_INIT],		[AC_DEFUN([_LT_AC_SHELL_INIT])])
+m4_ifndef([_LT_AC_SYS_LIBPATH_AIX],	[AC_DEFUN([_LT_AC_SYS_LIBPATH_AIX])])
+m4_ifndef([_LT_PROG_LTMAIN],		[AC_DEFUN([_LT_PROG_LTMAIN])])
+m4_ifndef([_LT_AC_TAGVAR],		[AC_DEFUN([_LT_AC_TAGVAR])])
+m4_ifndef([AC_LTDL_ENABLE_INSTALL],	[AC_DEFUN([AC_LTDL_ENABLE_INSTALL])])
+m4_ifndef([AC_LTDL_PREOPEN],		[AC_DEFUN([AC_LTDL_PREOPEN])])
+m4_ifndef([_LT_AC_SYS_COMPILER],	[AC_DEFUN([_LT_AC_SYS_COMPILER])])
+m4_ifndef([_LT_AC_LOCK],		[AC_DEFUN([_LT_AC_LOCK])])
+m4_ifndef([AC_LIBTOOL_SYS_OLD_ARCHIVE],	[AC_DEFUN([AC_LIBTOOL_SYS_OLD_ARCHIVE])])
+m4_ifndef([_LT_AC_TRY_DLOPEN_SELF],	[AC_DEFUN([_LT_AC_TRY_DLOPEN_SELF])])
+m4_ifndef([AC_LIBTOOL_PROG_CC_C_O],	[AC_DEFUN([AC_LIBTOOL_PROG_CC_C_O])])
+m4_ifndef([AC_LIBTOOL_SYS_HARD_LINK_LOCKS], [AC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS])])
+m4_ifndef([AC_LIBTOOL_OBJDIR],		[AC_DEFUN([AC_LIBTOOL_OBJDIR])])
+m4_ifndef([AC_LTDL_OBJDIR],		[AC_DEFUN([AC_LTDL_OBJDIR])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH], [AC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH])])
+m4_ifndef([AC_LIBTOOL_SYS_LIB_STRIP],	[AC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP])])
+m4_ifndef([AC_PATH_MAGIC],		[AC_DEFUN([AC_PATH_MAGIC])])
+m4_ifndef([AC_PROG_LD_GNU],		[AC_DEFUN([AC_PROG_LD_GNU])])
+m4_ifndef([AC_PROG_LD_RELOAD_FLAG],	[AC_DEFUN([AC_PROG_LD_RELOAD_FLAG])])
+m4_ifndef([AC_DEPLIBS_CHECK_METHOD],	[AC_DEFUN([AC_DEPLIBS_CHECK_METHOD])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_NO_RTTI], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI])])
+m4_ifndef([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE], [AC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_PIC], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_SHLIBS],	[AC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS])])
+m4_ifndef([AC_LIBTOOL_POSTDEP_PREDEP],	[AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP])])
+m4_ifndef([LT_AC_PROG_EGREP],		[AC_DEFUN([LT_AC_PROG_EGREP])])
+m4_ifndef([LT_AC_PROG_SED],		[AC_DEFUN([LT_AC_PROG_SED])])
+m4_ifndef([_LT_CC_BASENAME],		[AC_DEFUN([_LT_CC_BASENAME])])
+m4_ifndef([_LT_COMPILER_BOILERPLATE],	[AC_DEFUN([_LT_COMPILER_BOILERPLATE])])
+m4_ifndef([_LT_LINKER_BOILERPLATE],	[AC_DEFUN([_LT_LINKER_BOILERPLATE])])
+m4_ifndef([_AC_PROG_LIBTOOL],		[AC_DEFUN([_AC_PROG_LIBTOOL])])
+m4_ifndef([AC_LIBTOOL_SETUP],		[AC_DEFUN([AC_LIBTOOL_SETUP])])
+m4_ifndef([_LT_AC_CHECK_DLFCN],		[AC_DEFUN([_LT_AC_CHECK_DLFCN])])
+m4_ifndef([AC_LIBTOOL_SYS_DYNAMIC_LINKER],	[AC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER])])
+m4_ifndef([_LT_AC_TAGCONFIG],		[AC_DEFUN([_LT_AC_TAGCONFIG])])
+m4_ifndef([AC_DISABLE_FAST_INSTALL],	[AC_DEFUN([AC_DISABLE_FAST_INSTALL])])
+m4_ifndef([_LT_AC_LANG_CXX],		[AC_DEFUN([_LT_AC_LANG_CXX])])
+m4_ifndef([_LT_AC_LANG_F77],		[AC_DEFUN([_LT_AC_LANG_F77])])
+m4_ifndef([_LT_AC_LANG_GCJ],		[AC_DEFUN([_LT_AC_LANG_GCJ])])
+m4_ifndef([AC_LIBTOOL_RC],		[AC_DEFUN([AC_LIBTOOL_RC])])
+m4_ifndef([AC_LIBTOOL_LANG_C_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG])])
+m4_ifndef([_LT_AC_LANG_C_CONFIG],	[AC_DEFUN([_LT_AC_LANG_C_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_CXX_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG])])
+m4_ifndef([_LT_AC_LANG_CXX_CONFIG],	[AC_DEFUN([_LT_AC_LANG_CXX_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_F77_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG])])
+m4_ifndef([_LT_AC_LANG_F77_CONFIG],	[AC_DEFUN([_LT_AC_LANG_F77_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_GCJ_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG])])
+m4_ifndef([_LT_AC_LANG_GCJ_CONFIG],	[AC_DEFUN([_LT_AC_LANG_GCJ_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_RC_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG])])
+m4_ifndef([_LT_AC_LANG_RC_CONFIG],	[AC_DEFUN([_LT_AC_LANG_RC_CONFIG])])
+m4_ifndef([AC_LIBTOOL_CONFIG],		[AC_DEFUN([AC_LIBTOOL_CONFIG])])
+m4_ifndef([_LT_AC_FILE_LTDLL_C],	[AC_DEFUN([_LT_AC_FILE_LTDLL_C])])
+
+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_AUTOMAKE_VERSION(VERSION)
+# ----------------------------
+# Automake X.Y traces this macro to ensure aclocal.m4 has been
+# generated from the m4 files accompanying Automake X.Y.
+# (This private macro should not be called outside this file.)
+AC_DEFUN([AM_AUTOMAKE_VERSION],
+[am__api_version='1.10'
+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
+dnl require some minimum version.  Point them to the right macro.
+m4_if([$1], [1.10.2], [],
+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
+])
+
+# _AM_AUTOCONF_VERSION(VERSION)
+# -----------------------------
+# aclocal traces this macro to find the Autoconf version.
+# This is a private macro too.  Using m4_define simplifies
+# the logic in aclocal, which can simply ignore this definition.
+m4_define([_AM_AUTOCONF_VERSION], [])
+
+# AM_SET_CURRENT_AUTOMAKE_VERSION
+# -------------------------------
+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
+[AM_AUTOMAKE_VERSION([1.10.2])dnl
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
+
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+#
+# Of course, Automake must honor this variable whenever it calls a
+# tool from the auxiliary directory.  The problem is that $srcdir (and
+# therefore $ac_aux_dir as well) can be either absolute or relative,
+# depending on how configure is run.  This is pretty annoying, since
+# it makes $ac_aux_dir quite unusable in subdirectories: in the top
+# source directory, any form will work fine, but in subdirectories a
+# relative path needs to be adjusted first.
+#
+# $ac_aux_dir/missing
+#    fails when called from a subdirectory if $ac_aux_dir is relative
+# $top_srcdir/$ac_aux_dir/missing
+#    fails if $ac_aux_dir is absolute,
+#    fails when called from a subdirectory in a VPATH build with
+#          a relative $ac_aux_dir
+#
+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
+# are both prefixed by $srcdir.  In an in-source build this is usually
+# harmless because $srcdir is `.', but things will broke when you
+# start a VPATH build or use an absolute $srcdir.
+#
+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
+#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
+# and then we would define $MISSING as
+#   MISSING="\${SHELL} $am_aux_dir/missing"
+# This will work as long as MISSING is not called from configure, because
+# unfortunately $(top_srcdir) has no meaning in configure.
+# However there are other variables, like CC, which are often used in
+# configure, and could therefore not use this "fixed" $ac_aux_dir.
+#
+# Another solution, used here, is to always expand $ac_aux_dir to an
+# absolute PATH.  The drawback is that using absolute paths prevent a
+# configured tree to be moved without reconfiguration.
+
+AC_DEFUN([AM_AUX_DIR_EXPAND],
+[dnl Rely on autoconf to set up CDPATH properly.
+AC_PREREQ([2.50])dnl
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+])
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 8
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ(2.52)dnl
+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])dnl
+AC_SUBST([$1_FALSE])dnl
+_AM_SUBST_NOTMAKE([$1_TRUE])dnl
+_AM_SUBST_NOTMAKE([$1_FALSE])dnl
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 9
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
+       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
+       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
+       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                   [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE(dependency-tracking,
+[  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])dnl
+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+#serial 5
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[{
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`AS_DIRNAME("$mf")`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`AS_DIRNAME(["$file"])`
+      AS_MKDIR_P([$dirpart/$fdir])
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each `.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Do all the work for Automake.                             -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005, 2006, 2008 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 13
+
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
+
+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
+# AM_INIT_AUTOMAKE([OPTIONS])
+# -----------------------------------------------
+# The call with PACKAGE and VERSION arguments is the old style
+# call (pre autoconf-2.50), which is being phased out.  PACKAGE
+# and VERSION should now be passed to AC_INIT and removed from
+# the call to AM_INIT_AUTOMAKE.
+# We support both call styles for the transition.  After
+# the next Automake release, Autoconf can make the AC_INIT
+# arguments mandatory, and then we can depend on a new Autoconf
+# release and drop the old call support.
+AC_DEFUN([AM_INIT_AUTOMAKE],
+[AC_PREREQ([2.60])dnl
+dnl Autoconf wants to disallow AM_ names.  We explicitly allow
+dnl the ones we care about.
+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
+AC_REQUIRE([AC_PROG_INSTALL])dnl
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+AC_SUBST([CYGPATH_W])
+
+# Define the identity of the package.
+dnl Distinguish between old-style and new-style calls.
+m4_ifval([$2],
+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+ AC_SUBST([PACKAGE], [$1])dnl
+ AC_SUBST([VERSION], [$2])],
+[_AM_SET_OPTIONS([$1])dnl
+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
+
+_AM_IF_OPTION([no-define],,
+[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+ AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+
+# Some tools Automake needs.
+AC_REQUIRE([AM_SANITY_CHECK])dnl
+AC_REQUIRE([AC_ARG_PROGRAM])dnl
+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
+AM_MISSING_PROG(AUTOCONF, autoconf)
+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
+AM_MISSING_PROG(AUTOHEADER, autoheader)
+AM_MISSING_PROG(MAKEINFO, makeinfo)
+AM_PROG_INSTALL_SH
+AM_PROG_INSTALL_STRIP
+AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
+              [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
+	      		     [_AM_PROG_TAR([v7])])])
+_AM_IF_OPTION([no-dependencies],,
+[AC_PROVIDE_IFELSE([AC_PROG_CC],
+                  [_AM_DEPENDENCIES(CC)],
+                  [define([AC_PROG_CC],
+                          defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_CXX],
+                  [_AM_DEPENDENCIES(CXX)],
+                  [define([AC_PROG_CXX],
+                          defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_OBJC],
+                  [_AM_DEPENDENCIES(OBJC)],
+                  [define([AC_PROG_OBJC],
+                          defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
+])
+])
+
+
+# When config.status generates a header, we must update the stamp-h file.
+# This file resides in the same directory as the config header
+# that is generated.  The stamp files are numbered to have different names.
+
+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
+# loop where config.status creates the headers, so we can generate
+# our stamp files there.
+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
+[# Compute $1's index in $config_headers.
+_am_arg=$1
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_SH
+# ------------------
+# Define $install_sh.
+AC_DEFUN([AM_PROG_INSTALL_SH],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+install_sh=${install_sh-"\$(SHELL) $am_aux_dir/install-sh"}
+AC_SUBST(install_sh)])
+
+# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# Check whether the underlying file-system supports filenames
+# with a leading dot.  For instance MS-DOS doesn't.
+AC_DEFUN([AM_SET_LEADING_DOT],
+[rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+AC_SUBST([am__leading_dot])])
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
+
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 5
+
+# AM_MISSING_PROG(NAME, PROGRAM)
+# ------------------------------
+AC_DEFUN([AM_MISSING_PROG],
+[AC_REQUIRE([AM_MISSING_HAS_RUN])
+$1=${$1-"${am_missing_run}$2"}
+AC_SUBST($1)])
+
+
+# AM_MISSING_HAS_RUN
+# ------------------
+# Define MISSING if not defined so far and test if it supports --run.
+# If it does, set am_missing_run to use it, otherwise, to nothing.
+AC_DEFUN([AM_MISSING_HAS_RUN],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([missing])dnl
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  AC_MSG_WARN([`missing' script is too old or missing])
+fi
+])
+
+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_MKDIR_P
+# ---------------
+# Check for `mkdir -p'.
+AC_DEFUN([AM_PROG_MKDIR_P],
+[AC_PREREQ([2.60])dnl
+AC_REQUIRE([AC_PROG_MKDIR_P])dnl
+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
+dnl while keeping a definition of mkdir_p for backward compatibility.
+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
+dnl Makefile.ins that do not define MKDIR_P, so we do our own
+dnl adjustment using top_builddir (which is defined more often than
+dnl MKDIR_P).
+AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
+case $mkdir_p in
+  [[\\/$]]* | ?:[[\\/]]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+])
+
+# Helper functions for option handling.                     -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# _AM_MANGLE_OPTION(NAME)
+# -----------------------
+AC_DEFUN([_AM_MANGLE_OPTION],
+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
+
+# _AM_SET_OPTION(NAME)
+# ------------------------------
+# Set option NAME.  Presently that only means defining a flag for this option.
+AC_DEFUN([_AM_SET_OPTION],
+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+
+# _AM_SET_OPTIONS(OPTIONS)
+# ----------------------------------
+# OPTIONS is a space-separated list of Automake options.
+AC_DEFUN([_AM_SET_OPTIONS],
+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+
+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
+# -------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+AC_DEFUN([_AM_IF_OPTION],
+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_SANITY_CHECK
+# ---------------
+AC_DEFUN([AM_SANITY_CHECK],
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
+   if test "$[*]" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$[*]" != "X $srcdir/configure conftest.file" \
+      && test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "$[2]" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+AC_MSG_RESULT(yes)])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_STRIP
+# ---------------------
+# One issue with vendor `install' (even GNU) is that you can't
+# specify the program used to strip binaries.  This is especially
+# annoying in cross-compiling environments, where the build's strip
+# is unlikely to handle the host's binaries.
+# Fortunately install-sh will honor a STRIPPROG variable, so we
+# always use install-sh in `make install-strip', and initialize
+# STRIPPROG with the value of the STRIP variable (set by the user).
+AC_DEFUN([AM_PROG_INSTALL_STRIP],
+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+if test "$cross_compiling" != no; then
+  AC_CHECK_TOOL([STRIP], [strip], :)
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+AC_SUBST([INSTALL_STRIP_PROGRAM])])
+
+# Copyright (C) 2006  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# _AM_SUBST_NOTMAKE(VARIABLE)
+# ---------------------------
+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
+# This macro is traced by Automake.
+AC_DEFUN([_AM_SUBST_NOTMAKE])
+
+# Check how to create a tarball.                            -*- Autoconf -*-
+
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_PROG_TAR(FORMAT)
+# --------------------
+# Check how to create a tarball in format FORMAT.
+# FORMAT should be one of `v7', `ustar', or `pax'.
+#
+# Substitute a variable $(am__tar) that is a command
+# writing to stdout a FORMAT-tarball containing the directory
+# $tardir.
+#     tardir=directory && $(am__tar) > result.tar
+#
+# Substitute a variable $(am__untar) that extract such
+# a tarball read from stdin.
+#     $(am__untar) < result.tar
+AC_DEFUN([_AM_PROG_TAR],
+[# Always define AMTAR for backward compatibility.
+AM_MISSING_PROG([AMTAR], [tar])
+m4_if([$1], [v7],
+     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [m4_case([$1], [ustar],, [pax],,
+              [m4_fatal([Unknown tar format])])
+AC_MSG_CHECKING([how to create a $1 tar archive])
+# Loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
+_am_tools=${am_cv_prog_tar_$1-$_am_tools}
+# Do not fold the above two line into one, because Tru64 sh and
+# Solaris sh will not grok spaces in the rhs of `-'.
+for _am_tool in $_am_tools
+do
+  case $_am_tool in
+  gnutar)
+    for _am_tar in tar gnutar gtar;
+    do
+      AM_RUN_LOG([$_am_tar --version]) && break
+    done
+    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+    am__untar="$_am_tar -xf -"
+    ;;
+  plaintar)
+    # Must skip GNU tar: if it does not support --format= it doesn't create
+    # ustar tarball either.
+    (tar --version) >/dev/null 2>&1 && continue
+    am__tar='tar chf - "$$tardir"'
+    am__tar_='tar chf - "$tardir"'
+    am__untar='tar xf -'
+    ;;
+  pax)
+    am__tar='pax -L -x $1 -w "$$tardir"'
+    am__tar_='pax -L -x $1 -w "$tardir"'
+    am__untar='pax -r'
+    ;;
+  cpio)
+    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+    am__untar='cpio -i -H $1 -d'
+    ;;
+  none)
+    am__tar=false
+    am__tar_=false
+    am__untar=false
+    ;;
+  esac
+
+  # If the value was cached, stop now.  We just wanted to have am__tar
+  # and am__untar set.
+  test -n "${am_cv_prog_tar_$1}" && break
+
+  # tar/untar a dummy directory, and stop if the command works
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  echo GrepMe > conftest.dir/file
+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest.dir
+  if test -s conftest.tar; then
+    AM_RUN_LOG([$am__untar <conftest.tar])
+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+  fi
+done
+rm -rf conftest.dir
+
+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+AC_SUBST([am__tar])
+AC_SUBST([am__untar])
+]) # _AM_PROG_TAR
+
diff --git a/configure b/configure
new file mode 100755
index 0000000..11e19eb
--- /dev/null
+++ b/configure
@@ -0,0 +1,5889 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.63 for gtkworkbook 0.20.
+#
+# Report bugs to <jvb4@njit.edu>.
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+if test "x$CONFIG_SHELL" = x; then
+  if (eval ":") 2>/dev/null; then
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+
+  if test $as_have_required = yes &&	 (eval ":
+(as_func_return () {
+  (exit \$1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test \$exitcode = 0) || { (exit 1); exit 1; }
+
+(
+  as_lineno_1=\$LINENO
+  as_lineno_2=\$LINENO
+  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
+  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
+") 2> /dev/null; then
+  :
+else
+  as_candidate_shells=
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  case $as_dir in
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
+	   done;;
+       esac
+done
+IFS=$as_save_IFS
+
+
+      for as_shell in $as_candidate_shells $SHELL; do
+	 # Try only shells that exist, to save several forks.
+	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		{ ("$as_shell") 2> /dev/null <<\_ASEOF
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+:
+_ASEOF
+}; then
+  CONFIG_SHELL=$as_shell
+	       as_have_required=yes
+	       if { "$as_shell" 2> /dev/null <<\_ASEOF
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+:
+(as_func_return () {
+  (exit $1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = "$1" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test $exitcode = 0) || { (exit 1); exit 1; }
+
+(
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }
+
+_ASEOF
+}; then
+  break
+fi
+
+fi
+
+      done
+
+      if test "x$CONFIG_SHELL" != x; then
+  for as_var in BASH_ENV ENV
+	do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+	done
+	export CONFIG_SHELL
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+fi
+
+
+    if test $as_have_required = no; then
+  echo This script requires a shell more modern than all the
+      echo shells that I found on your system.  Please install a
+      echo modern shell, or manually run the script under such a
+      echo shell if you do have one.
+      { (exit 1); exit 1; }
+fi
+
+
+fi
+
+fi
+
+
+
+(eval "as_func_return () {
+  (exit \$1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test \$exitcode = 0") || {
+  echo No shell found that supports shell functions.
+  echo Please tell bug-autoconf@gnu.org about your system,
+  echo including any error possibly output before this message.
+  echo This can help us improve future autoconf versions.
+  echo Configuration will now proceed without shell functions.
+}
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+
+exec 7<&0 </dev/null 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Identity of this package.
+PACKAGE_NAME='gtkworkbook'
+PACKAGE_TARNAME='gtkworkbook'
+PACKAGE_VERSION='0.20'
+PACKAGE_STRING='gtkworkbook 0.20'
+PACKAGE_BUGREPORT='jvb4@njit.edu'
+
+ac_unique_file="gtkworkbook/cell.c"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='LTLIBOBJS
+LIBOBJS
+EGREP
+GREP
+RANLIB
+SET_MAKE
+LN_S
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+CPP
+ac_ct_CC
+CFLAGS
+CC
+AWK
+OBJEXT
+EXEEXT
+ac_ct_CXX
+CPPFLAGS
+LDFLAGS
+CXXFLAGS
+CXX
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CXX
+CXXFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CCC
+CC
+CFLAGS
+CPP'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
+   { (exit 1); exit 1; }; }
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
+   { (exit 1); exit 1; }; }
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
+   { (exit 1); exit 1; }; }
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
+   { (exit 1); exit 1; }; }
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { $as_echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { $as_echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
+   { (exit 1); exit 1; }; } ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  { $as_echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; }
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  { $as_echo "$as_me: error: working directory cannot be determined" >&2
+   { (exit 1); exit 1; }; }
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
+   { (exit 1); exit 1; }; }
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  { $as_echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || { $as_echo "$as_me: error: $ac_msg" >&2
+   { (exit 1); exit 1; }; }
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures gtkworkbook 0.20 to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/gtkworkbook]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of gtkworkbook 0.20:";;
+   esac
+  cat <<\_ACEOF
+
+Some influential environment variables:
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to <jvb4@njit.edu>.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+gtkworkbook configure 0.20
+generated by GNU Autoconf 2.63
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by gtkworkbook $as_me 0.20, which was
+generated by GNU Autoconf 2.63.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  $as_echo "PATH: $as_dir"
+done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args '$ac_arg'"
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------------- ##
+## File substitutions. ##
+## ------------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  ac_site_file1=$CONFIG_SITE
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test -r "$ac_site_file"; then
+    { $as_echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { $as_echo "$as_me:$LINENO: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:$LINENO: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:$LINENO: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:$LINENO:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:$LINENO:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+$as_echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+# Checks for programs.
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  { $as_echo "$as_me:$LINENO: result: $CXX" >&5
+$as_echo "$CXX" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CXX" >&5
+$as_echo "$ac_ct_CXX" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CXX" && break
+done
+
+  if test "x$ac_ct_CXX" = x; then
+    CXX="g++"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CXX=$ac_ct_CXX
+  fi
+fi
+
+  fi
+fi
+# Provide some information about the compiler.
+$as_echo "$as_me:$LINENO: checking for C++ compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:$LINENO: checking for C++ compiler default output file name" >&5
+$as_echo_n "checking for C++ compiler default output file name... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { (ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+        if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+
+{ $as_echo "$as_me:$LINENO: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+if test -z "$ac_file"; then
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C++ compiler cannot create executables
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: C++ compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:$LINENO: checking whether the C++ compiler works" >&5
+$as_echo_n "checking whether the C++ compiler works... " >&6; }
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot run C++ compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot run C++ compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+    fi
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+{ $as_echo "$as_me:$LINENO: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
+
+{ $as_echo "$as_me:$LINENO: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+{ $as_echo "$as_me:$LINENO: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if test "${ac_cv_objext+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C++ compiler" >&5
+$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
+if test "${ac_cv_cxx_compiler_gnu+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu" >&5
+$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GXX=yes
+else
+  GXX=
+fi
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+{ $as_echo "$as_me:$LINENO: checking whether $CXX accepts -g" >&5
+$as_echo_n "checking whether $CXX accepts -g... " >&6; }
+if test "${ac_cv_prog_cxx_g+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
+   ac_cxx_werror_flag=yes
+   ac_cv_prog_cxx_g=no
+   CXXFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cxx_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CXXFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+	 CXXFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cxx_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cxx_g" >&5
+$as_echo "$ac_cv_prog_cxx_g" >&6; }
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AWK+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:$LINENO: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:$LINENO: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_c89=$ac_arg
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:$LINENO: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:$LINENO: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:$LINENO: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { $as_echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
+$as_echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ $as_echo "$as_me:$LINENO: checking whether ln -s works" >&5
+$as_echo_n "checking whether ln -s works... " >&6; }
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no, using $LN_S" >&5
+$as_echo "no, using $LN_S" >&6; }
+fi
+
+{ $as_echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:$LINENO: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+
+# Checks for libraries.
+# FIXME: Replace `main' with a function in `-ldl':
+
+
+{ $as_echo "$as_me:$LINENO: checking for main in -ldl" >&5
+$as_echo_n "checking for main in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_main+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+return main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dl_main=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dl_main=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_main" >&5
+$as_echo "$ac_cv_lib_dl_main" >&6; }
+if test "x$ac_cv_lib_dl_main" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBDL 1
+_ACEOF
+
+  LIBS="-ldl $LIBS"
+
+fi
+
+
+# Checks for header files.
+
+{ $as_echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    { { $as_echo "$as_me:$LINENO: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+$as_echo "$as_me: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:$LINENO: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    { { $as_echo "$as_me:$LINENO: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+$as_echo "$as_me: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_header_stdc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_header_stdc=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+
+
+
+for ac_header in arpa/inet.h netdb.h netinet/in.h string.h sys/socket.h sys/time.h unistd.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
+$as_echo_n "checking $ac_header usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
+$as_echo_n "checking $ac_header presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    ( cat <<\_ASBOX
+## ---------------------------- ##
+## Report this to jvb4@njit.edu ##
+## ---------------------------- ##
+_ASBOX
+     ) | sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+
+fi
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+# Checks for typedefs, structures, and compiler characteristics.
+{ $as_echo "$as_me:$LINENO: checking for stdbool.h that conforms to C99" >&5
+$as_echo_n "checking for stdbool.h that conforms to C99... " >&6; }
+if test "${ac_cv_header_stdbool_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdbool.h>
+#ifndef bool
+ "error: bool is not defined"
+#endif
+#ifndef false
+ "error: false is not defined"
+#endif
+#if false
+ "error: false is not 0"
+#endif
+#ifndef true
+ "error: true is not defined"
+#endif
+#if true != 1
+ "error: true is not 1"
+#endif
+#ifndef __bool_true_false_are_defined
+ "error: __bool_true_false_are_defined is not defined"
+#endif
+
+	struct s { _Bool s: 1; _Bool t; } s;
+
+	char a[true == 1 ? 1 : -1];
+	char b[false == 0 ? 1 : -1];
+	char c[__bool_true_false_are_defined == 1 ? 1 : -1];
+	char d[(bool) 0.5 == true ? 1 : -1];
+	bool e = &s;
+	char f[(_Bool) 0.0 == false ? 1 : -1];
+	char g[true];
+	char h[sizeof (_Bool)];
+	char i[sizeof s.t];
+	enum { j = false, k = true, l = false * true, m = true * 256 };
+	/* The following fails for
+	   HP aC++/ANSI C B3910B A.05.55 [Dec 04 2003]. */
+	_Bool n[m];
+	char o[sizeof n == m * sizeof n[0] ? 1 : -1];
+	char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
+#	if defined __xlc__ || defined __GNUC__
+	 /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0
+	    reported by James Lemley on 2005-10-05; see
+	    http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+	    This test is not quite right, since xlc is allowed to
+	    reject this program, as the initializer for xlcbug is
+	    not one of the forms that C requires support for.
+	    However, doing the test right would require a runtime
+	    test, and that would make cross-compilation harder.
+	    Let us hope that IBM fixes the xlc bug, and also adds
+	    support for this kind of constant expression.  In the
+	    meantime, this test will reject xlc, which is OK, since
+	    our stdbool.h substitute should suffice.  We also test
+	    this with GCC, where it should work, to detect more
+	    quickly whether someone messes up the test in the
+	    future.  */
+	 char digs[] = "0123456789";
+	 int xlcbug = 1 / (&(digs + 5)[-2 + (bool) 1] == &digs[4] ? 1 : -1);
+#	endif
+	/* Catch a bug in an HP-UX C compiler.  See
+	   http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+	   http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+	 */
+	_Bool q = true;
+	_Bool *pq = &q;
+
+int
+main ()
+{
+
+	*pq |= q;
+	*pq |= ! q;
+	/* Refer to every declared value, to avoid compiler optimizations.  */
+	return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
+		+ !m + !n + !o + !p + !q + !pq);
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_header_stdbool_h=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_header_stdbool_h=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdbool_h" >&5
+$as_echo "$ac_cv_header_stdbool_h" >&6; }
+{ $as_echo "$as_me:$LINENO: checking for _Bool" >&5
+$as_echo_n "checking for _Bool... " >&6; }
+if test "${ac_cv_type__Bool+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type__Bool=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (_Bool))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((_Bool)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type__Bool=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type__Bool" >&5
+$as_echo "$ac_cv_type__Bool" >&6; }
+if test "x$ac_cv_type__Bool" = x""yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE__BOOL 1
+_ACEOF
+
+
+fi
+
+if test $ac_cv_header_stdbool_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_STDBOOL_H 1
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for inline" >&5
+$as_echo_n "checking for inline... " >&6; }
+if test "${ac_cv_c_inline+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_inline=$ac_kw
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  test "$ac_cv_c_inline" != no && break
+done
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
+$as_echo "$ac_cv_c_inline" >&6; }
+
+
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
+_ACEOF
+    ;;
+esac
+
+{ $as_echo "$as_me:$LINENO: checking for size_t" >&5
+$as_echo_n "checking for size_t... " >&6; }
+if test "${ac_cv_type_size_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_size_t=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (size_t))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((size_t)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_size_t=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
+$as_echo "$ac_cv_type_size_t" >&6; }
+if test "x$ac_cv_type_size_t" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned int
+_ACEOF
+
+fi
+
+
+# Checks for library functions.
+
+
+
+
+for ac_func in gethostbyname gettimeofday memset socket
+do
+as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
+$as_echo_n "checking for $ac_func... " >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  eval "$as_ac_var=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+ac_config_files="$ac_config_files Makefile gtkworkbook/OBJS/Makefile src/OBJS/Makefile src/largefile/OBJS/Makefile src/realtime/OBJS/Makefile"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { $as_echo "$as_me:$LINENO: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { $as_echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+ac_script='
+:mline
+/\\$/{
+ N
+ s,\\\n,,
+ b mline
+}
+t clear
+:clear
+s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\)/-D\1=\2/g
+t quote
+s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)/-D\1=\2/g
+t quote
+b any
+:quote
+s/[	 `~#$^&*(){}\\|;'\''"<>?]/\\&/g
+s/\[/\\&/g
+s/\]/\\&/g
+s/\$/$$/g
+H
+:any
+${
+	g
+	s/^\n//
+	s/\n/ /g
+	p
+}
+'
+DEFS=`sed -n "$ac_script" confdefs.h`
+
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+
+# Save the log message, to keep $[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by gtkworkbook $as_me 0.20, which was
+generated by GNU Autoconf 2.63.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTION]... [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to <bug-autoconf@gnu.org>."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_version="\\
+gtkworkbook config.status 0.20
+configured by $0, generated by GNU Autoconf 2.63,
+  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2008 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    CONFIG_FILES="$CONFIG_FILES '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h |  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { $as_echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "gtkworkbook/OBJS/Makefile") CONFIG_FILES="$CONFIG_FILES gtkworkbook/OBJS/Makefile" ;;
+    "src/OBJS/Makefile") CONFIG_FILES="$CONFIG_FILES src/OBJS/Makefile" ;;
+    "src/largefile/OBJS/Makefile") CONFIG_FILES="$CONFIG_FILES src/largefile/OBJS/Makefile" ;;
+    "src/realtime/OBJS/Makefile") CONFIG_FILES="$CONFIG_FILES src/realtime/OBJS/Makefile" ;;
+
+  *) { { $as_echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+$as_echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} ||
+{
+   $as_echo "$as_me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=''
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\).*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\).*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || { { $as_echo "$as_me:$LINENO: error: could not setup config files machinery" >&5
+$as_echo "$as_me: error: could not setup config files machinery" >&2;}
+   { (exit 1); exit 1; }; }
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+
+eval set X "  :F $CONFIG_FILES      "
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
+$as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
+   { (exit 1); exit 1; }; };;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   { { $as_echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
+$as_echo "$as_me: error: cannot find input file: $ac_f" >&2;}
+   { (exit 1); exit 1; }; };;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      ac_file_inputs="$ac_file_inputs '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:$LINENO: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; } ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  { as_dir="$ac_dir"
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
+   { (exit 1); exit 1; }; }; }
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p
+'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+    s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  esac \
+  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
+ ;;
+
+
+
+  esac
+
+done # for ac_tag
+
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  { { $as_echo "$as_me:$LINENO: error: write failure creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: write failure creating $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
diff --git a/configure.ac b/configure.ac
new file mode 100644
index 0000000..c17fa88
--- /dev/null
+++ b/configure.ac
@@ -0,0 +1,38 @@
+#                                               -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+
+AC_PREREQ([2.59])
+AC_INIT([gtkworkbook], [0.20], [jvb4@njit.edu])
+AC_CONFIG_SRCDIR([gtkworkbook/cell.c])
+
+# Checks for programs.
+AC_PROG_CXX
+AC_PROG_AWK
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+AC_PROG_RANLIB
+
+# Checks for libraries.
+# FIXME: Replace `main' with a function in `-ldl':
+AC_CHECK_LIB([dl], [main])
+
+# Checks for header files.
+AC_CHECK_HEADERS([arpa/inet.h netdb.h netinet/in.h string.h sys/socket.h sys/time.h unistd.h])
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_HEADER_STDBOOL
+AC_C_INLINE
+AC_TYPE_SIZE_T
+
+# Checks for library functions.
+AC_CHECK_FUNCS([gethostbyname gettimeofday memset socket])
+
+AC_CONFIG_FILES([Makefile
+                 gtkworkbook/OBJS/Makefile
+                 src/OBJS/Makefile
+                 src/largefile/OBJS/Makefile
+                 src/realtime/OBJS/Makefile])
+AC_OUTPUT
diff --git a/gtkworkbook/Makefile b/gtkworkbook/Makefile
deleted file mode 100755
index d0f94c7..0000000
--- a/gtkworkbook/Makefile
+++ /dev/null
@@ -1,31 +0,0 @@
-include ../Makefile.base
-
-SRCS=$(wildcard *.c)
-OBJS=$(patsubst %.c,${OBJDIR}/libgtkworkbook/%.o,${SRCS})
-
-all: 	libgtkworkbook
-
-install:
-	${RM} ${INSLIBDIR}/libgtkworkbook.a ${INSLIBDIR}/libgtkworkbook.so.1 \
-	${INSLIBDIR}/libgtkworkbook.so.1
-	${CP} ${PROJDIR}/lib/libgtkworkbook.so ${INSLIBDIR}/libgtkworkbook.so.1
-	${LN} ${INSLIBDIR}/libgtkworkbook.so.1 ${INSLIBDIR}/libgtkworkbook.a
-	${LN} ${INSLIBDIR}/libgtkworkbook.a ${INSLIBDIR}/libgtkworkbook.so
-#	chcon -t textrel_shlib_t ${INSLIBDIR}/libgtkworkbook.so.1
-
-libgtkworkbook: ${OBJS}
-	${MD} ${PROJDIR}/lib
-	${RM} ${PROJDIR}/lib/libgtkworkbook.so.1 ${PROJDIR}/lib/libgtkworkbook.so
-	${CC} ${CCFLAGS} -shared -Wl,-soname,libgtkworkbook.so.1 \
-	-o ${PROJDIR}/lib/libgtkworkbook.so ${OBJS} ${LIBS} \
-	-lgtkextra-x11-2.0 -ldl -gthread-2.0
-	${LN} ${PROJDIR}/lib/libgtkworkbook.so ${PROJDIR}/lib/libgtkworkbook.so.1
-clean:		
-	${MD} ${OBJDIR}/libgtkworkbook	
-	${RM} ${OBJS} ${PROJDIR}/lib/libgtkworkbook.so.1
-
-${OBJDIR}/libgtkworkbook/%.o: %.c
-	${CC} ${INCS} -c -fPIC ${CCFLAGS} $< -o $@
-
-.c.o:
-	${CC} ${INCS} -c -fPIC ${CCFLAGS} $<
diff --git a/src/Makefile b/src/Makefile
deleted file mode 100755
index 3c909a2..0000000
--- a/src/Makefile
+++ /dev/null
@@ -1,33 +0,0 @@
-include ../Makefile.base
-
-INCS += -I./shared
-SRCS=$(wildcard *.cpp) $(wildcard shared/proactor/*.cpp) $(wildcard shared/concurrent/*.cpp) \
-$(wildcard shared/network/*.cpp)
-OBJS=$(patsubst %.cpp,${OBJDIR}/%.o,${SRCS})
-
-LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0
-
-all: 	gtkworkbook
-	make -C realtime/ all
-	make -C largefile/ all
-
-gtkworkbook: ${OBJS}
-	${CX} ${CXFLAGS} -rdynamic -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
-
-clean:		
-	${MD} ${OBJDIR}	
-	${RM} ${OBJS} ${INSBINDIR}/gtkworkbook
-	make -C realtime/ clean
-	make -C largefile/ clean
-
-install: all
-	${MD} ${INSBINDIR}
-	${CP} ${PROJDIR}/bin/gtkworkbook ${INSBINDIR}/gtkworkbook
-	make -C realtime/ install
-	make -C largefile/ install
-
-${OBJDIR}/%.o: %.cpp
-	${CX} -rdynamic ${INCS} -c ${CXFLAGS} $< -o $@
-
-.cpp.o:
-	${CX} -rdynamic ${INCS} -c ${CXFLAGS} $<
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
deleted file mode 100755
index 134ddb8..0000000
--- a/src/largefile/Makefile
+++ /dev/null
@@ -1,27 +0,0 @@
-include ../../Makefile.base
-
-INCS += -I/home/johnb/include -I../shared -I../
-SRCS=$(wildcard *.cpp) 
-OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
-
-_CXFLAGS= -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
-
-all: 	largefile
-
-largefile: ${OBJS}
-	${CX} ${CXFLAGS} ${_CXFLAGS} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread -lcsv
-
-clean:		
-	${MD} ${OBJDIR}/largefile
-	${RM} ${OBJS} ${PROJDIR}/bin/largefile.so
-
-install: all
-	${MD} ${INSEXTDIR}
-	${CP} ${PROJDIR}/bin/largefile.so ${INSEXTDIR}/largefile.so
-
-${OBJDIR}/largefile/%.o: %.cpp
-	${CX} ${_CXFLAGS} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
-
-.cpp.o:
-	${CX} ${_CXFLAGS} ${INCS} -c -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
diff --git a/src/realtime/Makefile b/src/realtime/Makefile
deleted file mode 100755
index 2513255..0000000
--- a/src/realtime/Makefile
+++ /dev/null
@@ -1,25 +0,0 @@
-include ../../Makefile.base
-
-INCS += -I$../shared -I../shared
-SRCS = $(wildcard *.cpp) 
-OBJS = $(patsubst %.cpp,${OBJDIR}/realtime/%.o,${SRCS}) 
-
-all: 	realtime
-
-realtime: ${OBJS}
-	${CX} -shared -Wl -o ${PROJDIR}/bin/realtime.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread -lcsv
-
-clean:		
-	${MD} ${OBJDIR}/realtime
-	${RM} ${OBJS} ${PROJDIR}/bin/realtime.so
-
-install: all
-	${MD} ${INSEXTDIR}
-	${CP} ${PROJDIR}/bin/realtime.so ${INSEXTDIR}/realtime.so
-
-${OBJDIR}/realtime/%.o: %.cpp
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
-
-.cpp.o:
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<
\ No newline at end of file

commit e723c8536d58b65193f2c3a65a483cc9e0f0d88d
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Aug 7 16:32:24 2009 -0400

    Added the beginnings of a RecordView dialog object.

diff --git a/bin/application.cfg b/bin/application.cfg
index 5d21ff8..2207b39 100755
--- a/bin/application.cfg
+++ b/bin/application.cfg
@@ -3,7 +3,7 @@
 }
 %block realtime
 {
-	onLoad :: run=1;
+	onLoad :: run=0;
 	linux :: filename=realtime.so;
 	log :: path=/home/johnb;
 	tcp :: port=8888;
diff --git a/src/Application.cpp b/src/Application.cpp
index bb47aa4..c1413e6 100755
--- a/src/Application.cpp
+++ b/src/Application.cpp
@@ -18,12 +18,10 @@
 */
 #include "Application.hpp"
 #include "Plugin.hpp"
+#include "RecordView.hpp"
 #include <cstring>
 #include <iostream>
 
-/* @description: This method takes the argument and clears the string of
-   everything except for the directories. Therefore the return value would
-   be a string sans anything before the last directory delimiter '/'. */
 static gchar *
 munchpath (gchar * path_) {
 	gchar * path = g_strdup(path_);
@@ -205,6 +203,11 @@ Application::shutdown(void) {
 	gtk_main_quit ();
 }
 
+RecordView *
+Application::OpenRecordView (Sheet * sheet, int row, int col) {
+	return NULL;
+}
+
 void
 Application::open_extension (const gchar * filename, gboolean absolute_path) {
 	gchar * fname = NULL;
diff --git a/src/Application.hpp b/src/Application.hpp
index a5d0834..70d8314 100755
--- a/src/Application.hpp
+++ b/src/Application.hpp
@@ -28,6 +28,8 @@
 #include "proactor/Proactor.hpp"
 
 class Plugin;
+class RecordView;
+
 class Application {
 public:
 	enum sigs {
@@ -66,6 +68,8 @@ public:
 	Plugin * load_plugin (const std::string filename);
 	void open_extension (const gchar * filename, gboolean absolute_path);
 
+	RecordView * OpenRecordView (Sheet * sheet, int row, int col);
+	
 	inline GtkWidget * gtkwindow() { return this->gtk_window; }
 	inline GtkWidget * gtkvbox() { return this->gtk_window_vbox; }
 	inline GtkWidget * gtkmenu() { return this->gtk_menu; }
diff --git a/src/RecordView.cpp b/src/RecordView.cpp
new file mode 100755
index 0000000..0559d10
--- /dev/null
+++ b/src/RecordView.cpp
@@ -0,0 +1,30 @@
+#include "RecordView.hpp"
+
+static void
+RecordViewCallback (GtkWidget * w, gpointer data) {
+
+}
+
+RecordView::RecordView (Application * appstate) {
+	this->appstate = appstate;
+
+	this->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	gtk_window_set_title (GTK_WINDOW (this->gtk_window), "Record View");
+	/*	gtk_window_set_model (GTK_WINDOW (this->gtk_window), FALSE);
+		gtk_window_set_resizeable (GTK_WINDOW (this->gtk_window), TRUE); */
+	gtk_window_set_destroy_with_parent (GTK_WINDOW (this->gtk_window), TRUE);
+}
+
+RecordView::~RecordView (void) {
+
+}
+
+GtkWidget *
+RecordView::window (void) {
+	return this->gtk_window;
+}
+
+Application *
+RecordView::app (void) {
+	return this->appstate;
+}
diff --git a/src/RecordView.hpp b/src/RecordView.hpp
new file mode 100755
index 0000000..3bc1feb
--- /dev/null
+++ b/src/RecordView.hpp
@@ -0,0 +1,20 @@
+#ifndef HPP_RECORDVIEW
+#define HPP_RECORDVIEW
+
+#include <gtk/gtk.h>
+#include <gtkworkbook/workbook.h>
+#include "Application.hpp"
+
+class RecordView {
+private:
+	GtkWidget * gtk_window;
+	Application * appstate;
+public:
+	RecordView (Application * app);
+	~RecordView (void);
+
+	Application * app (void);
+	GtkWidget * window (void);
+};
+
+#endif
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index 32d1fa4..38c7ded 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -191,14 +191,11 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 
 		// Connect the signals to we can do fancy switching.
 		g_signal_connect (G_OBJECT (gtk_radiobyte), "toggled",
-								G_CALLBACK (GotoDialogRadioToggleCallback),
-								dialog);
+								G_CALLBACK (GotoDialogRadioToggleCallback), dialog);
 		g_signal_connect (G_OBJECT (gtk_radioline), "toggled",
-								G_CALLBACK (GotoDialogRadioToggleCallback),
-								dialog);
+								G_CALLBACK (GotoDialogRadioToggleCallback), dialog);
 		g_signal_connect (G_OBJECT (gtk_radioperc), "toggled",
-								G_CALLBACK (GotoDialogRadioToggleCallback),
-								dialog);
+								G_CALLBACK (GotoDialogRadioToggleCallback), dialog);
 		g_signal_connect (G_OBJECT (dialog->widget), "response",
 								G_CALLBACK (GotoDialogResponseCallback), dialog);
 		
diff --git a/src/realtime/OpenStreamDialog.hpp b/src/realtime/OpenStreamDialog.hpp
index c2dd794..e1374f5 100755
--- a/src/realtime/OpenStreamDialog.hpp
+++ b/src/realtime/OpenStreamDialog.hpp
@@ -1,3 +1,21 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_OPENSTREAMDIALOG
 #define HPP_OPENSTREAMDIALOG
 
diff --git a/src/realtime/Realtime.cpp b/src/realtime/Realtime.cpp
index eab50df..4760810 100755
--- a/src/realtime/Realtime.cpp
+++ b/src/realtime/Realtime.cpp
@@ -1,3 +1,21 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include <sstream>
 #include <gdk/gdkkeysyms.h>
 #include <gtkworkbook/workbook.h>
diff --git a/src/realtime/Realtime.hpp b/src/realtime/Realtime.hpp
index 1832e69..813e070 100755
--- a/src/realtime/Realtime.hpp
+++ b/src/realtime/Realtime.hpp
@@ -1,3 +1,21 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_REALTIME
 #define HPP_REALTIME
 

commit 56cccfed6d755a939db6f9c2ba8befadd046b8ab
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Aug 7 13:08:43 2009 -0400

    Updated TODO.

diff --git a/TODO b/TODO
index f985c37..d5fef82 100755
--- a/TODO
+++ b/TODO
@@ -1,9 +1,5 @@
 TODO for GTKWorkbook
 
-* Application
-	- Bugs
-		o Possible issue with new plugin architecture unloading library inside
-		  the object's destructor. 
 * largefile
 	- Bugs	
 		o Likely heap corruption inside of commented out GtkSheet management code

commit b95b32c4dad252503d181e4da604948cdea709b6
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Aug 7 11:56:55 2009 -0400

    Removed -lgtkworkbookshared parameter.

diff --git a/src/Makefile b/src/Makefile
index 3e8eb48..3c909a2 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,10 +1,11 @@
 include ../Makefile.base
 
 INCS += -I./shared
-SRCS=$(wildcard *.cpp) 
+SRCS=$(wildcard *.cpp) $(wildcard shared/proactor/*.cpp) $(wildcard shared/concurrent/*.cpp) \
+$(wildcard shared/network/*.cpp)
 OBJS=$(patsubst %.cpp,${OBJDIR}/%.o,${SRCS})
 
-LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0 -lgtkworkbookshared
+LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0
 
 all: 	gtkworkbook
 	make -C realtime/ all
@@ -30,7 +31,3 @@ ${OBJDIR}/%.o: %.cpp
 
 .cpp.o:
 	${CX} -rdynamic ${INCS} -c ${CXFLAGS} $<
-
-
-.cc.o:
-	${CX} -rdynamic ${INCS} -c ${CXFLAGS} $<

commit 9a6e1a56200059f519cb4bbb2a428845c711bc80
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Aug 7 11:28:28 2009 -0400

    Moved shared directory into src/.

diff --git a/Makefile b/Makefile
index 3bd9a93..0106a18 100755
--- a/Makefile
+++ b/Makefile
@@ -2,26 +2,20 @@ MD=mkdir -p
 MAKE=-make -C
 PWD=`pwd`
 
-all:	libgtkworkbook libgtkworkbookshared gtkworkbookapp
+all:	libgtkworkbook gtkworkbookapp
 
 libgtkworkbook:
 	${MD} OBJS/libgtkworkbook
 	${MAKE} gtkworkbook/ all
 
-libgtkworkbookshared:
-	${MD} OBJS/libgtkworkbookshared
-	${MAKE} shared/ all
-
 gtkworkbookapp:
-	${MD} OBJS/realtime OBJS/largefile
+	${MD} OBJS/realtime OBJS/largefile OBJS/shared
 	$(MAKE) src/ all
 
 clean:
-	${MAKE} shared/ clean
 	${MAKE} gtkworkbook/ clean
 	$(MAKE) src/ clean
 
 install: all
-	${MAKE} shared/ install
 	${MAKE} gtkworkbook/ install
 	${MAKE} src/ install
diff --git a/shared/Makefile b/shared/Makefile
deleted file mode 100755
index 6dc7764..0000000
--- a/shared/Makefile
+++ /dev/null
@@ -1,26 +0,0 @@
-include ../Makefile.base
-
-SRCS=$(wildcard *.cc) $(wildcard concurrent/*.cc) \
-$(wildcard network/*.cc) $(wildcard proactor/*.cc)
-OBJS=$(patsubst %.cc,${OBJDIR}/libgtkworkbookshared/%.o,${SRCS})
-
-all: 	gtkworkbookshared
-
-gtkworkbookshared: ${OBJS}
-	${CX} ${CXFLAGS} -shared -Wl -o ${PROJDIR}/lib/libgtkworkbookshared.so ${OBJS} ${LIBS} \
-	-lpthread
-	${CP} ${PROJDIR}/lib/libgtkworkbookshared.so ${PROJDIR}/lib/libgtkworkbookshared.so.1
-
-clean:		
-	${MD} ${OBJDIR}/libgtkworkbookshared/concurrent ${OBJDIR}/libgtkworkbookshared/network \
-	${OBJDIR}/libgtkworkbookshared/proactor
-	${RM} ${OBJS} ${PROJDIR}/lib/libgtkworkbookshared.so ${PROJDIR}/lib/libgtkworkbookshared.so.1
-
-install: all
-	${MD} ${INSEXTDIR}
-
-${OBJDIR}/libgtkworkbookshared/%.o: %.cc
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
-
-.cc.o:
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<
\ No newline at end of file
diff --git a/shared/concurrent/List.hpp b/shared/concurrent/List.hpp
deleted file mode 100755
index 130cb5d..0000000
--- a/shared/concurrent/List.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_LIST
-#define HPP_CONCURRENT_LIST
-
-#include <list>
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  template <typename T>
-  class List : public RecursiveMutex, public std::list<T> {
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/concurrent/Lockable.hpp b/shared/concurrent/Lockable.hpp
deleted file mode 100755
index 31fdc75..0000000
--- a/shared/concurrent/Lockable.hpp
+++ /dev/null
@@ -1,31 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_LOCKABLE
-#define HPP_THREAD_LOCKABLE
-
-class ILockable {
-public:
-  virtual ~ILockable (void) { }
-
-  virtual void lock (void) = 0;
-  virtual void unlock (void) = 0;
-  virtual bool trylock (void) = 0;
-};
-
-#endif
diff --git a/shared/concurrent/Map.hpp b/shared/concurrent/Map.hpp
deleted file mode 100755
index 9f4b9ce..0000000
--- a/shared/concurrent/Map.hpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MAP
-#define HPP_THREAD_MAP
-
-#include <iterator>
-#include <map>
-#include "Mutex.hpp"
-
-namespace concurrent {
- 
-  /* @description: This object uses the standard std::map and wraps all of
-     the calls that are exposed with a Mutex object. This object uses a
-     single lock and may cause performance issues if several threads are
-     attempting to use it. 
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template<typename K, typename V>
-  class Map : public RecursiveMutex, public std::map<K,V> {
-  private:
-  public:
-    Map (void) : RecursiveMutex() { }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/concurrent/Mutex.cc b/shared/concurrent/Mutex.cc
deleted file mode 100755
index 43ec628..0000000
--- a/shared/concurrent/Mutex.cc
+++ /dev/null
@@ -1,89 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  IMutex::IMutex (void) {
-    this->mutex = NULL;
-    this->attrib = NULL;
-  }
-
-  IMutex::IMutex (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-  }
-
-  IMutex::~IMutex (void) {
-  }
-
-  IMutex & 
-  IMutex::operator= (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-    return *this;
-  }
-
-  void
-  IMutex::lock (void) {
-    pthread_mutex_lock (this->mutex);
-  }
-
-  void 
-  IMutex::unlock (void) {
-    pthread_mutex_unlock (this->mutex);
-  }
-
-  bool
-  IMutex::trylock (void) {
-    return (pthread_mutex_trylock (this->mutex) == 0) ?
-      true : false;
-  }
-  
-  RecursiveMutex::RecursiveMutex (void) {
-    this->mutex = new pthread_mutex_t;
-    this->attrib = new pthread_mutexattr_t;
-
-    pthread_mutexattr_init (this->attrib);
-    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
-    
-    pthread_mutex_init (this->mutex, attrib);
-  }
-
-  RecursiveMutex::~RecursiveMutex (void) {
-    pthread_mutex_destroy (this->mutex);
-    pthread_mutexattr_destroy (this->attrib);
-
-    delete this->mutex;
-    delete this->attrib;
-  }
-
-  Mutex::Mutex (void) {
-    this->mutex = new pthread_mutex_t;
-
-    pthread_mutex_init (this->mutex, NULL);
-  }
-
-  Mutex::~Mutex (void) {
-    pthread_mutex_destroy (this->mutex);
-
-    delete this->mutex;
-  }
-
-} // end of namespace
diff --git a/shared/concurrent/Mutex.hpp b/shared/concurrent/Mutex.hpp
deleted file mode 100755
index f4be8a9..0000000
--- a/shared/concurrent/Mutex.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MUTEX
-#define HPP_THREAD_MUTEX
-
-#include <pthread.h>
-#include "Lockable.hpp"
-
-namespace concurrent {
-
-  class IMutex : public ILockable {
-  protected:
-    pthread_mutex_t * mutex;
-    pthread_mutexattr_t * attrib;
-  public:
-    IMutex (void);
-    IMutex (const IMutex & m);
-    virtual ~IMutex (void);
-
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-
-    IMutex & operator= (const IMutex & m);
-  };
-
-  class Mutex : public IMutex {
-  public:
-    Mutex (void);
-    virtual ~Mutex (void);
-  };
-
-  class RecursiveMutex : public IMutex {
-  public:
-    RecursiveMutex (void);
-    virtual ~RecursiveMutex (void);
-  };
-}
-
-#endif
diff --git a/shared/concurrent/Queue.hpp b/shared/concurrent/Queue.hpp
deleted file mode 100755
index 092953b..0000000
--- a/shared/concurrent/Queue.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_QUEUE
-#define HPP_THREAD_QUEUE
-
-#include "Mutex.hpp"
-#include <queue>
-#include <algorithm>
-
-namespace concurrent {
-  
-  /* @description: This object wraps the existing std::queue container with
-     the custom Mutex object from the concurrent namespace. The single lock
-     may be placed in the future with a read/write lock in order to gain a
-     speed advantage.
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template <typename T>
-  class Queue : public RecursiveMutex {
-  private:
-    std::queue<T> the_queue;
-  public:
-    Queue (void) { }
-    virtual ~Queue (void) { }
-
-    inline void clear (void) {
-      this->lock();
-      while (this->the_queue.size() > 0)
-	this->the_queue.pop();
-      this->unlock();
-    }
-
-    inline void copy (std::queue<T> & Q) {
-      this->lock();
-      Q = this->the_queue;
-      this->unlock();
-    }
-
-    inline const T & back (void) {
-      this->lock();
-      T & elem = this->the_queue.back();
-      this->unlock();
-      return elem;
-    }
-
-    inline const T & front (void) {
-      this->lock();
-      T & elem = this->the_queue.front();
-      this->unlock();
-      return elem;
-    }
-
-    inline void push (const T & x) {
-      this->lock();
-      this->the_queue.push (x);
-      this->unlock();
-    }
-
-    inline T pop (void) {
-      this->lock();
-      T elem = this->the_queue.front();
-      this->the_queue.pop();
-      this->unlock();
-      return elem;
-    }
-    
-    inline size_t size (void) {
-      this->lock();
-      size_t size = this->the_queue.size();
-      this->unlock();
-      return size;
-    }
-
-    inline bool empty (void) {
-      this->lock();
-      bool result = this->the_queue.empty();
-      this->unlock();
-      return result;
-    }
-  };
-}
-#endif
diff --git a/shared/concurrent/Runnable.cc b/shared/concurrent/Runnable.cc
deleted file mode 100755
index 14668ab..0000000
--- a/shared/concurrent/Runnable.cc
+++ /dev/null
@@ -1,44 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Runnable.hpp"
-
-namespace concurrent {
-	IRunnable::IRunnable (void)
-		: running(false) {
-	}
-
-	IRunnable::~IRunnable (void) {
-	}
-
-	bool
-	IRunnable::isRunning (void) {
-		bool result;
-		this->mutex.lock();
-		result = this->running;
-		this->mutex.unlock();
-		return result;
-	}
-
-	void
-	IRunnable::setRunning (bool r) {
-		this->mutex.lock();
-		this->running = r;
-		this->mutex.unlock();
-	}
-}
diff --git a/shared/concurrent/Runnable.hpp b/shared/concurrent/Runnable.hpp
deleted file mode 100755
index bc054a3..0000000
--- a/shared/concurrent/Runnable.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_RUNNABLE
-#define HPP_CONCURRENT_RUNNABLE
-
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-	class IRunnable {
-	private:
-		RecursiveMutex mutex;
-		volatile bool running;
-	public:
-		IRunnable (void);
-		virtual ~IRunnable (void);
-
-		virtual void * run (void *) = 0;
-  
-		bool isRunning (void);
-		void setRunning (bool r);
-	};
-}
-#endif
diff --git a/shared/concurrent/ScopedMemoryLock.cc b/shared/concurrent/ScopedMemoryLock.cc
deleted file mode 100755
index 1063fa3..0000000
--- a/shared/concurrent/ScopedMemoryLock.cc
+++ /dev/null
@@ -1,123 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ScopedMemoryLock.hpp"
-
-namespace concurrent {
-	ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
-
-	ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
-		this->hasLock = false;
-		this->address = address;
-		this->mutex = NULL;
-
-		ScopedMemoryLock::addressMutexMap.lock();
-		AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-		ScopedMemoryLock::addressMutexMap.unlock();
-
-		/* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
-			if someone is passing an address that has not been formally added via the static method
-			call then that means it is very unlikely that they are not removing it either. We do
-			not want a memory leak therefore this seems like the best method. */
-		if (it != ScopedMemoryLock::addressMutexMap.end()) 
-			this->mutex = it->second;
-
-		if (engage == true)
-			this->lock();
-	}
-
-	ScopedMemoryLock::~ScopedMemoryLock (void) {
-		if (this->hasLock == true)
-			unlock();
-	}
-
-	void
-	ScopedMemoryLock::lock (void) {
-		this->mutex->lock();
-		this->hasLock = true;
-	}
-
-	void 
-	ScopedMemoryLock::unlock (void) {
-		this->mutex->unlock();
-		this->hasLock = false;
-	}
-
-	bool
-	ScopedMemoryLock::isLocked (void) const {
-		return this->hasLock;
-	}
-	
-	bool
-	ScopedMemoryLock::trylock (void) {
-		this->hasLock = (this->hasLock==true) ? true : this->mutex->trylock();
-		return this->hasLock;
-	}
-
-	bool
-	ScopedMemoryLock::remove (void) {
-		if (this->hasLock == false) {
-			return false;
-		}
-
-		addressMutexMap.lock();
-
-		bool result = false;
-		AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-		if (it != addressMutexMap.end()) {
-			delete it->second;
-			addressMutexMap.end();
-			result = true;
-		}
-    
-		addressMutexMap.unlock();
-		return result;
-	}
-
-	bool 
-	ScopedMemoryLock::addMemoryLock (unsigned long address) {
-		addressMutexMap.lock();
-
-		bool result = false;
-		AddressToMutexMap::iterator it = addressMutexMap.find (address);
-		if (it == addressMutexMap.end()) {
-			addressMutexMap.insert (std::make_pair (address, new Mutex));
-			result = true;
-		}
-
-		addressMutexMap.unlock();
-		return result;
-	}
-
-	bool 
-	ScopedMemoryLock::removeMemoryLock (unsigned long address) {
-		addressMutexMap.lock();
-
-		bool result = false;
-		AddressToMutexMap::iterator it = addressMutexMap.find (address);
-		if (it != addressMutexMap.end()) {
-			delete it->second;
-			addressMutexMap.erase(it);
-			result = true;
-		}
-
-		addressMutexMap.unlock();
-		return result;
-	}
-
-} // end of namespace
diff --git a/shared/concurrent/ScopedMemoryLock.hpp b/shared/concurrent/ScopedMemoryLock.hpp
deleted file mode 100755
index d60c7fd..0000000
--- a/shared/concurrent/ScopedMemoryLock.hpp
+++ /dev/null
@@ -1,51 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_SCOPEDMEMORYLOCK
-#define HPP_CONCURRENT_SCOPEDMEMORYLOCK
-
-#include "Map.hpp"
-#include "Mutex.hpp"
-#include <string>
-
-namespace concurrent {
-
-	class ScopedMemoryLock : public ILockable {
-	private:
-		typedef Map<long int,Mutex *> AddressToMutexMap;
-		static AddressToMutexMap addressMutexMap;
-
-		bool hasLock;
-		unsigned long address;
-		Mutex * mutex;
-	public:
-		ScopedMemoryLock (unsigned long address, bool engage = false);
-		virtual ~ScopedMemoryLock (void);
- 
-		void lock (void);
-		void unlock (void);
-		bool trylock (void);
-		bool remove (void);
-		bool isLocked (void) const;
-	  
-		static bool addMemoryLock (unsigned long address);
-		static bool removeMemoryLock (unsigned long address);
-	};
-} // end of namespace
-
-#endif 
diff --git a/shared/concurrent/Semaphore.cc b/shared/concurrent/Semaphore.cc
deleted file mode 100755
index 4e5a58d..0000000
--- a/shared/concurrent/Semaphore.cc
+++ /dev/null
@@ -1,42 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Semaphore.hpp"
-
-namespace concurrent {
-
-  Semaphore::Semaphore (void) {
-    sem_init (&this->semaphore, 0, 0);
-  }
-
-  Semaphore::~Semaphore (void) {
-    sem_destroy (&this->semaphore);
-  }
-
-  void
-  Semaphore::acquire (void) {
-    sem_wait (&this->semaphore);
-  }
-
-  void
-  Semaphore::release (void) {
-    sem_post (&this->semaphore);
-  }
-
-} // end of namespace
-
diff --git a/shared/concurrent/Semaphore.hpp b/shared/concurrent/Semaphore.hpp
deleted file mode 100755
index 3b9e0f4..0000000
--- a/shared/concurrent/Semaphore.hpp
+++ /dev/null
@@ -1,39 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_SEMAPHORE
-#define HPP_THREAD_SEMAPHORE
-
-#include <semaphore.h>
-
-namespace concurrent {
-
-class Semaphore {
-private:
-  sem_t semaphore;
-public:
-  Semaphore (void);
-  virtual ~Semaphore (void);
-
-  void acquire (void);
-  void release (void);
-};
-
-}
-
-#endif
diff --git a/shared/concurrent/Thread.cc b/shared/concurrent/Thread.cc
deleted file mode 100755
index b697ae0..0000000
--- a/shared/concurrent/Thread.cc
+++ /dev/null
@@ -1,132 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Thread.hpp"
-#include "ThreadGroup.hpp"
-#include <iostream>
-#include <ctime>
-
-namespace concurrent {
-
-	static void *
-	thread_run (void * runner) {
-		IRunnable * thread = (IRunnable *)runner;
-
-		thread->setRunning(true);
-		void * rvalue = thread->run (NULL);
-		thread->setRunning(false);
-		return rvalue;
-	}
-
-	Thread::Thread (ThreadGroup * group,
-						 IRunnable * runner, 
-						 const std::string & name) : thread(0) {
-		this->group = group;
-		this->runner = runner;
-		this->name = name;
-	}
-
-	Thread::Thread (IRunnable * runner,
-						 const std::string & name) 
-		: group(NULL), thread(0) {
-		this->runner = runner;
-		this->name = name;
-	}
-
-	Thread::Thread (const std::string & name) 
-		: group(NULL), runner(NULL), thread(0) {
-		this->name = name;
-	}
-
-	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
-	}
-
-	Thread::~Thread (void) {
-		if (this->isRunning() == true) {
-			this->setRunning(false);
-			this->join();
-		}
-	}
-
-	void 
-	Thread::interrupt (void) {
-		this->setRunning(false);
-		pthread_cancel (this->thread);
-		pthread_detach (this->thread);
-	}
-
-	void 
-	Thread::yield (void) {
-		pthread_yield();
-	}
-
-	void * 
-	Thread::stop (void) {
-		this->setRunning(false);
-		return this->join();
-	}
-
-	int 
-	Thread::sleep (unsigned long ms) {
-		struct timespec req = {0};
-		time_t sec = (int)(ms/1000);
-		ms = ms - (sec*1000);
-		req.tv_sec = sec;
-		req.tv_nsec = ms*1000000L;
-		while (nanosleep (&req, &req) == -1)
-			continue;
-		return 1;
-	}
-
-	bool 
-	Thread::start (void) {
-		if (this->isRunning() == true)
-			return false;
-		
-		if (this->runner != NULL) {
-			if (pthread_create (&this->thread,
-									  NULL,
-									  thread_run,
-									  this->runner))
-				return false;
-		}
-		else {
-			if (pthread_create (&this->thread,
-									  NULL,
-									  thread_run,
-									  this))
-				return false;
-		}
-		return true;
-	}
-
-	void *
-	Thread::join (void) {
-		void * rvalue = NULL;
-		if (this->thread > 0)
-			pthread_join (this->thread, &rvalue);
-		return rvalue;
-	}
-
-	void *
-	Thread::run (void * null) {
-		std::cerr << "Thread::run : null runner\n";
-		pthread_exit (null);
-	}
-
-} // end of namespace
diff --git a/shared/concurrent/Thread.hpp b/shared/concurrent/Thread.hpp
deleted file mode 100755
index cb7be67..0000000
--- a/shared/concurrent/Thread.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREAD
-#define HPP_CONCURRENT_THREAD
-
-#include <shared.h>
-#include <string>
-#include <pthread.h>
-#include <map>
-#include "Runnable.hpp"
-
-namespace concurrent {
-
-	class ThreadGroup;
-
-	class Thread : public IRunnable {
-	private:
-		friend class ThreadGroup;
-
-		ThreadGroup * group;
-		std::string name;
-		IRunnable * runner;
-		pthread_t thread;
-		bool joinable;
-		int priority;
-	public:
-		Thread (ThreadGroup * group, 
-				  IRunnable * runner, 
-				  const std::string & name);
-		Thread (IRunnable * runner,
-				  const std::string & name);
-		Thread (const std::string & name);
-		Thread (void);
-		virtual ~Thread (void);
-
-		bool start (void);
-		void * stop (void);
-		void * join (void);
-		void interrupt (void);
-		void yield (void);
-  
-		virtual void * run (void *);
-
-		inline const std::string & getName (void) const { return this->name; }
-		inline int getPriority (void) const { return this->priority; }
-		inline void setPriority (int priority) { this->priority = priority; }
-		inline const ThreadGroup * getThreadGroup (void) const { 
-			return this->group; 
-		}
-
-		static int sleep (unsigned long ms);
-	};  
-
-}
-
-#endif
diff --git a/shared/concurrent/ThreadArgs.hpp b/shared/concurrent/ThreadArgs.hpp
deleted file mode 100755
index f44742c..0000000
--- a/shared/concurrent/ThreadArgs.hpp
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef H_THREAD_THREADARGS
-#define H_THREAD_THREADARGS
-
-#include <vector>
-
-typedef std::vector<void *> ThreadArgs;
-
-#endif
diff --git a/shared/concurrent/ThreadGroup.cc b/shared/concurrent/ThreadGroup.cc
deleted file mode 100755
index f50b487..0000000
--- a/shared/concurrent/ThreadGroup.cc
+++ /dev/null
@@ -1,105 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadGroup.hpp"
-#include <algorithm>
-
-namespace concurrent {
-
-  ThreadGroup::ThreadGroup (void) 
-    : parent(NULL), daemon(false) {
-  }
-
-  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
-    : daemon(false) {
-    this->parent = parent;
-    this->name = name;
-  }
-
-  ThreadGroup::ThreadGroup (const std::string & name) 
-    : parent(NULL), daemon(false) {
-    this->name = name;
-  }
-
-  ThreadGroup::~ThreadGroup (void) {
-    if (this->daemon == true) {
-      this->stop();
-    }
-  }
-
-  bool 
-  ThreadGroup::parentOf (ThreadGroup * parent) {
-    if ((this->parent == NULL) || (parent == NULL))
-      return false;
-    // Needs to be better than this. 
-    return (this->parent == parent) ? true : false;
-  } 
-    
-  bool
-  ThreadGroup::addThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-    if (it == this->threads.end()) {
-      thread->group = this;
-      this->threads.push_back (thread);
-      return true;
-    }
-    return false;
-  }
-
-  bool 
-  ThreadGroup::removeThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-
-    if (it == this->threads.end())
-      return false;
-    this->threads.erase(it);
-    return true;
-  }
-
-  void
-  ThreadGroup::interrupt (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->interrupt();
-    }
-  }
-
-  bool
-  ThreadGroup::start (void) {
-    bool rvalue = false;
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      rvalue = (*it++)->start();
-    }
-
-    return rvalue;
-  }
-
-  void 
-  ThreadGroup::stop (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->stop();
-    }
-  }
-} // end of namesapce
diff --git a/shared/concurrent/ThreadGroup.hpp b/shared/concurrent/ThreadGroup.hpp
deleted file mode 100755
index f907fd4..0000000
--- a/shared/concurrent/ThreadGroup.hpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREADGROUP
-#define HPP_CONCURRENT_THREADGROUP
-
-#include <string>
-#include "List.hpp"
-#include "Thread.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup {
-  private:
-    typedef concurrent::List<Thread *> ThreadList;
-    
-    ThreadGroup * parent;
-    std::string name;
-    ThreadList threads;
-    bool daemon; 
-  public:
-    ThreadGroup (void);
-    ThreadGroup (ThreadGroup * parent, const std::string & name);
-    ThreadGroup (const std::string & name);
-    virtual ~ThreadGroup (void);
-
-    bool parentOf (ThreadGroup * parent);
-    bool addThread (Thread * thread);
-    bool removeThread (Thread * thread);
-    void interrupt (void);
-    bool start (void);
-    void stop (void);
-    
-    inline bool isDaemon (void) const { return this->daemon; }
-    inline void setDaemon (bool daemon) { this->daemon = daemon; }
-    inline const std::string & getName (void) const { return this->name; }
-    inline ThreadGroup * getParent (void) const { return this->parent; }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/concurrent/ThreadPool.cc b/shared/concurrent/ThreadPool.cc
deleted file mode 100755
index 62c95be..0000000
--- a/shared/concurrent/ThreadPool.cc
+++ /dev/null
@@ -1,121 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadPool.hpp"
-
-namespace concurrent {
-  int ThreadPool::defaultTaskMax = 5;
-
-  ThreadPool::Task::Task (ThreadPool * pool) {
-    this->pool = pool;
-  }
-
-  void *
-  ThreadPool::Task::run (void * null) {
-	  while (this->isRunning() == true) {
-		 if (this->pool->isRunning() == false)
-			 break;
-      
-		 if (this->pool->getQueueSize() > 0) {
-			 IRunnable * runner = this->pool->removeFromQueue();
-			 runner->run (NULL);
-			 delete runner;
-		 }
-		 Thread::sleep (1);
-    }
-
-    return NULL;
-  }
-
-  ThreadPool::ThreadPool (void) {
-    this->running = false;
-
-    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::ThreadPool (int N) {
-    this->running = false;
-
-    for (int ii = 0; ii < N; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::~ThreadPool (void) {
-    if (this->running == true)
-      this->stop(true);
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      Thread * t = (*it); it++;
-      delete t;
-    }
-
-    while (this->runQueue.size() > 0) {
-      IRunnable * r = this->runQueue.pop();
-      delete r;
-    }
-  }
-
-  void 
-  ThreadPool::start (void) {
-    this->running = true;
-    
-	 ThreadList::iterator it = this->threads.begin();
-	 while (it != this->threads.end())
-    {
-		 (*it)->start();
-		 it++;
-    }
-  }
-
-  void 
-  ThreadPool::stop (bool join) {
-    this->running = false;
-
-    /* Waiting to join all of the threads will mean that the thread that the
-       pool is calling the stop() method from will block until all of the 
-       threads inside of the pool have stopped.
-
-       There is a PROBLEM here. If you call this, for some reason, from inside
-       of one of the Task threads then you are going to hit a deadlock. Never
-       pass the join parameter if this is being called from inside the Tasks.*/
-    if (join == true) {
-		 ThreadList::iterator it = this->threads.begin();
-		 while (it != this->threads.end()) {
-			 (*it)->stop();
-			 it++;
-		 }
-    }
-  }
-
-  void 
-  ThreadPool::execute (IRunnable * runner) {
-    this->runQueue.push (runner);
-  }
-
-} // end of namespace
-
diff --git a/shared/concurrent/ThreadPool.hpp b/shared/concurrent/ThreadPool.hpp
deleted file mode 100755
index 1999f0e..0000000
--- a/shared/concurrent/ThreadPool.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_THREADPOOL
-#define HPP_THREAD_THREADPOOL
-
-#include "Mutex.hpp"
-#include "Thread.hpp"
-#include "Queue.hpp"
-#include <queue>
-#include <list>
-
-namespace concurrent {
-
-  /* @description: This is a ThreadPool object that will keep N concurrent
-     threads running. Runnable objects can be attached to this object and they
-     will be executed immediately as a thread becomes available to run them. 
-     @author: John `jb Bellone (jvb4@njit.edu)
-     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
-  class ThreadPool {
-  private:
-    typedef std::list<Thread *> ThreadList;
-    
-    class Task : public IRunnable {
-    private:
-      ThreadPool * pool;
-    public:
-      Task (ThreadPool * pool);
-      
-      void * run (void * null);
-    };
-    
-    concurrent::Queue<IRunnable *> runQueue;
-    ThreadList threads;
-    bool running;
-  public:
-    static int defaultTaskMax;
-
-    ThreadPool (void);
-    ThreadPool (int N);
-    ~ThreadPool (void);
-
-    /* Thread un-Safe Methods */
-    void start (void);
-    void stop (bool join = false);
-
-    /* Thread-Safe Methods */
-    void execute (IRunnable *);
-    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
-    inline bool isRunning (void) const { return this->running; }
-    inline int getMaxThreads (void) const { return this->threads.size(); }
-    inline size_t getQueueSize (void) { return this->runQueue.size(); }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/network/Socket.hpp b/shared/network/Socket.hpp
deleted file mode 100755
index 5a87a3d..0000000
--- a/shared/network/Socket.hpp
+++ /dev/null
@@ -1,39 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_NETWORK_SOCKET
-#define HPP_NETWORK_SOCKET
-
-#include <cstring>
-
-namespace network {
-
-  class ISocket {
-  protected:
-    int sockfd;
-  public:
-    virtual ~ISocket (void) { }
-
-    virtual void close (void) = 0;
-    virtual int send (const char * bytes, size_t length) = 0;
-    virtual int receive (char * btyes, size_t size) = 0;
-  };
-
-} // end of namesapce
-
-#endif
diff --git a/shared/network/Tcp.cc b/shared/network/Tcp.cc
deleted file mode 100755
index 1eb2645..0000000
--- a/shared/network/Tcp.cc
+++ /dev/null
@@ -1,158 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Tcp.hpp"
-#include <iostream>
-
-namespace network {
-
-	TcpSocket::TcpSocket (void) {
-		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
-	}
-
-	TcpSocket::~TcpSocket (void) {
-		this->close();
-	}
-
-	void
-	TcpSocket::close (void) {
-		if (this->sockfd > 0)
-			::close (this->sockfd);
-	}
-	
-	int
-	TcpSocket::send (const char * bytes, size_t length) {
-		return ::write (this->sockfd, bytes, length);
-	}
-
-	int
-	TcpSocket::receive (char * bytes, size_t size) {
-		return ::read (this->sockfd, bytes, size);
-	}
-
-	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
-		this->port = port;
-
-		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-		this->sockaddr.sin_port = htons (this->port);
-	}
-
-	TcpServerSocket::~TcpServerSocket (void) {
-		this->close();
-	}
-
-	bool
-	TcpServerSocket::start (int backlog = 5) {
-		int opt = 1;
-
-		// This is to prevent conflicts with major services' ports.
-		if (this->port < 1024)
-			return false;
-
-		if (::setsockopt (this->sockfd, 
-								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
-			return false;
-
-		if (::bind (this->sockfd,
-						(struct sockaddr *)&(this->sockaddr),
-						sizeof (this->sockaddr)) < 0)
-			return false;
-
-		if (::listen (this->sockfd, backlog) < 0)
-			return false;
-
-		return true;
-	}
-
-	int
-	TcpServerSocket::getPort (void) const {
-		return this->port;
-	}
-	
-	void
-	TcpServerSocket::close (void) {
-		TcpSocket::close();
-	}
-
-	TcpServerSocket::Acceptor *
-	TcpServerSocket::newAcceptor (void) {
-		return new TcpServerSocket::Acceptor (this, this->sockfd);
-	}
-
-	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
-		this->socket = server;
-		this->sockfd = sockfd;
-	}
-
-	int
-	TcpServerSocket::Acceptor::acceptIncoming (void) {
-		int newfd = -1;
-		static struct sockaddr_in clientaddr;
-		unsigned int x = sizeof (clientaddr);
-
-		if ((newfd = ::accept (this->sockfd, 
-									  (struct sockaddr *)&clientaddr,
-									  &x)) < 0)
-			return -1;
-		return newfd;
-	}
-
-	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
-		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-	}
-
-	TcpClientSocket::TcpClientSocket (int newfd) {
-		this->sockfd = newfd;
-	}
-				
-	TcpClientSocket::~TcpClientSocket (void) {
-	}
-
-	bool
-	TcpClientSocket::connect (const char * host, int port) {
-		if (!host || (*host == '\0'))
-			return false;
-
-		if ((this->hp = ::gethostbyname (host)) == NULL)
-			return false;
- 
-		// Copy over the hostname address.
-		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr 
-			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
-		this->sockaddr.sin_port = htons (port);
-
-		if (::connect (this->sockfd,
-							(struct sockaddr *)&(this->sockaddr),
-							sizeof (struct sockaddr)) < 0)
-			return false;
-    
-		return true;
-	}
-
-	void
-	TcpClientSocket::close (void) {
-		TcpSocket::close();
-	}
-
-} // end of namespace
diff --git a/shared/network/Tcp.hpp b/shared/network/Tcp.hpp
deleted file mode 100755
index 2480a3f..0000000
--- a/shared/network/Tcp.hpp
+++ /dev/null
@@ -1,81 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_NETWORK_TCP
-#define HPP_NETWORK_TCP
-
-#include "Socket.hpp"
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <netdb.h>
-
-namespace network {
-
-	class TcpSocket : public ISocket {
-	protected:
-		struct sockaddr_in sockaddr;
-	public:
-		TcpSocket (void);
-		virtual ~TcpSocket (void);
-
-		void close (void);
-		int send (const char * bytes, size_t length);
-		int receive (char * bytes, size_t size);
-	};
-
-	class TcpServerSocket : public TcpSocket {
-	private:
-		int port;
-	public:
-		class Acceptor {
-		private:
-			TcpServerSocket * socket;
-			int sockfd;
-		public:
-			Acceptor (TcpServerSocket * server, int sockfd);
-
-			int acceptIncoming (void);
-		};
-
-		TcpServerSocket (int port);
-		virtual ~TcpServerSocket (void);
-    
-		bool start (int backlog);
-		void close (void);
-		Acceptor * newAcceptor (void);
-		int getPort(void) const;
-	};
-  
-	class TcpClientSocket : public TcpSocket {
-	private:
-		struct hostent * hp;
-	public:
-		TcpClientSocket (void);
-		TcpClientSocket (int newfd);
-		virtual ~TcpClientSocket (void);
-
-		bool connect (const char * host, int port);
-		void close (void);
-	};
-
-} // end of namespace
-
-#endif
diff --git a/shared/proactor/Dispatcher.cc b/shared/proactor/Dispatcher.cc
deleted file mode 100755
index ec23069..0000000
--- a/shared/proactor/Dispatcher.cc
+++ /dev/null
@@ -1,61 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Dispatcher.hpp"
-#include "Worker.hpp"
-#include <algorithm>
-
-namespace proactor {
-
-  Dispatcher::~Dispatcher (void) {
-      
-  }
-   
-	bool
-	Dispatcher::addWorker (Worker * w) {
-		this->workers.lock();
-		
-		WorkerListType::iterator it = std::find (this->workers.begin(),
-															  this->workers.end(),
-															  w);
-		if (it == this->workers.end()) {
-			this->workers.push_back (w);
-			this->workers.unlock();
-			return w->start();
-      }
-		this->workers.unlock();
-		return false;
-	}
-  
-	bool
-	Dispatcher::removeWorker (Worker * w) {
-		this->workers.lock();
-		
-		WorkerListType::iterator it = std::find (this->workers.begin(),
-															  this->workers.end(),
-															  w);
-		bool result = false;
-		if (it != this->workers.end()) {
-			this->workers.erase (it);
-			result = true;
-		}
-		this->workers.unlock();
-		return result;
-	}
-
-} // end of namesapce
diff --git a/shared/proactor/Dispatcher.hpp b/shared/proactor/Dispatcher.hpp
deleted file mode 100755
index 124f03d..0000000
--- a/shared/proactor/Dispatcher.hpp
+++ /dev/null
@@ -1,43 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_DISPATCHER
-#define HPP_PROACTOR_DISPATCHER
-
-#include "../concurrent/Thread.hpp"
-#include "../concurrent/List.hpp"
-
-namespace proactor {
-
-  class Worker;
-
-  class Dispatcher : public concurrent::Thread {
-  protected:
-    typedef concurrent::List<Worker *> WorkerListType;
-
-    WorkerListType workers;
-  public:
-    virtual ~Dispatcher (void);
-
-    bool addWorker (Worker * w);
-    bool removeWorker (Worker * w);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/proactor/Event.cc b/shared/proactor/Event.cc
deleted file mode 100755
index a1c5c2b..0000000
--- a/shared/proactor/Event.cc
+++ /dev/null
@@ -1,38 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Event.hpp"
-
-namespace proactor {
-
-  int Event::numEvents = 0;
-
-  Event::Event (int e, const std::string & buf) {
-    this->id = e;
-    this->buf = buf;
-  }
-
-  int
-  Event::uniqueEventId (void) {
-    return Event::numEvents++;
-  }
-
-  EventDispatcher::~EventDispatcher (void) {
-  }
- 
-} // end of namespace
diff --git a/shared/proactor/Event.hpp b/shared/proactor/Event.hpp
deleted file mode 100755
index f5c9f7e..0000000
--- a/shared/proactor/Event.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_EVENT
-#define HPP_PROACTOR_EVENT
-
-#include "Dispatcher.hpp"
-#include <string>
-
-namespace proactor {
-
-  class Event {
-  private:
-    static int numEvents;
-  public:
-    int id;
-    std::string buf;
-
-    Event (int id, const std::string & buf);
-
-    static int uniqueEventId (void);
-  };
-
-  class EventDispatcher : public Dispatcher {
-  private:
-    int eventId;
-  public:
-    virtual ~EventDispatcher (void);
-
-    inline void setEventId (int e) { 
-      this->eventId = e;
-    }
-
-    inline int getEventId (void) { 
-      return this->eventId;
-    }
-  };
-
-}
-
-#endif
diff --git a/shared/proactor/InputDispatcher.cc b/shared/proactor/InputDispatcher.cc
deleted file mode 100755
index 52210fd..0000000
--- a/shared/proactor/InputDispatcher.cc
+++ /dev/null
@@ -1,60 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "InputDispatcher.hpp"
-#include "Proactor.hpp"
-
-namespace proactor {
-
-	InputDispatcher::~InputDispatcher (void) {
-		this->inputQueue.lock();
-		while (this->inputQueue.size() > 0)
-			this->inputQueue.pop();
-		this->inputQueue.unlock();
-	}
-
-	void *
-	InputDispatcher::stop (void) {
-		WorkerListType::iterator it = this->workers.begin();
-		while (it != this->workers.end()) {
-			(*it)->stop();
-			it = this->workers.erase(it);
-		}
-		return Thread::stop();
-	}
-
-	void *
-	InputDispatcher::run (void * null) {
-		while (this->isRunning() == true) {
-			// Dispatch all of the input items on the queue.
-			this->inputQueue.lock();
-
-			while (this->inputQueue.size() > 0) {
-				// For right now all we're doing is pushing up the chain.
-				this->pro->onReadComplete ( this->inputQueue.pop() );
-			}
-
-			this->inputQueue.unlock();
-
-			Thread::sleep(100);
-		}
-  
-		return NULL; 
-	}
-
-} // end of namespace
diff --git a/shared/proactor/InputDispatcher.hpp b/shared/proactor/InputDispatcher.hpp
deleted file mode 100755
index fc78fcb..0000000
--- a/shared/proactor/InputDispatcher.hpp
+++ /dev/null
@@ -1,53 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_INPUTDISPATCHER
-#define HPP_PROACTOR_INPUTDISPATCHER
-
-#include "../concurrent/Queue.hpp"
-#include "Event.hpp"
-
-namespace proactor {
-
-	class Proactor;
-
-	class InputDispatcher : public EventDispatcher {
-	protected:
-		typedef concurrent::Queue<Event> InputQueueType;
-
-		Proactor * pro;
-		InputQueueType inputQueue;
-	public:
-		virtual ~InputDispatcher (void);
-
-		void * stop (void);
-    
-		inline void onReadComplete (const char * buf) {
-			this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
-		}
-
-		inline void onReadComplete (const std::string & buf) {
-			this->inputQueue.push ( Event (getEventId(), std::string (buf) ) );
-		}
-
-		void * run (void * null);
-	};
-
-} // end of namespace
-
-#endif
diff --git a/shared/proactor/Proactor.cc b/shared/proactor/Proactor.cc
deleted file mode 100755
index 16426e6..0000000
--- a/shared/proactor/Proactor.cc
+++ /dev/null
@@ -1,149 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Proactor.hpp"
-#include <iostream>
-#include <algorithm>
-
-namespace proactor {
-
-	Proactor::Proactor (void) {
-	}
-
-	Proactor::~Proactor (void) {
-		// Remove all of the lists of event handlers.
-		{
-			EventMapType::iterator it = this->eventsToHandlers.begin();
-			while (it != this->eventsToHandlers.end()) {
-				WorkerListType * q = (it->second);
-				delete q;
-				it++;
-			}
-		}
- 
-		// Handle the dispatchers that have not been manually removed.
-		{
-			DispatcherList::iterator it = this->dispatchers.begin();
-			while (it != this->dispatchers.end())
-			{
-				Dispatcher * d = (*it);
-				delete d;
-				it++;
-			}
-		}
-  
-	}
-
-	bool
-	Proactor::addWorker (int e, Worker * job) {
-		this->eventsToHandlers.lock();
-		{
-			EventMapType::iterator it = this->eventsToHandlers.find (e);
-  
-			if (it == this->eventsToHandlers.end())
-				this->eventsToHandlers[e] = new WorkerListType;  
-			this->eventsToHandlers[e]->push_back (job);
-		}
-		this->eventsToHandlers.unlock();
-
-		return job->start();
-	}
-
-	void
-	Proactor::onReadComplete (Event e) {
-		this->events.push (e);
-	}
-
-	void 
-	Proactor::onReadComplete (int e, const char * buf) {
-		this->events.push ( Event (e, std::string (buf)) );   
-	}
-
-	bool
-	Proactor::removeWorker (int e, Worker * job) {
-		bool result = false;
-
-		this->eventsToHandlers.lock();
-		{
-			WorkerListType::iterator it = 
-				std::find (this->eventsToHandlers[e]->begin(),
-							  this->eventsToHandlers[e]->end(),
-							  job);
-    
-			if (it != this->eventsToHandlers[e]->end())
-			{
-				this->eventsToHandlers[e]->erase (it);
-				result = true;
-			}
-		}
-		this->eventsToHandlers.unlock();
-   
-		return result;
-	}
-
-	void
-	Proactor::addDispatcher (Dispatcher * d) {
-		this->dispatchers.push_back (d);
-	}
-
-	bool
-	Proactor::removeDispatcher (Dispatcher * d) {
-		DispatcherList::iterator it = std::find (this->dispatchers.begin(),
-															  this->dispatchers.end(),
-															  d);
-
-		if (it == this->dispatchers.end())
-			return false;
-  
-		this->dispatchers.erase (it);
-		return true;
-	}
-
-	void *
-	Proactor::run (void * null) {
-		WorkerListType::iterator it;
-
-		while (this->isRunning() == true) {
-			this->events.lock();
-
-			while (this->events.size() > 0) {
-				Event e = this->events.pop();
-
-				// We are throwing events with no handlers to catch them.
-				if (this->eventsToHandlers.find (e.id) == 
-					 this->eventsToHandlers.end())
-					continue;
- 
-				it = this->eventsToHandlers[e.id]->begin();
-	  
-				while (it != this->eventsToHandlers[e.id]->end()) {
-					Worker * j = (*it);
-	      
-					j->pushInputQueue (e.buf);
-		      
-					it++;
-				}
-			}
-			this->events.unlock();
-      
-			Thread::sleep(100);
-      }
-		return NULL;
-	}
-
-} // end of namespace
diff --git a/shared/proactor/Proactor.hpp b/shared/proactor/Proactor.hpp
deleted file mode 100755
index fc90f59..0000000
--- a/shared/proactor/Proactor.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_PROACTOR
-#define HPP_PROACTOR_PROACTOR
-
-#include "../concurrent/Thread.hpp"
-#include "../concurrent/Map.hpp"
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/List.hpp"
-#include "Worker.hpp"
-#include "Event.hpp"
-#include "Dispatcher.hpp"
-#include "InputDispatcher.hpp"
-
-namespace proactor {
-
-	class Proactor : public Dispatcher {
-	private:
-		typedef concurrent::List<Dispatcher *> DispatcherList;
-		typedef concurrent::Map<int, WorkerListType *> EventMapType;
-		typedef concurrent::Queue<Event> EventQueueType;
-
-		EventMapType eventsToHandlers;
-		DispatcherList dispatchers;
-		EventQueueType events;
-	public:
-		Proactor (void);
-		virtual ~Proactor (void);
-
-		bool addWorker (int e, Worker * w);
-		bool removeWorker (int e, Worker * w);
-		void addDispatcher (Dispatcher * d);
-		bool removeDispatcher (Dispatcher * d);
-    
-		void * run (void * null);
- 
-		void onReadComplete (Event e);
-		void onReadComplete (int e, const char * buf);
-
-		inline const std::string & peekInputQueue (void) {
-			return (this->events.front()).buf;
-		}
-	};
-
-} // end of namespace
-
-#endif
diff --git a/shared/proactor/Worker.cc b/shared/proactor/Worker.cc
deleted file mode 100755
index be5863f..0000000
--- a/shared/proactor/Worker.cc
+++ /dev/null
@@ -1,26 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Worker.hpp"
-
-namespace proactor {
-
-  Worker::~Worker (void) {
-  }
-
-} // end of namesapce
diff --git a/shared/proactor/Worker.hpp b/shared/proactor/Worker.hpp
deleted file mode 100755
index 5b5efe9..0000000
--- a/shared/proactor/Worker.hpp
+++ /dev/null
@@ -1,46 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_WORKER
-#define HPP_PROACTOR_WORKER
-
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/Thread.hpp"
-#include <string>
-
-namespace proactor {
-
-  class InputDispatcher;
-
-  class Worker : public concurrent::Thread {
-  protected:
-    typedef concurrent::Queue<std::string> InputQueueType;
-
-    InputDispatcher * dispatcher;
-    InputQueueType inputQueue;
-  public:
-    virtual ~Worker (void);
-
-    inline void pushInputQueue (const std::string & buf) {
-		 this->inputQueue.push (std::string (buf));
-    }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/Makefile b/src/Makefile
index 5c26dc0..3e8eb48 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,7 +1,7 @@
 include ../Makefile.base
 
-INCS += -I${PROJDIR}/shared
-SRCS=$(wildcard *.cpp)
+INCS += -I./shared
+SRCS=$(wildcard *.cpp) 
 OBJS=$(patsubst %.cpp,${OBJDIR}/%.o,${SRCS})
 
 LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0 -lgtkworkbookshared
@@ -30,3 +30,7 @@ ${OBJDIR}/%.o: %.cpp
 
 .cpp.o:
 	${CX} -rdynamic ${INCS} -c ${CXFLAGS} $<
+
+
+.cc.o:
+	${CX} -rdynamic ${INCS} -c ${CXFLAGS} $<
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index e511440..134ddb8 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.base
 
-INCS += -I/home/johnb/include -I${PROJDIR}/shared -I../
+INCS += -I/home/johnb/include -I../shared -I../
 SRCS=$(wildcard *.cpp) 
 OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
 
diff --git a/src/realtime/Makefile b/src/realtime/Makefile
index 29ac64d..2513255 100755
--- a/src/realtime/Makefile
+++ b/src/realtime/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.base
 
-INCS += -I${PROJDIR}/shared -I../
+INCS += -I$../shared -I../shared
 SRCS = $(wildcard *.cpp) 
 OBJS = $(patsubst %.cpp,${OBJDIR}/realtime/%.o,${SRCS}) 
 
diff --git a/src/shared/concurrent/List.hpp b/src/shared/concurrent/List.hpp
new file mode 100755
index 0000000..130cb5d
--- /dev/null
+++ b/src/shared/concurrent/List.hpp
@@ -0,0 +1,33 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_LIST
+#define HPP_CONCURRENT_LIST
+
+#include <list>
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  template <typename T>
+  class List : public RecursiveMutex, public std::list<T> {
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/shared/concurrent/Lockable.hpp b/src/shared/concurrent/Lockable.hpp
new file mode 100755
index 0000000..31fdc75
--- /dev/null
+++ b/src/shared/concurrent/Lockable.hpp
@@ -0,0 +1,31 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_LOCKABLE
+#define HPP_THREAD_LOCKABLE
+
+class ILockable {
+public:
+  virtual ~ILockable (void) { }
+
+  virtual void lock (void) = 0;
+  virtual void unlock (void) = 0;
+  virtual bool trylock (void) = 0;
+};
+
+#endif
diff --git a/src/shared/concurrent/Map.hpp b/src/shared/concurrent/Map.hpp
new file mode 100755
index 0000000..9f4b9ce
--- /dev/null
+++ b/src/shared/concurrent/Map.hpp
@@ -0,0 +1,42 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MAP
+#define HPP_THREAD_MAP
+
+#include <iterator>
+#include <map>
+#include "Mutex.hpp"
+
+namespace concurrent {
+ 
+  /* @description: This object uses the standard std::map and wraps all of
+     the calls that are exposed with a Mutex object. This object uses a
+     single lock and may cause performance issues if several threads are
+     attempting to use it. 
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template<typename K, typename V>
+  class Map : public RecursiveMutex, public std::map<K,V> {
+  private:
+  public:
+    Map (void) : RecursiveMutex() { }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/shared/concurrent/Mutex.cpp b/src/shared/concurrent/Mutex.cpp
new file mode 100755
index 0000000..43ec628
--- /dev/null
+++ b/src/shared/concurrent/Mutex.cpp
@@ -0,0 +1,89 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  IMutex::IMutex (void) {
+    this->mutex = NULL;
+    this->attrib = NULL;
+  }
+
+  IMutex::IMutex (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+  }
+
+  IMutex::~IMutex (void) {
+  }
+
+  IMutex & 
+  IMutex::operator= (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+    return *this;
+  }
+
+  void
+  IMutex::lock (void) {
+    pthread_mutex_lock (this->mutex);
+  }
+
+  void 
+  IMutex::unlock (void) {
+    pthread_mutex_unlock (this->mutex);
+  }
+
+  bool
+  IMutex::trylock (void) {
+    return (pthread_mutex_trylock (this->mutex) == 0) ?
+      true : false;
+  }
+  
+  RecursiveMutex::RecursiveMutex (void) {
+    this->mutex = new pthread_mutex_t;
+    this->attrib = new pthread_mutexattr_t;
+
+    pthread_mutexattr_init (this->attrib);
+    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+    
+    pthread_mutex_init (this->mutex, attrib);
+  }
+
+  RecursiveMutex::~RecursiveMutex (void) {
+    pthread_mutex_destroy (this->mutex);
+    pthread_mutexattr_destroy (this->attrib);
+
+    delete this->mutex;
+    delete this->attrib;
+  }
+
+  Mutex::Mutex (void) {
+    this->mutex = new pthread_mutex_t;
+
+    pthread_mutex_init (this->mutex, NULL);
+  }
+
+  Mutex::~Mutex (void) {
+    pthread_mutex_destroy (this->mutex);
+
+    delete this->mutex;
+  }
+
+} // end of namespace
diff --git a/src/shared/concurrent/Mutex.hpp b/src/shared/concurrent/Mutex.hpp
new file mode 100755
index 0000000..f4be8a9
--- /dev/null
+++ b/src/shared/concurrent/Mutex.hpp
@@ -0,0 +1,56 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MUTEX
+#define HPP_THREAD_MUTEX
+
+#include <pthread.h>
+#include "Lockable.hpp"
+
+namespace concurrent {
+
+  class IMutex : public ILockable {
+  protected:
+    pthread_mutex_t * mutex;
+    pthread_mutexattr_t * attrib;
+  public:
+    IMutex (void);
+    IMutex (const IMutex & m);
+    virtual ~IMutex (void);
+
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+
+    IMutex & operator= (const IMutex & m);
+  };
+
+  class Mutex : public IMutex {
+  public:
+    Mutex (void);
+    virtual ~Mutex (void);
+  };
+
+  class RecursiveMutex : public IMutex {
+  public:
+    RecursiveMutex (void);
+    virtual ~RecursiveMutex (void);
+  };
+}
+
+#endif
diff --git a/src/shared/concurrent/Queue.hpp b/src/shared/concurrent/Queue.hpp
new file mode 100755
index 0000000..092953b
--- /dev/null
+++ b/src/shared/concurrent/Queue.hpp
@@ -0,0 +1,97 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_QUEUE
+#define HPP_THREAD_QUEUE
+
+#include "Mutex.hpp"
+#include <queue>
+#include <algorithm>
+
+namespace concurrent {
+  
+  /* @description: This object wraps the existing std::queue container with
+     the custom Mutex object from the concurrent namespace. The single lock
+     may be placed in the future with a read/write lock in order to gain a
+     speed advantage.
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template <typename T>
+  class Queue : public RecursiveMutex {
+  private:
+    std::queue<T> the_queue;
+  public:
+    Queue (void) { }
+    virtual ~Queue (void) { }
+
+    inline void clear (void) {
+      this->lock();
+      while (this->the_queue.size() > 0)
+	this->the_queue.pop();
+      this->unlock();
+    }
+
+    inline void copy (std::queue<T> & Q) {
+      this->lock();
+      Q = this->the_queue;
+      this->unlock();
+    }
+
+    inline const T & back (void) {
+      this->lock();
+      T & elem = this->the_queue.back();
+      this->unlock();
+      return elem;
+    }
+
+    inline const T & front (void) {
+      this->lock();
+      T & elem = this->the_queue.front();
+      this->unlock();
+      return elem;
+    }
+
+    inline void push (const T & x) {
+      this->lock();
+      this->the_queue.push (x);
+      this->unlock();
+    }
+
+    inline T pop (void) {
+      this->lock();
+      T elem = this->the_queue.front();
+      this->the_queue.pop();
+      this->unlock();
+      return elem;
+    }
+    
+    inline size_t size (void) {
+      this->lock();
+      size_t size = this->the_queue.size();
+      this->unlock();
+      return size;
+    }
+
+    inline bool empty (void) {
+      this->lock();
+      bool result = this->the_queue.empty();
+      this->unlock();
+      return result;
+    }
+  };
+}
+#endif
diff --git a/src/shared/concurrent/Runnable.cpp b/src/shared/concurrent/Runnable.cpp
new file mode 100755
index 0000000..14668ab
--- /dev/null
+++ b/src/shared/concurrent/Runnable.cpp
@@ -0,0 +1,44 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Runnable.hpp"
+
+namespace concurrent {
+	IRunnable::IRunnable (void)
+		: running(false) {
+	}
+
+	IRunnable::~IRunnable (void) {
+	}
+
+	bool
+	IRunnable::isRunning (void) {
+		bool result;
+		this->mutex.lock();
+		result = this->running;
+		this->mutex.unlock();
+		return result;
+	}
+
+	void
+	IRunnable::setRunning (bool r) {
+		this->mutex.lock();
+		this->running = r;
+		this->mutex.unlock();
+	}
+}
diff --git a/src/shared/concurrent/Runnable.hpp b/src/shared/concurrent/Runnable.hpp
new file mode 100755
index 0000000..bc054a3
--- /dev/null
+++ b/src/shared/concurrent/Runnable.hpp
@@ -0,0 +1,40 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_RUNNABLE
+#define HPP_CONCURRENT_RUNNABLE
+
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+	class IRunnable {
+	private:
+		RecursiveMutex mutex;
+		volatile bool running;
+	public:
+		IRunnable (void);
+		virtual ~IRunnable (void);
+
+		virtual void * run (void *) = 0;
+  
+		bool isRunning (void);
+		void setRunning (bool r);
+	};
+}
+#endif
diff --git a/src/shared/concurrent/ScopedMemoryLock.cpp b/src/shared/concurrent/ScopedMemoryLock.cpp
new file mode 100755
index 0000000..1063fa3
--- /dev/null
+++ b/src/shared/concurrent/ScopedMemoryLock.cpp
@@ -0,0 +1,123 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ScopedMemoryLock.hpp"
+
+namespace concurrent {
+	ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
+
+	ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
+		this->hasLock = false;
+		this->address = address;
+		this->mutex = NULL;
+
+		ScopedMemoryLock::addressMutexMap.lock();
+		AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+		ScopedMemoryLock::addressMutexMap.unlock();
+
+		/* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
+			if someone is passing an address that has not been formally added via the static method
+			call then that means it is very unlikely that they are not removing it either. We do
+			not want a memory leak therefore this seems like the best method. */
+		if (it != ScopedMemoryLock::addressMutexMap.end()) 
+			this->mutex = it->second;
+
+		if (engage == true)
+			this->lock();
+	}
+
+	ScopedMemoryLock::~ScopedMemoryLock (void) {
+		if (this->hasLock == true)
+			unlock();
+	}
+
+	void
+	ScopedMemoryLock::lock (void) {
+		this->mutex->lock();
+		this->hasLock = true;
+	}
+
+	void 
+	ScopedMemoryLock::unlock (void) {
+		this->mutex->unlock();
+		this->hasLock = false;
+	}
+
+	bool
+	ScopedMemoryLock::isLocked (void) const {
+		return this->hasLock;
+	}
+	
+	bool
+	ScopedMemoryLock::trylock (void) {
+		this->hasLock = (this->hasLock==true) ? true : this->mutex->trylock();
+		return this->hasLock;
+	}
+
+	bool
+	ScopedMemoryLock::remove (void) {
+		if (this->hasLock == false) {
+			return false;
+		}
+
+		addressMutexMap.lock();
+
+		bool result = false;
+		AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+		if (it != addressMutexMap.end()) {
+			delete it->second;
+			addressMutexMap.end();
+			result = true;
+		}
+    
+		addressMutexMap.unlock();
+		return result;
+	}
+
+	bool 
+	ScopedMemoryLock::addMemoryLock (unsigned long address) {
+		addressMutexMap.lock();
+
+		bool result = false;
+		AddressToMutexMap::iterator it = addressMutexMap.find (address);
+		if (it == addressMutexMap.end()) {
+			addressMutexMap.insert (std::make_pair (address, new Mutex));
+			result = true;
+		}
+
+		addressMutexMap.unlock();
+		return result;
+	}
+
+	bool 
+	ScopedMemoryLock::removeMemoryLock (unsigned long address) {
+		addressMutexMap.lock();
+
+		bool result = false;
+		AddressToMutexMap::iterator it = addressMutexMap.find (address);
+		if (it != addressMutexMap.end()) {
+			delete it->second;
+			addressMutexMap.erase(it);
+			result = true;
+		}
+
+		addressMutexMap.unlock();
+		return result;
+	}
+
+} // end of namespace
diff --git a/src/shared/concurrent/ScopedMemoryLock.hpp b/src/shared/concurrent/ScopedMemoryLock.hpp
new file mode 100755
index 0000000..d60c7fd
--- /dev/null
+++ b/src/shared/concurrent/ScopedMemoryLock.hpp
@@ -0,0 +1,51 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_SCOPEDMEMORYLOCK
+#define HPP_CONCURRENT_SCOPEDMEMORYLOCK
+
+#include "Map.hpp"
+#include "Mutex.hpp"
+#include <string>
+
+namespace concurrent {
+
+	class ScopedMemoryLock : public ILockable {
+	private:
+		typedef Map<long int,Mutex *> AddressToMutexMap;
+		static AddressToMutexMap addressMutexMap;
+
+		bool hasLock;
+		unsigned long address;
+		Mutex * mutex;
+	public:
+		ScopedMemoryLock (unsigned long address, bool engage = false);
+		virtual ~ScopedMemoryLock (void);
+ 
+		void lock (void);
+		void unlock (void);
+		bool trylock (void);
+		bool remove (void);
+		bool isLocked (void) const;
+	  
+		static bool addMemoryLock (unsigned long address);
+		static bool removeMemoryLock (unsigned long address);
+	};
+} // end of namespace
+
+#endif 
diff --git a/src/shared/concurrent/Semaphore.cpp b/src/shared/concurrent/Semaphore.cpp
new file mode 100755
index 0000000..4e5a58d
--- /dev/null
+++ b/src/shared/concurrent/Semaphore.cpp
@@ -0,0 +1,42 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Semaphore.hpp"
+
+namespace concurrent {
+
+  Semaphore::Semaphore (void) {
+    sem_init (&this->semaphore, 0, 0);
+  }
+
+  Semaphore::~Semaphore (void) {
+    sem_destroy (&this->semaphore);
+  }
+
+  void
+  Semaphore::acquire (void) {
+    sem_wait (&this->semaphore);
+  }
+
+  void
+  Semaphore::release (void) {
+    sem_post (&this->semaphore);
+  }
+
+} // end of namespace
+
diff --git a/src/shared/concurrent/Semaphore.hpp b/src/shared/concurrent/Semaphore.hpp
new file mode 100755
index 0000000..3b9e0f4
--- /dev/null
+++ b/src/shared/concurrent/Semaphore.hpp
@@ -0,0 +1,39 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_SEMAPHORE
+#define HPP_THREAD_SEMAPHORE
+
+#include <semaphore.h>
+
+namespace concurrent {
+
+class Semaphore {
+private:
+  sem_t semaphore;
+public:
+  Semaphore (void);
+  virtual ~Semaphore (void);
+
+  void acquire (void);
+  void release (void);
+};
+
+}
+
+#endif
diff --git a/src/shared/concurrent/Thread.cpp b/src/shared/concurrent/Thread.cpp
new file mode 100755
index 0000000..b697ae0
--- /dev/null
+++ b/src/shared/concurrent/Thread.cpp
@@ -0,0 +1,132 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Thread.hpp"
+#include "ThreadGroup.hpp"
+#include <iostream>
+#include <ctime>
+
+namespace concurrent {
+
+	static void *
+	thread_run (void * runner) {
+		IRunnable * thread = (IRunnable *)runner;
+
+		thread->setRunning(true);
+		void * rvalue = thread->run (NULL);
+		thread->setRunning(false);
+		return rvalue;
+	}
+
+	Thread::Thread (ThreadGroup * group,
+						 IRunnable * runner, 
+						 const std::string & name) : thread(0) {
+		this->group = group;
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (IRunnable * runner,
+						 const std::string & name) 
+		: group(NULL), thread(0) {
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (const std::string & name) 
+		: group(NULL), runner(NULL), thread(0) {
+		this->name = name;
+	}
+
+	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
+	}
+
+	Thread::~Thread (void) {
+		if (this->isRunning() == true) {
+			this->setRunning(false);
+			this->join();
+		}
+	}
+
+	void 
+	Thread::interrupt (void) {
+		this->setRunning(false);
+		pthread_cancel (this->thread);
+		pthread_detach (this->thread);
+	}
+
+	void 
+	Thread::yield (void) {
+		pthread_yield();
+	}
+
+	void * 
+	Thread::stop (void) {
+		this->setRunning(false);
+		return this->join();
+	}
+
+	int 
+	Thread::sleep (unsigned long ms) {
+		struct timespec req = {0};
+		time_t sec = (int)(ms/1000);
+		ms = ms - (sec*1000);
+		req.tv_sec = sec;
+		req.tv_nsec = ms*1000000L;
+		while (nanosleep (&req, &req) == -1)
+			continue;
+		return 1;
+	}
+
+	bool 
+	Thread::start (void) {
+		if (this->isRunning() == true)
+			return false;
+		
+		if (this->runner != NULL) {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this->runner))
+				return false;
+		}
+		else {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this))
+				return false;
+		}
+		return true;
+	}
+
+	void *
+	Thread::join (void) {
+		void * rvalue = NULL;
+		if (this->thread > 0)
+			pthread_join (this->thread, &rvalue);
+		return rvalue;
+	}
+
+	void *
+	Thread::run (void * null) {
+		std::cerr << "Thread::run : null runner\n";
+		pthread_exit (null);
+	}
+
+} // end of namespace
diff --git a/src/shared/concurrent/Thread.hpp b/src/shared/concurrent/Thread.hpp
new file mode 100755
index 0000000..cb7be67
--- /dev/null
+++ b/src/shared/concurrent/Thread.hpp
@@ -0,0 +1,72 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREAD
+#define HPP_CONCURRENT_THREAD
+
+#include <shared.h>
+#include <string>
+#include <pthread.h>
+#include <map>
+#include "Runnable.hpp"
+
+namespace concurrent {
+
+	class ThreadGroup;
+
+	class Thread : public IRunnable {
+	private:
+		friend class ThreadGroup;
+
+		ThreadGroup * group;
+		std::string name;
+		IRunnable * runner;
+		pthread_t thread;
+		bool joinable;
+		int priority;
+	public:
+		Thread (ThreadGroup * group, 
+				  IRunnable * runner, 
+				  const std::string & name);
+		Thread (IRunnable * runner,
+				  const std::string & name);
+		Thread (const std::string & name);
+		Thread (void);
+		virtual ~Thread (void);
+
+		bool start (void);
+		void * stop (void);
+		void * join (void);
+		void interrupt (void);
+		void yield (void);
+  
+		virtual void * run (void *);
+
+		inline const std::string & getName (void) const { return this->name; }
+		inline int getPriority (void) const { return this->priority; }
+		inline void setPriority (int priority) { this->priority = priority; }
+		inline const ThreadGroup * getThreadGroup (void) const { 
+			return this->group; 
+		}
+
+		static int sleep (unsigned long ms);
+	};  
+
+}
+
+#endif
diff --git a/src/shared/concurrent/ThreadArgs.hpp b/src/shared/concurrent/ThreadArgs.hpp
new file mode 100755
index 0000000..f44742c
--- /dev/null
+++ b/src/shared/concurrent/ThreadArgs.hpp
@@ -0,0 +1,8 @@
+#ifndef H_THREAD_THREADARGS
+#define H_THREAD_THREADARGS
+
+#include <vector>
+
+typedef std::vector<void *> ThreadArgs;
+
+#endif
diff --git a/src/shared/concurrent/ThreadGroup.cpp b/src/shared/concurrent/ThreadGroup.cpp
new file mode 100755
index 0000000..f50b487
--- /dev/null
+++ b/src/shared/concurrent/ThreadGroup.cpp
@@ -0,0 +1,105 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadGroup.hpp"
+#include <algorithm>
+
+namespace concurrent {
+
+  ThreadGroup::ThreadGroup (void) 
+    : parent(NULL), daemon(false) {
+  }
+
+  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
+    : daemon(false) {
+    this->parent = parent;
+    this->name = name;
+  }
+
+  ThreadGroup::ThreadGroup (const std::string & name) 
+    : parent(NULL), daemon(false) {
+    this->name = name;
+  }
+
+  ThreadGroup::~ThreadGroup (void) {
+    if (this->daemon == true) {
+      this->stop();
+    }
+  }
+
+  bool 
+  ThreadGroup::parentOf (ThreadGroup * parent) {
+    if ((this->parent == NULL) || (parent == NULL))
+      return false;
+    // Needs to be better than this. 
+    return (this->parent == parent) ? true : false;
+  } 
+    
+  bool
+  ThreadGroup::addThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+    if (it == this->threads.end()) {
+      thread->group = this;
+      this->threads.push_back (thread);
+      return true;
+    }
+    return false;
+  }
+
+  bool 
+  ThreadGroup::removeThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+
+    if (it == this->threads.end())
+      return false;
+    this->threads.erase(it);
+    return true;
+  }
+
+  void
+  ThreadGroup::interrupt (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->interrupt();
+    }
+  }
+
+  bool
+  ThreadGroup::start (void) {
+    bool rvalue = false;
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      rvalue = (*it++)->start();
+    }
+
+    return rvalue;
+  }
+
+  void 
+  ThreadGroup::stop (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->stop();
+    }
+  }
+} // end of namesapce
diff --git a/src/shared/concurrent/ThreadGroup.hpp b/src/shared/concurrent/ThreadGroup.hpp
new file mode 100755
index 0000000..f907fd4
--- /dev/null
+++ b/src/shared/concurrent/ThreadGroup.hpp
@@ -0,0 +1,57 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREADGROUP
+#define HPP_CONCURRENT_THREADGROUP
+
+#include <string>
+#include "List.hpp"
+#include "Thread.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup {
+  private:
+    typedef concurrent::List<Thread *> ThreadList;
+    
+    ThreadGroup * parent;
+    std::string name;
+    ThreadList threads;
+    bool daemon; 
+  public:
+    ThreadGroup (void);
+    ThreadGroup (ThreadGroup * parent, const std::string & name);
+    ThreadGroup (const std::string & name);
+    virtual ~ThreadGroup (void);
+
+    bool parentOf (ThreadGroup * parent);
+    bool addThread (Thread * thread);
+    bool removeThread (Thread * thread);
+    void interrupt (void);
+    bool start (void);
+    void stop (void);
+    
+    inline bool isDaemon (void) const { return this->daemon; }
+    inline void setDaemon (bool daemon) { this->daemon = daemon; }
+    inline const std::string & getName (void) const { return this->name; }
+    inline ThreadGroup * getParent (void) const { return this->parent; }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/shared/concurrent/ThreadPool.cpp b/src/shared/concurrent/ThreadPool.cpp
new file mode 100755
index 0000000..62c95be
--- /dev/null
+++ b/src/shared/concurrent/ThreadPool.cpp
@@ -0,0 +1,121 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadPool.hpp"
+
+namespace concurrent {
+  int ThreadPool::defaultTaskMax = 5;
+
+  ThreadPool::Task::Task (ThreadPool * pool) {
+    this->pool = pool;
+  }
+
+  void *
+  ThreadPool::Task::run (void * null) {
+	  while (this->isRunning() == true) {
+		 if (this->pool->isRunning() == false)
+			 break;
+      
+		 if (this->pool->getQueueSize() > 0) {
+			 IRunnable * runner = this->pool->removeFromQueue();
+			 runner->run (NULL);
+			 delete runner;
+		 }
+		 Thread::sleep (1);
+    }
+
+    return NULL;
+  }
+
+  ThreadPool::ThreadPool (void) {
+    this->running = false;
+
+    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::ThreadPool (int N) {
+    this->running = false;
+
+    for (int ii = 0; ii < N; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::~ThreadPool (void) {
+    if (this->running == true)
+      this->stop(true);
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      Thread * t = (*it); it++;
+      delete t;
+    }
+
+    while (this->runQueue.size() > 0) {
+      IRunnable * r = this->runQueue.pop();
+      delete r;
+    }
+  }
+
+  void 
+  ThreadPool::start (void) {
+    this->running = true;
+    
+	 ThreadList::iterator it = this->threads.begin();
+	 while (it != this->threads.end())
+    {
+		 (*it)->start();
+		 it++;
+    }
+  }
+
+  void 
+  ThreadPool::stop (bool join) {
+    this->running = false;
+
+    /* Waiting to join all of the threads will mean that the thread that the
+       pool is calling the stop() method from will block until all of the 
+       threads inside of the pool have stopped.
+
+       There is a PROBLEM here. If you call this, for some reason, from inside
+       of one of the Task threads then you are going to hit a deadlock. Never
+       pass the join parameter if this is being called from inside the Tasks.*/
+    if (join == true) {
+		 ThreadList::iterator it = this->threads.begin();
+		 while (it != this->threads.end()) {
+			 (*it)->stop();
+			 it++;
+		 }
+    }
+  }
+
+  void 
+  ThreadPool::execute (IRunnable * runner) {
+    this->runQueue.push (runner);
+  }
+
+} // end of namespace
+
diff --git a/src/shared/concurrent/ThreadPool.hpp b/src/shared/concurrent/ThreadPool.hpp
new file mode 100755
index 0000000..1999f0e
--- /dev/null
+++ b/src/shared/concurrent/ThreadPool.hpp
@@ -0,0 +1,72 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_THREADPOOL
+#define HPP_THREAD_THREADPOOL
+
+#include "Mutex.hpp"
+#include "Thread.hpp"
+#include "Queue.hpp"
+#include <queue>
+#include <list>
+
+namespace concurrent {
+
+  /* @description: This is a ThreadPool object that will keep N concurrent
+     threads running. Runnable objects can be attached to this object and they
+     will be executed immediately as a thread becomes available to run them. 
+     @author: John `jb Bellone (jvb4@njit.edu)
+     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
+  class ThreadPool {
+  private:
+    typedef std::list<Thread *> ThreadList;
+    
+    class Task : public IRunnable {
+    private:
+      ThreadPool * pool;
+    public:
+      Task (ThreadPool * pool);
+      
+      void * run (void * null);
+    };
+    
+    concurrent::Queue<IRunnable *> runQueue;
+    ThreadList threads;
+    bool running;
+  public:
+    static int defaultTaskMax;
+
+    ThreadPool (void);
+    ThreadPool (int N);
+    ~ThreadPool (void);
+
+    /* Thread un-Safe Methods */
+    void start (void);
+    void stop (bool join = false);
+
+    /* Thread-Safe Methods */
+    void execute (IRunnable *);
+    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
+    inline bool isRunning (void) const { return this->running; }
+    inline int getMaxThreads (void) const { return this->threads.size(); }
+    inline size_t getQueueSize (void) { return this->runQueue.size(); }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/shared/network/Socket.hpp b/src/shared/network/Socket.hpp
new file mode 100755
index 0000000..5a87a3d
--- /dev/null
+++ b/src/shared/network/Socket.hpp
@@ -0,0 +1,39 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK_SOCKET
+#define HPP_NETWORK_SOCKET
+
+#include <cstring>
+
+namespace network {
+
+  class ISocket {
+  protected:
+    int sockfd;
+  public:
+    virtual ~ISocket (void) { }
+
+    virtual void close (void) = 0;
+    virtual int send (const char * bytes, size_t length) = 0;
+    virtual int receive (char * btyes, size_t size) = 0;
+  };
+
+} // end of namesapce
+
+#endif
diff --git a/src/shared/network/Tcp.cpp b/src/shared/network/Tcp.cpp
new file mode 100755
index 0000000..1eb2645
--- /dev/null
+++ b/src/shared/network/Tcp.cpp
@@ -0,0 +1,158 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Tcp.hpp"
+#include <iostream>
+
+namespace network {
+
+	TcpSocket::TcpSocket (void) {
+		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	}
+
+	TcpSocket::~TcpSocket (void) {
+		this->close();
+	}
+
+	void
+	TcpSocket::close (void) {
+		if (this->sockfd > 0)
+			::close (this->sockfd);
+	}
+	
+	int
+	TcpSocket::send (const char * bytes, size_t length) {
+		return ::write (this->sockfd, bytes, length);
+	}
+
+	int
+	TcpSocket::receive (char * bytes, size_t size) {
+		return ::read (this->sockfd, bytes, size);
+	}
+
+	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
+		this->port = port;
+
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+		this->sockaddr.sin_port = htons (this->port);
+	}
+
+	TcpServerSocket::~TcpServerSocket (void) {
+		this->close();
+	}
+
+	bool
+	TcpServerSocket::start (int backlog = 5) {
+		int opt = 1;
+
+		// This is to prevent conflicts with major services' ports.
+		if (this->port < 1024)
+			return false;
+
+		if (::setsockopt (this->sockfd, 
+								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
+			return false;
+
+		if (::bind (this->sockfd,
+						(struct sockaddr *)&(this->sockaddr),
+						sizeof (this->sockaddr)) < 0)
+			return false;
+
+		if (::listen (this->sockfd, backlog) < 0)
+			return false;
+
+		return true;
+	}
+
+	int
+	TcpServerSocket::getPort (void) const {
+		return this->port;
+	}
+	
+	void
+	TcpServerSocket::close (void) {
+		TcpSocket::close();
+	}
+
+	TcpServerSocket::Acceptor *
+	TcpServerSocket::newAcceptor (void) {
+		return new TcpServerSocket::Acceptor (this, this->sockfd);
+	}
+
+	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
+		this->socket = server;
+		this->sockfd = sockfd;
+	}
+
+	int
+	TcpServerSocket::Acceptor::acceptIncoming (void) {
+		int newfd = -1;
+		static struct sockaddr_in clientaddr;
+		unsigned int x = sizeof (clientaddr);
+
+		if ((newfd = ::accept (this->sockfd, 
+									  (struct sockaddr *)&clientaddr,
+									  &x)) < 0)
+			return -1;
+		return newfd;
+	}
+
+	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+	}
+
+	TcpClientSocket::TcpClientSocket (int newfd) {
+		this->sockfd = newfd;
+	}
+				
+	TcpClientSocket::~TcpClientSocket (void) {
+	}
+
+	bool
+	TcpClientSocket::connect (const char * host, int port) {
+		if (!host || (*host == '\0'))
+			return false;
+
+		if ((this->hp = ::gethostbyname (host)) == NULL)
+			return false;
+ 
+		// Copy over the hostname address.
+		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr 
+			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
+		this->sockaddr.sin_port = htons (port);
+
+		if (::connect (this->sockfd,
+							(struct sockaddr *)&(this->sockaddr),
+							sizeof (struct sockaddr)) < 0)
+			return false;
+    
+		return true;
+	}
+
+	void
+	TcpClientSocket::close (void) {
+		TcpSocket::close();
+	}
+
+} // end of namespace
diff --git a/src/shared/network/Tcp.hpp b/src/shared/network/Tcp.hpp
new file mode 100755
index 0000000..2480a3f
--- /dev/null
+++ b/src/shared/network/Tcp.hpp
@@ -0,0 +1,81 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK_TCP
+#define HPP_NETWORK_TCP
+
+#include "Socket.hpp"
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <netdb.h>
+
+namespace network {
+
+	class TcpSocket : public ISocket {
+	protected:
+		struct sockaddr_in sockaddr;
+	public:
+		TcpSocket (void);
+		virtual ~TcpSocket (void);
+
+		void close (void);
+		int send (const char * bytes, size_t length);
+		int receive (char * bytes, size_t size);
+	};
+
+	class TcpServerSocket : public TcpSocket {
+	private:
+		int port;
+	public:
+		class Acceptor {
+		private:
+			TcpServerSocket * socket;
+			int sockfd;
+		public:
+			Acceptor (TcpServerSocket * server, int sockfd);
+
+			int acceptIncoming (void);
+		};
+
+		TcpServerSocket (int port);
+		virtual ~TcpServerSocket (void);
+    
+		bool start (int backlog);
+		void close (void);
+		Acceptor * newAcceptor (void);
+		int getPort(void) const;
+	};
+  
+	class TcpClientSocket : public TcpSocket {
+	private:
+		struct hostent * hp;
+	public:
+		TcpClientSocket (void);
+		TcpClientSocket (int newfd);
+		virtual ~TcpClientSocket (void);
+
+		bool connect (const char * host, int port);
+		void close (void);
+	};
+
+} // end of namespace
+
+#endif
diff --git a/src/shared/proactor/Dispatcher.cpp b/src/shared/proactor/Dispatcher.cpp
new file mode 100755
index 0000000..ec23069
--- /dev/null
+++ b/src/shared/proactor/Dispatcher.cpp
@@ -0,0 +1,61 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Dispatcher.hpp"
+#include "Worker.hpp"
+#include <algorithm>
+
+namespace proactor {
+
+  Dispatcher::~Dispatcher (void) {
+      
+  }
+   
+	bool
+	Dispatcher::addWorker (Worker * w) {
+		this->workers.lock();
+		
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+		if (it == this->workers.end()) {
+			this->workers.push_back (w);
+			this->workers.unlock();
+			return w->start();
+      }
+		this->workers.unlock();
+		return false;
+	}
+  
+	bool
+	Dispatcher::removeWorker (Worker * w) {
+		this->workers.lock();
+		
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+		bool result = false;
+		if (it != this->workers.end()) {
+			this->workers.erase (it);
+			result = true;
+		}
+		this->workers.unlock();
+		return result;
+	}
+
+} // end of namesapce
diff --git a/src/shared/proactor/Dispatcher.hpp b/src/shared/proactor/Dispatcher.hpp
new file mode 100755
index 0000000..124f03d
--- /dev/null
+++ b/src/shared/proactor/Dispatcher.hpp
@@ -0,0 +1,43 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_DISPATCHER
+#define HPP_PROACTOR_DISPATCHER
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/List.hpp"
+
+namespace proactor {
+
+  class Worker;
+
+  class Dispatcher : public concurrent::Thread {
+  protected:
+    typedef concurrent::List<Worker *> WorkerListType;
+
+    WorkerListType workers;
+  public:
+    virtual ~Dispatcher (void);
+
+    bool addWorker (Worker * w);
+    bool removeWorker (Worker * w);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/shared/proactor/Event.cpp b/src/shared/proactor/Event.cpp
new file mode 100755
index 0000000..a1c5c2b
--- /dev/null
+++ b/src/shared/proactor/Event.cpp
@@ -0,0 +1,38 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Event.hpp"
+
+namespace proactor {
+
+  int Event::numEvents = 0;
+
+  Event::Event (int e, const std::string & buf) {
+    this->id = e;
+    this->buf = buf;
+  }
+
+  int
+  Event::uniqueEventId (void) {
+    return Event::numEvents++;
+  }
+
+  EventDispatcher::~EventDispatcher (void) {
+  }
+ 
+} // end of namespace
diff --git a/src/shared/proactor/Event.hpp b/src/shared/proactor/Event.hpp
new file mode 100755
index 0000000..f5c9f7e
--- /dev/null
+++ b/src/shared/proactor/Event.hpp
@@ -0,0 +1,56 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_EVENT
+#define HPP_PROACTOR_EVENT
+
+#include "Dispatcher.hpp"
+#include <string>
+
+namespace proactor {
+
+  class Event {
+  private:
+    static int numEvents;
+  public:
+    int id;
+    std::string buf;
+
+    Event (int id, const std::string & buf);
+
+    static int uniqueEventId (void);
+  };
+
+  class EventDispatcher : public Dispatcher {
+  private:
+    int eventId;
+  public:
+    virtual ~EventDispatcher (void);
+
+    inline void setEventId (int e) { 
+      this->eventId = e;
+    }
+
+    inline int getEventId (void) { 
+      return this->eventId;
+    }
+  };
+
+}
+
+#endif
diff --git a/src/shared/proactor/InputDispatcher.cpp b/src/shared/proactor/InputDispatcher.cpp
new file mode 100755
index 0000000..52210fd
--- /dev/null
+++ b/src/shared/proactor/InputDispatcher.cpp
@@ -0,0 +1,60 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "InputDispatcher.hpp"
+#include "Proactor.hpp"
+
+namespace proactor {
+
+	InputDispatcher::~InputDispatcher (void) {
+		this->inputQueue.lock();
+		while (this->inputQueue.size() > 0)
+			this->inputQueue.pop();
+		this->inputQueue.unlock();
+	}
+
+	void *
+	InputDispatcher::stop (void) {
+		WorkerListType::iterator it = this->workers.begin();
+		while (it != this->workers.end()) {
+			(*it)->stop();
+			it = this->workers.erase(it);
+		}
+		return Thread::stop();
+	}
+
+	void *
+	InputDispatcher::run (void * null) {
+		while (this->isRunning() == true) {
+			// Dispatch all of the input items on the queue.
+			this->inputQueue.lock();
+
+			while (this->inputQueue.size() > 0) {
+				// For right now all we're doing is pushing up the chain.
+				this->pro->onReadComplete ( this->inputQueue.pop() );
+			}
+
+			this->inputQueue.unlock();
+
+			Thread::sleep(100);
+		}
+  
+		return NULL; 
+	}
+
+} // end of namespace
diff --git a/src/shared/proactor/InputDispatcher.hpp b/src/shared/proactor/InputDispatcher.hpp
new file mode 100755
index 0000000..fc78fcb
--- /dev/null
+++ b/src/shared/proactor/InputDispatcher.hpp
@@ -0,0 +1,53 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_INPUTDISPATCHER
+#define HPP_PROACTOR_INPUTDISPATCHER
+
+#include "../concurrent/Queue.hpp"
+#include "Event.hpp"
+
+namespace proactor {
+
+	class Proactor;
+
+	class InputDispatcher : public EventDispatcher {
+	protected:
+		typedef concurrent::Queue<Event> InputQueueType;
+
+		Proactor * pro;
+		InputQueueType inputQueue;
+	public:
+		virtual ~InputDispatcher (void);
+
+		void * stop (void);
+    
+		inline void onReadComplete (const char * buf) {
+			this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
+		}
+
+		inline void onReadComplete (const std::string & buf) {
+			this->inputQueue.push ( Event (getEventId(), std::string (buf) ) );
+		}
+
+		void * run (void * null);
+	};
+
+} // end of namespace
+
+#endif
diff --git a/src/shared/proactor/Proactor.cpp b/src/shared/proactor/Proactor.cpp
new file mode 100755
index 0000000..16426e6
--- /dev/null
+++ b/src/shared/proactor/Proactor.cpp
@@ -0,0 +1,149 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Proactor.hpp"
+#include <iostream>
+#include <algorithm>
+
+namespace proactor {
+
+	Proactor::Proactor (void) {
+	}
+
+	Proactor::~Proactor (void) {
+		// Remove all of the lists of event handlers.
+		{
+			EventMapType::iterator it = this->eventsToHandlers.begin();
+			while (it != this->eventsToHandlers.end()) {
+				WorkerListType * q = (it->second);
+				delete q;
+				it++;
+			}
+		}
+ 
+		// Handle the dispatchers that have not been manually removed.
+		{
+			DispatcherList::iterator it = this->dispatchers.begin();
+			while (it != this->dispatchers.end())
+			{
+				Dispatcher * d = (*it);
+				delete d;
+				it++;
+			}
+		}
+  
+	}
+
+	bool
+	Proactor::addWorker (int e, Worker * job) {
+		this->eventsToHandlers.lock();
+		{
+			EventMapType::iterator it = this->eventsToHandlers.find (e);
+  
+			if (it == this->eventsToHandlers.end())
+				this->eventsToHandlers[e] = new WorkerListType;  
+			this->eventsToHandlers[e]->push_back (job);
+		}
+		this->eventsToHandlers.unlock();
+
+		return job->start();
+	}
+
+	void
+	Proactor::onReadComplete (Event e) {
+		this->events.push (e);
+	}
+
+	void 
+	Proactor::onReadComplete (int e, const char * buf) {
+		this->events.push ( Event (e, std::string (buf)) );   
+	}
+
+	bool
+	Proactor::removeWorker (int e, Worker * job) {
+		bool result = false;
+
+		this->eventsToHandlers.lock();
+		{
+			WorkerListType::iterator it = 
+				std::find (this->eventsToHandlers[e]->begin(),
+							  this->eventsToHandlers[e]->end(),
+							  job);
+    
+			if (it != this->eventsToHandlers[e]->end())
+			{
+				this->eventsToHandlers[e]->erase (it);
+				result = true;
+			}
+		}
+		this->eventsToHandlers.unlock();
+   
+		return result;
+	}
+
+	void
+	Proactor::addDispatcher (Dispatcher * d) {
+		this->dispatchers.push_back (d);
+	}
+
+	bool
+	Proactor::removeDispatcher (Dispatcher * d) {
+		DispatcherList::iterator it = std::find (this->dispatchers.begin(),
+															  this->dispatchers.end(),
+															  d);
+
+		if (it == this->dispatchers.end())
+			return false;
+  
+		this->dispatchers.erase (it);
+		return true;
+	}
+
+	void *
+	Proactor::run (void * null) {
+		WorkerListType::iterator it;
+
+		while (this->isRunning() == true) {
+			this->events.lock();
+
+			while (this->events.size() > 0) {
+				Event e = this->events.pop();
+
+				// We are throwing events with no handlers to catch them.
+				if (this->eventsToHandlers.find (e.id) == 
+					 this->eventsToHandlers.end())
+					continue;
+ 
+				it = this->eventsToHandlers[e.id]->begin();
+	  
+				while (it != this->eventsToHandlers[e.id]->end()) {
+					Worker * j = (*it);
+	      
+					j->pushInputQueue (e.buf);
+		      
+					it++;
+				}
+			}
+			this->events.unlock();
+      
+			Thread::sleep(100);
+      }
+		return NULL;
+	}
+
+} // end of namespace
diff --git a/src/shared/proactor/Proactor.hpp b/src/shared/proactor/Proactor.hpp
new file mode 100755
index 0000000..fc90f59
--- /dev/null
+++ b/src/shared/proactor/Proactor.hpp
@@ -0,0 +1,63 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_PROACTOR
+#define HPP_PROACTOR_PROACTOR
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/Map.hpp"
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/List.hpp"
+#include "Worker.hpp"
+#include "Event.hpp"
+#include "Dispatcher.hpp"
+#include "InputDispatcher.hpp"
+
+namespace proactor {
+
+	class Proactor : public Dispatcher {
+	private:
+		typedef concurrent::List<Dispatcher *> DispatcherList;
+		typedef concurrent::Map<int, WorkerListType *> EventMapType;
+		typedef concurrent::Queue<Event> EventQueueType;
+
+		EventMapType eventsToHandlers;
+		DispatcherList dispatchers;
+		EventQueueType events;
+	public:
+		Proactor (void);
+		virtual ~Proactor (void);
+
+		bool addWorker (int e, Worker * w);
+		bool removeWorker (int e, Worker * w);
+		void addDispatcher (Dispatcher * d);
+		bool removeDispatcher (Dispatcher * d);
+    
+		void * run (void * null);
+ 
+		void onReadComplete (Event e);
+		void onReadComplete (int e, const char * buf);
+
+		inline const std::string & peekInputQueue (void) {
+			return (this->events.front()).buf;
+		}
+	};
+
+} // end of namespace
+
+#endif
diff --git a/src/shared/proactor/Worker.cpp b/src/shared/proactor/Worker.cpp
new file mode 100755
index 0000000..be5863f
--- /dev/null
+++ b/src/shared/proactor/Worker.cpp
@@ -0,0 +1,26 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Worker.hpp"
+
+namespace proactor {
+
+  Worker::~Worker (void) {
+  }
+
+} // end of namesapce
diff --git a/src/shared/proactor/Worker.hpp b/src/shared/proactor/Worker.hpp
new file mode 100755
index 0000000..5b5efe9
--- /dev/null
+++ b/src/shared/proactor/Worker.hpp
@@ -0,0 +1,46 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_WORKER
+#define HPP_PROACTOR_WORKER
+
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/Thread.hpp"
+#include <string>
+
+namespace proactor {
+
+  class InputDispatcher;
+
+  class Worker : public concurrent::Thread {
+  protected:
+    typedef concurrent::Queue<std::string> InputQueueType;
+
+    InputDispatcher * dispatcher;
+    InputQueueType inputQueue;
+  public:
+    virtual ~Worker (void);
+
+    inline void pushInputQueue (const std::string & buf) {
+		 this->inputQueue.push (std::string (buf));
+    }
+  };
+
+} // end of namespace
+
+#endif

commit c88a149040361431997ab017089341637c91d84a
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Aug 7 11:25:28 2009 -0400

    Fixed issue with config vector not loading multiple items.

diff --git a/src/Application.cpp b/src/Application.cpp
index 1c8c7e4..bb47aa4 100755
--- a/src/Application.cpp
+++ b/src/Application.cpp
@@ -19,6 +19,7 @@
 #include "Application.hpp"
 #include "Plugin.hpp"
 #include <cstring>
+#include <iostream>
 
 /* @description: This method takes the argument and clears the string of
    everything except for the directories. Therefore the return value would
@@ -328,11 +329,11 @@ Application::init (int argc, char *** argv) {
       
 			while ((block = ext->get(ext, ii)) != NULL) {
 				ConfigPair * run = cfg->get_pair (cfg, block, "onLoad", "run");
-	      
+				
 				if (run && (strcmp (run->value, "1") == 0)) {
 					ConfigPair * filename 
 						= cfg->get_pair (cfg, block, "linux", "filename");
-
+					
 					if (!IS_NULL (filename) && !IS_NULLSTR (filename->value)) {
 						gboolean RelativePath 
 							= (filename->value[0] == '/') ? FALSE : TRUE;
diff --git a/src/config.cpp b/src/config.cpp
index 5c1a591..a370186 100755
--- a/src/config.cpp
+++ b/src/config.cpp
@@ -612,14 +612,15 @@ configrow_method_get_vector (ConfigRow * row, const gchar * key)
 
       ConfigVector * vec = configvector_new (row, pair->key);
       gchar buf[1024];
-      gchar * p = parse (pair->value, &buf[0], 1024, ','); 
-      gchar * q = pair->value + strlen (pair->value);
-    
-      do
-		{
-			vec->add (vec, trim (&buf[0]));
-		} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
+      gchar * p = NULL;
+		gchar * q = pair->value;
+		gchar * r = pair->value + strlen (pair->value);
 
+		do {
+			p = parse (q,&buf[0],1024,',');
+			vec->add (vec, trim (&buf[0]));
+			q = p + 1;
+		} while (q < r);
       return vec;
 	}
 	return NULL;
@@ -733,7 +734,7 @@ configvector_method_get (ConfigVector * vec, guint index)
 
 	if (index >= vec->array->len) return NULL;
 
-	gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
+	gchar * rvalue = (gchar *) g_ptr_array_index (vec->array, index);
 	return rvalue;
 }
 

commit 07b794b632dbd97c775ab50cdd827df84237b681
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Aug 7 10:39:09 2009 -0400

    Fixed some problems with Makefiles that have been hanging abouts for
    awhile.

diff --git a/Makefile b/Makefile
index 5f2d79a..3bd9a93 100755
--- a/Makefile
+++ b/Makefile
@@ -2,7 +2,7 @@ MD=mkdir -p
 MAKE=-make -C
 PWD=`pwd`
 
-all:	libgtkworkbookshared libgtkworkbook gtkworkbook
+all:	libgtkworkbook libgtkworkbookshared gtkworkbookapp
 
 libgtkworkbook:
 	${MD} OBJS/libgtkworkbook
@@ -12,16 +12,14 @@ libgtkworkbookshared:
 	${MD} OBJS/libgtkworkbookshared
 	${MAKE} shared/ all
 
-gtkworkbook:
-	${MD} OBJS/realtime ${MD}/largefile
+gtkworkbookapp:
+	${MD} OBJS/realtime OBJS/largefile
 	$(MAKE) src/ all
-	$(MAKE) src/largefile all
 
 clean:
 	${MAKE} shared/ clean
 	${MAKE} gtkworkbook/ clean
 	$(MAKE) src/ clean
-	$(MAKE) src/largefile clean
 
 install: all
 	${MAKE} shared/ install
diff --git a/Makefile.base b/Makefile.base
index e767ae2..1208907 100755
--- a/Makefile.base
+++ b/Makefile.base
@@ -25,6 +25,7 @@ export LD_LIBRARY_PATH
 INCS = -I${INCDIR}/gtkextra-2.0
 INCS += -I${PROJDIR}/include
 INCS += -I/usr/local/include/gtkextra-2.0
+INCS += -I${HOME}/include
 INCS += `pkg-config gtk+-2.0 glib-2.0 --cflags`
 
 LIBS = -lpixman-1
diff --git a/src/Makefile b/src/Makefile
index c13d801..5c26dc0 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -7,7 +7,7 @@ OBJS=$(patsubst %.cpp,${OBJDIR}/%.o,${SRCS})
 LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0 -lgtkworkbookshared
 
 all: 	gtkworkbook
-#	make -C realtime/ all
+	make -C realtime/ all
 	make -C largefile/ all
 
 gtkworkbook: ${OBJS}
@@ -16,13 +16,13 @@ gtkworkbook: ${OBJS}
 clean:		
 	${MD} ${OBJDIR}	
 	${RM} ${OBJS} ${INSBINDIR}/gtkworkbook
-#	make -C realtime/ clean
+	make -C realtime/ clean
 	make -C largefile/ clean
 
 install: all
 	${MD} ${INSBINDIR}
 	${CP} ${PROJDIR}/bin/gtkworkbook ${INSBINDIR}/gtkworkbook
-#	make -C realtime/ install
+	make -C realtime/ install
 	make -C largefile/ install
 
 ${OBJDIR}/%.o: %.cpp
diff --git a/src/realtime/OpenStreamDialog.hpp b/src/realtime/OpenStreamDialog.hpp
old mode 100644
new mode 100755
diff --git a/src/realtime/PacketParser.cpp b/src/realtime/PacketParser.cpp
old mode 100644
new mode 100755
diff --git a/src/realtime/PluginFactory.cpp b/src/realtime/PluginFactory.cpp
old mode 100644
new mode 100755
diff --git a/src/realtime/Realtime.cpp b/src/realtime/Realtime.cpp
old mode 100644
new mode 100755
diff --git a/src/realtime/Realtime.hpp b/src/realtime/Realtime.hpp
old mode 100644
new mode 100755

commit c6451252281c59c5906255db5f2f4eb186124690
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Aug 6 17:59:38 2009 -0400

    (1) Added getPort() method to network::TcpServerSocket
    (2) Modified Realtime to handle dialog to start client connections to
    outside CSV streams. Currently activated via the Realtime menu.
    (3) Removed old thread_main.cpp file.
    (4) Modified Realtime to support starting Tcp server to accept input.

diff --git a/shared/concurrent/Thread.hpp b/shared/concurrent/Thread.hpp
index 79f2cf0..cb7be67 100755
--- a/shared/concurrent/Thread.hpp
+++ b/shared/concurrent/Thread.hpp
@@ -27,45 +27,45 @@
 
 namespace concurrent {
 
-  class ThreadGroup;
+	class ThreadGroup;
 
-  class Thread : public IRunnable {
-  private:
-    friend class ThreadGroup;
+	class Thread : public IRunnable {
+	private:
+		friend class ThreadGroup;
 
-    ThreadGroup * group;
-    std::string name;
-    IRunnable * runner;
-    pthread_t thread;
-    bool joinable;
-    int priority;
-  public:
-    Thread (ThreadGroup * group, 
-	    IRunnable * runner, 
-	    const std::string & name);
-    Thread (IRunnable * runner,
-	    const std::string & name);
-    Thread (const std::string & name);
-    Thread (void);
-    virtual ~Thread (void);
+		ThreadGroup * group;
+		std::string name;
+		IRunnable * runner;
+		pthread_t thread;
+		bool joinable;
+		int priority;
+	public:
+		Thread (ThreadGroup * group, 
+				  IRunnable * runner, 
+				  const std::string & name);
+		Thread (IRunnable * runner,
+				  const std::string & name);
+		Thread (const std::string & name);
+		Thread (void);
+		virtual ~Thread (void);
 
-    bool start (void);
-    void * stop (void);
-    void * join (void);
-    void interrupt (void);
-    void yield (void);
+		bool start (void);
+		void * stop (void);
+		void * join (void);
+		void interrupt (void);
+		void yield (void);
   
-    virtual void * run (void *);
+		virtual void * run (void *);
 
-    inline const std::string & getName (void) const { return this->name; }
-    inline int getPriority (void) const { return this->priority; }
-    inline void setPriority (int priority) { this->priority = priority; }
-    inline const ThreadGroup * getThreadGroup (void) const { 
-      return this->group; 
-    }
+		inline const std::string & getName (void) const { return this->name; }
+		inline int getPriority (void) const { return this->priority; }
+		inline void setPriority (int priority) { this->priority = priority; }
+		inline const ThreadGroup * getThreadGroup (void) const { 
+			return this->group; 
+		}
 
-    static int sleep (unsigned long ms);
-  };  
+		static int sleep (unsigned long ms);
+	};  
 
 }
 
diff --git a/shared/network/Tcp.cc b/shared/network/Tcp.cc
index b9a0572..1eb2645 100755
--- a/shared/network/Tcp.cc
+++ b/shared/network/Tcp.cc
@@ -81,6 +81,11 @@ namespace network {
 		return true;
 	}
 
+	int
+	TcpServerSocket::getPort (void) const {
+		return this->port;
+	}
+	
 	void
 	TcpServerSocket::close (void) {
 		TcpSocket::close();
diff --git a/shared/network/Tcp.hpp b/shared/network/Tcp.hpp
index 02ddc8a..2480a3f 100755
--- a/shared/network/Tcp.hpp
+++ b/shared/network/Tcp.hpp
@@ -29,51 +29,52 @@
 
 namespace network {
 
-  class TcpSocket : public ISocket {
-  protected:
-    struct sockaddr_in sockaddr;
-  public:
-    TcpSocket (void);
-    virtual ~TcpSocket (void);
+	class TcpSocket : public ISocket {
+	protected:
+		struct sockaddr_in sockaddr;
+	public:
+		TcpSocket (void);
+		virtual ~TcpSocket (void);
 
-    void close (void);
-    int send (const char * bytes, size_t length);
-    int receive (char * bytes, size_t size);
-  };
+		void close (void);
+		int send (const char * bytes, size_t length);
+		int receive (char * bytes, size_t size);
+	};
 
-  class TcpServerSocket : public TcpSocket {
-  private:
-    int port;
-  public:
-    class Acceptor {
-    private:
-      TcpServerSocket * socket;
-      int sockfd;
-    public:
-      Acceptor (TcpServerSocket * server, int sockfd);
+	class TcpServerSocket : public TcpSocket {
+	private:
+		int port;
+	public:
+		class Acceptor {
+		private:
+			TcpServerSocket * socket;
+			int sockfd;
+		public:
+			Acceptor (TcpServerSocket * server, int sockfd);
 
-      int acceptIncoming (void);
-    };
+			int acceptIncoming (void);
+		};
 
-    TcpServerSocket (int port);
-    virtual ~TcpServerSocket (void);
+		TcpServerSocket (int port);
+		virtual ~TcpServerSocket (void);
     
-    bool start (int backlog);
-    void close (void);
-    Acceptor * newAcceptor (void);
-  };
+		bool start (int backlog);
+		void close (void);
+		Acceptor * newAcceptor (void);
+		int getPort(void) const;
+	};
   
-  class TcpClientSocket : public TcpSocket {
-  private:
-    struct hostent * hp;
-  public:
-    TcpClientSocket (void);
-    TcpClientSocket (int newfd);
-    virtual ~TcpClientSocket (void);
+	class TcpClientSocket : public TcpSocket {
+	private:
+		struct hostent * hp;
+	public:
+		TcpClientSocket (void);
+		TcpClientSocket (int newfd);
+		virtual ~TcpClientSocket (void);
 
-    bool connect (const char * host, int port);
-    void close (void);
-  };
+		bool connect (const char * host, int port);
+		void close (void);
+	};
 
 } // end of namespace
 
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
index 00c400d..f624e89 100755
--- a/src/realtime/Network.cpp
+++ b/src/realtime/Network.cpp
@@ -22,46 +22,17 @@
 #define IS_TERMINAL(c) ((*c == '\n') || (*c == '\r'))
 
 namespace realtime {
-
-	NetworkCsvReceiver::NetworkCsvReceiver (int e, proactor::Proactor * pro) {
-		this->pro = pro;
-		setEventId (e);
-	}
-
-	NetworkCsvReceiver::~NetworkCsvReceiver (void) {
-	}
-
-	void *
-	NetworkCsvReceiver::run (void * null) {
-		
-		while (this->isRunning() == true) {
-			this->inputQueue.lock();
-      
-			while (this->inputQueue.size() > 0) {
-				if (this->isRunning() == false)
-					break;
-
-				this->pro->onReadComplete (this->inputQueue.pop());
-			}
-
-			this->inputQueue.unlock();
-
-			concurrent::Thread::sleep (5);
-		}
-
-		return NULL;
-	}
 	
-	NetworkPktReceiver::NetworkPktReceiver (int e, proactor::Proactor * pro) {
+	NetworkDispatcher::NetworkDispatcher (int e, proactor::Proactor * pro) {
 		this->pro = pro;
 		setEventId (e);
 	}
 
-	NetworkPktReceiver::~NetworkPktReceiver (void) {
+	NetworkDispatcher::~NetworkDispatcher (void) {
 	}
 
 	void *
-	NetworkPktReceiver::run (void * null) {
+	NetworkDispatcher::run (void * null) {
 		while (this->isRunning() == true) {
 			this->inputQueue.lock();
       
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
index fd972e0..82e0b57 100755
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -23,27 +23,22 @@
 #include <proactor/Worker.hpp>
 #include <proactor/Proactor.hpp>
 #include <iostream>
+#include <memory>
 
 #define MAX_INPUT_SIZE 1024
 
 namespace realtime {
 
-	class NetworkCsvReceiver : public proactor::InputDispatcher {
+	class NetworkDispatcher : public proactor::InputDispatcher {
 	public:
-		NetworkCsvReceiver (int e, proactor::Proactor * pro);
-		virtual ~NetworkCsvReceiver (void);
-
-		void * run (void * null);
-	};
-
-	class NetworkPktReceiver : public proactor::InputDispatcher {
+		typedef std::auto_ptr <NetworkDispatcher> AutoPtr;
 	public:
-		NetworkPktReceiver (int e, proactor::Proactor * pro);
-		virtual ~NetworkPktReceiver (void);
+		NetworkDispatcher (int e, proactor::Proactor * pro);
+		virtual ~NetworkDispatcher (void);
 
 		void * run (void * null);
 	};
-
+	
 	class ConnectionThread : public proactor::Worker {
 	private:
 		bool purge_socket;
@@ -57,6 +52,8 @@ namespace realtime {
 	};
 
 	class AcceptThread : public proactor::Worker {
+	public:
+		typedef std::auto_ptr <AcceptThread> AutoPtr;
 	private:
 		network::TcpServerSocket::Acceptor * acceptor;
 	public:
@@ -66,7 +63,6 @@ namespace realtime {
 
 		void * run (void * null);
 	};
-
 } // end of namespace
 
 #endif
diff --git a/src/realtime/OpenStreamDialog.hpp b/src/realtime/OpenStreamDialog.hpp
index a060b24..c2dd794 100644
--- a/src/realtime/OpenStreamDialog.hpp
+++ b/src/realtime/OpenStreamDialog.hpp
@@ -11,12 +11,14 @@ namespace realtime {
 		OpenStreamDialog (void) {
 			rt = NULL;
 			widget = NULL;
-			address_entry = NULL;
+			host_entry = NULL;
+			port_entry = NULL;
 		}
 
 		Realtime * rt;
 		GtkWidget * widget;
-		GtkWidget * address_entry;
+		GtkWidget * host_entry;
+		GtkWidget * port_entry;
 	};
 }
 
diff --git a/src/realtime/Packet.cpp b/src/realtime/Packet.cpp
index 8a4d516..ecec066 100755
--- a/src/realtime/Packet.cpp
+++ b/src/realtime/Packet.cpp
@@ -32,64 +32,64 @@
 
 namespace realtime {
 
-  Packet::Packet (void) {
-    this->delimiter = '\0';
-    this->type = -1;
-  }
-
-  Packet::~Packet (void) {
-    this->time.clear();
-    this->fields.clear();
-  }
-
-  gboolean
-  Packet::parse (const gchar * buf) {
-    this->fields.clear();
-
-    if (IS_NULLSTR (buf)) 
-      return FALSE;
+	Packet::Packet (void) {
+		this->delimiter = '\0';
+		this->type = -1;
+	}
+
+	Packet::~Packet (void) {
+		this->time.clear();
+		this->fields.clear();
+	}
+
+	gboolean
+	Packet::parse (const gchar * buf) {
+		this->fields.clear();
+
+		if (IS_NULLSTR (buf)) 
+			return FALSE;
   
-    this->delimiter = buf[0];
+		this->delimiter = buf[0];
 
-    String line(&buf[1]), value;
+		String line(&buf[1]), value;
 
-    WORD (this->delimiter, line, this->time);
-    WORD (this->delimiter, line, this->type);
+		WORD (this->delimiter, line, this->time);
+		WORD (this->delimiter, line, this->type);
 
-    while (line.length() > 0) {
-      WORD (this->delimiter, line, value);
-      this->fields.push_back (value);
-    }
+		while (line.length() > 0) {
+			WORD (this->delimiter, line, value);
+			this->fields.push_back (value);
+		}
 
-    return TRUE;
-  }
+		return TRUE;
+	}
 
-  Map<String,String>
-  Packet::parseFormatString (const gchar * buf) {
-    String fmt(buf);
-    Map<String,String> pairs; pairs.clear();
+	Map<String,String>
+	Packet::parseFormatString (const gchar * buf) {
+		String fmt(buf);
+		Map<String,String> pairs; pairs.clear();
 
-    size_t pos = 0, length = fmt.length(), comma = 0, equal = 0;
-    String key, val;
+		size_t pos = 0, length = fmt.length(), comma = 0, equal = 0;
+		String key, val;
 
-    while (pos < length) {
-      if ((comma = fmt.find_first_of (',')) == String::npos)
-	comma = length;
+		while (pos < length) {
+			if ((comma = fmt.find_first_of (',')) == String::npos)
+				comma = length;
       
-      if ((equal = fmt.find_first_of ('=')) == String::npos)
-	break;
+			if ((equal = fmt.find_first_of ('=')) == String::npos)
+				break;
 
-      key = fmt.substr (0, equal);
-      val = fmt.substr (equal+1, comma-equal-1);
+			key = fmt.substr (0, equal);
+			val = fmt.substr (equal+1, comma-equal-1);
 
-      pairs[key] = val;
+			pairs[key] = val;
 
-      if (comma == length)
-	break;
+			if (comma == length)
+				break;
 
-      fmt = fmt.substr (comma+1, length);
-      length = fmt.length();
-    }
-    return pairs;
-  }
+			fmt = fmt.substr (comma+1, length);
+			length = fmt.length();
+		}
+		return pairs;
+	}
 }
diff --git a/src/realtime/Packet.hpp b/src/realtime/Packet.hpp
index 5aa7ba0..e55ca4c 100755
--- a/src/realtime/Packet.hpp
+++ b/src/realtime/Packet.hpp
@@ -32,42 +32,42 @@
 
 namespace realtime {
 
-  class Packet {
-  private:
-    /* Members */
-    String time;
-    String type;
-    Array<String> fields;
-    gchar delimiter;
-  public:
-    enum {
-      TYPE_UPDATECELL = 0,
-      TYPE_ADDSHEET,
-      TYPE_REMSHEET,
-      TYPE_MOVESHEETINDEX,
-      TYPE_MOVESHEET,
-      TYPE_SAVESHEET,
-      TYPE_LOADSHEET,
-      /**/
-      MAX_TYPES
-    };
+	class Packet {
+	private:
+		/* Members */
+		String time;
+		String type;
+		Array<String> fields;
+		gchar delimiter;
+	public:
+		enum {
+			TYPE_UPDATECELL = 0,
+			TYPE_ADDSHEET,
+			TYPE_REMSHEET,
+			TYPE_MOVESHEETINDEX,
+			TYPE_MOVESHEET,
+			TYPE_SAVESHEET,
+			TYPE_LOADSHEET,
+			/**/
+			MAX_TYPES
+		};
   
-    Packet (void);
-    ~Packet (void);
+		Packet (void);
+		~Packet (void);
   
-    /* Methods */
-    gboolean parse (const gchar *);
-    Map<String,String> parseFormatString (const gchar *);
+		/* Methods */
+		gboolean parse (const gchar *);
+		Map<String,String> parseFormatString (const gchar *);
 
-    inline gchar getDelimiter (void) const { return this->delimiter; }
-    inline gint getType (void) const { return atoi (this->type.c_str()); }
-    inline const gchar * getTime (void) const { return this->time.c_str(); }
-    inline gint getFieldSize (void) const { return this->fields.size(); }
-    inline const gchar * operator[] (gint index) const {
-      return this->fields.at(index).c_str();
-    }
-    inline size_t size (void) const { return this->fields.size(); }
-  };
+		inline gchar getDelimiter (void) const { return this->delimiter; }
+		inline gint getType (void) const { return atoi (this->type.c_str()); }
+		inline const gchar * getTime (void) const { return this->time.c_str(); }
+		inline gint getFieldSize (void) const { return this->fields.size(); }
+		inline const gchar * operator[] (gint index) const {
+			return this->fields.at(index).c_str();
+		}
+		inline size_t size (void) const { return this->fields.size(); }
+	};
 
 } // end of namespace
 
diff --git a/src/realtime/PacketParser.cpp b/src/realtime/PacketParser.cpp
new file mode 100644
index 0000000..54b5a21
--- /dev/null
+++ b/src/realtime/PacketParser.cpp
@@ -0,0 +1,222 @@
+#include "PacketParser.hpp"
+#include <cstring>
+
+namespace realtime {
+
+	PacketParser::PacketParser (Workbook * wb, FILE * pktlog, int verbosity = 0) {
+		this->wb = wb;
+		this->pktlog = pktlog;
+		this->cell = cell_new();
+		this->verbosity = verbosity;
+	}
+
+	PacketParser::~PacketParser (void) {
+		this->cell->destroy (cell);
+	}
+
+	void *
+	PacketParser::run (void * null) {
+		std::queue<std::string> queue;
+		Packet packet;
+		const char * p = NULL;
+
+		while (this->isRunning() == true) {
+			if (this->inputQueue.size() > 0) {
+
+				// Lock, copy, clear, unlock. - Free this up.
+				this->inputQueue.lock();
+				this->inputQueue.copy (queue);
+				this->inputQueue.clear();
+				this->inputQueue.unlock();
+	  
+				while (queue.size() > 0) {
+					if (this->isRunning() == false)
+						break;
+
+					// Never understood why pop() doesn't return the element.
+					std::string buf = queue.front(); queue.pop();
+					p = buf.c_str();
+
+					if (packet.parse (p) == FALSE) {
+						g_warning ("Failed parsing packet '%s'", buf.c_str());
+						Thread::sleep (5);
+						continue;
+					}
+
+					switch (packet.getType()) {
+						default:
+						g_warning ("Invaild packet line '%s'", buf.c_str());
+						break;
+						/* ^time^type^sheet_name^sheet_name^after */
+						case Packet::TYPE_MOVESHEET: {
+							if (packet.size() != 3) {
+								g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
+											  buf.c_str());
+								break;
+							}
+	      
+							Sheet * sheet = wb->get_sheet (wb, packet[0]);
+							if (IS_NULL (sheet)) {
+								g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
+											  packet[0],
+											  (strcmp(packet[2], "0") == 0) ? "after" : "before",
+											  packet[1]);
+								break;
+							}
+
+							if (wb->move_sheet (wb, sheet, packet[1], atoi (packet[2]))
+								 == FALSE) {
+								g_warning ("Failed moving sheet '%s'", packet[0]);
+								break;
+							}
+						}
+						break;
+						/* ^time^type^sheet_name^loadpath */
+						case Packet::TYPE_LOADSHEET: {
+							if (packet.size() != 2) {			  
+								g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
+											  buf.c_str());
+								break;
+							}
+
+							Sheet * sheet = wb->get_sheet (wb, packet[0]);
+							if (IS_NULL (sheet)) {
+								g_warning ("Unable to load geometry file; sheet '%s'"
+											  " does not exist", packet[0]);
+								break;
+							}
+	      
+							sheet->load (sheet, packet[1]);
+						}
+						break;
+						/* ^time^type^sheet_name^savepath */
+						case Packet::TYPE_SAVESHEET: {
+							if (packet.size() != 2) {
+								g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
+											  buf.c_str());
+								break;
+							}
+		      
+							Sheet * sheet = wb->get_sheet (wb, packet[0]);
+							if (IS_NULL (sheet)) {
+								g_warning ("Failed saving sheet '%s'; does not exist",
+											  packet[0]);
+								break;
+							}
+	      
+							if (sheet->save (sheet, packet[1]) == FALSE) {
+								g_warning ("Unable to save sheet.");
+								break;
+							}
+						}
+						break;
+						/* ^time^type^sheet_name^position */
+						case Packet::TYPE_MOVESHEETINDEX: {
+							if (packet.size() != 2) {
+								g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
+											  "format: %s", buf.c_str());
+								break;
+							}
+
+							Sheet * sheet = wb->get_sheet (wb, packet[0]);
+							if (IS_NULL (sheet)) {
+								g_warning ("Failed moving sheet '%s' to %d:"
+											  " Does not exist", packet[0], atoi(packet[1]));
+								break;
+							}
+		      
+							if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) == FALSE) {
+								g_warning ("Failed moving sheet '%s' to %d:"
+											  " Invaild index\n", packet[0], atoi(packet[1]));
+							}
+						}
+						break;
+						/* ^time^type^sheet_name */
+						case Packet::TYPE_REMSHEET: {
+							if (packet.size() != 1) {
+								g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
+											  buf.c_str());
+								break;
+							}
+		      
+							Sheet * sheet = wb->get_sheet (wb, packet[0]);
+							if (IS_NULL (sheet)) {
+								g_warning ("Failed removing sheet '%s':"
+											  " Does not exist", packet[0]);
+								break;
+							}
+							wb->remove_sheet (wb, sheet);
+							sheet->destroy (sheet);
+						}
+						break;
+						/* ^time^type^sheet_name^max_row^max_column */
+						case Packet::TYPE_ADDSHEET: {
+							if (packet.size() != 3) {
+								g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
+											  buf.c_str());
+								break;
+							}
+		      
+							wb->add_new_sheet (wb, 
+													 packet[0],
+													 atoi (packet[1]),
+													 atoi (packet[2]));
+						}
+						break;
+						/* ^time^type^sheet_name^row^column^format^data */
+						case Packet::TYPE_UPDATECELL: {
+							if (packet.size() != 5) {
+								g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
+											  "format: %s", buf.c_str());
+								break;
+							}
+		      
+							Sheet * sheet = wb->get_sheet (wb, packet[0]);
+							if (IS_NULL (sheet)) {
+								g_warning ("Invaild sheet name '%s': Does not exist",
+											  packet[0]);
+								break;
+							}
+	            
+							cell->set_row (cell, atoi (packet[1]) );
+							cell->set_column (cell, atoi (packet[2]) );
+	      
+							if (strlen (packet[3]) > 0) {
+								Map<String,String> fmt = packet.parseFormatString (packet[3]);
+		
+								if (fmt["bgcolor"].length() > 0)
+									cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
+								if (fmt["fgcolor"].length() > 0)
+									cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
+								if (fmt["justification"].length() > 0)
+									cell->set_justification (cell, 
+																	 (GtkJustification)
+																	 atoi (fmt["justification"].c_str()));
+							}
+	      
+							cell->set_value (cell, packet[4]);
+
+							gdk_threads_enter();
+								
+							sheet->apply_cell (sheet, cell);
+
+							gdk_threads_leave();
+								
+							if (this->verbosity > 0) {
+								g_message ("Cell (%d,%d) updated", 
+											  cell->row, cell->column);
+							}
+						}
+						break;
+					}
+		
+					fprintf (pktlog, "%s\n", buf.c_str());
+					fflush (pktlog);
+					Thread::sleep(5);
+				}
+			}
+			Thread::sleep (10);
+		}
+		return NULL;
+	}
+}
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index f622796..cb6b7fa 100755
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -27,235 +27,25 @@
 #include <string>
 #include <queue>
 #include <ctime>
+#include <memory>
 
 namespace realtime {
 
 	class PacketParser : public proactor::Worker {
+	public:
+		typedef std::auto_ptr <PacketParser> AutoPtr;
 	private:
 		Workbook * wb;
 		FILE * pktlog;
 		Cell * cell;
 		int verbosity;
 	public:
-		PacketParser (Workbook * wb, FILE * pktlog, int verbosity = 0) { 
-			this->wb = wb;
-			this->pktlog = pktlog;
-			this->cell = cell_new();
-			this->verbosity = verbosity;
-		}
-  
-		virtual ~PacketParser (void) {
-			this->cell->destroy (cell);
-		}
-
-		void * run (void * null) {
-			std::queue<std::string> queue;
-			Packet packet;
-			const char * p = NULL;
-
-			while (this->isRunning() == true) {
-				if (this->inputQueue.size() > 0) {
-
-					// Lock, copy, clear, unlock. - Free this up.
-					this->inputQueue.lock();
-					this->inputQueue.copy (queue);
-					this->inputQueue.clear();
-					this->inputQueue.unlock();
-	  
-					while (queue.size() > 0) {
-
-						if (this->isRunning() == false)
-							break;
-
-						// Never understood why pop() doesn't return the element.
-						std::string buf = queue.front(); queue.pop();
-						p = buf.c_str();
-
-						if (packet.parse (p) == FALSE) {
-							g_warning ("Failed parsing packet '%s'", buf.c_str());
-							Thread::sleep (5);
-							continue;
-						}
+		PacketParser (Workbook * wb, FILE * pktlog, int verbosity);
+		virtual ~PacketParser (void);
 
-						switch (packet.getType()) {
-							default:
-							g_warning ("Invaild packet line '%s'", buf.c_str());
-							break;
-							/* ^time^type^sheet_name^sheet_name^after */
-							case Packet::TYPE_MOVESHEET: {
-								if (packet.size() != 3) {
-									g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
-												  buf.c_str());
-									break;
-								}
-	      
-								Sheet * sheet = wb->get_sheet (wb, packet[0]);
-								if (IS_NULL (sheet)) {
-									g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
-												  packet[0],
-												  (strcmp(packet[2], "0") == 0) ? "after" : "before",
-												  packet[1]);
-									break;
-								}
-
-								if (wb->move_sheet (wb, sheet, packet[1], atoi (packet[2]))
-									 == FALSE) {
-									g_warning ("Failed moving sheet '%s'", packet[0]);
-									break;
-								}
-							}
-							break;
-							/* ^time^type^sheet_name^loadpath */
-							case Packet::TYPE_LOADSHEET: {
-								if (packet.size() != 2) {			  
-									g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
-												  buf.c_str());
-									break;
-								}
-
-								Sheet * sheet = wb->get_sheet (wb, packet[0]);
-								if (IS_NULL (sheet)) {
-									g_warning ("Unable to load geometry file; sheet '%s'"
-												  " does not exist", packet[0]);
-									break;
-								}
-	      
-								sheet->load (sheet, packet[1]);
-							}
-							break;
-							/* ^time^type^sheet_name^savepath */
-							case Packet::TYPE_SAVESHEET: {
-								if (packet.size() != 2) {
-									g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
-												  buf.c_str());
-									break;
-								}
-		      
-								Sheet * sheet = wb->get_sheet (wb, packet[0]);
-								if (IS_NULL (sheet)) {
-									g_warning ("Failed saving sheet '%s'; does not exist",
-												  packet[0]);
-									break;
-								}
-	      
-								if (sheet->save (sheet, packet[1]) == FALSE) {
-									g_warning ("Unable to save sheet.");
-									break;
-								}
-							}
-							break;
-							/* ^time^type^sheet_name^position */
-							case Packet::TYPE_MOVESHEETINDEX: {
-								if (packet.size() != 2) {
-									g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
-												  "format: %s", buf.c_str());
-									break;
-								}
-
-								Sheet * sheet = wb->get_sheet (wb, packet[0]);
-								if (IS_NULL (sheet)) {
-									g_warning ("Failed moving sheet '%s' to %d:"
-												  " Does not exist", packet[0], atoi(packet[1]));
-									break;
-								}
-		      
-								if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) == FALSE) {
-									g_warning ("Failed moving sheet '%s' to %d:"
-												  " Invaild index\n", packet[0], atoi(packet[1]));
-								}
-							}
-							break;
-							/* ^time^type^sheet_name */
-							case Packet::TYPE_REMSHEET: {
-								if (packet.size() != 1) {
-									g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
-												  buf.c_str());
-									break;
-								}
-		      
-								Sheet * sheet = wb->get_sheet (wb, packet[0]);
-								if (IS_NULL (sheet)) {
-									g_warning ("Failed removing sheet '%s':"
-												  " Does not exist", packet[0]);
-									break;
-								}
-								wb->remove_sheet (wb, sheet);
-								sheet->destroy (sheet);
-							}
-							break;
-							/* ^time^type^sheet_name^max_row^max_column */
-							case Packet::TYPE_ADDSHEET: {
-								if (packet.size() != 3) {
-									g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
-												  buf.c_str());
-									break;
-								}
-		      
-								wb->add_new_sheet (wb, 
-														 packet[0],
-														 atoi (packet[1]),
-														 atoi (packet[2]));
-							}
-							break;
-							/* ^time^type^sheet_name^row^column^format^data */
-							case Packet::TYPE_UPDATECELL: {
-								if (packet.size() != 5) {
-									g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
-												  "format: %s", buf.c_str());
-									break;
-								}
-		      
-								Sheet * sheet = wb->get_sheet (wb, packet[0]);
-								if (IS_NULL (sheet)) {
-									g_warning ("Invaild sheet name '%s': Does not exist",
-												  packet[0]);
-									break;
-								}
-	            
-								cell->set_row (cell, atoi (packet[1]) );
-								cell->set_column (cell, atoi (packet[2]) );
-	      
-								if (strlen (packet[3]) > 0) {
-									Map<String,String> fmt = packet.parseFormatString (packet[3]);
-		
-									if (fmt["bgcolor"].length() > 0)
-										cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
-									if (fmt["fgcolor"].length() > 0)
-										cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
-									if (fmt["justification"].length() > 0)
-										cell->set_justification (cell, 
-																		 (GtkJustification)
-																		 atoi (fmt["justification"].c_str()));
-								}
-	      
-								cell->set_value (cell, packet[4]);
-
-								gdk_threads_enter();
-								
-								sheet->apply_cell (sheet, cell);
-
-								gdk_threads_leave();
-								
-								if (this->verbosity > 0) {
-									g_message ("Cell (%d,%d) updated", 
-												  cell->row, cell->column);
-								}
-							}
-							break;
-						}
-		
-						fprintf (pktlog, "%s\n", buf.c_str());
-						fflush (pktlog);
-						Thread::sleep(5);
-					}
-				}
-				Thread::sleep (10);
-			}
-
-			return NULL;
-		}
+		void * run (void * null);
 	};
-
+	
 } // end of namespace
 
 #endif
diff --git a/src/realtime/PluginFactory.cpp b/src/realtime/PluginFactory.cpp
index fd41bca..36b103a 100644
--- a/src/realtime/PluginFactory.cpp
+++ b/src/realtime/PluginFactory.cpp
@@ -32,6 +32,8 @@ extern "C" {
 	 realtime::Realtime * lf = new realtime::Realtime (appstate, platform);
 	 GtkWidget * box = lf->BuildLayout();
 
+	 lf->Start();
+	 
 	 gtk_widget_show (box);
     return lf;
   }
diff --git a/src/realtime/Realtime.cpp b/src/realtime/Realtime.cpp
index 181c1ce..eab50df 100644
--- a/src/realtime/Realtime.cpp
+++ b/src/realtime/Realtime.cpp
@@ -3,6 +3,7 @@
 #include <gtkworkbook/workbook.h>
 #include <proactor/Proactor.hpp>
 #include <proactor/Event.hpp>
+#include <network/Tcp.hpp>
 #include "Realtime.hpp"
 
 using namespace realtime;
@@ -21,8 +22,6 @@ static void
 StreamOpenDialogCallback (GtkWidget * w, gpointer data) {
 	Realtime * rt = (Realtime *)data;
 	OpenStreamDialog * dialog = rt->streamdialog();
-	//Workbook * wb = rt->workbook();
-	//Sheet * sheet = wb->focus_sheet;
 
 	if (dialog->widget == NULL) {
 		dialog->rt = rt;
@@ -34,12 +33,22 @@ StreamOpenDialogCallback (GtkWidget * w, gpointer data) {
 																	 GTK_STOCK_CANCEL,
 																	 GTK_RESPONSE_CANCEL,
 																	 NULL);
-		GtkWidget * gtk_frame = gtk_frame_new ("Stream Options");
+		
+		GtkWidget * gtk_frame = gtk_frame_new ("Connection Options");
+		GtkWidget * hbox = gtk_hbox_new(FALSE, 0);
 		GtkWidget * box = GTK_DIALOG (dialog->widget)->vbox;
-		dialog->address_entry = gtk_entry_new_with_max_length (15);
+		dialog->host_entry = gtk_entry_new();
+		dialog->port_entry = gtk_entry_new();
 
-		gtk_container_add (GTK_CONTAINER (gtk_frame), dialog->address_entry);
-		gtk_box_pack_start (GTK_BOX (box), gtk_frame, TRUE, TRUE, 0);
+		gtk_entry_set_max_length (GTK_ENTRY (dialog->host_entry), 15);
+		gtk_entry_set_max_length (GTK_ENTRY (dialog->port_entry), 5);
+		gtk_entry_set_width_chars (GTK_ENTRY (dialog->host_entry), 15);
+		gtk_entry_set_width_chars (GTK_ENTRY (dialog->port_entry), 5);
+		
+		gtk_box_pack_start (GTK_BOX (hbox), dialog->host_entry, FALSE, FALSE, 0);
+		gtk_box_pack_end (GTK_BOX (hbox), dialog->port_entry, FALSE, FALSE, 0);
+		gtk_container_add (GTK_CONTAINER (gtk_frame), hbox);
+		gtk_box_pack_start (GTK_BOX (box), gtk_frame, FALSE, FALSE, 0);
 		
 		g_signal_connect (G_OBJECT (dialog->widget), "delete-event",
 								G_CALLBACK (gtk_widget_hide_on_delete), NULL);
@@ -48,19 +57,23 @@ StreamOpenDialogCallback (GtkWidget * w, gpointer data) {
 	gtk_widget_show_all ( dialog->widget );
 	
 	if (gtk_dialog_run (GTK_DIALOG (dialog->widget)) == GTK_RESPONSE_OK) {
-		const char * entry_value = gtk_entry_get_text (GTK_ENTRY (dialog->address_entry));
-		Sheet * sheet = rt->workbook()->add_new_sheet (rt->workbook(), entry_value, 100, 20);
-		
-		if (sheet == NULL) {
-			g_warning ("Failed adding a new sheet to [realtime] workbook");
+		const char * host_value = gtk_entry_get_text (GTK_ENTRY (dialog->host_entry));
+		const char * port_value = gtk_entry_get_text (GTK_ENTRY (dialog->port_entry));
+		Sheet * sheet = rt->workbook()->add_new_sheet (rt->workbook(), host_value, 100, 20);
+
+		if (IS_NULLSTR (host_value) || IS_NULLSTR (port_value)) {
+			g_warning ("One of requird values are empty");
+		}
+		else if (sheet == NULL) {
+			g_warning ("Cannot open connection to %s:%s because of failure to add sheet",
+						  host_value, port_value);
+		}
+		else if (rt->OpenTcpClient (sheet, host_value, atoi (port_value)) == false) {
+			// STUB: Popup an alertbox about failing to connect?
 		}
 		else {
-			if (rt->Openstream (sheet, "", 2000) == false) {
-				
-			}
-			else {
-
-			}
+			// STUB: Success. Do we want to do anything else here?
+			g_message ("Client connection opened on %s:%s on sheet %s", host_value, port_value, sheet->name);
 		}
 	}
 
@@ -69,9 +82,6 @@ StreamOpenDialogCallback (GtkWidget * w, gpointer data) {
 
 Realtime::Realtime (Application * appstate, Handle * platform)
 	: Plugin (appstate, platform) {
-	this->ncd = NULL;
-	this->wb = workbook_open (appstate->gtkwindow(), "realtime");
-
 	ConfigPair * logpath =
 		appstate->config()->get_pair (appstate->config(), "realtime", "log", "path");
 
@@ -86,109 +96,165 @@ Realtime::Realtime (Application * appstate, Handle * platform)
 	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
 		g_critical ("Failed opening file '%s' for packet logging", logname.c_str());
     }
+
+	this->wb = workbook_open (appstate->gtkwindow(), "realtime");
+	this->packet_parser = NULL;
+	this->tcp_server = NULL;
 }
 
 Realtime::~Realtime (void) {
-	if (this->ncd != NULL)
-		delete this->ncd;
+	// Iterate through the list of active connections, and begin closing them. This should also
+	// include deleting the pointers to all of the accepting threads. Eventually there should be
+	// a boost::shared_ptr here so that we don't have to do the dirty work.
+	ActiveThreads::iterator it = this->threads.begin();
+	while (it != this->threads.end()) {
+		network::TcpSocket * socket = ((*it).first);
+		concurrent::Thread * thread = ((*it).second);
+
+		it = this->threads.erase (it);
+				
+		if (socket) delete socket;
+		if (thread) {
+			thread->stop();
+			delete thread;
+		}
+	}
+
+	if (this->packet_parser) {
+		this->packet_parser->stop();
+		delete this->packet_parser;
+	}
+
+	if (this->tcp_server) {
+		this->tcp_server->stop();
+		delete this->tcp_server;
+	}
 	
-	FCLOSE (pktlog);
+	FCLOSE (this->pktlog);
 }
 
-/*
 bool
-Realtime::Openserver (Sheet * sheet, int port) {
-	this->lock();
-	
-	int eventId = -1;
-	if (this->npd == NULL) {
-		evenetId = proactor::Event::uniqueEventId();
-
-		this->npd = new network::NetworkPktReceiver (eventId, appstate->proactor());
-		if (this->npd->start() == false) {
-			g_critical ("Failed starting network packet receiver");
-			this->unlock();
-			return false;
-		}
-	}
-	else {
-		eventId = this->npd->getEventId();
+Realtime::CreateNewServerConnection (network::TcpServerSocket * socket, AcceptThread * accept_thread) {
+	this->threads.push_back ( ActiveThread (socket, accept_thread) );
+
+	if (this->tcp_server->addWorker (accept_thread) == false) {
+		g_critical ("Failed starting accepting thread on socket %d", socket->getPort() );
+		return false;
 	}
 
-	int port = atoi (servport->value);
-	this->server = new network::TcpServerSocket (port);
-	if (socket->start (5) == false) {
-		g_critical ("Failed starting server socket on port %d", port);
+	return true;
+}
+
+bool
+Realtime::CreateNewClientConnection (network::TcpClientSocket * socket, CsvParser * csv, NetworkDispatcher * nd) {
+	this->threads.push_back ( ActiveThread (socket, csv) );
+	this->threads.push_back ( ActiveThread (NULL, nd) );  // this is a hack
+
+	ConnectionThread * reader = new ConnectionThread (nd, socket);
+	if (nd->addWorker (reader) == false) {
+		g_critical ("Failed starting the client reader");
+		delete reader;
 		return false;
 	}
-	
-	this->unlock();
+
+	this->threads.push_back ( ActiveThread (NULL, reader) ); // this is a hack
 	return true;
 }
-*/
 
 bool
-Realtime::Openstream (Sheet * sheet, const std::string & address, int port) {
-	this->lock();
+Realtime::OpenTcpServer (int port) {
+	// Has to be above the service ports.
+	if (port < 1000) {
+		g_warning ("Failed starting Tcp server: port (%d) must be above 1000", port);
+		return false;
+	}
 
-	int eventId = -1;
-	if (this->ncd == NULL) {
-		eventId = proactor::Event::uniqueEventId();
+	// The first time we attempt to create a port to receive input on we need to create a dispatcher, and
+	// specify an event identifier so that we can communicate with it from workers. At this point the
+	// Packet Parser is created as well. 
+	if (this->tcp_server == NULL) {
+		int eventId = proactor::Event::uniqueEventId();
+		NetworkDispatcher * nd = new NetworkDispatcher (eventId, this->app()->proactor());
+		PacketParser * pp = new PacketParser (this->workbook(), this->pktlog, 0);
 		
-		this->ncd = new NetworkCsvReceiver (eventId, appstate->proactor());
-		if (this->ncd->start() == false) {
-			g_critical ("Failed starting network csv receiver");
-			this->unlock();
+		if (nd->start() == false) {
+			g_critical ("Failed starting network dispatcher for tcp server");
 			return false;
 		}
-	}
-	else {
-		eventId = this->ncd->getEventId();
-	}
 
-	network::TcpClientSocket * client = new network::TcpClientSocket;
-	if (client->connect (address.c_str(), port) == false) {
-		g_critical ("Failed connecting to client socket %s:%d", address.c_str(), port);
-		delete client;
-		this->unlock();
-		return false;
+		if (this->app()->proactor()->addWorker (eventId, pp) == false) {
+			g_critical ("Failed starting packet parser for tcp server");
+			return false;
+		}
+		
+		this->tcp_server = nd;
+		this->packet_parser = pp;
 	}
-	
-	ConnectionThread * reader = new ConnectionThread (this->ncd, client);
-	if (this->ncd->addWorker (reader) == false) {
-		g_critical ("Failed starting the client reader");
-		delete reader;
-		delete client;
-		this->unlock();
+
+	network::TcpServerSocket * socket = new network::TcpServerSocket (port);
+	if (socket->start(5) == false) {
+		g_critical ("Failed starting network socket for tcp server on port %d", port);
 		return false;
 	}
-	
-	this->unlock();
-	return true;
+
+	AcceptThread * accept_thread = new AcceptThread (socket->newAcceptor(), this->tcp_server);
+	return this->CreateNewServerConnection (socket, accept_thread);
 }
 
 bool
-Realtime::Start() {
-	Config * cfg = this->app()->config();
-	ConfigPair * servport = cfg->get_pair (cfg, "realtime", "tcp", "port");
-	ConfigPair * verbosity = cfg->get_pair (cfg, "realtime", "debug", "verbosity");
+Realtime::OpenTcpClient (Sheet * sheet, const std::string & address, int port) {
+	// Has to be above the service ports.
+	if (port < 1000) {
+		g_warning ("Failed starting Tcp client: port (%d) must be above 1000", port);
+		return false;
+	}
 
-	if (IS_NULL (servport)) {
-      g_critical ("Failed loading tcp->port from configuration file; "
-						"exiting thread");
-      return false;
+	// We need to create a network dispatcher for each one of these connections because of
+	// the current limitation of the Proactor design. It really needs to be rewritten, but
+	// that is a separate project in and of itself. For now a list of dispatchers must be
+	// kept so that we do not lose track.
+	int eventId = proactor::Event::uniqueEventId();
+	NetworkDispatcher * dispatcher = new NetworkDispatcher (eventId, this->app()->proactor());
+	if (dispatcher->start() == false) {
+		g_critical ("Failed starting network dispatcher for %s:%d", address.c_str(), port);
+		delete dispatcher;
+		return false;
 	}
 
-	if (IS_NULL (verbosity))
-		g_warning ("Failed loading debug->verbosity from configuration file.");
+	// Keeping this simple is the reason why we need multiple dispatchers. If I could come
+	// up with a simple way to strap on the ability to have multiple sheets without the need
+	// for an additioanl dispatcher/csv combo I would. It totally destroys the principle of
+	// the proactor design.
+	CsvParser * csv = new CsvParser (sheet, this->pktlog, 0, 20);
+	if (this->app()->proactor()->addWorker (eventId, csv) == false) {
+		g_critical ("Failed starting csv parser and adding to proactor for %s:%d",
+						address.c_str(), port);
+		delete csv;
+		delete dispatcher;
+		return false;
+	}
 
-	this->client = new network::TcpClientSocket;
-	if (this->client->connect ("localhost", 50000) == false) {
-		g_critical ("Failed connecting to %s:%d", "localhost", 50000);
+	network::TcpClientSocket * socket = new network::TcpClientSocket;
+	if (socket->connect (address.c_str(), port) == false) {
+		g_critical ("Failed making Tcp connection to %s:%d", address.c_str(), port);
+		delete socket;
+		delete csv;
+		delete dispatcher;
 		return false;
 	}
+	
+	return this->CreateNewClientConnection (socket, csv, dispatcher);
+}
 
-	return true;
+void
+Realtime::Start(void) {
+	Config * cfg = this->app()->config();
+	ConfigPair * servport = cfg->get_pair (cfg, "realtime", "tcp", "port");
+	int port = atoi (servport->value);
+
+	if (this->OpenTcpServer (port) == true) {
+		g_message ("Opened Tcp server on port %d", port);
+	}
 }
 
 GtkWidget *
diff --git a/src/realtime/Realtime.hpp b/src/realtime/Realtime.hpp
index 9271c2e..1832e69 100644
--- a/src/realtime/Realtime.hpp
+++ b/src/realtime/Realtime.hpp
@@ -3,21 +3,29 @@
 
 #include <map>
 #include <string>
+#include <vector>
+#include <memory>
+#include <concurrent/Thread.hpp>
 #include "../Plugin.hpp"
 #include "../Application.hpp"
 #include "../config.h"
 #include "OpenStreamDialog.hpp"
 #include "Network.hpp"
+#include "PacketParser.hpp"
+#include "CsvParser.hpp"
 
 namespace realtime {
 
 	class Realtime : public Plugin {
 	private:
+		typedef std::pair <network::TcpSocket *, concurrent::Thread *> ActiveThread;
+		typedef std::vector <ActiveThread> ActiveThreads;
+			
+		ActiveThreads threads;
 		OpenStreamDialog stream_dialog;
 		FILE * pktlog;
-		NetworkCsvReceiver * ncd;
-		NetworkPktReceiver * npd;
-		network::TcpClientSocket * client;
+		NetworkDispatcher * tcp_server;
+		PacketParser * packet_parser;
 		
 		GtkWidget * CreateMainMenu (void);
 	public:
@@ -26,8 +34,11 @@ namespace realtime {
 
 		GtkWidget * BuildLayout (void);
 
-		bool Openstream (Sheet * sheet, const std::string & address, int port);
-		bool Start (void);
+		bool CreateNewServerConnection (network::TcpServerSocket * socket, AcceptThread * accept_thread);
+		bool CreateNewClientConnection (network::TcpClientSocket * socket, CsvParser * csv, NetworkDispatcher * nd);
+		bool OpenTcpServer (int port);
+		bool OpenTcpClient (Sheet * sheet, const std::string & address, int port);
+		void Start (void);
 		
 		inline OpenStreamDialog * streamdialog() { return &this->stream_dialog; }
 	};
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
deleted file mode 100755
index 6c1befd..0000000
--- a/src/realtime/thread_main.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <gtkworkbook/workbook.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <cstdlib>
-#include <signal.h>
-#include <iostream>
-#include <sstream>
-#include <string>
-#include <concurrent/Thread.hpp>
-#include <concurrent/ThreadArgs.hpp>
-#include <proactor/Proactor.hpp>
-#include <proactor/Event.hpp>
-#include "Network.hpp"
-#include "CsvParser.hpp"
-#include "PacketParser.hpp"
-#include "Packet.hpp"
-#include "../config.h"
-
-using namespace realtime;
-
-/* @description: This method creates a filename with the prefix supplied and
-   uses the pid of the process as its suffix. 
-   @pre: The prefix (should be a file path, obviously). */
-static std::string
-append_pidname (const gchar * pre) {
-  std::stringstream s;
-  s << pre << getppid();
-  return s.str();
-}
-
-/* @description: This is the main execution function for the thread.
-   @wb: The Workbook that the thread will be changing. */
-void
-thread_main (ThreadArgs * args) {
-  Workbook * wb = (Workbook *)args->at(0);
-  Config * cfg  = (Config *)args->at(1);
-  gboolean * SHUTDOWN = (gboolean *)args->at(2);
-
-  ConfigPair * logpath = cfg->get_pair (cfg, "realtime", "log", "path");
-  if (IS_NULL (logpath)) {
-      g_critical ("Failed loading log->path from configuration file; "
-		  "exiting thread");
-      return;
-    }
-
-  ConfigPair * servport = cfg->get_pair (cfg, "realtime", "tcp", "port");
-  if (IS_NULL (servport)) {
-      g_critical ("Failed loading tcp->port from configuration file; "
-		  "exiting thread");
-      return;
-    }
-
-  ConfigPair * verbosity = cfg->get_pair (cfg, 
-					  "realtime", "debug", "verbosity");
-  if (IS_NULL (verbosity))
-    g_warning ("Failed loading debug->verbosity from configuration file.");
-  
-  FILE * pktlog = NULL;
-  std::string logname = std::string (logpath->value).append("/");
-  logname.append (append_pidname("realtime.").append(".log"));
-
-  if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
-      g_critical ("Failed opening file '%s' for packet logging; exiting"
-		  " thread", logname.c_str());
-      return;
-    }
-
-  /* Start up the Tcp Socket server on the port specified inside of the
-     configuration file. This IS NOT a separate thread. */
-  int port = atoi(servport->value);
-  network::TcpServerSocket socket ( port );
-  if (socket.start(5) == false) {
-      g_critical ("Failed starting TcpServerSocket on port localhost:%d;"
-		  " exiting thread", port);
-      return;
-    }
-
-  network::TcpClientSocket * client = new network::TcpClientSocket;
-  if (client->connect ("localhost", 50000) == false) {
-      g_critical ("Failed connecting to TcpClientSocket");
-      return;
-    }
-  
-  // Get a unique event identifier that will be used throughout.
-  int csvEventID = proactor::Event::uniqueEventId();
-  int pktEventID = proactor::Event::uniqueEventId();
-  
-  proactor::Proactor proactor;
-  NetworkCsvReceiver csvDispatcher (csvEventID, &proactor);
-  NetworkPktReceiver pktDispatcher (pktEventID, &proactor);
-  AcceptThread acceptor (socket.newAcceptor(), &pktDispatcher);
-  ConnectionThread creader (&csvDispatcher, client);
-  PacketParser pkt_worker (wb, pktlog, atoi(verbosity->value));
-  CsvParser csv_worker (wb->sheet_first, pktlog, atoi(verbosity->value));
-
-  if (proactor.start() == false) {
-      g_critical ("Failed starting Proactor; exiting thread.");
-      return;
-    }
-
-  if (proactor.addWorker (pktEventID, &pkt_worker) == false) {
-    g_critical ("Failed starting packet parser worker; exiting thread.");
-    return;
-  }
-
-  if (proactor.addWorker (csvEventID, &csv_worker) == false) {
-    g_critical ("Failed starting csv parser worker; exiting thread.");
-    return;
-  }
-  
-  if (pktDispatcher.start() == false) {
-      g_critical ("Failed starting network; exiting thread.");
-      return;
-    }
-
-  if (pktDispatcher.addWorker (&acceptor) == false) {
-    g_critical ("Failed starting acceptor; exiting thread.");
-    return;
-  }
-  
-  if (csvDispatcher.start() == false) {
-      g_critical ("Failed starting network; exiting thread.");
-      return;
-    }
-  
-  if (csvDispatcher.addWorker (&creader) == false) {
-    g_critical ("Failed starting client reader; exiting thread.");
-    return;
-  }
-
-  while (*SHUTDOWN == FALSE) {
-    // Continually sleep basically until our application terminates.
-    concurrent::Thread::sleep (100);
-  }
-
-  csv_worker.stop();
-  pkt_worker.stop();
-  creader.interrupt();
-  acceptor.interrupt();
-  socket.close();  
-
-  FCLOSE (pktlog);
-  delete args;
-}

commit b9249d384da7cc70c0215206aaf839bae6d8fe6b
Author: John Bellone <jvb4@njit.edu>
Date:   Tue Aug 4 15:38:58 2009 -0400

    (1) Added OpenStreamDialog object, and added to
    (2) Added callbacks for open stream dialog in realtime plugin.
    (3) Fixed dialog response and layout.

diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
index 8c59f48..00c400d 100755
--- a/src/realtime/Network.cpp
+++ b/src/realtime/Network.cpp
@@ -61,9 +61,7 @@ namespace realtime {
 	}
 
 	void *
-	NetworkCsvReceiver::run (void * null) {
-		
-		
+	NetworkPktReceiver::run (void * null) {
 		while (this->isRunning() == true) {
 			this->inputQueue.lock();
       
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
index 42bc48e..fd972e0 100755
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -30,21 +30,18 @@ namespace realtime {
 
 	class NetworkCsvReceiver : public proactor::InputDispatcher {
 	public:
-		NetworkCsvReceiver (int e, proactor::Proactor * pro) {
-			this->pro = pro;
-			setEventId(e);
-		}
-		virtual ~NetworkCsvReceiver (void) { }
+		NetworkCsvReceiver (int e, proactor::Proactor * pro);
+		virtual ~NetworkCsvReceiver (void);
+
+		void * run (void * null);
 	};
 
 	class NetworkPktReceiver : public proactor::InputDispatcher {
 	public:
-		NetworkPktReceiver (int e, proactor::Proactor * pro) {
-			this->pro = pro;
-			setEventId(e);
-		}
+		NetworkPktReceiver (int e, proactor::Proactor * pro);
+		virtual ~NetworkPktReceiver (void);
 
-		virtual ~NetworkPktReceiver (void) { }
+		void * run (void * null);
 	};
 
 	class ConnectionThread : public proactor::Worker {
diff --git a/src/realtime/OpenStreamDialog.hpp b/src/realtime/OpenStreamDialog.hpp
new file mode 100644
index 0000000..a060b24
--- /dev/null
+++ b/src/realtime/OpenStreamDialog.hpp
@@ -0,0 +1,23 @@
+#ifndef HPP_OPENSTREAMDIALOG
+#define HPP_OPENSTREAMDIALOG
+
+#include <gtk/gtk.h>
+
+namespace realtime {
+
+	class Realtime;
+
+	struct OpenStreamDialog {
+		OpenStreamDialog (void) {
+			rt = NULL;
+			widget = NULL;
+			address_entry = NULL;
+		}
+
+		Realtime * rt;
+		GtkWidget * widget;
+		GtkWidget * address_entry;
+	};
+}
+
+#endif
diff --git a/src/realtime/Realtime.cpp b/src/realtime/Realtime.cpp
index 5a23031..181c1ce 100644
--- a/src/realtime/Realtime.cpp
+++ b/src/realtime/Realtime.cpp
@@ -17,9 +17,58 @@ AppendProcessId (const gchar * pre) {
   return s.str();
 }
 
+static void
+StreamOpenDialogCallback (GtkWidget * w, gpointer data) {
+	Realtime * rt = (Realtime *)data;
+	OpenStreamDialog * dialog = rt->streamdialog();
+	//Workbook * wb = rt->workbook();
+	//Sheet * sheet = wb->focus_sheet;
+
+	if (dialog->widget == NULL) {
+		dialog->rt = rt;
+
+		dialog->widget = gtk_dialog_new_with_buttons ("Open stream ", GTK_WINDOW (rt->app()->gtkwindow()),
+																	 (GtkDialogFlags) (GTK_DIALOG_MODAL|GTK_DIALOG_NO_SEPARATOR),
+																	 GTK_STOCK_OK,
+																	 GTK_RESPONSE_OK,
+																	 GTK_STOCK_CANCEL,
+																	 GTK_RESPONSE_CANCEL,
+																	 NULL);
+		GtkWidget * gtk_frame = gtk_frame_new ("Stream Options");
+		GtkWidget * box = GTK_DIALOG (dialog->widget)->vbox;
+		dialog->address_entry = gtk_entry_new_with_max_length (15);
+
+		gtk_container_add (GTK_CONTAINER (gtk_frame), dialog->address_entry);
+		gtk_box_pack_start (GTK_BOX (box), gtk_frame, TRUE, TRUE, 0);
+		
+		g_signal_connect (G_OBJECT (dialog->widget), "delete-event",
+								G_CALLBACK (gtk_widget_hide_on_delete), NULL);
+	}
+
+	gtk_widget_show_all ( dialog->widget );
+	
+	if (gtk_dialog_run (GTK_DIALOG (dialog->widget)) == GTK_RESPONSE_OK) {
+		const char * entry_value = gtk_entry_get_text (GTK_ENTRY (dialog->address_entry));
+		Sheet * sheet = rt->workbook()->add_new_sheet (rt->workbook(), entry_value, 100, 20);
+		
+		if (sheet == NULL) {
+			g_warning ("Failed adding a new sheet to [realtime] workbook");
+		}
+		else {
+			if (rt->Openstream (sheet, "", 2000) == false) {
+				
+			}
+			else {
+
+			}
+		}
+	}
+
+	gtk_widget_hide_all ( dialog->widget );
+}
+
 Realtime::Realtime (Application * appstate, Handle * platform)
 	: Plugin (appstate, platform) {
-
 	this->ncd = NULL;
 	this->wb = workbook_open (appstate->gtkwindow(), "realtime");
 
@@ -46,6 +95,7 @@ Realtime::~Realtime (void) {
 	FCLOSE (pktlog);
 }
 
+/*
 bool
 Realtime::Openserver (Sheet * sheet, int port) {
 	this->lock();
@@ -65,11 +115,17 @@ Realtime::Openserver (Sheet * sheet, int port) {
 		eventId = this->npd->getEventId();
 	}
 
-	
+	int port = atoi (servport->value);
+	this->server = new network::TcpServerSocket (port);
+	if (socket->start (5) == false) {
+		g_critical ("Failed starting server socket on port %d", port);
+		return false;
+	}
 	
 	this->unlock();
 	return true;
 }
+*/
 
 bool
 Realtime::Openstream (Sheet * sheet, const std::string & address, int port) {
@@ -79,7 +135,7 @@ Realtime::Openstream (Sheet * sheet, const std::string & address, int port) {
 	if (this->ncd == NULL) {
 		eventId = proactor::Event::uniqueEventId();
 		
-		this->ncd = new network::NetworkCsvReceiver (eventId, appstate->proactor());
+		this->ncd = new NetworkCsvReceiver (eventId, appstate->proactor());
 		if (this->ncd->start() == false) {
 			g_critical ("Failed starting network csv receiver");
 			this->unlock();
@@ -98,12 +154,11 @@ Realtime::Openstream (Sheet * sheet, const std::string & address, int port) {
 		return false;
 	}
 	
-	ConnectionThread * reader = new network::ConnectionThread (this->ncd, client);
-	if (nd->addWorker (reader) == false) {
+	ConnectionThread * reader = new ConnectionThread (this->ncd, client);
+	if (this->ncd->addWorker (reader) == false) {
 		g_critical ("Failed starting the client reader");
 		delete reader;
 		delete client;
-		delete csv;
 		this->unlock();
 		return false;
 	}
@@ -114,39 +169,38 @@ Realtime::Openstream (Sheet * sheet, const std::string & address, int port) {
 
 bool
 Realtime::Start() {
-	Config * cfg = this->app()->cfg;
-	
+	Config * cfg = this->app()->config();
 	ConfigPair * servport = cfg->get_pair (cfg, "realtime", "tcp", "port");
 	ConfigPair * verbosity = cfg->get_pair (cfg, "realtime", "debug", "verbosity");
 
 	if (IS_NULL (servport)) {
       g_critical ("Failed loading tcp->port from configuration file; "
 						"exiting thread");
-      return;
+      return false;
 	}
 
 	if (IS_NULL (verbosity))
 		g_warning ("Failed loading debug->verbosity from configuration file.");
 
 	this->client = new network::TcpClientSocket;
-	if (client->connect ("localhost", 50000) == false) {
+	if (this->client->connect ("localhost", 50000) == false) {
 		g_critical ("Failed connecting to %s:%d", "localhost", 50000);
 		return false;
 	}
 
-	int port = atoi (servport->value);
-	this->server = new network::TcpServerSocket (port);
-	if (socket->start (5) == false) {
-		g_critical ("Failed starting server socket on port %d", port);
-		return false;
-	}
+	return true;
 }
 
 GtkWidget *
 Realtime::CreateMainMenu (void) {
 	GtkWidget * rtmenu = gtk_menu_new();
 	GtkWidget * rtmenu_item = gtk_menu_item_new_with_label ("Realtime");
+	GtkWidget * rtmenu_open = gtk_menu_item_new_with_label ("Open Csv stream...");
+	gtk_menu_shell_append (GTK_MENU_SHELL (rtmenu), rtmenu_open);
 
+	g_signal_connect (G_OBJECT (rtmenu_open), "activate",
+							G_CALLBACK (StreamOpenDialogCallback), this);
+		
 	gtk_menu_item_set_submenu (GTK_MENU_ITEM (rtmenu_item), rtmenu);
 	return rtmenu_item;
 }
diff --git a/src/realtime/Realtime.hpp b/src/realtime/Realtime.hpp
index b2ea84f..9271c2e 100644
--- a/src/realtime/Realtime.hpp
+++ b/src/realtime/Realtime.hpp
@@ -6,14 +6,18 @@
 #include "../Plugin.hpp"
 #include "../Application.hpp"
 #include "../config.h"
+#include "OpenStreamDialog.hpp"
+#include "Network.hpp"
 
 namespace realtime {
 
 	class Realtime : public Plugin {
 	private:
+		OpenStreamDialog stream_dialog;
 		FILE * pktlog;
-		network::NetworkCsvReceiver * ncd;
-		network::NetworkPktReceiver * npd;
+		NetworkCsvReceiver * ncd;
+		NetworkPktReceiver * npd;
+		network::TcpClientSocket * client;
 		
 		GtkWidget * CreateMainMenu (void);
 	public:
@@ -21,6 +25,11 @@ namespace realtime {
 		virtual ~Realtime (void);
 
 		GtkWidget * BuildLayout (void);
+
+		bool Openstream (Sheet * sheet, const std::string & address, int port);
+		bool Start (void);
+		
+		inline OpenStreamDialog * streamdialog() { return &this->stream_dialog; }
 	};
 }
 

commit 93523d6d85bf0e19fb0c713cd2c85b957d13909a
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 30 16:22:02 2009 -0400

    Moving realtime plugin closer to newer architecture.

diff --git a/bin/application.cfg b/bin/application.cfg
index 1cb1b40..5d21ff8 100755
--- a/bin/application.cfg
+++ b/bin/application.cfg
@@ -1,9 +1,9 @@
 %block application {
-	load :: extensions=largefile,realtime;
+	load :: extensions=realtime,largefile;
 }
 %block realtime
 {
-	onLoad :: run=0;
+	onLoad :: run=1;
 	linux :: filename=realtime.so;
 	log :: path=/home/johnb;
 	tcp :: port=8888;
diff --git a/shared/proactor/InputDispatcher.hpp b/shared/proactor/InputDispatcher.hpp
index 3129154..fc78fcb 100755
--- a/shared/proactor/InputDispatcher.hpp
+++ b/shared/proactor/InputDispatcher.hpp
@@ -45,10 +45,6 @@ namespace proactor {
 			this->inputQueue.push ( Event (getEventId(), std::string (buf) ) );
 		}
 
-		inline void onReadComplete (std::string buf) {
-			this->inputQueue.push ( Event (getEventId(), std::string (buf) ) );
-		}
-
 		void * run (void * null);
 	};
 
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index aac3de4..32d1fa4 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -216,6 +216,7 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	}
 	return result;
 }
+
 Largefile::Largefile (Application * appstate, Handle * platform)
 	: Plugin (appstate, platform) {
 
@@ -234,9 +235,7 @@ Largefile::Largefile (Application * appstate, Handle * platform)
 	logname.append (AppendProcessId("largefile.").append(".log"));
 	
 	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
-		g_critical ("Failed opening file '%s' for packet logging; exiting"
-					" thread", logname.c_str());
-		return;
+		g_critical ("Failed opening file '%s' for packet logging", logname.c_str());
     }
 	
 	gtk_signal_connect (GTK_OBJECT (this->wb->gtk_window), "key_press_event",
@@ -244,6 +243,7 @@ Largefile::Largefile (Application * appstate, Handle * platform)
 }
 
 Largefile::~Largefile (void) {
+	FCLOSE (pktlog);
 }
 
 GtkWidget *
diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
index 53a610a..08c994e 100755
--- a/src/realtime/CsvParser.cpp
+++ b/src/realtime/CsvParser.cpp
@@ -1,108 +1,157 @@
 /*
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "CsvParser.hpp"
 #include <gtkworkbook/sheet.h>
-#include <gtkworkbook/cell.h>
+#include <queue>
+#include <string>
 #include <iostream>
 
 namespace realtime {
 
-  struct csv_column {
-    Sheet * sheet;
-    Cell ** array;
-    int row;
-    int field;
-    char * value;
-  };
-
-  /* This structure is due to the libcsv parser; it uses function pointers to
-     do any work inside of an actual tuple. So the cb1 is called after a field
-     is parsed and cb2 is called after a tuple/row is parsed. */
-  static void 
-  cb1 (void * s, size_t length, void * data) {
-    struct csv_column * column = (struct csv_column *)data;
-    Cell * cell = column->array[column->field];
-
-    cell->set_row (cell, column->row);
-    cell->set_column (cell, column->field++);
-    cell->set_value_length (cell, s, length);
-  }
-
-  static void
-  cb2 (int c, void * data) {
-    struct csv_column * column = (struct csv_column *)data;
-    column->row++;
-    column->field = 0;
-  }
-
-  void *
-  CsvParser::run (void * null) {
-    this->running = true;
-    struct csv_parser csv;
-    struct csv_column column = {this->wb->sheet_first,
-				this->cell, 
-				0, 
-				0, 
-				new char[1024]};
-    
-    if (csv_init (&csv, CSV_STRICT) != 0) {
-      std::cerr << "Failed initializing libcsv parser\n";
-      return NULL;
-    }
-
-    while (this->running == true) {
-      while (this->inputQueue.size() > 0) {
-
-	if (this->running == false)
-	  break;
-
-	std::string buf = this->inputQueue.pop();
-	size_t bytes = buf.length();
- 
-	// Parse the CSV input
-	if ((bytes = csv_parse(&csv, 
-			       buf.c_str(), 
-			       bytes, 
-			       cb1,
-			       cb2,
-			       &column)) == bytes) {
-	  if (csv_error (&csv) == CSV_EPARSE)
-	    std::cerr << "Parsing error on input: " << buf << "\n";
+	struct csv_column {
+		Sheet * sheet;
+		Cell ** array;
+		int & array_max;
+		int & array_size;
+		int row;
+		int field;
+		char * value;
+	};
+
+	/* This structure is due to the libcsv parser; it uses function pointers to
+		do any work inside of an actual tuple. So the cb1 is called after a field
+		is parsed and cb2 is called after a tuple/row is parsed. */
+	static void 
+	cb1 (void * s, size_t length, void * data) {
+		struct csv_column * column = (struct csv_column *) data;
+		int & array_max = column->array_max;
+
+		// Resize the cell array here.
+		if (column->field >= array_max) {
+			int max = (2 * array_max);
+			(column->array) = (Cell **) g_realloc ((column->array),max*sizeof (Cell*));
+
+			for (int ii = array_max; ii < max; ii++)
+				(column->array)[ii] = NULL;
+		}
+	
+		if ((column->array)[column->field] == NULL)
+			(column->array)[column->field] = cell_new();
+
+		Cell * cell = (column->array)[column->field];
+		cell->set_row (cell, column->row);
+		cell->set_column (cell, column->field++);
+		cell->set_value_length (cell, s, length);
+	}
+  
+	static void
+	cb2 (int c, void * data) {
+		struct csv_column * column = (struct csv_column *)data;
+		column->row++;
+		column->array_size = column->field - 1;
+		column->field = 0;
 	}
 
-	csv_fini (&csv, cb1, cb2, &column);
-
-	this->wb->sheet_first->apply_array (this->wb->sheet_first,
-					    this->cell,
-					    10);
-
-	if (column.row >= (column.sheet)->max_rows)
-	  column.row = 0;
-      }
-
-      Thread::sleep(100);
+	CsvParser::CsvParser (Sheet * sheet,
+								 FILE * log,
+								 int verbosity,
+								 int maxOfFields)
+		: sheet(sheet), log (log), maxOfFields (maxOfFields) {
+		this->wb = sheet->workbook;
+		this->sizeOfFields = 0;
+		this->fields = (Cell **) g_malloc (maxOfFields*sizeof (Cell*));
+
+		for (int ii = 0; ii < this->maxOfFields; ii++)
+			this->fields[ii] = NULL;
+	}
 
-    }
+	CsvParser::~CsvParser (void) {
+		for (int ii = 0; ii < this->maxOfFields; ii++) {
+			if (this->fields[ii])
+				(this->fields[ii])->destroy (this->fields[ii]);
+		}
+    
+		g_free (this->fields);
+	}
 
-    csv_free (&csv);
-    delete column.value;
-    return NULL;
-  }
+	void *
+	CsvParser::run (void * null) {
+		std::queue<std::string> queue;
+		struct csv_parser csv;
+		struct csv_column column = {sheet,
+											 this->fields,
+											 this->maxOfFields,
+											 this->sizeOfFields,
+											 0,
+											 0,
+											 new char [1024]};
+    
+		if (csv_init (&csv, CSV_STRICT) != 0) {
+			std::cerr << "Failed initializing libcsv parser library\n";
+			return NULL;
+		}
+
+		while (this->isRunning() == true) {
+			if (this->inputQueue.size() > 0) {
+	
+				// Lock, copy, clear, unlock. - Free this up.
+				this->inputQueue.lock();
+				this->inputQueue.copy (queue);
+				this->inputQueue.clear();
+				this->inputQueue.unlock();
+
+				while (queue.size() > 0) {
+					std::string buf = queue.front(); queue.pop();
+					size_t bytes = buf.length();
+
+					if (this->isRunning() == false)
+						break;
+
+					if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
+						if (csv_error (&csv) == CSV_EPARSE) {
+							std::cerr << "Parsing error on input: "<<"\n";
+							continue;
+						}
+					}
+
+					csv_fini (&csv, cb1, cb2, &column);
+
+					gdk_threads_enter ();
+					
+					sheet->apply_row (sheet,
+											this->fields,
+											column.row - 1,
+											this->sizeOfFields);
+
+					gdk_threads_leave ();
+
+					if (column.row >= (column.sheet)->max_rows)
+						column.row = 0;
+
+					concurrent::Thread::sleep(5);
+				}
+				
+			}	
+			concurrent::Thread::sleep(5);
+		}
+
+		return NULL;
+	}
 
 } // end of namespace
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
index 77324ab..ec801a2 100755
--- a/src/realtime/CsvParser.hpp
+++ b/src/realtime/CsvParser.hpp
@@ -1,56 +1,46 @@
 /*
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
-#ifndef HPP_CSVPARSER
-#define HPP_CSVPARSER
+#ifndef HPP_RT_CSVPARSER
+#define HPP_RT_CSVPARSER
 
 #include <proactor/Worker.hpp>
 #include <gtkworkbook/workbook.h>
-#include <gtkworkbook/sheet.h>
-#include <gtkworkbook/cell.h>
+#include <concurrent/Thread.hpp>
 #include <libcsv/csv.h>
-#include <iostream>
 
 namespace realtime {
 
-  class CsvParser : public proactor::Worker {
-  private:
-    Workbook * wb;
-    FILE * pktlog;
-    Cell * cell[10];
-    int verbosity;
-  public:
-    CsvParser (Workbook * wb, FILE * pktlog, int verbosity) {
-      this->wb = wb;
-      this->pktlog = pktlog;
-      this->verbosity = verbosity;
-
-      for (unsigned int ii = 0; ii < 10; ii++)
-	this->cell[ii] = cell_new();
-    }
-
-    virtual ~CsvParser (void) {
-      for (unsigned int ii = 0; ii < 10; ii++)
-	this->cell[ii]->destroy (this->cell[ii]);
-    }
-
-    void * run (void * null);
-  };
+	class CsvParser : public proactor::Worker {
+	private:
+		Sheet * sheet;
+		Workbook * wb;
+		Cell ** fields;
+		FILE * log;
+		int verbosity;
+		int maxOfFields;
+		int sizeOfFields;
+	public:
+		CsvParser (Sheet * sheet, FILE * log, int verbosity, int maxOfFields = 10);
+		virtual ~CsvParser (void);
+
+		void * run (void * null);
+	};
 
 } // end of namespace
 
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
index 540a4ce..8c59f48 100755
--- a/src/realtime/Network.cpp
+++ b/src/realtime/Network.cpp
@@ -1,20 +1,20 @@
 /*
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "Network.hpp"
 #include <iostream>
@@ -23,98 +23,153 @@
 
 namespace realtime {
 
-  ConnectionThread::ConnectionThread (proactor::InputDispatcher * d, 
-				      int newfd) {
-    this->socket = new network::TcpClientSocket (newfd);
-    this->dispatcher = d;
-  }
-
-  ConnectionThread::ConnectionThread (proactor::InputDispatcher * d,
-				      network::TcpSocket * s) {
-    this->socket = s;
-    this->dispatcher = d;
-  }
-
-  ConnectionThread::~ConnectionThread (void) {
-    if (this->socket != NULL) {
-      this->socket->close();
-      delete this->socket;
-      this->socket = NULL;
-    }
-  }
-
-  void *
-  ConnectionThread::run (void * null) {
-    this->running = true;
-    int size = 0;
-    size_t pos = 0;
-    char * buf = new char[MAX_INPUT_SIZE];
-    std::string packet;
-
-    while (this->running == true) {
-      packet.clear();
-
-      while ((size = this->socket->receive (buf, MAX_INPUT_SIZE)) >= 0) {
-
-	if ((this->running == false) || (size == 0)) {
-	  this->running = false;
-	  break;
+	NetworkCsvReceiver::NetworkCsvReceiver (int e, proactor::Proactor * pro) {
+		this->pro = pro;
+		setEventId (e);
 	}
 
-	*(buf+size) = 0;
-	packet.append(buf);
+	NetworkCsvReceiver::~NetworkCsvReceiver (void) {
+	}
 
-	while ((pos = packet.find_first_of('\n')) != std::string::npos) {
-	  
-	  if (this->running == false)
-	    break;
+	void *
+	NetworkCsvReceiver::run (void * null) {
+		
+		while (this->isRunning() == true) {
+			this->inputQueue.lock();
+      
+			while (this->inputQueue.size() > 0) {
+				if (this->isRunning() == false)
+					break;
+
+				this->pro->onReadComplete (this->inputQueue.pop());
+			}
+
+			this->inputQueue.unlock();
 
-	  this->dispatcher->onReadComplete (packet.substr (0, pos));
-	  packet = packet.substr (pos+1, packet.length());
+			concurrent::Thread::sleep (5);
+		}
+
+		return NULL;
 	}
-      }
-
-      Thread::sleep (100);
-    }
-
-    this->dispatcher->removeWorker (this);
-    delete buf;
-    return NULL;
-  }
-
-  AcceptThread::AcceptThread (network::TcpServerSocket::Acceptor * acceptor,
-			      proactor::InputDispatcher * dispatcher) {
-    this->dispatcher = dispatcher;
-    this->acceptor = acceptor;
-  }
-
-  AcceptThread::~AcceptThread (void) {
-    delete this->acceptor;
-  }
-
-  void *
-  AcceptThread::run (void * null) {
-    this->running = true;
-    
-    while (this->running == true) {
-      int newfd = -1;
 	
-      if ((newfd = this->acceptor->acceptIncoming()) < 0) {
-	this->running = false;
-	break;
-      }
+	NetworkPktReceiver::NetworkPktReceiver (int e, proactor::Proactor * pro) {
+		this->pro = pro;
+		setEventId (e);
+	}
 
-      ConnectionThread * c = new ConnectionThread (this->dispatcher, newfd);
+	NetworkPktReceiver::~NetworkPktReceiver (void) {
+	}
+
+	void *
+	NetworkCsvReceiver::run (void * null) {
+		
+		
+		while (this->isRunning() == true) {
+			this->inputQueue.lock();
       
-      if (this->dispatcher->addWorker (c) == false) {
-	// Failed for some reason; cut out and quit for now.
-	break;
-      }
+			while (this->inputQueue.size() > 0) {
+				if (this->isRunning() == false)
+					break;
+
+				this->pro->onReadComplete (this->inputQueue.pop());
+			}
+
+			this->inputQueue.unlock();
+
+			concurrent::Thread::sleep(5);
+		}
+
+		return NULL;
+	}
 	
-      Thread::sleep (100);
-    }
+	ConnectionThread::ConnectionThread (proactor::InputDispatcher * d, 
+													int newfd) {
+		this->socket = new network::TcpClientSocket (newfd);
+		this->dispatcher = d;
+	}
+
+	ConnectionThread::ConnectionThread (proactor::InputDispatcher * d,
+													network::TcpSocket * s) {
+		this->socket = s;
+		this->dispatcher = d;
+	}
+
+	ConnectionThread::~ConnectionThread (void) {
+		if (this->socket != NULL) {
+			this->socket->close();
+			delete this->socket;
+			this->socket = NULL;
+		}
+	}
+
+	void *
+	ConnectionThread::run (void * null) {
+		int size = 0;
+		size_t pos = 0;
+		char * buf = new char[MAX_INPUT_SIZE];
+		std::string packet;
 
-    return NULL;
-  }
+		while (this->isRunning() == true) {
+			packet.clear();
+
+			while ((size = this->socket->receive (buf, MAX_INPUT_SIZE)) >= 0) {
+
+				if ((this->isRunning() == false) || (size == 0)) {
+					this->setRunning(false);
+					break;
+				}
+
+				*(buf+size) = 0;
+				packet.append(buf);
+
+				while ((pos = packet.find_first_of('\n')) != std::string::npos) {
+	  
+					if (this->isRunning() == false)
+						break;
+
+					std::string str = packet.substr (0, pos);
+					this->dispatcher->onReadComplete (str);
+					packet = packet.substr (pos+1, packet.length());
+				}
+			}
+
+			Thread::sleep (10);
+		}
+
+		this->dispatcher->removeWorker (this);
+		delete buf;
+		return NULL;
+	}
+
+	AcceptThread::AcceptThread (network::TcpServerSocket::Acceptor * acceptor,
+										 proactor::InputDispatcher * dispatcher) {
+		this->dispatcher = dispatcher;
+		this->acceptor = acceptor;
+	}
+
+	AcceptThread::~AcceptThread (void) {
+		delete this->acceptor;
+	}
+
+	void *
+	AcceptThread::run (void * null) {
+		while (this->isRunning() == true) {
+			int newfd = -1;
+	
+			if ((newfd = this->acceptor->acceptIncoming()) < 0) {
+				break;
+			}
+
+			ConnectionThread * c = new ConnectionThread (this->dispatcher, newfd);
+      
+			if (this->dispatcher->addWorker (c) == false) {
+				// Failed for some reason; cut out and quit for now.
+				break;
+			}
+	
+			Thread::sleep (10);
+		}
+		return NULL;
+	}
 
 } // end of namespace
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
index c72fa9a..42bc48e 100755
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -28,48 +28,47 @@
 
 namespace realtime {
 
-  class NetworkCsvReceiver : public proactor::InputDispatcher {
-  public:
-    NetworkCsvReceiver (int e, proactor::Proactor * pro) {
-      this->pro = pro;
-      setEventId(e);
-    }
+	class NetworkCsvReceiver : public proactor::InputDispatcher {
+	public:
+		NetworkCsvReceiver (int e, proactor::Proactor * pro) {
+			this->pro = pro;
+			setEventId(e);
+		}
+		virtual ~NetworkCsvReceiver (void) { }
+	};
 
-    virtual ~NetworkCsvReceiver (void) { }
-  };
+	class NetworkPktReceiver : public proactor::InputDispatcher {
+	public:
+		NetworkPktReceiver (int e, proactor::Proactor * pro) {
+			this->pro = pro;
+			setEventId(e);
+		}
 
-  class NetworkPktReceiver : public proactor::InputDispatcher {
-  public:
-    NetworkPktReceiver (int e, proactor::Proactor * pro) {
-      this->pro = pro;
-      setEventId(e);
-    }
+		virtual ~NetworkPktReceiver (void) { }
+	};
 
-    virtual ~NetworkPktReceiver (void) { }
-  };
-
-  class ConnectionThread : public proactor::Worker {
-  private:
-    bool purge_socket;
-    network::TcpSocket * socket;
-  public:
-    ConnectionThread (proactor::InputDispatcher * d, int newfd);
-    ConnectionThread (proactor::InputDispatcher * d, network::TcpSocket * s);
-    virtual ~ConnectionThread (void);
+	class ConnectionThread : public proactor::Worker {
+	private:
+		bool purge_socket;
+		network::TcpSocket * socket;
+	public:
+		ConnectionThread (proactor::InputDispatcher * d, int newfd);
+		ConnectionThread (proactor::InputDispatcher * d, network::TcpSocket * s);
+		virtual ~ConnectionThread (void);
   
-    void * run (void * null);
-  };
+		void * run (void * null);
+	};
 
-  class AcceptThread : public proactor::Worker {
-  private:
-    network::TcpServerSocket::Acceptor * acceptor;
-  public:
-    AcceptThread (network::TcpServerSocket::Acceptor * acceptor,
-		  proactor::InputDispatcher * dispatcher);
-    virtual ~AcceptThread (void);
+	class AcceptThread : public proactor::Worker {
+	private:
+		network::TcpServerSocket::Acceptor * acceptor;
+	public:
+		AcceptThread (network::TcpServerSocket::Acceptor * acceptor,
+						  proactor::InputDispatcher * dispatcher);
+		virtual ~AcceptThread (void);
 
-    void * run (void * null);
-  };
+		void * run (void * null);
+	};
 
 } // end of namespace
 
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index 9cf53c0..f622796 100755
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -30,231 +30,231 @@
 
 namespace realtime {
 
-  class PacketParser : public proactor::Worker {
-  private:
-    Workbook * wb;
-    FILE * pktlog;
-    Cell * cell;
-    int verbosity;
-  public:
-    PacketParser (Workbook * wb, FILE * pktlog, int verbosity = 0) { 
-      this->wb = wb;
-      this->pktlog = pktlog;
-      this->cell = cell_new();
-      this->verbosity = verbosity;
-    }
+	class PacketParser : public proactor::Worker {
+	private:
+		Workbook * wb;
+		FILE * pktlog;
+		Cell * cell;
+		int verbosity;
+	public:
+		PacketParser (Workbook * wb, FILE * pktlog, int verbosity = 0) { 
+			this->wb = wb;
+			this->pktlog = pktlog;
+			this->cell = cell_new();
+			this->verbosity = verbosity;
+		}
   
-    virtual ~PacketParser (void) {
-      this->cell->destroy (cell);
-    }
+		virtual ~PacketParser (void) {
+			this->cell->destroy (cell);
+		}
 
-    void * run (void * null) {
-      this->running = true;
-      std::queue<std::string> queue;
-      Packet packet;
-      const char * p = NULL;
+		void * run (void * null) {
+			std::queue<std::string> queue;
+			Packet packet;
+			const char * p = NULL;
 
-      while (this->running == true) {
-	if (this->inputQueue.size() > 0) {
+			while (this->isRunning() == true) {
+				if (this->inputQueue.size() > 0) {
 
-	  if (this->running == false)
-	    break;
-
-	  // Lock, copy, clear, unlock. - Free this up.
-	  this->inputQueue.lock();
-	  this->inputQueue.copy (queue);
-	  this->inputQueue.clear();
-	  this->inputQueue.unlock();
+					// Lock, copy, clear, unlock. - Free this up.
+					this->inputQueue.lock();
+					this->inputQueue.copy (queue);
+					this->inputQueue.clear();
+					this->inputQueue.unlock();
 	  
-	  while (queue.size() > 0) {
+					while (queue.size() > 0) {
 
-	    if (this->running == false)
-	      break;
+						if (this->isRunning() == false)
+							break;
 
-	    // Never understood why pop() doesn't return the element.
-	    std::string buf = queue.front(); queue.pop();
-	    p = buf.c_str();
+						// Never understood why pop() doesn't return the element.
+						std::string buf = queue.front(); queue.pop();
+						p = buf.c_str();
 
-	    if (packet.parse (p) == FALSE) {
-	      g_warning ("Failed parsing packet '%s'", buf.c_str());
-	      Thread::sleep (5);
-	      continue;
-	    }
+						if (packet.parse (p) == FALSE) {
+							g_warning ("Failed parsing packet '%s'", buf.c_str());
+							Thread::sleep (5);
+							continue;
+						}
 
-	    switch (packet.getType()) {
-	    default:
-	      g_warning ("Invaild packet line '%s'", buf.c_str());
-	      break;
-	      /* ^time^type^sheet_name^sheet_name^after */
-	    case Packet::TYPE_MOVESHEET: {
-	      if (packet.size() != 3) {
-		g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
-			   buf.c_str());
-		break;
-	      }
+						switch (packet.getType()) {
+							default:
+							g_warning ("Invaild packet line '%s'", buf.c_str());
+							break;
+							/* ^time^type^sheet_name^sheet_name^after */
+							case Packet::TYPE_MOVESHEET: {
+								if (packet.size() != 3) {
+									g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
+												  buf.c_str());
+									break;
+								}
 	      
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet)) {
-		g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
-			   packet[0],
-			   (strcmp(packet[2], "0") == 0) ? "after" : "before",
-			   packet[1]);
-		break;
-	      }
+								Sheet * sheet = wb->get_sheet (wb, packet[0]);
+								if (IS_NULL (sheet)) {
+									g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
+												  packet[0],
+												  (strcmp(packet[2], "0") == 0) ? "after" : "before",
+												  packet[1]);
+									break;
+								}
 
-	      if (wb->move_sheet (wb, sheet, packet[1], atoi (packet[2]))
-		  == FALSE) {
-		g_warning ("Failed moving sheet '%s'", packet[0]);
-		break;
-	      }
-	    }
-	      break;
-	      /* ^time^type^sheet_name^loadpath */
-	    case Packet::TYPE_LOADSHEET: {
-	      if (packet.size() != 2) {			  
-		g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
-			   buf.c_str());
-		break;
-	      }
+								if (wb->move_sheet (wb, sheet, packet[1], atoi (packet[2]))
+									 == FALSE) {
+									g_warning ("Failed moving sheet '%s'", packet[0]);
+									break;
+								}
+							}
+							break;
+							/* ^time^type^sheet_name^loadpath */
+							case Packet::TYPE_LOADSHEET: {
+								if (packet.size() != 2) {			  
+									g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
+												  buf.c_str());
+									break;
+								}
 
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet)) {
-		g_warning ("Unable to load geometry file; sheet '%s'"
-			   " does not exist", packet[0]);
-		break;
-	      }
+								Sheet * sheet = wb->get_sheet (wb, packet[0]);
+								if (IS_NULL (sheet)) {
+									g_warning ("Unable to load geometry file; sheet '%s'"
+												  " does not exist", packet[0]);
+									break;
+								}
 	      
-	      sheet->load (sheet, packet[1]);
-	    }
-	      break;
-	      /* ^time^type^sheet_name^savepath */
-	    case Packet::TYPE_SAVESHEET: {
-	      if (packet.size() != 2) {
-		g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
-			   buf.c_str());
-		break;
-	      }
+								sheet->load (sheet, packet[1]);
+							}
+							break;
+							/* ^time^type^sheet_name^savepath */
+							case Packet::TYPE_SAVESHEET: {
+								if (packet.size() != 2) {
+									g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
+												  buf.c_str());
+									break;
+								}
 		      
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet)) {
-		g_warning ("Failed saving sheet '%s'; does not exist",
-			   packet[0]);
-		break;
-	      }
+								Sheet * sheet = wb->get_sheet (wb, packet[0]);
+								if (IS_NULL (sheet)) {
+									g_warning ("Failed saving sheet '%s'; does not exist",
+												  packet[0]);
+									break;
+								}
 	      
-	      if (sheet->save (sheet, packet[1]) == FALSE) {
-		g_warning ("Unable to save sheet.");
-		break;
-	      }
-	    }
-	      break;
-	      /* ^time^type^sheet_name^position */
-	    case Packet::TYPE_MOVESHEETINDEX: {
-	      if (packet.size() != 2) {
-		g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
-			   "format: %s", buf.c_str());
-		break;
-	      }
+								if (sheet->save (sheet, packet[1]) == FALSE) {
+									g_warning ("Unable to save sheet.");
+									break;
+								}
+							}
+							break;
+							/* ^time^type^sheet_name^position */
+							case Packet::TYPE_MOVESHEETINDEX: {
+								if (packet.size() != 2) {
+									g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
+												  "format: %s", buf.c_str());
+									break;
+								}
 
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet)) {
-		g_warning ("Failed moving sheet '%s' to %d:"
-			   " Does not exist", packet[0], atoi(packet[1]));
-		break;
-	      }
+								Sheet * sheet = wb->get_sheet (wb, packet[0]);
+								if (IS_NULL (sheet)) {
+									g_warning ("Failed moving sheet '%s' to %d:"
+												  " Does not exist", packet[0], atoi(packet[1]));
+									break;
+								}
 		      
-	      if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) == FALSE) {
-		g_warning ("Failed moving sheet '%s' to %d:"
-			   " Invaild index\n", packet[0], atoi(packet[1]));
-	      }
-	    }
-	      break;
-	      /* ^time^type^sheet_name */
-	    case Packet::TYPE_REMSHEET: {
-	      if (packet.size() != 1) {
-		g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
-			   buf.c_str());
-		break;
-	      }
+								if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) == FALSE) {
+									g_warning ("Failed moving sheet '%s' to %d:"
+												  " Invaild index\n", packet[0], atoi(packet[1]));
+								}
+							}
+							break;
+							/* ^time^type^sheet_name */
+							case Packet::TYPE_REMSHEET: {
+								if (packet.size() != 1) {
+									g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
+												  buf.c_str());
+									break;
+								}
 		      
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet)) {
-		g_warning ("Failed removing sheet '%s':"
-			   " Does not exist", packet[0]);
-		break;
-	      }
-	      wb->remove_sheet (wb, sheet);
-	      sheet->destroy (sheet);
-	    }
-	      break;
-	      /* ^time^type^sheet_name^max_row^max_column */
-	    case Packet::TYPE_ADDSHEET: {
-	      if (packet.size() != 3) {
-		g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
-			   buf.c_str());
-		break;
-	      }
+								Sheet * sheet = wb->get_sheet (wb, packet[0]);
+								if (IS_NULL (sheet)) {
+									g_warning ("Failed removing sheet '%s':"
+												  " Does not exist", packet[0]);
+									break;
+								}
+								wb->remove_sheet (wb, sheet);
+								sheet->destroy (sheet);
+							}
+							break;
+							/* ^time^type^sheet_name^max_row^max_column */
+							case Packet::TYPE_ADDSHEET: {
+								if (packet.size() != 3) {
+									g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
+												  buf.c_str());
+									break;
+								}
 		      
-	      wb->add_new_sheet (wb, 
-				 packet[0],
-				 atoi (packet[1]),
-				 atoi (packet[2]));
-	    }
-	      break;
-	      /* ^time^type^sheet_name^row^column^format^data */
-	    case Packet::TYPE_UPDATECELL: {
-	      if (packet.size() != 5) {
-		g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
-			   "format: %s", buf.c_str());
-		break;
-	      }
+								wb->add_new_sheet (wb, 
+														 packet[0],
+														 atoi (packet[1]),
+														 atoi (packet[2]));
+							}
+							break;
+							/* ^time^type^sheet_name^row^column^format^data */
+							case Packet::TYPE_UPDATECELL: {
+								if (packet.size() != 5) {
+									g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
+												  "format: %s", buf.c_str());
+									break;
+								}
 		      
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet)) {
-		g_warning ("Invaild sheet name '%s': Does not exist",
-			   packet[0]);
-		break;
-	      }
+								Sheet * sheet = wb->get_sheet (wb, packet[0]);
+								if (IS_NULL (sheet)) {
+									g_warning ("Invaild sheet name '%s': Does not exist",
+												  packet[0]);
+									break;
+								}
 	            
-	      cell->set_row (cell, atoi (packet[1]) );
-	      cell->set_column (cell, atoi (packet[2]) );
+								cell->set_row (cell, atoi (packet[1]) );
+								cell->set_column (cell, atoi (packet[2]) );
 	      
-	      if (strlen (packet[3]) > 0) {
-		Map<String,String> fmt = packet.parseFormatString (packet[3]);
+								if (strlen (packet[3]) > 0) {
+									Map<String,String> fmt = packet.parseFormatString (packet[3]);
 		
-		if (fmt["bgcolor"].length() > 0)
-		  cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
-		if (fmt["fgcolor"].length() > 0)
-		  cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
-		if (fmt["justification"].length() > 0)
-		  cell->set_justification (cell, 
-					   (GtkJustification)
-					   atoi (fmt["justification"].c_str()));
-	      }
-	      
-	      cell->set_value (cell, packet[4]);
+									if (fmt["bgcolor"].length() > 0)
+										cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
+									if (fmt["fgcolor"].length() > 0)
+										cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
+									if (fmt["justification"].length() > 0)
+										cell->set_justification (cell, 
+																		 (GtkJustification)
+																		 atoi (fmt["justification"].c_str()));
+								}
 	      
-	      sheet->apply_cell (sheet, cell);
-		      
-	      if (this->verbosity > 0) {
-		g_message ("Cell (%d,%d) updated", 
-			   cell->row, cell->column);
-	      }
-	    }
-	      break;
-	    }
+								cell->set_value (cell, packet[4]);
+
+								gdk_threads_enter();
+								
+								sheet->apply_cell (sheet, cell);
+
+								gdk_threads_leave();
+								
+								if (this->verbosity > 0) {
+									g_message ("Cell (%d,%d) updated", 
+												  cell->row, cell->column);
+								}
+							}
+							break;
+						}
 		
-	    fprintf (pktlog, "%s\n", buf.c_str());
-	    fflush (pktlog);
-	    Thread::sleep(5);
-	  }
-	}
-	Thread::sleep (100);
-      }
+						fprintf (pktlog, "%s\n", buf.c_str());
+						fflush (pktlog);
+						Thread::sleep(5);
+					}
+				}
+				Thread::sleep (10);
+			}
 
-      return NULL;
-    }
-  };
+			return NULL;
+		}
+	};
 
 } // end of namespace
 
diff --git a/src/realtime/PluginFactory.cpp b/src/realtime/PluginFactory.cpp
new file mode 100644
index 0000000..fd41bca
--- /dev/null
+++ b/src/realtime/PluginFactory.cpp
@@ -0,0 +1,38 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <iostream>
+#include <gtkworkbook/workbook.h>
+#include <concurrent/ThreadArgs.hpp>
+#include <gtk/gtk.h>
+#include "Realtime.hpp"
+#include "../config.h"
+#include "../Application.hpp"
+
+extern "C" {
+  Plugin *
+  PluginFactoryCreate (Application * appstate, Handle * platform) {
+    ASSERT (appstate != NULL);
+    ASSERT (platform != NULL);
+	 realtime::Realtime * lf = new realtime::Realtime (appstate, platform);
+	 GtkWidget * box = lf->BuildLayout();
+
+	 gtk_widget_show (box);
+    return lf;
+  }
+} 
diff --git a/src/realtime/Realtime.cpp b/src/realtime/Realtime.cpp
new file mode 100644
index 0000000..5a23031
--- /dev/null
+++ b/src/realtime/Realtime.cpp
@@ -0,0 +1,171 @@
+#include <sstream>
+#include <gdk/gdkkeysyms.h>
+#include <gtkworkbook/workbook.h>
+#include <proactor/Proactor.hpp>
+#include <proactor/Event.hpp>
+#include "Realtime.hpp"
+
+using namespace realtime;
+
+/* @description: This method creates a filename with the prefix supplied and
+   uses the pid of the process as its suffix. 
+   @pre: The prefix (should be a file path, obviously). */
+static std::string
+AppendProcessId (const gchar * pre) {
+  std::stringstream s;
+  s << pre << getppid();
+  return s.str();
+}
+
+Realtime::Realtime (Application * appstate, Handle * platform)
+	: Plugin (appstate, platform) {
+
+	this->ncd = NULL;
+	this->wb = workbook_open (appstate->gtkwindow(), "realtime");
+
+	ConfigPair * logpath =
+		appstate->config()->get_pair (appstate->config(), "realtime", "log", "path");
+
+	if (IS_NULL (logpath)) {
+		g_critical ("Failed loading log->path from configuration file. Exiting application.");
+		exit(1);
+	}
+
+	std::string logname = std::string (logpath->value).append("/");
+	logname.append (AppendProcessId("realtime.").append(".log"));
+	
+	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
+		g_critical ("Failed opening file '%s' for packet logging", logname.c_str());
+    }
+}
+
+Realtime::~Realtime (void) {
+	if (this->ncd != NULL)
+		delete this->ncd;
+	
+	FCLOSE (pktlog);
+}
+
+bool
+Realtime::Openserver (Sheet * sheet, int port) {
+	this->lock();
+	
+	int eventId = -1;
+	if (this->npd == NULL) {
+		evenetId = proactor::Event::uniqueEventId();
+
+		this->npd = new network::NetworkPktReceiver (eventId, appstate->proactor());
+		if (this->npd->start() == false) {
+			g_critical ("Failed starting network packet receiver");
+			this->unlock();
+			return false;
+		}
+	}
+	else {
+		eventId = this->npd->getEventId();
+	}
+
+	
+	
+	this->unlock();
+	return true;
+}
+
+bool
+Realtime::Openstream (Sheet * sheet, const std::string & address, int port) {
+	this->lock();
+
+	int eventId = -1;
+	if (this->ncd == NULL) {
+		eventId = proactor::Event::uniqueEventId();
+		
+		this->ncd = new network::NetworkCsvReceiver (eventId, appstate->proactor());
+		if (this->ncd->start() == false) {
+			g_critical ("Failed starting network csv receiver");
+			this->unlock();
+			return false;
+		}
+	}
+	else {
+		eventId = this->ncd->getEventId();
+	}
+
+	network::TcpClientSocket * client = new network::TcpClientSocket;
+	if (client->connect (address.c_str(), port) == false) {
+		g_critical ("Failed connecting to client socket %s:%d", address.c_str(), port);
+		delete client;
+		this->unlock();
+		return false;
+	}
+	
+	ConnectionThread * reader = new network::ConnectionThread (this->ncd, client);
+	if (nd->addWorker (reader) == false) {
+		g_critical ("Failed starting the client reader");
+		delete reader;
+		delete client;
+		delete csv;
+		this->unlock();
+		return false;
+	}
+	
+	this->unlock();
+	return true;
+}
+
+bool
+Realtime::Start() {
+	Config * cfg = this->app()->cfg;
+	
+	ConfigPair * servport = cfg->get_pair (cfg, "realtime", "tcp", "port");
+	ConfigPair * verbosity = cfg->get_pair (cfg, "realtime", "debug", "verbosity");
+
+	if (IS_NULL (servport)) {
+      g_critical ("Failed loading tcp->port from configuration file; "
+						"exiting thread");
+      return;
+	}
+
+	if (IS_NULL (verbosity))
+		g_warning ("Failed loading debug->verbosity from configuration file.");
+
+	this->client = new network::TcpClientSocket;
+	if (client->connect ("localhost", 50000) == false) {
+		g_critical ("Failed connecting to %s:%d", "localhost", 50000);
+		return false;
+	}
+
+	int port = atoi (servport->value);
+	this->server = new network::TcpServerSocket (port);
+	if (socket->start (5) == false) {
+		g_critical ("Failed starting server socket on port %d", port);
+		return false;
+	}
+}
+
+GtkWidget *
+Realtime::CreateMainMenu (void) {
+	GtkWidget * rtmenu = gtk_menu_new();
+	GtkWidget * rtmenu_item = gtk_menu_item_new_with_label ("Realtime");
+
+	gtk_menu_item_set_submenu (GTK_MENU_ITEM (rtmenu_item), rtmenu);
+	return rtmenu_item;
+}
+
+GtkWidget *
+Realtime::BuildLayout (void) {
+	GtkWidget * gtk_menu = this->app()->gtkmenu();
+	GtkWidget * box = gtk_vbox_new (FALSE, 0);
+	GtkWidget * realtime_menu = this->CreateMainMenu();
+
+	// Append to the existing menu structure from the application.
+	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), realtime_menu);
+
+	// Setup the workbook.
+	wb->signals[SIG_WORKBOOK_CHANGED] = this->app()->signals[Application::SHEET_CHANGED];
+	wb->gtk_box = box;
+
+	// Pack all of the objects into a vertical box, and then pack that box into the application.
+	gtk_box_pack_start (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
+	gtk_box_pack_start (GTK_BOX (this->app()->gtkvbox()), box, FALSE, FALSE, 0);
+	return box;
+}
diff --git a/src/realtime/Realtime.hpp b/src/realtime/Realtime.hpp
new file mode 100644
index 0000000..b2ea84f
--- /dev/null
+++ b/src/realtime/Realtime.hpp
@@ -0,0 +1,27 @@
+#ifndef HPP_REALTIME
+#define HPP_REALTIME
+
+#include <map>
+#include <string>
+#include "../Plugin.hpp"
+#include "../Application.hpp"
+#include "../config.h"
+
+namespace realtime {
+
+	class Realtime : public Plugin {
+	private:
+		FILE * pktlog;
+		network::NetworkCsvReceiver * ncd;
+		network::NetworkPktReceiver * npd;
+		
+		GtkWidget * CreateMainMenu (void);
+	public:
+		Realtime (Application * appstate, Handle * platform);
+		virtual ~Realtime (void);
+
+		GtkWidget * BuildLayout (void);
+	};
+}
+
+#endif
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
deleted file mode 100755
index 956fa38..0000000
--- a/src/realtime/plugin_main.cpp
+++ /dev/null
@@ -1,70 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <iostream>
-#include <glib/gthread.h>
-#include <gtkworkbook/workbook.h>
-#include <concurrent/ThreadArgs.hpp>
-#include "../config.h"
-#include "../Application.hpp"
-#include "../Plugin.hpp"
-
-/* Prototypes */
-extern void thread_main (ThreadArgs *);
-
-extern "C"
-{
-  Workbook *
-  plugin_main (Application * app) {
-    ASSERT (app != NULL);
-    ASSERT (plugin != NULL);
-
-    Workbook * wb = NULL;
-    GtkWidget * hbox = gtk_handle_box_new ();
-    
-    if ((wb = workbook_open (app->gtkwindow(), "realtime")) == NULL) {
-		 g_critical ("Failed opening workbook; exiting plugin");
-		 return NULL;
-	 }
-
-    wb->signals[SIG_WORKBOOK_CHANGED] = app->signals[Application::SHEET_CHANGED];
-
-    gtk_container_add (GTK_CONTAINER (hbox), wb->gtk_notebook);
- 
-    wb->gtk_box = hbox;
-    
-    wb->add_new_sheet (wb, "sheet0", 100, 11);
-
-    ThreadArgs args;
-    args.push_back( (void *)wb );
-    args.push_back( (void *)app );
-  
-    if (plugin->create_thread (plugin, 
-			       (GThreadFunc)thread_main,
-			       (gpointer)new ThreadArgs (args)
-			       ) == NULL)
-      {
-	g_critical ("Failed creating thread; exiting plugin");
-	return NULL;
-      }
-
-    gtk_box_pack_start (GTK_BOX (app->gtkvbox()), hbox, FALSE,FALSE, 0);
-    gtk_widget_show (hbox);
-    return wb;
-  }
-}
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index c3c4103..6c1befd 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -110,7 +110,7 @@ thread_main (ThreadArgs * args) {
   AcceptThread acceptor (socket.newAcceptor(), &pktDispatcher);
   ConnectionThread creader (&csvDispatcher, client);
   PacketParser pkt_worker (wb, pktlog, atoi(verbosity->value));
-  CsvParser csv_worker (wb, pktlog, atoi(verbosity->value));
+  CsvParser csv_worker (wb->sheet_first, pktlog, atoi(verbosity->value));
 
   if (proactor.start() == false) {
       g_critical ("Failed starting Proactor; exiting thread.");

commit 4607ccec188dc052ecaefcf512509570d41cdd13
Merge: 16c9a54... 5526349...
Author: John Bellone <jvb4@njit.edu>
Date:   Tue Jul 28 23:50:25 2009 -0400

    Merge branch 'largefile' of ssh://j_bellone,gtkworkbook@gtkworkbook.git.sourceforge.net/gitroot/gtkworkbook into largefile

commit 16c9a54d2666e7afe6f67d722f833445e3cfffbf
Author: John Bellone <jvb4@njit.edu>
Date:   Tue Jul 28 22:53:55 2009 -0400

    (1) Fixed an issue with spinlock causing the Indexer to never actually finish
    its indexing.
    (2) Fixed a problem with LineIndexer which caused lock not being released.
    (3) Value of LineReader should not be subtracted by one.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 9d3f49f..97387c6 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -248,11 +248,6 @@ namespace largefile {
 				byte_beg = cursor;
 				count++;
 			}
-
-			// Crude implementation of a spinlock. Wait while another thread is doing
-			// some reading before we begin indexing again.
-			while (this->marks->trylock() == false)
-				Thread::sleep(5);
 						
   			if (this->marks->get(index).byte == cursor++) {
 				this->marks->get(index).line = count;
@@ -260,17 +255,28 @@ namespace largefile {
 			
 				index++;
 
+				this->marks->unlock();
+				
 				if (index == LINE_INDEX_MAX) {
-					this->marks->unlock();
 					break;
 				}
+				else {
+					Thread::sleep(5);								  
+				}
+				
+				// Crude implementation of a spinlock. Wait while another thread is doing
+				// some reading before we begin indexing again.
+				while (this->marks->trylock() == false)
+					Thread::sleep(5);
 			}
 		}
 
+		this->marks->unlock();
+		
 		gettimeofday (&end, NULL);
 
 		double ms = ((((end.tv_sec-start.tv_sec) * 1000) + ((end.tv_usec-start.tv_usec)/1000.0)) + 0.5);
-		std::cout<<"index done (ms:"<<ms<<")!\n"<<std::flush;
+		std::cout<<"ready (ms:"<<ms<<")!\n"<<std::flush;
 		this->dispatcher->removeWorker (this);
 		this->Closefile();
 		return NULL;
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index acb9494..aac3de4 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -66,7 +66,7 @@ GotoDialogResponseCallback (GtkWidget * gtkdialog, gint response, gpointer data)
 				// absolute line
 				case 1: {
 					dialog->lf->Readline (dialog->lf->workbook()->focus_sheet,
-												 value - 1,
+												 value,
 												 1000);
 				}
 				break;
@@ -76,7 +76,7 @@ GotoDialogResponseCallback (GtkWidget * gtkdialog, gint response, gpointer data)
 					long long perc_value = (long long) (atof ( entry_value ) * 10);
 					
 					dialog->lf->Readpercent (dialog->lf->workbook()->focus_sheet,
-													 perc_value,
+													 perc_value * 100,
 													 1000);
 				}
 				break;

commit 55263492e93f35cfd0edbdf7806d73e465d779a0
Author: John Bellone <jvb4@njit.edu>
Date:   Tue Jul 28 22:53:55 2009 -0400

    Fixed an issue with spinlock causing the Indexer to never actually finish
    its indexing.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 9d3f49f..988b3cc 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -248,11 +248,6 @@ namespace largefile {
 				byte_beg = cursor;
 				count++;
 			}
-
-			// Crude implementation of a spinlock. Wait while another thread is doing
-			// some reading before we begin indexing again.
-			while (this->marks->trylock() == false)
-				Thread::sleep(5);
 						
   			if (this->marks->get(index).byte == cursor++) {
 				this->marks->get(index).line = count;
@@ -260,17 +255,26 @@ namespace largefile {
 			
 				index++;
 
+				this->marks->unlock();
+				
 				if (index == LINE_INDEX_MAX) {
-					this->marks->unlock();
 					break;
 				}
+				else {
+					Thread::sleep(5);								  
+				}
+				
+				// Crude implementation of a spinlock. Wait while another thread is doing
+				// some reading before we begin indexing again.
+				while (this->marks->trylock() == false)
+					Thread::sleep(5);
 			}
 		}
 
 		gettimeofday (&end, NULL);
 
 		double ms = ((((end.tv_sec-start.tv_sec) * 1000) + ((end.tv_usec-start.tv_usec)/1000.0)) + 0.5);
-		std::cout<<"index done (ms:"<<ms<<")!\n"<<std::flush;
+		std::cout<<"ready (ms:"<<ms<<")!\n"<<std::flush;
 		this->dispatcher->removeWorker (this);
 		this->Closefile();
 		return NULL;

commit 7237c53e04ffb09a80b7d6b06b94a9a21ab03988
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 24 15:46:37 2009 -0400

    (1) Linux can handle multiple file descriptors open at the same time
    while reading from the same file. So now each worker opens its own
    file descriptor, and there no longer needs to be a single one managed
    between them all.
    (2) The LineIndex object is now a RecursiveMutex.
    (3) Spinlocks were implemented inside of the main processing loops
    of the workers to manage the LineIndex object.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 5de90a5..9d3f49f 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -27,30 +27,27 @@
 namespace largefile {
 	
 	FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
-		this->fp = NULL;
 		this->pro = pro;
 		setEventId(e);
 	}
 
 	FileDispatcher::~FileDispatcher (void) {
-		if (this->fp != NULL)
-			this->Close ();
 	}
 
 	bool
 	FileDispatcher::Readline (off64_t start, off64_t N) {
-		if (start > this->marks[LINE_INDEX_MAX-1].byte) return false;
+		if (start > this->marks.get(LINE_INDEX_MAX-1).byte) return false;
 		
-		LineReader * reader = new LineReader (this, this->fp, this->marks, start, N);
+		LineReader * reader = new LineReader (this, this->filename, &this->marks, start, N);
 		this->addWorker (reader);
 		return true;
 	}
 
 	bool
 	FileDispatcher::Readoffset (off64_t offset, off64_t N) {
-		if (offset > this->marks[LINE_INDEX_MAX-1].byte) return false;
+		if (offset > this->marks.get(LINE_INDEX_MAX-1).byte) return false;
 		
-		OffsetReader * reader = new OffsetReader (this, this->fp, offset, N);
+		OffsetReader * reader = new OffsetReader (this, this->filename, offset, N);
 		this->addWorker (reader);
 		return true;
 	}
@@ -58,61 +55,54 @@ namespace largefile {
 	bool
 	FileDispatcher::Readpercent (guint percent, off64_t N) {
 		if (percent > 100) return false;
-		if (this->marks[percent * 10].byte == -1) return false;
+		if (this->marks.get(percent * 10).byte == -1) return false;
 
-		OffsetReader * reader = new OffsetReader (this, this->fp, this->marks[percent * 10].byte, N);
+		OffsetReader * reader = new OffsetReader (this, this->filename,
+																this->marks.get(percent * 10).byte,
+																N);
 		this->addWorker (reader);
 		return true;
 	}
 
 	void
 	FileDispatcher::Index (void) {
-		LineIndexer * indexer = new LineIndexer (this, this->fp, this->marks);
+		LineIndexer * indexer = new LineIndexer (this, this->filename, &this->marks);
 		this->addWorker (indexer);
 	}
 
 	bool
-	FileDispatcher::OpenFile (const std::string & filename) {
+	FileDispatcher::Openfile (const std::string & filename) {
 		if (filename.length() == 0)
 			return false;
-
-		if ((this->fp = fopen64 (filename.c_str(), "r")) == NULL) {
+		
+		FILE * fp = NULL;
+		if ((fp = fopen64 (filename.c_str(), "r")) == NULL) {
 			// stub: throw an error somewhere
 			return false;
 		}
 
 		// Take the relative byte position, e.g. .75 * byte_end, and we now have the a relative
 		// line at that byte position for indexing at a later point in time.
-		fseeko64 (this->fp, 0L, SEEK_END);
-		off64_t byte_end = ftello64 (this->fp);
+		fseeko64 (fp, 0L, SEEK_END);
+		off64_t byte_end = ftello64 (fp);
 
-		this->marks[0].byte = 0;
-		this->marks[0].line = 0;
+		this->marks.get(0).byte = 0;
+		this->marks.get(0).line = 0;
 		
 		// Compute fuzzy relative position, and set line to -1 for indexing.
 		for (int ii = 1; ii < LINE_INDEX_MAX; ii++) {
 			double N = ii, K = LINE_PRECISION;
-			this->marks[ii].byte = (off64_t)((N/K) * byte_end);
-			this->marks[ii].line = -1;
+			this->marks.get(ii).byte = (off64_t)((N/K) * byte_end);
+			this->marks.get(ii).line = -1;
 		}
 
-		fseeko64 (this->fp, 0L, SEEK_SET);
+		fseeko64 (fp, 0L, SEEK_SET);
+
+		fclose(fp);
 		
-		concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
 		this->filename = filename;
 		return true;
 	}
-
-	bool 
-	FileDispatcher::Close (void) {
-		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp);
-		if (this->fp == NULL)
-			return false;
-
-		fclose (this->fp); this->fp = NULL;
-		mutex.remove();
-		return true;
-	}
   
 	void *
 	FileDispatcher::run (void * data) {
@@ -137,11 +127,45 @@ namespace largefile {
 		return NULL;
 	}
 
+	FileIndex::FileIndex (void) {
+	}
+
+	FileIndex::~FileIndex (void) {
+	}
+	
+	FileWorker::FileWorker (const std::string & filename, FileIndex * marks)
+		: marks (marks), filename (filename) {
+		this->fp = NULL;
+	}
+
+	FileWorker::~FileWorker (void) {
+		this->Closefile();
+	}
+	
+	bool
+	FileWorker::Openfile (void) {
+		if (this->fp != NULL) return false;
+
+		if ((this->fp = fopen64 (this->filename.c_str(), "r")) == NULL) {
+			// stub: throw an error somewhere
+			return false;
+		}
+		return true;
+	}
+
+	bool
+	FileWorker::Closefile (void) {
+		if (this->fp == NULL) return false;
+
+		fclose (this->fp); this->fp = NULL;
+		return true;
+	}
+	
 	OffsetReader::OffsetReader (proactor::InputDispatcher * d,
-										 FILE * fp,
+										 const std::string & filename,
 										 off64_t offset,
-										 off64_t N) {
-		this->fp = fp;
+										 off64_t N)
+		: FileWorker (filename, NULL) {
 		this->startOffset = offset;
 		this->numberOfLinesToRead = N;
 		this->dispatcher = d;
@@ -154,8 +178,13 @@ namespace largefile {
 	OffsetReader::run (void * null) {
 		char buf[4096];
 		int ch;
+
+		if (FileWorker::Openfile () == false) {
+			// STUB: throw some kind of error here; we failed opening the file.
+			g_critical ("Failed opening file descriptor inside of OffsetReader.");
+			return NULL;
+		}
 		
-		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 		off64_t start = ftello64 (this->fp);
 		off64_t offset = 0;
 		off64_t read_max = this->numberOfLinesToRead;
@@ -180,15 +209,15 @@ namespace largefile {
 		fseeko64 (this->fp, start, SEEK_SET);
 		
 		this->dispatcher->removeWorker (this);
+		this->Closefile();
 		return NULL;
 	}
 		
 	LineIndexer::LineIndexer (proactor::InputDispatcher * d,
-									  FILE * fp,
-									  LineIndex * marks) {
-		this->fp = fp;
+									  const std::string & filename,
+									  FileIndex * marks)
+		: FileWorker (filename, marks) {
 		this->dispatcher = d;
-		this->marks = marks;
 	}
 
 	LineIndexer::~LineIndexer (void) {
@@ -199,10 +228,14 @@ namespace largefile {
 		int ch, index = 0;
 		off64_t cursor = 0, count = 0, byte_beg = 0;
 		struct timeval start, end;
-		
-		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, false);
 
-		std::cout<<"index start...";
+		if (FileWorker::Openfile() == false) {
+			// STUB: throw some kind of error here; we failed opening the file.
+			g_critical ("Failed opening file descriptor in line indexer");
+			return NULL;
+		}
+		
+		std::cout<<"index start..."<<std::flush;
 		
 		gettimeofday (&start, NULL);
 		
@@ -210,54 +243,48 @@ namespace largefile {
 		// going to get away from having to sequentially read this file in, but once we
 		// have line numbers we can jump throughout the file pretty quickly.
 		while ((ch = fgetc(this->fp)) != EOF) {
-
-			// Crude implementation of a spinlock. Wait while another thread is doing
-			// some reading before we begin indexing again.
-			while (mutex.trylock() == false)
-				Thread::sleep(5);
 						
 			if (ch=='\n') {
 				byte_beg = cursor;
 				count++;
 			}
 
-  			if (this->marks[index].byte == cursor++) {
+			// Crude implementation of a spinlock. Wait while another thread is doing
+			// some reading before we begin indexing again.
+			while (this->marks->trylock() == false)
+				Thread::sleep(5);
 						
-				this->marks[index].line = count;
-				this->marks[index].byte = byte_beg;
-				
+  			if (this->marks->get(index).byte == cursor++) {
+				this->marks->get(index).line = count;
+				this->marks->get(index).byte = byte_beg;
+			
 				index++;
 
-				if (index == LINE_INDEX_MAX)
+				if (index == LINE_INDEX_MAX) {
+					this->marks->unlock();
 					break;
-
-				// While the indexer is running we want to still allow for reads on the
-				// screen. This is an easy way to give them a "minor" priority. Once a
-				// percentage of the file has been index we're going to unlock and give
-				// a healthy amount of time for a thread switch to happen.
-				mutex.unlock();
-				Thread::sleep(10);
+				}
 			}
 		}
 
 		gettimeofday (&end, NULL);
 
 		double ms = ((((end.tv_sec-start.tv_sec) * 1000) + ((end.tv_usec-start.tv_usec)/1000.0)) + 0.5);
-		std::cout<<"index done (ms:"<<ms<<")!\n";
+		std::cout<<"index done (ms:"<<ms<<")!\n"<<std::flush;
 		this->dispatcher->removeWorker (this);
+		this->Closefile();
 		return NULL;
 	}
 
 	LineReader::LineReader (proactor::InputDispatcher * d,
-									FILE * fp,
-									LineIndex * marks,
+									const std::string & filename,
+									FileIndex * marks,
 									off64_t start,
-									off64_t N) {
-		this->fp = fp;
+									off64_t N)
+		: FileWorker (filename, marks) {
 		this->dispatcher = d;
 		this->startLine = start;
 		this->numberOfLinesToRead = N;
-		this->marks = marks;
 	}
 
 	LineReader::~LineReader (void) {
@@ -267,19 +294,31 @@ namespace largefile {
 	LineReader::run (void * null) {
 		char buf[4096];
 
-		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
+		if (FileWorker::Openfile () == false) {
+			// STUB: throw some kind of error here; we failed opening the file.
+			g_critical ("Failed opening file descriptor in LineReader");
+			return NULL;
+		}
+		
 		off64_t start = ftello64 (this->fp);
 		off64_t offset = 0, delta = 0;
 		off64_t read_max = this->numberOfLinesToRead, line_max = this->startLine + read_max;
 
 		for (off64_t index = 1; index < LINE_INDEX_MAX; index++) {
-			if (line_max < this->marks[index].line) {
-				delta = this->startLine - this->marks[index-1].line;
-				offset = this->marks[index-1].byte;
+			// Crude implementation of a spinlock. Wait while another thread is doing
+			// some reading before we begin indexing again.
+			while (this->marks->trylock() == false)
+				Thread::sleep(5);
+			
+			if (line_max < this->marks->get(index).line) {
+				delta = this->startLine - this->marks->get(index-1).line;
+				offset = this->marks->get(index-1).byte;
+				this->marks->unlock();
 				break;
 			}
+			this->marks->unlock();
 		}
-						
+		
 		fseeko64 (this->fp, offset, SEEK_SET);
 
 		// Munch lines to get to our starting point.
@@ -299,6 +338,7 @@ namespace largefile {
 		fseeko64 (this->fp, start, SEEK_SET);
 		
 		this->dispatcher->removeWorker (this);
+		this->Closefile();
 		return NULL;
 	}
 
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index f543c10..ac75eac 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -19,6 +19,7 @@
 #ifndef FILE_HPP
 #define FILE_HPP
 
+#include <concurrent/Mutex.hpp>
 #include <proactor/InputDispatcher.hpp>
 #include <proactor/Proactor.hpp>
 #include <proactor/Worker.hpp>
@@ -35,17 +36,26 @@ namespace largefile {
 		off64_t byte;
 		off64_t line;
 	};
-	
-	class FileDispatcher : public proactor::InputDispatcher {
+
+	class FileIndex : public concurrent::RecursiveMutex {
 	private:
 		LineIndex marks[LINE_INDEX_MAX];
-		FILE * fp;
+	public:
+		FileIndex (void);
+		virtual ~FileIndex (void);
+
+		inline LineIndex & get (int index) { return this->marks[index]; }
+	};	
+
+	class FileDispatcher : public proactor::InputDispatcher {
+	private:
+		FileIndex marks;
 		std::string filename;
 	public:
 		FileDispatcher (int e, proactor::Proactor * pro);
 		virtual ~FileDispatcher (void);
 
-		bool OpenFile (const std::string & filename);
+		bool Openfile (const std::string & filename);
 		bool Close (void);
 		void * run (void * null);
 
@@ -54,31 +64,38 @@ namespace largefile {
 		bool Readpercent (guint percent, off64_t N);
 		
 		void Index (void);
+	};
+
+	class FileWorker : public proactor::Worker {
+	protected:
+		FileIndex * marks;
+		FILE * fp;
+		std::string filename;
+	public:
+		FileWorker (const std::string & filename, FileIndex * marks);
+		virtual ~FileWorker (void);
 
-		inline bool isIndexed(void) const { return (this->marks[LINE_INDEX_MAX-1].line != -1); }
+		bool Openfile (void);
+		bool Closefile (void);
 	};
 	
-	class LineIndexer : public proactor::Worker {
-	private:
-		LineIndex * marks;
-		FILE * fp;
+	class LineIndexer : public FileWorker {
 	public:
 		LineIndexer (proactor::InputDispatcher * d,
-						 FILE * fp,
-						 LineIndex * marks);
+						 const std::string & filename,
+						 FileIndex * marks);
 		virtual ~LineIndexer (void);
 
 		void * run (void * null);
 	};
 
-	class OffsetReader : public proactor::Worker {
+	class OffsetReader : public FileWorker {
 	private:
-		FILE * fp;
 		off64_t numberOfLinesToRead;
 		off64_t startOffset;
 	public:
 		OffsetReader (proactor::InputDispatcher * d,
-						  FILE * fp,
+						  const std::string & filename,
 						  off64_t offset,
 						  off64_t N);
 		virtual ~OffsetReader (void);
@@ -86,16 +103,14 @@ namespace largefile {
 		void * run (void * null);
 	};
 	
-	class LineReader : public proactor::Worker {
+	class LineReader : public FileWorker {
 	private:
-		FILE * fp;
 		off64_t numberOfLinesToRead;
 		off64_t startLine;
-		LineIndex * marks;
 	public:
 		LineReader (proactor::InputDispatcher * d,
-						FILE * fp,
-						LineIndex * marks,
+						const std::string & filename,
+						FileIndex * marks,
 						off64_t start,
 						off64_t N);
 		virtual ~LineReader (void);
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index 97030db..acb9494 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -341,7 +341,7 @@ Largefile::OpenFile (Sheet * sheet, const std::string & filename) {
 		return false;
 	}
 
-	if (fd->OpenFile (filename) == false) {
+	if (fd->Openfile (filename) == false) {
 		g_critical ("Failed opening %s", filename.c_str());
 		this->unlock();
 		return false;

commit 46edcaac002fb6f9ed9570722465ebc50a5c7d60
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 24 15:20:05 2009 -0400

    (1) Modified File.cpp to fix algorithm for indexing. Was not computing corrected byte locations.
    (2) Removed status bar references from Largefile.cpp.

diff --git a/gtkworkbook/Makefile b/gtkworkbook/Makefile
index ee3af15..d0f94c7 100755
--- a/gtkworkbook/Makefile
+++ b/gtkworkbook/Makefile
@@ -16,7 +16,7 @@ install:
 libgtkworkbook: ${OBJS}
 	${MD} ${PROJDIR}/lib
 	${RM} ${PROJDIR}/lib/libgtkworkbook.so.1 ${PROJDIR}/lib/libgtkworkbook.so
-	${CC} -shared -Wl,-soname,libgtkworkbook.so.1 \
+	${CC} ${CCFLAGS} -shared -Wl,-soname,libgtkworkbook.so.1 \
 	-o ${PROJDIR}/lib/libgtkworkbook.so ${OBJS} ${LIBS} \
 	-lgtkextra-x11-2.0 -ldl -gthread-2.0
 	${LN} ${PROJDIR}/lib/libgtkworkbook.so ${PROJDIR}/lib/libgtkworkbook.so.1
diff --git a/shared/Makefile b/shared/Makefile
index ac02869..6dc7764 100755
--- a/shared/Makefile
+++ b/shared/Makefile
@@ -7,7 +7,7 @@ OBJS=$(patsubst %.cc,${OBJDIR}/libgtkworkbookshared/%.o,${SRCS})
 all: 	gtkworkbookshared
 
 gtkworkbookshared: ${OBJS}
-	${CX} -shared -Wl -o ${PROJDIR}/lib/libgtkworkbookshared.so ${OBJS} ${LIBS} \
+	${CX} ${CXFLAGS} -shared -Wl -o ${PROJDIR}/lib/libgtkworkbookshared.so ${OBJS} ${LIBS} \
 	-lpthread
 	${CP} ${PROJDIR}/lib/libgtkworkbookshared.so ${PROJDIR}/lib/libgtkworkbookshared.so.1
 
diff --git a/src/Application.cpp b/src/Application.cpp
index c44724b..1c8c7e4 100755
--- a/src/Application.cpp
+++ b/src/Application.cpp
@@ -294,7 +294,7 @@ Application::init (int argc, char *** argv) {
   
 	/* Set the initial size of the application; we could load this
 		from a configuration file eventually. */
-	gtk_widget_set_usize (this->gtk_window, 1024, 800);
+	gtk_widget_set_usize (this->gtk_window, 1024, 820);
   
 	/* Attach the window box to the window and present to the screen. */
 	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
diff --git a/src/Makefile b/src/Makefile
index 642cef6..c13d801 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -11,7 +11,7 @@ all: 	gtkworkbook
 	make -C largefile/ all
 
 gtkworkbook: ${OBJS}
-	${CX} -rdynamic -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
+	${CX} ${CXFLAGS} -rdynamic -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
 
 clean:		
 	${MD} ${OBJDIR}	
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index a69a84b..5de90a5 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -198,8 +198,13 @@ namespace largefile {
 	LineIndexer::run (void * null) {
 		int ch, index = 0;
 		off64_t cursor = 0, count = 0, byte_beg = 0;
+		struct timeval start, end;
 		
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, false);
+
+		std::cout<<"index start...";
+		
+		gettimeofday (&start, NULL);
 		
 		// We need to get a absoltue line number from the relative position. We're not
 		// going to get away from having to sequentially read this file in, but once we
@@ -211,9 +216,13 @@ namespace largefile {
 			while (mutex.trylock() == false)
 				Thread::sleep(5);
 						
-			if (ch=='\n') count++;
+			if (ch=='\n') {
+				byte_beg = cursor;
+				count++;
+			}
 
   			if (this->marks[index].byte == cursor++) {
+						
 				this->marks[index].line = count;
 				this->marks[index].byte = byte_beg;
 				
@@ -229,10 +238,12 @@ namespace largefile {
 				mutex.unlock();
 				Thread::sleep(10);
 			}
-
-			if (ch=='\n') byte_beg = cursor + 1;
 		}
-		
+
+		gettimeofday (&end, NULL);
+
+		double ms = ((((end.tv_sec-start.tv_sec) * 1000) + ((end.tv_usec-start.tv_usec)/1000.0)) + 0.5);
+		std::cout<<"index done (ms:"<<ms<<")!\n";
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}
@@ -259,16 +270,16 @@ namespace largefile {
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 		off64_t start = ftello64 (this->fp);
 		off64_t offset = 0, delta = 0;
-		off64_t read_max = this->numberOfLinesToRead;
-		
-		for (int index = 1; index < LINE_INDEX_MAX; index++) {
-			if ((this->startLine + read_max) < this->marks[index].line) {
-				delta = std::abs(this->marks[index-1].line - this->startLine);
+		off64_t read_max = this->numberOfLinesToRead, line_max = this->startLine + read_max;
+
+		for (off64_t index = 1; index < LINE_INDEX_MAX; index++) {
+			if (line_max < this->marks[index].line) {
+				delta = this->startLine - this->marks[index-1].line;
 				offset = this->marks[index-1].byte;
 				break;
 			}
 		}
-		
+						
 		fseeko64 (this->fp, offset, SEEK_SET);
 
 		// Munch lines to get to our starting point.
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 5571fd2..f543c10 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -63,7 +63,7 @@ namespace largefile {
 		LineIndex * marks;
 		FILE * fp;
 	public:
-		LineIndexer (proactor::InputDispatcher * d, 
+		LineIndexer (proactor::InputDispatcher * d,
 						 FILE * fp,
 						 LineIndex * marks);
 		virtual ~LineIndexer (void);
@@ -93,7 +93,7 @@ namespace largefile {
 		off64_t startLine;
 		LineIndex * marks;
 	public:
-		LineReader (proactor::InputDispatcher * d, 
+		LineReader (proactor::InputDispatcher * d,
 						FILE * fp,
 						LineIndex * marks,
 						off64_t start,
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index 26fb43b..97030db 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -49,14 +49,16 @@ GotoDialogResponseCallback (GtkWidget * gtkdialog, gint response, gpointer data)
 	if (response == GTK_RESPONSE_OK) {
 		GList * children = gtk_container_get_children ( GTK_CONTAINER (GTK_DIALOG(gtkdialog)->vbox) );
 		GtkWidget * entry = (GtkWidget *)g_list_nth_data (children, 1);
-		const gchar * value = gtk_entry_get_text ( GTK_ENTRY (entry) );
-
-		if (value && *value != '\0') {
+		const char * entry_value = gtk_entry_get_text ( GTK_ENTRY (entry) ); 
+				
+		if (entry_value && *entry_value != '\0') {
+			long long value = atoll (entry_value);
+						
 			switch (dialog->active_index) {
 				// byte offset
 				case 0: {
 					dialog->lf->Readoffset (dialog->lf->workbook()->focus_sheet,
-													atol (value),
+													value,
 													1000);
 				}
 				break;
@@ -64,15 +66,17 @@ GotoDialogResponseCallback (GtkWidget * gtkdialog, gint response, gpointer data)
 				// absolute line
 				case 1: {
 					dialog->lf->Readline (dialog->lf->workbook()->focus_sheet,
-												 atol (value) - 1,
+												 value - 1,
 												 1000);
 				}
 				break;
 
 				// relative percentage
 				case 2: {
+					long long perc_value = (long long) (atof ( entry_value ) * 10);
+					
 					dialog->lf->Readpercent (dialog->lf->workbook()->focus_sheet,
-													 atol (value),
+													 perc_value,
 													 1000);
 				}
 				break;
@@ -118,7 +122,6 @@ CsvOpenDialogCallback (GtkWidget * w, gpointer data) {
 				
 	if (gtk_dialog_run (GTK_DIALOG (open_dialog)) == GTK_RESPONSE_ACCEPT) {
 		gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (open_dialog));
-
 		Sheet * sheet = lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
 
 		if (sheet == NULL) {
@@ -196,7 +199,6 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 		g_signal_connect (G_OBJECT (gtk_radioperc), "toggled",
 								G_CALLBACK (GotoDialogRadioToggleCallback),
 								dialog);
-		
 		g_signal_connect (G_OBJECT (dialog->widget), "response",
 								G_CALLBACK (GotoDialogResponseCallback), dialog);
 		
@@ -218,7 +220,6 @@ Largefile::Largefile (Application * appstate, Handle * platform)
 	: Plugin (appstate, platform) {
 
 	this->wb = workbook_open (appstate->gtkwindow(), "largefile");
-	this->gtk_statusbar = NULL;
 	this->gtk_togglegroup = NULL;
 	
 	ConfigPair * logpath =
@@ -246,18 +247,6 @@ Largefile::~Largefile (void) {
 }
 
 GtkWidget *
-Largefile::CreateStatusBar (void) {
-	GtkWidget * statusbar = gtk_statusbar_new();
-	
-	gtk_statusbar_push (GTK_STATUSBAR (statusbar),
-							  gtk_statusbar_get_context_id(GTK_STATUSBAR (statusbar), "Ready"),
-							  "Ready");
-
-	gtk_widget_show (statusbar);
-	return statusbar;
-}
-
-GtkWidget *
 Largefile::CreateMainMenu (void) {
 	GtkWidget * lfmenu = gtk_menu_new();
 	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
@@ -274,19 +263,16 @@ Largefile::CreateMainMenu (void) {
 GtkWidget *
 Largefile::BuildLayout (void) {
 	GtkWidget * gtk_menu = this->app()->gtkmenu();
-	//	GtkWidget * statusbar = this->CreateStatusBar();
 	GtkWidget * box = gtk_vbox_new (FALSE, 0);
 	GtkWidget * largefile_menu = this->CreateMainMenu();
+	
 	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
 
 	wb->signals[SIG_WORKBOOK_CHANGED] = this->app()->signals[Application::SHEET_CHANGED];
 	wb->gtk_box = box;
 
-	//	gtk_box_pack_end (GTK_BOX (box), statusbar, FALSE, FALSE, 0);
 	gtk_box_pack_start (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
 	gtk_box_pack_start (GTK_BOX (this->app()->gtkvbox()), box, FALSE, FALSE, 0);
-
-	//	this->gtk_statusbar = statusbar;
 	return box;
 }
 
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
index 4a530ee..10a350c 100755
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -34,7 +34,6 @@ namespace largefile {
 		typedef std::map<std::string,FileDispatcher *> FilenameMap;
 
 		GotoDialog goto_dialog;
-		GtkWidget * gtk_statusbar;
 		FILE * pktlog;
 		FilenameMap mapping;
 		GSList * gtk_togglegroup;
@@ -53,7 +52,6 @@ namespace largefile {
 		bool Readoffset (Sheet * sheet, off64_t offset, off64_t N);
 		bool Readpercent (Sheet * sheet, guint percent, off64_t N);
 		
-		inline GtkWidget * statusbar (void) { return this->gtk_statusbar; }
 		inline void setGotoDialogRadioGroup (GSList * group) { this->gtk_togglegroup = group; }
 		inline GotoDialog * gotodialog() { return &this->goto_dialog; }
 	};
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index 49a9c0d..e511440 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -9,7 +9,7 @@ _CXFLAGS= -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
 all: 	largefile
 
 largefile: ${OBJS}
-	${CX} ${_CXFLAGS} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
+	${CX} ${CXFLAGS} ${_CXFLAGS} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
 	-lgthread-2.0 -lpthread -lcsv
 
 clean:		

commit af8da1815c2f0fb40d6aee5d33bc8c82a4794e83
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 24 10:44:58 2009 -0400

    (1) Removed PGUP/PGDOWN references so that scrolled window will again
    properly pan inside of a workbook.

diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
index 4bd95b8..fb52eda 100755
--- a/gtkworkbook/sheet.c
+++ b/gtkworkbook/sheet.c
@@ -142,18 +142,18 @@ sheet_object_init (Workbook * book,
 	/* Create the sheet containers and GtkSheet object. */
 	sheet->gtk_box = gtk_vbox_new (FALSE, 1);
 
-	GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
-	gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
-	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
+	sheet->gtk_scrolledwindow = gtk_scrolled_window_new (NULL, NULL);
+	gtk_box_pack_start (GTK_BOX (sheet->gtk_box), sheet->gtk_scrolledwindow, 1,1,1);
+	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (sheet->gtk_scrolledwindow),
 											  GTK_POLICY_AUTOMATIC,
 											  GTK_POLICY_AUTOMATIC);
-	gtk_widget_show (scrolled_window);
+	gtk_widget_show (sheet->gtk_scrolledwindow);
 
 	sheet->gtk_label = gtk_label_new (label);
   
 	sheet->gtk_sheet = gtk_sheet_new (rows, columns, label);
 	gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
-	gtk_container_add (GTK_CONTAINER (scrolled_window),
+	gtk_container_add (GTK_CONTAINER (sheet->gtk_scrolledwindow),
 							 GTK_WIDGET (sheet->gtk_sheet));
 
 	/* We should be able to use sheet->gtk_box now throughout all of our
diff --git a/include/gtkworkbook/cell.h b/include/gtkworkbook/cell.h
index fb956cd..65d4e6b 100755
--- a/include/gtkworkbook/cell.h
+++ b/include/gtkworkbook/cell.h
@@ -26,66 +26,66 @@
 extern "C" {
 #endif
 
-  typedef struct _Cell Cell;
-  typedef struct _CellAttributes CellAttributes;
+	typedef struct _Cell Cell;
+	typedef struct _CellAttributes CellAttributes;
 
-  #include "sheet.h"
+#include "sheet.h"
 
-  /*
-    @description: These objects will evolve as more uses are found for it. 
-    Right now it provides as an intermediate abstraction for the cell 
-    information of a GtkSheetEntry. It works in conjunction with the Sheet 
-    object (the Sheet object performs all the gtk_sheet_* functions). 
+	/*
+	  @description: These objects will evolve as more uses are found for it. 
+	  Right now it provides as an intermediate abstraction for the cell 
+	  information of a GtkSheetEntry. It works in conjunction with the Sheet 
+	  object (the Sheet object performs all the gtk_sheet_* functions). 
 
-    If you decide to manually set any of the members be sure:
-    a. For single cell changes row and column ranges must equal each other
-       because GtkSheet does not provide interfaces for all operations to
-       be done on single cell.
-    b. Keep in mind that this object was built with the ability to dump a whole
-       array of changes into a Sheet with a single call. This was built for 
-       simple brute forcing of cell additions (and changes).
-    c. If you find yourself adding a lot of code to this object then it may
-       be time to add a new object to libworkbook. It was meant to be simple.
+	  If you decide to manually set any of the members be sure:
+	  a. For single cell changes row and column ranges must equal each other
+	  because GtkSheet does not provide interfaces for all operations to
+	  be done on single cell.
+	  b. Keep in mind that this object was built with the ability to dump a whole
+	  array of changes into a Sheet with a single call. This was built for 
+	  simple brute forcing of cell additions (and changes).
+	  c. If you find yourself adding a lot of code to this object then it may
+	  be time to add a new object to libworkbook. It was meant to be simple.
 
-    If you decide to use gtk_sheet_* calls:
-    a. Do not add them to any methods inside of this object. This object does
-       not (and should not) contain any locking procedures. All the locking for
-       threading should be done in the Sheet object (where all gtk+ calls 
-       should be performed). 
-  */
-  struct _CellAttributes
-  {
-    GString * bgcolor;
-    GString * fgcolor;
-    GtkJustification justification;
-  };
+	  If you decide to use gtk_sheet_* calls:
+	  a. Do not add them to any methods inside of this object. This object does
+	  not (and should not) contain any locking procedures. All the locking for
+	  threading should be done in the Sheet object (where all gtk+ calls 
+	  should be performed). 
+	*/
+	struct _CellAttributes
+	{
+		GString * bgcolor;
+		GString * fgcolor;
+		GtkJustification justification;
+	};
 
-  struct _Cell
-  {
-    /* Members */
-    Sheet * sheet;
-    Cell * next;
-    GString * value;
-    CellAttributes attributes;
-    GtkSheetRange range;
-    gint row, column;
+	struct _Cell
+	{
+		/* Members */
+		Sheet * sheet;
+		Cell * next;
+		GString * value;
+		CellAttributes attributes;
+		GtkSheetRange range;
+		gint row, column;
     
-    /* Methods */
-    void (*set) (Cell * cell, gint row, gint column, const gchar * value);
-    void (*set_value) (Cell * cell, const gchar * value);  
-    void (*set_value_length) (Cell * cell, void * s, size_t length);
-    void (*set_column) (Cell * cell, gint column);
-    void (*set_row) (Cell * cell, gint row);
-    void (*set_range) (Cell * cell, const GtkSheetRange * range);
-    void (*set_justification) (Cell * cell, GtkJustification justification);
-    void (*set_fgcolor) (Cell * cell, const gchar * color);
-    void (*set_bgcolor) (Cell * cell, const gchar * color);
-    void (*set_attributes) (Cell * cell, const CellAttributes * attrib);
-    void (*destroy) (Cell * cell);
-  };
+		/* Methods */
+		void (*set) (Cell * cell, gint row, gint column, const gchar * value);
+		void (*set_value) (Cell * cell, const gchar * value);  
+		void (*set_value_length) (Cell * cell, void * s, size_t length);
+		void (*set_column) (Cell * cell, gint column);
+		void (*set_row) (Cell * cell, gint row);
+		void (*set_range) (Cell * cell, const GtkSheetRange * range);
+		void (*set_justification) (Cell * cell, GtkJustification justification);
+		void (*set_fgcolor) (Cell * cell, const gchar * color);
+		void (*set_bgcolor) (Cell * cell, const gchar * color);
+		void (*set_attributes) (Cell * cell, const CellAttributes * attrib);
+		void (*destroy) (Cell * cell);
+	};
 
-  /* cell.c */
-  Cell *cell_new (void);
+	/* cell.c */
+	Cell *cell_new (void);
 
 #ifdef __cplusplus
 }
diff --git a/include/gtkworkbook/sheet.h b/include/gtkworkbook/sheet.h
index 6156459..f8fb080 100755
--- a/include/gtkworkbook/sheet.h
+++ b/include/gtkworkbook/sheet.h
@@ -29,63 +29,64 @@ extern "C" {
 
 #define GEOMETRY_FILE_VERSION 0x000001
 
-typedef struct _Sheet Sheet;
+	typedef struct _Sheet Sheet;
 
 #include "workbook.h"
 #include "cell.h"
 
-  /*
-    @description: This object abstracts away all of the calls to the native
-    GtkSheet methods. It is meant to be used with the Cell object(s).
+	/*
+	  @description: This object abstracts away all of the calls to the native
+	  GtkSheet methods. It is meant to be used with the Cell object(s).
     
-    Please keep the following in mind:
-    a. All calls to gtk_* methods should be performed in here and not inside of
-       a cell object. 
-    b. All calls to gtk_* methods should be performed inside of a lock, e.g. 
-       you should always use gdk_threads_enter and gtk_threads_exit. Any calls
-       outside of the window (main) thread will usually result in problems if
-       you do not get a mutex. 
-  */
-  struct _Sheet
-  {
-    /* Members */
-    Sheet * next;
-    Sheet * prev;
-    gchar * name;
-    Workbook * workbook;
-    GtkWidget * gtk_label;
-    GtkWidget * gtk_sheet;
-    GtkWidget * gtk_box;
-    gint page;
-    gint attention;
-    gint notices;
-    gint max_rows;
-    gint max_columns;
-    gboolean has_focus;
+	  Please keep the following in mind:
+	  a. All calls to gtk_* methods should be performed in here and not inside of
+	  a cell object. 
+	  b. All calls to gtk_* methods should be performed inside of a lock, e.g. 
+	  you should always use gdk_threads_enter and gtk_threads_exit. Any calls
+	  outside of the window (main) thread will usually result in problems if
+	  you do not get a mutex. 
+	*/
+	struct _Sheet
+	{
+		/* Members */
+		Sheet * next;
+		Sheet * prev;
+		gchar * name;
+		Workbook * workbook;
+		GtkWidget * gtk_label;
+		GtkWidget * gtk_sheet;
+		GtkWidget * gtk_box;
+		GtkWidget * gtk_scrolledwindow;
+		gint page;
+		gint attention;
+		gint notices;
+		gint max_rows;
+		gint max_columns;
+		gboolean has_focus;
 
-    /* Methods */
-    void (*destroy) (Sheet *);
-    void (*set_attention) (Sheet *, gint);
-    void (*apply_range) (Sheet *, 
-			 const GtkSheetRange *, 
-			 const CellAttributes *);
-    void (*apply_array) (Sheet *, Cell **, gint);
-    void (*apply_cell) (Sheet *, const Cell *);
-    void (*apply_row) (Sheet *, Cell **, gint, gint);
+		/* Methods */
+		void (*destroy) (Sheet *);
+		void (*set_attention) (Sheet *, gint);
+		void (*apply_range) (Sheet *, 
+									const GtkSheetRange *, 
+									const CellAttributes *);
+		void (*apply_array) (Sheet *, Cell **, gint);
+		void (*apply_cell) (Sheet *, const Cell *);
+		void (*apply_row) (Sheet *, Cell **, gint, gint);
 
-    void (*set_cell) (Sheet *, gint, gint, const gchar *);  
-    void (*range_set_background) (Sheet *, 
-				  const GtkSheetRange *, 
-				  const gchar *);
-    void (*range_set_foreground) (Sheet *, 
-				  const GtkSheetRange *,
-				  const gchar *);
-    gboolean (*save) (Sheet *, const gchar *);
-    gboolean (*load) (Sheet *, const gchar *);
-  };
+		void (*set_cell) (Sheet *, gint, gint, const gchar *);  
+		void (*range_set_background) (Sheet *, 
+												const GtkSheetRange *, 
+												const gchar *);
+		void (*range_set_foreground) (Sheet *, 
+												const GtkSheetRange *,
+												const gchar *);
+		gboolean (*save) (Sheet *, const gchar *);
+		gboolean (*load) (Sheet *, const gchar *);
+	};
 
-  /* sheet.c */
-  Sheet *sheet_new (Workbook *, const gchar *, gint, gint);
+	/* sheet.c */
+	Sheet *sheet_new (Workbook *, const gchar *, gint, gint);
 
 #ifdef __cplusplus
 }
diff --git a/include/gtkworkbook/workbook.h b/include/gtkworkbook/workbook.h
index 0e39324..199a718 100755
--- a/include/gtkworkbook/workbook.h
+++ b/include/gtkworkbook/workbook.h
@@ -26,42 +26,42 @@
 extern "C" {
 #endif
 
-  enum
-    {
-      SIG_WORKBOOK_CHANGED = 0,
-      /**/
-      MAX_WORKBOOK_SIGNALS
-    };
+	enum
+		{
+			SIG_WORKBOOK_CHANGED = 0,
+			/**/
+			MAX_WORKBOOK_SIGNALS
+		};
 
-  typedef struct _Workbook Workbook;
+	typedef struct _Workbook Workbook;
 
 #include "sheet.h"
 
-  struct _Workbook
-  {
-    /* Members */
-    GSourceFunc signals[MAX_WORKBOOK_SIGNALS];
-    Sheet * sheet_first;
-    Sheet * sheet_last;
-    Sheet * focus_sheet;
-    Workbook * next;
-    Workbook * prev;  
-    GtkWidget * gtk_notebook;
-    GtkWidget * gtk_window;
-    GtkWidget * gtk_box;
-    gchar * filename;
+	struct _Workbook
+	{
+		/* Members */
+		GSourceFunc signals[MAX_WORKBOOK_SIGNALS];
+		Sheet * sheet_first;
+		Sheet * sheet_last;
+		Sheet * focus_sheet;
+		Workbook * next;
+		Workbook * prev;  
+		GtkWidget * gtk_notebook;
+		GtkWidget * gtk_window;
+		GtkWidget * gtk_box;
+		gchar * filename;
 
-    /* Methods */
-    void (*destroy) (Workbook *);
-    Sheet *(*add_new_sheet) (Workbook *, const gchar *, gint, gint);
-    Sheet *(*get_sheet) (Workbook *, const gchar *);
-    void (*remove_sheet) (Workbook *, Sheet *);
-    gboolean (*move_sheet_index) (Workbook *, Sheet *, gint);
-    gboolean (*move_sheet) (Workbook *, Sheet *, const gchar *, gboolean); 
-  };
+		/* Methods */
+		void (*destroy) (Workbook *);
+		Sheet *(*add_new_sheet) (Workbook *, const gchar *, gint, gint);
+		Sheet *(*get_sheet) (Workbook *, const gchar *);
+		void (*remove_sheet) (Workbook *, Sheet *);
+		gboolean (*move_sheet_index) (Workbook *, Sheet *, gint);
+		gboolean (*move_sheet) (Workbook *, Sheet *, const gchar *, gboolean); 
+	};
 
-  /* workbook.c */
-  Workbook *workbook_open (GtkWidget *, const gchar *);
+	/* workbook.c */
+	Workbook *workbook_open (GtkWidget *, const gchar *);
 
 #ifdef __cplusplus
 }
diff --git a/shared/concurrent/Runnable.cc b/shared/concurrent/Runnable.cc
old mode 100644
new mode 100755
diff --git a/src/largefile/GotoDialog.hpp b/src/largefile/GotoDialog.hpp
old mode 100644
new mode 100755
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index b9611d7..26fb43b 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -204,10 +204,6 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 								G_CALLBACK (gtk_widget_hide_on_delete), NULL);
 	}	
 	
-	//	int vposition = std::abs((int)gtksheet->vadjustment->value);
-	static off64_t cursor = 0;
-	//	float N = vposition, K = 24388, V = (N/K);
-	
 	switch (event->keyval) {
 		case GDK_F1: {
 			if (sheet != NULL) {
@@ -215,28 +211,9 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 			}
 		}
 		break;
-		
-		case GDK_Page_Up: {
-			lf->Readline (sheet, cursor, 100);
-			cursor += 100;
-		}
-		result = TRUE;
-		break;
-		
-		case GDK_Page_Down: {
-			if (cursor <= 100)
-				cursor = 0;
-			else
-				cursor -= 100;
-			
-			lf->Readline (sheet, cursor, 100);
-		}
-		result = TRUE;
-		break;
 	}
 	return result;
 }
-
 Largefile::Largefile (Application * appstate, Handle * platform)
 	: Plugin (appstate, platform) {
 
diff --git a/src/largefile/PluginFactory.cpp b/src/largefile/PluginFactory.cpp
old mode 100644
new mode 100755

commit 87eef7603274ae2359534001caceb1e1f3f342a4
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 23 19:40:50 2009 -0400

    Modified code to not divide by the wrong number of bytes for the index
    calculation. This was an un-noticed problem, and may still have a few
    flaws.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 04bb9b0..a69a84b 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -39,7 +39,7 @@ namespace largefile {
 
 	bool
 	FileDispatcher::Readline (off64_t start, off64_t N) {
-		if (start > this->marks[100].byte) return false;
+		if (start > this->marks[LINE_INDEX_MAX-1].byte) return false;
 		
 		LineReader * reader = new LineReader (this, this->fp, this->marks, start, N);
 		this->addWorker (reader);
@@ -48,7 +48,7 @@ namespace largefile {
 
 	bool
 	FileDispatcher::Readoffset (off64_t offset, off64_t N) {
-		if (offset > this->marks[100].byte) return false;
+		if (offset > this->marks[LINE_INDEX_MAX-1].byte) return false;
 		
 		OffsetReader * reader = new OffsetReader (this, this->fp, offset, N);
 		this->addWorker (reader);
@@ -58,8 +58,9 @@ namespace largefile {
 	bool
 	FileDispatcher::Readpercent (guint percent, off64_t N) {
 		if (percent > 100) return false;
+		if (this->marks[percent * 10].byte == -1) return false;
 
-		OffsetReader * reader = new OffsetReader (this, this->fp, this->marks[percent].byte, N);
+		OffsetReader * reader = new OffsetReader (this, this->fp, this->marks[percent * 10].byte, N);
 		this->addWorker (reader);
 		return true;
 	}
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index a685a45..5571fd2 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -27,7 +27,7 @@
 #include <string>
 
 #define LINE_INDEX_MAX 1001
-#define LINE_PRECISION 10000
+#define LINE_PRECISION 1000
 
 namespace largefile {
 

commit e5d3b17fe805269bdf0ab9ea0272f481a590ba4f
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 23 19:19:10 2009 -0400

    Fixed EOF problem inside of OffsetReader.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 2e1292e..04bb9b0 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -162,7 +162,7 @@ namespace largefile {
 		fseeko64 (this->fp, this->startOffset, SEEK_SET);
 		
 		// We need to go to the beginning of the (next) line.
-		while ((ch = fgetc (this->fp)) == EOF) {
+		while ((ch = fgetc (this->fp)) != EOF) {
 			if (ch == '\n') {
 				offset = ftello64 (this->fp);
 				break;

commit 2844c2109cc581743e78164d60cce619fe5cc380
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 23 19:18:23 2009 -0400

    Modified TODO file.

diff --git a/TODO b/TODO
index c4f1efc..f985c37 100755
--- a/TODO
+++ b/TODO
@@ -10,18 +10,15 @@ TODO for GTKWorkbook
 		  which was yanked from GtkExtra distribution. This needs to be run inside
 		  of heap profiler for testing.
 	- Priorities (before merge)
-		o Absolute line goto dialog
 		o Index indicator
 		o Panning/Paging controls
 		o Move shared library into application folder
-		o Page up, page down for panning
 		o Control + G for GOTO line
 		o Control + O for percentage offset
 		o Control + I for index up to line
 	- Priorities (after merge)
 		o Framebuffering and Caching
 		o Statistics on writing to screen, reading, and panning/paging
-		o Staging for the indexer... N percentile increments
 	- Merge
 		o Largefile merge happens into an autotools branch
 		o Final merge back into the master branch

commit 94d74837a7638fa27d4c52ddb4067f104f646fc4
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 23 16:27:00 2009 -0400

    (1) Modified ScopedMemoryLock so that creating a simplistic spinlock can
    be done with the trylock() method.
    (2) Added a spinlock to the FileIndexer to allow for readers to get a little
    time with the file descriptor.
    (3) Added read by offset and read by percentage support.

diff --git a/shared/concurrent/ScopedMemoryLock.cc b/shared/concurrent/ScopedMemoryLock.cc
index eb9b901..1063fa3 100755
--- a/shared/concurrent/ScopedMemoryLock.cc
+++ b/shared/concurrent/ScopedMemoryLock.cc
@@ -19,100 +19,105 @@
 #include "ScopedMemoryLock.hpp"
 
 namespace concurrent {
-  ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
-
-  ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
-    this->hasLock = false;
-    this->address = address;
-    this->mutex = NULL;
-
-    ScopedMemoryLock::addressMutexMap.lock();
-    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-    ScopedMemoryLock::addressMutexMap.unlock();
-
-    /* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
-       if someone is passing an address that has not been formally added via the static method
-       call then that means it is very unlikely that they are not removing it either. We do
-       not want a memory leak therefore this seems like the best method. */
-    if (it != ScopedMemoryLock::addressMutexMap.end()) 
-      this->mutex = it->second;
-
-    if (engage == true)
-      this->lock();
-  }
-
-  ScopedMemoryLock::~ScopedMemoryLock (void) {
-    if (this->hasLock == true)
-      unlock();
-  }
-
-  void
-  ScopedMemoryLock::lock (void) {
-    this->mutex->lock();
-    this->hasLock = true;
-  }
-
-  void 
-  ScopedMemoryLock::unlock (void) {
-    this->mutex->unlock();
-    this->hasLock = false;
-  }
-
-  bool
-  ScopedMemoryLock::trylock (void) {
-    this->hasLock = this->mutex->trylock();
-    return this->hasLock;
-  }
-
-  bool
-  ScopedMemoryLock::remove (void) {
-    if (this->hasLock == false) {
-      return false;
-    }
-
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-    if (it != addressMutexMap.end()) {
-      delete it->second;
-      addressMutexMap.end();
-      result = true;
-    }
+	ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
+
+	ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
+		this->hasLock = false;
+		this->address = address;
+		this->mutex = NULL;
+
+		ScopedMemoryLock::addressMutexMap.lock();
+		AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+		ScopedMemoryLock::addressMutexMap.unlock();
+
+		/* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
+			if someone is passing an address that has not been formally added via the static method
+			call then that means it is very unlikely that they are not removing it either. We do
+			not want a memory leak therefore this seems like the best method. */
+		if (it != ScopedMemoryLock::addressMutexMap.end()) 
+			this->mutex = it->second;
+
+		if (engage == true)
+			this->lock();
+	}
+
+	ScopedMemoryLock::~ScopedMemoryLock (void) {
+		if (this->hasLock == true)
+			unlock();
+	}
+
+	void
+	ScopedMemoryLock::lock (void) {
+		this->mutex->lock();
+		this->hasLock = true;
+	}
+
+	void 
+	ScopedMemoryLock::unlock (void) {
+		this->mutex->unlock();
+		this->hasLock = false;
+	}
+
+	bool
+	ScopedMemoryLock::isLocked (void) const {
+		return this->hasLock;
+	}
+	
+	bool
+	ScopedMemoryLock::trylock (void) {
+		this->hasLock = (this->hasLock==true) ? true : this->mutex->trylock();
+		return this->hasLock;
+	}
+
+	bool
+	ScopedMemoryLock::remove (void) {
+		if (this->hasLock == false) {
+			return false;
+		}
+
+		addressMutexMap.lock();
+
+		bool result = false;
+		AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+		if (it != addressMutexMap.end()) {
+			delete it->second;
+			addressMutexMap.end();
+			result = true;
+		}
     
-    addressMutexMap.unlock();
-    return result;
-  }
-
-  bool 
-  ScopedMemoryLock::addMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it == addressMutexMap.end()) {
-      addressMutexMap.insert (std::make_pair (address, new Mutex));
-      result = true;
-    }
-
-    addressMutexMap.unlock();
-    return result;
-  }
-
-  bool 
-  ScopedMemoryLock::removeMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it != addressMutexMap.end()) {
-      delete it->second;
-      addressMutexMap.erase(it);
-      result = true;
-    }
-
-    addressMutexMap.unlock();
-    return result;
-  }
+		addressMutexMap.unlock();
+		return result;
+	}
+
+	bool 
+	ScopedMemoryLock::addMemoryLock (unsigned long address) {
+		addressMutexMap.lock();
+
+		bool result = false;
+		AddressToMutexMap::iterator it = addressMutexMap.find (address);
+		if (it == addressMutexMap.end()) {
+			addressMutexMap.insert (std::make_pair (address, new Mutex));
+			result = true;
+		}
+
+		addressMutexMap.unlock();
+		return result;
+	}
+
+	bool 
+	ScopedMemoryLock::removeMemoryLock (unsigned long address) {
+		addressMutexMap.lock();
+
+		bool result = false;
+		AddressToMutexMap::iterator it = addressMutexMap.find (address);
+		if (it != addressMutexMap.end()) {
+			delete it->second;
+			addressMutexMap.erase(it);
+			result = true;
+		}
+
+		addressMutexMap.unlock();
+		return result;
+	}
 
 } // end of namespace
diff --git a/shared/concurrent/ScopedMemoryLock.hpp b/shared/concurrent/ScopedMemoryLock.hpp
index eadab0b..d60c7fd 100755
--- a/shared/concurrent/ScopedMemoryLock.hpp
+++ b/shared/concurrent/ScopedMemoryLock.hpp
@@ -25,26 +25,27 @@
 
 namespace concurrent {
 
-  class ScopedMemoryLock : public ILockable {
-  private:
-    typedef Map<long int,Mutex *> AddressToMutexMap;
-    static AddressToMutexMap addressMutexMap;
-
-    bool hasLock;
-    unsigned long address;
-    Mutex * mutex;
-  public:
-    ScopedMemoryLock (unsigned long address, bool engage = false);
-    virtual ~ScopedMemoryLock (void);
+	class ScopedMemoryLock : public ILockable {
+	private:
+		typedef Map<long int,Mutex *> AddressToMutexMap;
+		static AddressToMutexMap addressMutexMap;
+
+		bool hasLock;
+		unsigned long address;
+		Mutex * mutex;
+	public:
+		ScopedMemoryLock (unsigned long address, bool engage = false);
+		virtual ~ScopedMemoryLock (void);
  
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-    bool remove (void);
-
-    static bool addMemoryLock (unsigned long address);
-    static bool removeMemoryLock (unsigned long address);
-  };
+		void lock (void);
+		void unlock (void);
+		bool trylock (void);
+		bool remove (void);
+		bool isLocked (void) const;
+	  
+		static bool addMemoryLock (unsigned long address);
+		static bool removeMemoryLock (unsigned long address);
+	};
 } // end of namespace
 
 #endif 
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 559040c..2e1292e 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -37,10 +37,31 @@ namespace largefile {
 			this->Close ();
 	}
 
-	void
+	bool
 	FileDispatcher::Readline (off64_t start, off64_t N) {
+		if (start > this->marks[100].byte) return false;
+		
 		LineReader * reader = new LineReader (this, this->fp, this->marks, start, N);
 		this->addWorker (reader);
+		return true;
+	}
+
+	bool
+	FileDispatcher::Readoffset (off64_t offset, off64_t N) {
+		if (offset > this->marks[100].byte) return false;
+		
+		OffsetReader * reader = new OffsetReader (this, this->fp, offset, N);
+		this->addWorker (reader);
+		return true;
+	}
+
+	bool
+	FileDispatcher::Readpercent (guint percent, off64_t N) {
+		if (percent > 100) return false;
+
+		OffsetReader * reader = new OffsetReader (this, this->fp, this->marks[percent].byte, N);
+		this->addWorker (reader);
+		return true;
 	}
 
 	void
@@ -94,6 +115,7 @@ namespace largefile {
   
 	void *
 	FileDispatcher::run (void * data) {
+		this->Readline(0,1000);
 		this->Index();
 		
 		while (this->isRunning() == true) {
@@ -113,7 +135,53 @@ namespace largefile {
 
 		return NULL;
 	}
-  
+
+	OffsetReader::OffsetReader (proactor::InputDispatcher * d,
+										 FILE * fp,
+										 off64_t offset,
+										 off64_t N) {
+		this->fp = fp;
+		this->startOffset = offset;
+		this->numberOfLinesToRead = N;
+		this->dispatcher = d;
+	}
+
+	OffsetReader::~OffsetReader (void) {
+	}
+	
+	void *
+	OffsetReader::run (void * null) {
+		char buf[4096];
+		int ch;
+		
+		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
+		off64_t start = ftello64 (this->fp);
+		off64_t offset = 0;
+		off64_t read_max = this->numberOfLinesToRead;
+
+		fseeko64 (this->fp, this->startOffset, SEEK_SET);
+		
+		// We need to go to the beginning of the (next) line.
+		while ((ch = fgetc (this->fp)) == EOF) {
+			if (ch == '\n') {
+				offset = ftello64 (this->fp);
+				break;
+			}
+		}
+			
+		for (off64_t ii = 0; ii < read_max; ii++) {
+			if (std::fgets (buf, 4096, this->fp) == NULL)		
+				break;
+      
+			this->dispatcher->onReadComplete (buf);
+		}
+
+		fseeko64 (this->fp, start, SEEK_SET);
+		
+		this->dispatcher->removeWorker (this);
+		return NULL;
+	}
+		
 	LineIndexer::LineIndexer (proactor::InputDispatcher * d,
 									  FILE * fp,
 									  LineIndex * marks) {
@@ -129,18 +197,19 @@ namespace largefile {
 	LineIndexer::run (void * null) {
 		int ch, index = 0;
 		off64_t cursor = 0, count = 0, byte_beg = 0;
-
-		struct timeval start, end;
 		
-		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-
-		gettimeofday(&start, NULL);
+		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, false);
 		
 		// We need to get a absoltue line number from the relative position. We're not
 		// going to get away from having to sequentially read this file in, but once we
 		// have line numbers we can jump throughout the file pretty quickly.
 		while ((ch = fgetc(this->fp)) != EOF) {
-			
+
+			// Crude implementation of a spinlock. Wait while another thread is doing
+			// some reading before we begin indexing again.
+			while (mutex.trylock() == false)
+				Thread::sleep(5);
+						
 			if (ch=='\n') count++;
 
   			if (this->marks[index].byte == cursor++) {
@@ -148,18 +217,20 @@ namespace largefile {
 				this->marks[index].byte = byte_beg;
 				
 				index++;
-				
+
 				if (index == LINE_INDEX_MAX)
 					break;
-				
+
+				// While the indexer is running we want to still allow for reads on the
+				// screen. This is an easy way to give them a "minor" priority. Once a
+				// percentage of the file has been index we're going to unlock and give
+				// a healthy amount of time for a thread switch to happen.
+				mutex.unlock();
+				Thread::sleep(10);
 			}
 
 			if (ch=='\n') byte_beg = cursor + 1;
 		}
-
-		gettimeofday(&end, NULL);
-
-		std::cout<<"ms: "<<((((end.tv_sec-start.tv_sec) * 1000) + ((end.tv_usec-start.tv_usec)/1000.0)) + 0.5)<<"\n";
 		
 		this->dispatcher->removeWorker (this);
 		return NULL;
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 80b9206..a685a45 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -49,15 +49,15 @@ namespace largefile {
 		bool Close (void);
 		void * run (void * null);
 
-		void Readline (off64_t start, off64_t N);
-		void Readoffset (off64_t start, off64_t N);
-		void Readpercent (guint percent, off64_t N);
+		bool Readline (off64_t start, off64_t N);
+		bool Readoffset (off64_t offset, off64_t N);
+		bool Readpercent (guint percent, off64_t N);
 		
 		void Index (void);
 
 		inline bool isIndexed(void) const { return (this->marks[LINE_INDEX_MAX-1].line != -1); }
 	};
-
+	
 	class LineIndexer : public proactor::Worker {
 	private:
 		LineIndex * marks;
@@ -71,6 +71,21 @@ namespace largefile {
 		void * run (void * null);
 	};
 
+	class OffsetReader : public proactor::Worker {
+	private:
+		FILE * fp;
+		off64_t numberOfLinesToRead;
+		off64_t startOffset;
+	public:
+		OffsetReader (proactor::InputDispatcher * d,
+						  FILE * fp,
+						  off64_t offset,
+						  off64_t N);
+		virtual ~OffsetReader (void);
+
+		void * run (void * null);
+	};
+	
 	class LineReader : public proactor::Worker {
 	private:
 		FILE * fp;
diff --git a/src/largefile/GotoDialog.hpp b/src/largefile/GotoDialog.hpp
index bff548f..6158ffe 100644
--- a/src/largefile/GotoDialog.hpp
+++ b/src/largefile/GotoDialog.hpp
@@ -1,3 +1,21 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_GOTODIALOG
 #define HPP_GOTODIALOG
 
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index 28f68c3..b9611d7 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -55,13 +55,15 @@ GotoDialogResponseCallback (GtkWidget * gtkdialog, gint response, gpointer data)
 			switch (dialog->active_index) {
 				// byte offset
 				case 0: {
-					std::cerr << "offset\n";
+					dialog->lf->Readoffset (dialog->lf->workbook()->focus_sheet,
+													atol (value),
+													1000);
 				}
 				break;
 
 				// absolute line
 				case 1: {
-					dialog->lf->ReadLine (dialog->lf->workbook()->focus_sheet,
+					dialog->lf->Readline (dialog->lf->workbook()->focus_sheet,
 												 atol (value) - 1,
 												 1000);
 				}
@@ -69,7 +71,9 @@ GotoDialogResponseCallback (GtkWidget * gtkdialog, gint response, gpointer data)
 
 				// relative percentage
 				case 2: {
-					std::cerr << "percentage\n";
+					dialog->lf->Readpercent (dialog->lf->workbook()->focus_sheet,
+													 atol (value),
+													 1000);
 				}
 				break;
 			}
@@ -97,7 +101,6 @@ GotoDialogRadioToggleCallback (GtkToggleButton * button, gpointer data) {
 			dialog->active_index = 2;
 		}
 	}
-	std::cout<<"toggled\n";
 }
 
 static void
@@ -214,7 +217,7 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 		break;
 		
 		case GDK_Page_Up: {
-			lf->ReadLine (sheet, cursor, 100);
+			lf->Readline (sheet, cursor, 100);
 			cursor += 100;
 		}
 		result = TRUE;
@@ -226,7 +229,7 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 			else
 				cursor -= 100;
 			
-			lf->ReadLine (sheet, cursor, 100);
+			lf->Readline (sheet, cursor, 100);
 		}
 		result = TRUE;
 		break;
@@ -311,7 +314,7 @@ Largefile::BuildLayout (void) {
 }
 
 bool
-Largefile::ReadLine (Sheet * sheet, off64_t start, off64_t N) {
+Largefile::Readline (Sheet * sheet, off64_t start, off64_t N) {
 	this->lock();
 	std::string key = sheet->name;
 	
@@ -322,9 +325,43 @@ Largefile::ReadLine (Sheet * sheet, off64_t start, off64_t N) {
 	}
 
 	FileDispatcher * fd = it->second;
-	fd->Readline (start, N);
+	bool result = fd->Readline (start, N);
 	this->unlock();
-	return true;
+	return result;
+}
+
+bool
+Largefile::Readoffset (Sheet * sheet, off64_t offset, off64_t N) {
+	this->lock();
+	std::string key = sheet->name;
+	
+	FilenameMap::iterator it = this->mapping.find (key);
+	if (it == this->mapping.end()) {
+		this->unlock();
+		return false;
+	}
+
+	FileDispatcher * fd = it->second;
+	bool result = fd->Readoffset (offset, N);
+	this->unlock();
+	return result;
+}
+
+bool
+Largefile::Readpercent (Sheet * sheet, guint percent, off64_t N) {
+	this->lock();
+	std::string key = sheet->name;
+	
+	FilenameMap::iterator it = this->mapping.find (key);
+	if (it == this->mapping.end()) {
+		this->unlock();
+		return false;
+	}
+
+	FileDispatcher * fd = it->second;
+	bool result = fd->Readpercent (percent, N);
+	this->unlock();
+	return result;
 }
 
 bool
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
index 2302cde..4a530ee 100755
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -49,9 +49,9 @@ namespace largefile {
 				
 		bool OpenFile (Sheet * sheet, const std::string & filename);
 		bool CloseFile (const std::string & filename);
-		bool ReadLine (Sheet * sheet, off64_t start, off64_t N);
-		bool ReadOffset (Sheet * sheet, off64_t start, off64_t N);
-		bool ReadPercentage (Sheet * sheet, guint percent, off64_t N);
+		bool Readline (Sheet * sheet, off64_t start, off64_t N);
+		bool Readoffset (Sheet * sheet, off64_t offset, off64_t N);
+		bool Readpercent (Sheet * sheet, guint percent, off64_t N);
 		
 		inline GtkWidget * statusbar (void) { return this->gtk_statusbar; }
 		inline void setGotoDialogRadioGroup (GSList * group) { this->gtk_togglegroup = group; }

commit 0680b43e81307f871fb3839f92d718a884036168
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 23 15:16:43 2009 -0400

    (1) Added GotoDialog structure which includes a RadioButton structure.
    (2) Goto dialog now works as advertised for line jumps.
    (3) Added stubs for jump by offset, jump by percentage.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index b73b9ff..559040c 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -38,7 +38,7 @@ namespace largefile {
 	}
 
 	void
-	FileDispatcher::Read (off64_t start, off64_t N) {
+	FileDispatcher::Readline (off64_t start, off64_t N) {
 		LineReader * reader = new LineReader (this, this->fp, this->marks, start, N);
 		this->addWorker (reader);
 	}
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 3d939a2..80b9206 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -49,7 +49,10 @@ namespace largefile {
 		bool Close (void);
 		void * run (void * null);
 
-		void Read (off64_t start, off64_t N);
+		void Readline (off64_t start, off64_t N);
+		void Readoffset (off64_t start, off64_t N);
+		void Readpercent (guint percent, off64_t N);
+		
 		void Index (void);
 
 		inline bool isIndexed(void) const { return (this->marks[LINE_INDEX_MAX-1].line != -1); }
diff --git a/src/largefile/GotoDialog.hpp b/src/largefile/GotoDialog.hpp
new file mode 100644
index 0000000..bff548f
--- /dev/null
+++ b/src/largefile/GotoDialog.hpp
@@ -0,0 +1,37 @@
+#ifndef HPP_GOTODIALOG
+#define HPP_GOTODIALOG
+
+#include <gtk/gtk.h>
+
+namespace largefile {
+
+	class Largefile;
+	
+	struct RadioButton {
+		GtkWidget * widget;
+		gint index;
+	};
+	
+	struct GotoDialog {
+		GotoDialog(void) {
+			lf = NULL;
+			widget = NULL;
+			radio_byte.widget = NULL;
+			radio_byte.index = 0;
+			radio_line.widget = NULL;
+			radio_line.index = 1;
+			radio_perc.widget = NULL;
+			radio_perc.index = 2;
+			active_index = 0;
+		}
+		
+		Largefile * lf;
+		GtkWidget * widget;
+		RadioButton radio_byte;
+		RadioButton radio_line;
+		RadioButton radio_perc;
+		gint active_index;
+	};
+}
+
+#endif
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index cda72b6..28f68c3 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -25,6 +25,7 @@
 #include <iostream>
 #include <string>
 #include <sstream>
+#include "GotoDialog.hpp"
 #include "Largefile.hpp"
 #include "File.hpp"
 #include "CsvParser.hpp"
@@ -42,22 +43,61 @@ AppendProcessId (const gchar * pre) {
 }
 
 static void
-GotoDialogResponseCallback (GtkWidget * dialog, gint response, gpointer data) {
-	Largefile * lf = (Largefile *)data;
+GotoDialogResponseCallback (GtkWidget * gtkdialog, gint response, gpointer data) {
+	GotoDialog * dialog = (GotoDialog *)data;
 	
 	if (response == GTK_RESPONSE_OK) {
-		GList * children = gtk_container_get_children ( GTK_CONTAINER (GTK_DIALOG(dialog)->vbox) );
+		GList * children = gtk_container_get_children ( GTK_CONTAINER (GTK_DIALOG(gtkdialog)->vbox) );
 		GtkWidget * entry = (GtkWidget *)g_list_nth_data (children, 1);
 		const gchar * value = gtk_entry_get_text ( GTK_ENTRY (entry) );
 
 		if (value && *value != '\0') {
-			lf->Read (lf->workbook()->focus_sheet, atol (value) - 1, 1000);
+			switch (dialog->active_index) {
+				// byte offset
+				case 0: {
+					std::cerr << "offset\n";
+				}
+				break;
+
+				// absolute line
+				case 1: {
+					dialog->lf->ReadLine (dialog->lf->workbook()->focus_sheet,
+												 atol (value) - 1,
+												 1000);
+				}
+				break;
+
+				// relative percentage
+				case 2: {
+					std::cerr << "percentage\n";
+				}
+				break;
+			}
 		}
 
 		gtk_entry_set_text (GTK_ENTRY (entry), "");
 	}
 	
-	gtk_widget_hide_all (dialog);
+	gtk_widget_hide_all (gtkdialog);
+}
+
+static void
+GotoDialogRadioToggleCallback (GtkToggleButton * button, gpointer data) {
+	GtkWidget * widget = GTK_WIDGET (button);
+	GotoDialog * dialog = (GotoDialog *)data;
+
+	if (GTK_TOGGLE_BUTTON (button)->active) {
+		if (dialog->radio_byte.widget == widget) {
+			dialog->active_index = 0;
+		}
+		else if (dialog->radio_line.widget == widget) {
+			dialog->active_index = 1;
+		}
+		else if (dialog->radio_perc.widget == widget) {
+			dialog->active_index = 2;
+		}
+	}
+	std::cout<<"toggled\n";
 }
 
 static void
@@ -99,33 +139,37 @@ CsvOpenDialogCallback (GtkWidget * w, gpointer data) {
 static gint
 GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	gint result = FALSE;
-	static GtkWidget * goto_dialog = NULL;
 	Largefile * lf = (Largefile *)data;
+	GotoDialog * dialog = lf->gotodialog();
 	Workbook * wb = lf->workbook();
 	Sheet * sheet = wb->focus_sheet;
 
 	// Only create the dialog the first time we run this method. 
-	if (goto_dialog == NULL) {
-		goto_dialog = gtk_dialog_new_with_buttons ("Goto position ", GTK_WINDOW (window),
-																 (GtkDialogFlags) (GTK_DIALOG_MODAL | GTK_DIALOG_NO_SEPARATOR),
-																 GTK_STOCK_OK,
-																 GTK_RESPONSE_OK,
-																 GTK_STOCK_CANCEL,
-																 GTK_RESPONSE_CANCEL,
-																 NULL);
+	if (dialog->widget == NULL) {
+		dialog->lf = lf;
+		
+		dialog->widget = gtk_dialog_new_with_buttons ("Goto position ", GTK_WINDOW (window),
+																	(GtkDialogFlags) (GTK_DIALOG_MODAL | GTK_DIALOG_NO_SEPARATOR),
+																	GTK_STOCK_OK,
+																	GTK_RESPONSE_OK,
+																	GTK_STOCK_CANCEL,
+																	GTK_RESPONSE_CANCEL,
+																	NULL);
 
 		GtkWidget * gtk_frame = gtk_frame_new ("Jump Options");
 		GtkWidget * gtk_hbox = gtk_hbox_new (FALSE, 0);
-		GtkWidget * gtk_radiobyte = gtk_radio_button_new_with_label (NULL,
-																						 "Offset");
+		GtkWidget * gtk_radiobyte = gtk_radio_button_new_with_label (NULL, "Offset");
 		GtkWidget * gtk_radioline = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (gtk_radiobyte),
 																						  "Line");
 		GtkWidget * gtk_radioperc = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (gtk_radiobyte),
 																						  "Percent");
-		GSList * group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (gtk_radiobyte));
-		
-		GtkWidget * box = GTK_DIALOG (goto_dialog)->vbox;
+		GtkWidget * box = GTK_DIALOG (dialog->widget)->vbox;
 		GtkWidget * entry = gtk_entry_new_with_max_length (30);
+
+		// Set the GotoDialog RadioButton objects to the proper pointers.
+		dialog->radio_byte.widget = gtk_radiobyte;
+		dialog->radio_line.widget = gtk_radioline;
+		dialog->radio_perc.widget = gtk_radioperc;
 		
 		gtk_container_add (GTK_CONTAINER (gtk_hbox), gtk_radiobyte);
 		gtk_container_add (GTK_CONTAINER (gtk_hbox), gtk_radioline);
@@ -138,13 +182,23 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 		gtk_box_pack_end (GTK_BOX (box), entry, TRUE, TRUE, 0);
 								
 		gtk_widget_show_all (box);
+
+		// Connect the signals to we can do fancy switching.
+		g_signal_connect (G_OBJECT (gtk_radiobyte), "toggled",
+								G_CALLBACK (GotoDialogRadioToggleCallback),
+								dialog);
+		g_signal_connect (G_OBJECT (gtk_radioline), "toggled",
+								G_CALLBACK (GotoDialogRadioToggleCallback),
+								dialog);
+		g_signal_connect (G_OBJECT (gtk_radioperc), "toggled",
+								G_CALLBACK (GotoDialogRadioToggleCallback),
+								dialog);
 		
-		g_signal_connect (G_OBJECT (goto_dialog), "response", G_CALLBACK (GotoDialogResponseCallback), lf);
+		g_signal_connect (G_OBJECT (dialog->widget), "response",
+								G_CALLBACK (GotoDialogResponseCallback), dialog);
 		
-		g_signal_connect (G_OBJECT (goto_dialog), "delete-event",
+		g_signal_connect (G_OBJECT (dialog->widget), "delete-event",
 								G_CALLBACK (gtk_widget_hide_on_delete), NULL);
-
-		lf->setGotoDialogRadioGroup (group);
 	}	
 	
 	//	int vposition = std::abs((int)gtksheet->vadjustment->value);
@@ -154,13 +208,13 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	switch (event->keyval) {
 		case GDK_F1: {
 			if (sheet != NULL) {
-				gtk_widget_show_all (goto_dialog);
+				gtk_widget_show_all (dialog->widget);
 			}
 		}
 		break;
 		
 		case GDK_Page_Up: {
-			lf->Read (sheet, cursor, 100);
+			lf->ReadLine (sheet, cursor, 100);
 			cursor += 100;
 		}
 		result = TRUE;
@@ -172,7 +226,7 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 			else
 				cursor -= 100;
 			
-			lf->Read (sheet, cursor, 100);
+			lf->ReadLine (sheet, cursor, 100);
 		}
 		result = TRUE;
 		break;
@@ -257,7 +311,7 @@ Largefile::BuildLayout (void) {
 }
 
 bool
-Largefile::Read (Sheet * sheet, off64_t start, off64_t N) {
+Largefile::ReadLine (Sheet * sheet, off64_t start, off64_t N) {
 	this->lock();
 	std::string key = sheet->name;
 	
@@ -268,7 +322,7 @@ Largefile::Read (Sheet * sheet, off64_t start, off64_t N) {
 	}
 
 	FileDispatcher * fd = it->second;
-	fd->Read (start, N);
+	fd->Readline (start, N);
 	this->unlock();
 	return true;
 }
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
index 89c4e69..2302cde 100755
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -25,6 +25,7 @@
 #include "../Plugin.hpp"
 #include "../Application.hpp"
 #include "../config.h"
+#include "GotoDialog.hpp"
 
 namespace largefile {
 
@@ -32,6 +33,7 @@ namespace largefile {
 	private:
 		typedef std::map<std::string,FileDispatcher *> FilenameMap;
 
+		GotoDialog goto_dialog;
 		GtkWidget * gtk_statusbar;
 		FILE * pktlog;
 		FilenameMap mapping;
@@ -47,11 +49,13 @@ namespace largefile {
 				
 		bool OpenFile (Sheet * sheet, const std::string & filename);
 		bool CloseFile (const std::string & filename);
-		bool Read (Sheet * sheet, off64_t start, off64_t N);
-
+		bool ReadLine (Sheet * sheet, off64_t start, off64_t N);
+		bool ReadOffset (Sheet * sheet, off64_t start, off64_t N);
+		bool ReadPercentage (Sheet * sheet, guint percent, off64_t N);
+		
 		inline GtkWidget * statusbar (void) { return this->gtk_statusbar; }
 		inline void setGotoDialogRadioGroup (GSList * group) { this->gtk_togglegroup = group; }
-		inline GSList * togglegroup (void) { return this->gtk_togglegroup; }
+		inline GotoDialog * gotodialog() { return &this->goto_dialog; }
 	};
 
 }

commit d234bcd80f21c0132c66ee56020c3b44cb43399c
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jul 22 17:09:51 2009 -0400

    (1) Modified code towards getting byte, offset, and line radio buttons working
    inside of the goto dialog.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 2947879..b73b9ff 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -93,7 +93,7 @@ namespace largefile {
 	}
   
 	void *
-	FileDispatcher::run (void * null) {
+	FileDispatcher::run (void * data) {
 		this->Index();
 		
 		while (this->isRunning() == true) {
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index add2d0f..cda72b6 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -47,7 +47,7 @@ GotoDialogResponseCallback (GtkWidget * dialog, gint response, gpointer data) {
 	
 	if (response == GTK_RESPONSE_OK) {
 		GList * children = gtk_container_get_children ( GTK_CONTAINER (GTK_DIALOG(dialog)->vbox) );
-		GtkWidget * entry = (GtkWidget *)g_list_nth_data (children, 0);
+		GtkWidget * entry = (GtkWidget *)g_list_nth_data (children, 1);
 		const gchar * value = gtk_entry_get_text ( GTK_ENTRY (entry) );
 
 		if (value && *value != '\0') {
@@ -113,21 +113,38 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 																 GTK_STOCK_CANCEL,
 																 GTK_RESPONSE_CANCEL,
 																 NULL);
+
+		GtkWidget * gtk_frame = gtk_frame_new ("Jump Options");
+		GtkWidget * gtk_hbox = gtk_hbox_new (FALSE, 0);
+		GtkWidget * gtk_radiobyte = gtk_radio_button_new_with_label (NULL,
+																						 "Offset");
+		GtkWidget * gtk_radioline = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (gtk_radiobyte),
+																						  "Line");
+		GtkWidget * gtk_radioperc = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (gtk_radiobyte),
+																						  "Percent");
+		GSList * group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (gtk_radiobyte));
 		
 		GtkWidget * box = GTK_DIALOG (goto_dialog)->vbox;
 		GtkWidget * entry = gtk_entry_new_with_max_length (30);
+		
+		gtk_container_add (GTK_CONTAINER (gtk_hbox), gtk_radiobyte);
+		gtk_container_add (GTK_CONTAINER (gtk_hbox), gtk_radioline);
+		gtk_container_add (GTK_CONTAINER (gtk_hbox), gtk_radioperc);
+		gtk_container_add (GTK_CONTAINER (gtk_frame), gtk_hbox);
 
 		gtk_box_set_spacing (GTK_BOX (box), 18);
 			
-		gtk_box_pack_start (GTK_BOX (box), entry, TRUE, TRUE, 0);
-				
+		gtk_box_pack_start (GTK_BOX (box), gtk_frame, TRUE, TRUE, 0);
+		gtk_box_pack_end (GTK_BOX (box), entry, TRUE, TRUE, 0);
+								
 		gtk_widget_show_all (box);
 		
 		g_signal_connect (G_OBJECT (goto_dialog), "response", G_CALLBACK (GotoDialogResponseCallback), lf);
 		
 		g_signal_connect (G_OBJECT (goto_dialog), "delete-event",
 								G_CALLBACK (gtk_widget_hide_on_delete), NULL);
-		
+
+		lf->setGotoDialogRadioGroup (group);
 	}	
 	
 	//	int vposition = std::abs((int)gtksheet->vadjustment->value);
@@ -167,6 +184,8 @@ Largefile::Largefile (Application * appstate, Handle * platform)
 	: Plugin (appstate, platform) {
 
 	this->wb = workbook_open (appstate->gtkwindow(), "largefile");
+	this->gtk_statusbar = NULL;
+	this->gtk_togglegroup = NULL;
 	
 	ConfigPair * logpath =
 		appstate->config()->get_pair (appstate->config(), "largefile", "log", "path");
@@ -195,7 +214,12 @@ Largefile::~Largefile (void) {
 GtkWidget *
 Largefile::CreateStatusBar (void) {
 	GtkWidget * statusbar = gtk_statusbar_new();
+	
+	gtk_statusbar_push (GTK_STATUSBAR (statusbar),
+							  gtk_statusbar_get_context_id(GTK_STATUSBAR (statusbar), "Ready"),
+							  "Ready");
 
+	gtk_widget_show (statusbar);
 	return statusbar;
 }
 
@@ -216,19 +240,19 @@ Largefile::CreateMainMenu (void) {
 GtkWidget *
 Largefile::BuildLayout (void) {
 	GtkWidget * gtk_menu = this->app()->gtkmenu();
-	GtkWidget * statusbar = this->CreateStatusBar();
+	//	GtkWidget * statusbar = this->CreateStatusBar();
 	GtkWidget * box = gtk_vbox_new (FALSE, 0);
 	GtkWidget * largefile_menu = this->CreateMainMenu();
 	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
 
-	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
-
 	wb->signals[SIG_WORKBOOK_CHANGED] = this->app()->signals[Application::SHEET_CHANGED];
 	wb->gtk_box = box;
 
+	//	gtk_box_pack_end (GTK_BOX (box), statusbar, FALSE, FALSE, 0);
+	gtk_box_pack_start (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
 	gtk_box_pack_start (GTK_BOX (this->app()->gtkvbox()), box, FALSE, FALSE, 0);
 
-	this->statusbar = statusbar;
+	//	this->gtk_statusbar = statusbar;
 	return box;
 }
 
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
index 740efea..89c4e69 100755
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -31,22 +31,27 @@ namespace largefile {
 	class Largefile : public Plugin {
 	private:
 		typedef std::map<std::string,FileDispatcher *> FilenameMap;
-	
+
+		GtkWidget * gtk_statusbar;
 		FILE * pktlog;
 		FilenameMap mapping;
-
-		void CreateMainMenu (void);
-		void CreateStatusBar (void);
+		GSList * gtk_togglegroup;
+		
+		GtkWidget * CreateMainMenu (void);
+		GtkWidget * CreateStatusBar (void);
 	public:
 		Largefile (Application * appstate, Handle * platform);
 		virtual ~Largefile (void);
 
-		void BuildLayout (void);
-		void CreateMainMenu (void);
-		
+		GtkWidget * BuildLayout (void);
+				
 		bool OpenFile (Sheet * sheet, const std::string & filename);
 		bool CloseFile (const std::string & filename);
 		bool Read (Sheet * sheet, off64_t start, off64_t N);
+
+		inline GtkWidget * statusbar (void) { return this->gtk_statusbar; }
+		inline void setGotoDialogRadioGroup (GSList * group) { this->gtk_togglegroup = group; }
+		inline GSList * togglegroup (void) { return this->gtk_togglegroup; }
 	};
 
 }

commit 33555aa133f73152364560d4e560bc8376c06f56
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jul 22 14:30:07 2009 -0400

    (1) Moved widget building methods into Largefile object.

diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index 43f047c..add2d0f 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -60,6 +60,42 @@ GotoDialogResponseCallback (GtkWidget * dialog, gint response, gpointer data) {
 	gtk_widget_hide_all (dialog);
 }
 
+static void
+CsvOpenDialogCallback (GtkWidget * w, gpointer data) {
+	GtkWidget * open_dialog = NULL;
+	Largefile * lf = (Largefile *)data;
+	open_dialog = gtk_file_chooser_dialog_new ("Open CSV File",
+															 GTK_WINDOW (lf->app()->gtkwindow()),
+															 GTK_FILE_CHOOSER_ACTION_OPEN,
+															 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+															 GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+															 NULL);  
+  
+	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (open_dialog), TRUE);
+				
+	if (gtk_dialog_run (GTK_DIALOG (open_dialog)) == GTK_RESPONSE_ACCEPT) {
+		gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (open_dialog));
+
+		Sheet * sheet = lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
+
+		if (sheet == NULL) {
+			g_warning ("Failed adding new sheet because one already exists");
+		}
+		else {
+			if (lf->OpenFile (sheet, filename) == true) {
+				// STUB: Do something magical.
+			}
+			else {
+				// STUB: The opening of the file failed. Do something meaningful here.
+			}
+		}
+		
+		g_free (filename);
+	}
+
+	gtk_widget_destroy (open_dialog);
+}
+
 static gint
 GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	gint result = FALSE;
@@ -156,6 +192,46 @@ Largefile::Largefile (Application * appstate, Handle * platform)
 Largefile::~Largefile (void) {
 }
 
+GtkWidget *
+Largefile::CreateStatusBar (void) {
+	GtkWidget * statusbar = gtk_statusbar_new();
+
+	return statusbar;
+}
+
+GtkWidget *
+Largefile::CreateMainMenu (void) {
+	GtkWidget * lfmenu = gtk_menu_new();
+	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
+	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
+	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
+
+	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
+							G_CALLBACK (CsvOpenDialogCallback), this);
+	
+	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
+	return lfmenu_item;
+}
+
+GtkWidget *
+Largefile::BuildLayout (void) {
+	GtkWidget * gtk_menu = this->app()->gtkmenu();
+	GtkWidget * statusbar = this->CreateStatusBar();
+	GtkWidget * box = gtk_vbox_new (FALSE, 0);
+	GtkWidget * largefile_menu = this->CreateMainMenu();
+	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
+
+	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
+
+	wb->signals[SIG_WORKBOOK_CHANGED] = this->app()->signals[Application::SHEET_CHANGED];
+	wb->gtk_box = box;
+
+	gtk_box_pack_start (GTK_BOX (this->app()->gtkvbox()), box, FALSE, FALSE, 0);
+
+	this->statusbar = statusbar;
+	return box;
+}
+
 bool
 Largefile::Read (Sheet * sheet, off64_t start, off64_t N) {
 	this->lock();
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
index 149f718..740efea 100755
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -34,10 +34,16 @@ namespace largefile {
 	
 		FILE * pktlog;
 		FilenameMap mapping;
+
+		void CreateMainMenu (void);
+		void CreateStatusBar (void);
 	public:
 		Largefile (Application * appstate, Handle * platform);
 		virtual ~Largefile (void);
 
+		void BuildLayout (void);
+		void CreateMainMenu (void);
+		
 		bool OpenFile (Sheet * sheet, const std::string & filename);
 		bool CloseFile (const std::string & filename);
 		bool Read (Sheet * sheet, off64_t start, off64_t N);
diff --git a/src/largefile/PluginFactory.cpp b/src/largefile/PluginFactory.cpp
index 4f7c90e..b87f7ce 100644
--- a/src/largefile/PluginFactory.cpp
+++ b/src/largefile/PluginFactory.cpp
@@ -24,84 +24,14 @@
 #include "../config.h"
 #include "../Application.hpp"
 
-using largefile::Largefile;
-
-static void
-CSVOpenDialogCallback (GtkWidget * w, gpointer data) {
-	GtkWidget * open_dialog = NULL;
-	Largefile * lf = (Largefile *)data;
-	open_dialog = gtk_file_chooser_dialog_new ("Open CSV File",
-															 GTK_WINDOW (lf->app()->gtkwindow()),
-															 GTK_FILE_CHOOSER_ACTION_OPEN,
-															 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-															 GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-															 NULL);  
-  
-	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (open_dialog), TRUE);
-				
-	if (gtk_dialog_run (GTK_DIALOG (open_dialog)) == GTK_RESPONSE_ACCEPT) {
-		gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (open_dialog));
-
-		Sheet * sheet = lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
-
-		if (sheet == NULL) {
-			g_warning ("Failed adding new sheet because one already exists");
-		}
-		else {
-			if (lf->OpenFile (sheet, filename) == true) {
-				// STUB: Do something magical.
-			}
-			else {
-				// STUB: The opening of the file failed. Do something meaningful here.
-			}
-		}
-		
-		g_free (filename);
-	}
-
-	gtk_widget_destroy (open_dialog);
-}
-
-static GtkWidget *
-CreateLargefileMenu (Application * appstate, Largefile * lf, GtkWidget * window) {
-	GtkWidget * lfmenu = gtk_menu_new();
-	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
-	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
-	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
-
-	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
-							G_CALLBACK (CSVOpenDialogCallback), lf);
-	
-	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
-	return lfmenu_item;
-}
-
-static GtkWidget *
-BuildNotebookLayout (Application * app, Largefile * lf) {
-	Workbook * wb = lf->workbook();
-	GtkWidget * gtk_menu = app->gtkmenu();
-	GtkWidget * box = gtk_vbox_new (FALSE, 0);
-	GtkWidget * largefile_menu = CreateLargefileMenu (app, lf, app->gtkwindow());
-	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
-
-	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
-
-	wb->signals[SIG_WORKBOOK_CHANGED] = app->signals[Application::SHEET_CHANGED];
-	wb->gtk_box = box;
-
-	gtk_box_pack_start (GTK_BOX (app->gtkvbox()), box, FALSE, FALSE, 0);
-
-	return box;
-}
-
 extern "C" {
   Plugin *
   PluginFactoryCreate (Application * appstate, Handle * platform) {
     ASSERT (appstate != NULL);
     ASSERT (platform != NULL);
-	 Largefile * lf = new Largefile (appstate, platform);
-	 
-	 GtkWidget * box = BuildNotebookLayout (appstate, lf);
+	 largefile::Largefile * lf = new largefile::Largefile (appstate, platform);
+	 GtkWidget * box = lf->BuildLayout();
+
 	 gtk_widget_show (box);
     return lf;
   }

commit 6b6f1cc0069c1fa3c7ec600b163fcea5d4937237
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jul 22 14:07:32 2009 -0400

    (1) Changed formatting and nomenclature of plugin methods.
    (2) Fixed locking issue inside of libgtkworkbook and plugins. There should
    no longer be an issue with drawing to the screen. Locks were placed on the
    callback methods when they should not have been.
    (3) Fixed locking issues inside of thread code; run state cannot be changed
    without using the Runnable inherited methods now.
    (4) Renamed plugin_main.cpp to PluginFactory.cpp to signify the plugin
    architecture change. The loaded symbol is now PluginFactoryCreate.

diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
index 77dd7c9..4bd95b8 100755
--- a/gtkworkbook/sheet.c
+++ b/gtkworkbook/sheet.c
@@ -119,13 +119,9 @@ Sheet *
 sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
 {
 	ASSERT (book != NULL);
-
-	gdk_threads_enter();
 	
 	Sheet * sheet = sheet_object_init (book, label, rows, columns);
 
-	gdk_threads_leave();
-	
 	/* STUB: Perform anything that is based on a style here. */
 
 	return sheet;
@@ -221,8 +217,6 @@ sheet_method_load (Sheet * sheet, const gchar * filepath)
 					  filepath);
       return FALSE;
 	}
-
-	gdk_threads_enter ();
 	
 	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
 	struct geometryFileHeader header = {-1,-1,-1};
@@ -234,8 +228,7 @@ sheet_method_load (Sheet * sheet, const gchar * filepath)
       g_warning ("Geometry file version %d is not accepted. (%d)",
 					  header.fileVersion, GEOMETRY_FILE_VERSION);
       FCLOSE (fp);
-      gdk_threads_leave ();
-      return FALSE;
+		return FALSE;
 	}
 
 	while (fread ((void *)&entry, sizeof (struct geometryFileEntry), 1, fp) > 0)
@@ -265,7 +258,6 @@ sheet_method_load (Sheet * sheet, const gchar * filepath)
 	}
 
 	FCLOSE (fp);
-	gdk_threads_leave ();
 	return TRUE;
 }
 
@@ -285,8 +277,6 @@ sheet_method_save (Sheet * sheet, const gchar * filepath) {
 					  filepath);
       return FALSE;
 	}
-  
-	gdk_threads_enter ();
 
 	GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
 	struct geometryFileHeader header = {
@@ -329,7 +319,6 @@ sheet_method_save (Sheet * sheet, const gchar * filepath) {
 	}
 
 	FCLOSE (fp);
-	gdk_threads_leave ();
 	return TRUE;
 }
 
@@ -339,7 +328,6 @@ sheet_method_save (Sheet * sheet, const gchar * filepath) {
 static void 
 sheet_method_set_attention (Sheet * sheet, gint attention) {
 	ASSERT (sheet != NULL);
-	gdk_threads_enter ();
 
 	sheet->attention = attention;
 
@@ -348,8 +336,6 @@ sheet_method_set_attention (Sheet * sheet, gint attention) {
 	if ((sheet->has_focus == FALSE) && (sheet->notices > 0)) {
       
 	}
-
-	gdk_threads_leave ();
 }
 
 /* @description: This method destroys the Sheet object.
@@ -357,13 +343,10 @@ sheet_method_set_attention (Sheet * sheet, gint attention) {
 static void
 sheet_method_destroy (Sheet * sheet) {
 	ASSERT (sheet != NULL);
-	gdk_threads_enter ();
 
 	DOUBLE_UNLINK (sheet);
 
 	sheet_object_free (sheet);
-
-	gdk_threads_leave ();
 }
 
 /* @description: This method frees the memory that was used by the Sheet
@@ -385,9 +368,6 @@ sheet_method_apply_cellrange (Sheet * sheet,
 	ASSERT (sheet != NULL);
 	g_return_if_fail (range != NULL);
 	g_return_if_fail (attrib != NULL);
-	gdk_threads_enter ();
-
-	gdk_threads_leave ();
 }
 
 static void
@@ -397,7 +377,6 @@ sheet_method_apply_cellrow (Sheet * sheet,
 									 gint size) {
 	ASSERT (sheet != NULL);
 	g_return_if_fail (array != NULL);
-	gdk_threads_enter();
 	
 	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
 	GtkSheetCell ** cell;
@@ -430,8 +409,6 @@ sheet_method_apply_cellrow (Sheet * sheet,
 
 		item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
 	}
-	
-	gdk_threads_leave();
 }
 
 static void
@@ -441,7 +418,6 @@ sheet_method_apply_cellarray (Sheet * sheet,
 {
 	ASSERT (sheet != NULL);
 	g_return_if_fail (array != NULL);
-	gdk_threads_enter ();
 	
 	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
 
@@ -469,8 +445,6 @@ sheet_method_apply_cellarray (Sheet * sheet,
 
 		cell->value->str[0] = cell->attributes.bgcolor->str[0] = cell->attributes.fgcolor->str[0] = 0;
 	}
-
-	gdk_threads_leave ();
 }
 
 /* @description: This method applies the settings from a Cell object into the
@@ -483,7 +457,6 @@ sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
 {
 	ASSERT (sheet != NULL);
 	g_return_if_fail (cell != NULL);
-	gdk_threads_enter ();
 
 	if (sheet->has_focus == FALSE)
 		sheet->notices++;
@@ -493,7 +466,6 @@ sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
 							  cell->column,
 							  cell->attributes.justification,
 							  cell->value->str);
-	gdk_threads_leave ();
 
 	if (!IS_NULLSTR (cell->attributes.bgcolor->str))
 		sheet->range_set_background (sheet, 
@@ -527,14 +499,12 @@ sheet_method_range_set_background (Sheet * sheet,
 
 	/* The color needs to be taken from the colormap; there is an alternative
 		way to do this if we use #rgb or #rrggbb formats. */
-	gdk_threads_enter ();
 	gdk_color_parse (desc, &color);
 	gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
 						  &color);
   
 	gtk_sheet_range_set_background (GTK_SHEET (sheet->gtk_sheet),
 											  range, &color);
-	gdk_threads_leave ();
 }
 
 /* @description: This method changes the foreground color over a range of
@@ -553,14 +523,12 @@ sheet_method_range_set_foreground (Sheet * sheet,
   
    /* The color needs to be taken from the colormap; there is an alternative
 		way to do this if we use #rgb or #rrggbb formats. */
-	gdk_threads_enter ();
 	gdk_color_parse (desc, &color);
 	gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
 						  &color);
       
 	gtk_sheet_range_set_foreground (GTK_SHEET (sheet->gtk_sheet),
 											  range, &color);
-	gdk_threads_leave ();
 }
 
 /* @description: This method manually sets a GtkSheet cell's value. It does
@@ -575,7 +543,6 @@ sheet_method_set_cell (Sheet * sheet,
 							  const gchar * value)
 {
 	ASSERT (sheet != NULL);
-	gdk_threads_enter ();
 
 	if (sheet->has_focus == FALSE)
 		sheet->notices++;
@@ -584,6 +551,4 @@ sheet_method_set_cell (Sheet * sheet,
 							  col, 
 							  GTK_JUSTIFY_LEFT, 
 							  value);
-
-	gdk_threads_leave ();
 }
diff --git a/gtkworkbook/workbook.c b/gtkworkbook/workbook.c
index c6107fe..fa95442 100755
--- a/gtkworkbook/workbook.c
+++ b/gtkworkbook/workbook.c
@@ -49,9 +49,7 @@ workbook_open (GtkWidget * window, const gchar * filename)
 		At this point we would load up the configuration files for the styles,
 		sheets and plugins to be loaded then this would all be executed here. */
 
-	gdk_threads_enter();
 	Workbook * book = workbook_object_init (window, filename);
-	gdk_threads_leave();
 	
 	return book;
 }
@@ -136,12 +134,10 @@ workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
 		/* Remove the sheet from the GtkNotebook */
 		if (it == sheet)
       {
-			gdk_threads_enter ();
 			gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
 														  sheet->gtk_box);
 			gtk_notebook_remove_page (GTK_NOTEBOOK (wb->gtk_notebook), page); 
 			gtk_widget_queue_draw (wb->gtk_notebook);
-			gdk_threads_leave ();
 			return;
       }
 	}
@@ -159,11 +155,9 @@ workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
 static gboolean
 workbook_method_move_sheet_index (Workbook * wb, Sheet * sheet, gint index)
 {
-	gdk_threads_enter ();
 	gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
 										 sheet->gtk_box,
 										 index);
-	gdk_threads_leave ();
 	return TRUE;
 }
 
@@ -186,8 +180,6 @@ workbook_method_move_sheet (Workbook * wb,
 					  sheet->name, wb->filename);
       return FALSE;
 	}
-
-	gdk_threads_enter ();
 	
 	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
 												  sh->gtk_box);
@@ -204,7 +196,6 @@ workbook_method_move_sheet (Workbook * wb,
 	gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
 										 sheet->gtk_box,
 										 page);
-	gdk_threads_leave ();
 	return TRUE;
 }
 
diff --git a/shared/concurrent/Runnable.cc b/shared/concurrent/Runnable.cc
new file mode 100644
index 0000000..14668ab
--- /dev/null
+++ b/shared/concurrent/Runnable.cc
@@ -0,0 +1,44 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Runnable.hpp"
+
+namespace concurrent {
+	IRunnable::IRunnable (void)
+		: running(false) {
+	}
+
+	IRunnable::~IRunnable (void) {
+	}
+
+	bool
+	IRunnable::isRunning (void) {
+		bool result;
+		this->mutex.lock();
+		result = this->running;
+		this->mutex.unlock();
+		return result;
+	}
+
+	void
+	IRunnable::setRunning (bool r) {
+		this->mutex.lock();
+		this->running = r;
+		this->mutex.unlock();
+	}
+}
diff --git a/shared/concurrent/Runnable.hpp b/shared/concurrent/Runnable.hpp
index f2241b5..bc054a3 100755
--- a/shared/concurrent/Runnable.hpp
+++ b/shared/concurrent/Runnable.hpp
@@ -19,16 +19,22 @@
 #ifndef HPP_CONCURRENT_RUNNABLE
 #define HPP_CONCURRENT_RUNNABLE
 
-class IRunnable {
-protected:
-  volatile bool running;
-public:
-  IRunnable (void) { this->running = false; }
-  virtual ~IRunnable (void) { }
+#include "Mutex.hpp"
 
-  virtual void * run (void *) = 0;
-  
-  inline bool isRunning (void) const { return this->running; }
-};
+namespace concurrent {
+
+	class IRunnable {
+	private:
+		RecursiveMutex mutex;
+		volatile bool running;
+	public:
+		IRunnable (void);
+		virtual ~IRunnable (void);
 
+		virtual void * run (void *) = 0;
+  
+		bool isRunning (void);
+		void setRunning (bool r);
+	};
+}
 #endif
diff --git a/shared/concurrent/Thread.cc b/shared/concurrent/Thread.cc
index dbb4b72..b697ae0 100755
--- a/shared/concurrent/Thread.cc
+++ b/shared/concurrent/Thread.cc
@@ -25,7 +25,11 @@ namespace concurrent {
 
 	static void *
 	thread_run (void * runner) {
-		void * rvalue = ((IRunnable *)runner)->run (NULL);
+		IRunnable * thread = (IRunnable *)runner;
+
+		thread->setRunning(true);
+		void * rvalue = thread->run (NULL);
+		thread->setRunning(false);
 		return rvalue;
 	}
 
@@ -53,15 +57,15 @@ namespace concurrent {
 	}
 
 	Thread::~Thread (void) {
-		if (this->running == true) {
-			this->running = false;
+		if (this->isRunning() == true) {
+			this->setRunning(false);
 			this->join();
 		}
 	}
 
 	void 
 	Thread::interrupt (void) {
-		this->running = false;
+		this->setRunning(false);
 		pthread_cancel (this->thread);
 		pthread_detach (this->thread);
 	}
@@ -73,7 +77,7 @@ namespace concurrent {
 
 	void * 
 	Thread::stop (void) {
-		this->running = false;
+		this->setRunning(false);
 		return this->join();
 	}
 
@@ -91,10 +95,8 @@ namespace concurrent {
 
 	bool 
 	Thread::start (void) {
-		if (this->running == true)
+		if (this->isRunning() == true)
 			return false;
-
-		this->running = true;
 		
 		if (this->runner != NULL) {
 			if (pthread_create (&this->thread,
@@ -110,7 +112,6 @@ namespace concurrent {
 									  this))
 				return false;
 		}
-
 		return true;
 	}
 
@@ -123,7 +124,8 @@ namespace concurrent {
 	}
 
 	void *
-	Thread::run (void *null) {
+	Thread::run (void * null) {
+		std::cerr << "Thread::run : null runner\n";
 		pthread_exit (null);
 	}
 
diff --git a/shared/concurrent/ThreadPool.cc b/shared/concurrent/ThreadPool.cc
index cd6890e..62c95be 100755
--- a/shared/concurrent/ThreadPool.cc
+++ b/shared/concurrent/ThreadPool.cc
@@ -27,9 +27,7 @@ namespace concurrent {
 
   void *
   ThreadPool::Task::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
+	  while (this->isRunning() == true) {
 		 if (this->pool->isRunning() == false)
 			 break;
       
diff --git a/shared/proactor/InputDispatcher.cc b/shared/proactor/InputDispatcher.cc
index 438abbe..52210fd 100755
--- a/shared/proactor/InputDispatcher.cc
+++ b/shared/proactor/InputDispatcher.cc
@@ -40,17 +40,11 @@ namespace proactor {
 
 	void *
 	InputDispatcher::run (void * null) {
-		this->running = true;
-
-		while (this->running == true) {
+		while (this->isRunning() == true) {
 			// Dispatch all of the input items on the queue.
 			this->inputQueue.lock();
 
 			while (this->inputQueue.size() > 0) {
-
-				if (this->running == false)
-					break;
-
 				// For right now all we're doing is pushing up the chain.
 				this->pro->onReadComplete ( this->inputQueue.pop() );
 			}
diff --git a/shared/proactor/Proactor.cc b/shared/proactor/Proactor.cc
index 17aeb5a..16426e6 100755
--- a/shared/proactor/Proactor.cc
+++ b/shared/proactor/Proactor.cc
@@ -116,18 +116,12 @@ namespace proactor {
 
 	void *
 	Proactor::run (void * null) {
-		this->running = true;
-  
 		WorkerListType::iterator it;
 
-		while (this->running == true) {
+		while (this->isRunning() == true) {
 			this->events.lock();
 
 			while (this->events.size() > 0) {
-
-				if (this->running == false)
-					break;
-
 				Event e = this->events.pop();
 
 				// We are throwing events with no handlers to catch them.
@@ -138,10 +132,6 @@ namespace proactor {
 				it = this->eventsToHandlers[e.id]->begin();
 	  
 				while (it != this->eventsToHandlers[e.id]->end()) {
-
-					if (this->running == false)
-						break;
-
 					Worker * j = (*it);
 	      
 					j->pushInputQueue (e.buf);
diff --git a/src/Plugin.cpp b/src/Plugin.cpp
index 0ed0221..25c1b96 100755
--- a/src/Plugin.cpp
+++ b/src/Plugin.cpp
@@ -46,7 +46,7 @@ Plugin::open_plugin (Application * appstate, const std::string filename) {
 
 	// Grab the main method from the plugin so we can execute to get an object back.
 	Plugin_Main plugin_main;
-	if ((plugin_main = (Plugin_Main)LIBRARY_SYM(platform->handle, "plugin_main")) == NULL) {
+	if ((plugin_main = (Plugin_Main)LIBRARY_SYM(platform->handle, "PluginFactoryCreate")) == NULL) {
 		fprintf (stderr, "%s\n", LIBRARY_ERROR());
 		exit(1);
 	}
diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index c63a8fc..19a7e71 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -92,7 +92,6 @@ namespace largefile {
 
 	void *
 	CsvParser::run (void * null) {
-		this->running = true;
 		std::queue<std::string> queue;
 		struct csv_parser csv;
 		struct csv_column column = {sheet,
@@ -108,7 +107,7 @@ namespace largefile {
 			return NULL;
 		}
 
-		while (this->running == true) {
+		while (this->isRunning() == true) {
 			if (this->inputQueue.size() > 0) {
 	
 				// Lock, copy, clear, unlock. - Free this up.
@@ -121,7 +120,7 @@ namespace largefile {
 					std::string buf = queue.front(); queue.pop();
 					size_t bytes = buf.length();
 
-					if (this->running == false)
+					if (this->isRunning() == false)
 						break;
 
 					if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
@@ -133,11 +132,15 @@ namespace largefile {
 
 					csv_fini (&csv, cb1, cb2, &column);
 
+					gdk_threads_enter ();
+					
 					sheet->apply_row (sheet,
 											this->fields,
 											column.row - 1,
 											this->sizeOfFields);
 
+					gdk_threads_leave ();
+
 					if (column.row >= (column.sheet)->max_rows)
 						column.row = 0;
 
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index de286d0..2947879 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -34,23 +34,23 @@ namespace largefile {
 
 	FileDispatcher::~FileDispatcher (void) {
 		if (this->fp != NULL)
-			this->close();
+			this->Close ();
 	}
 
 	void
-	FileDispatcher::read (off64_t start, off64_t N) {
+	FileDispatcher::Read (off64_t start, off64_t N) {
 		LineReader * reader = new LineReader (this, this->fp, this->marks, start, N);
 		this->addWorker (reader);
 	}
 
 	void
-	FileDispatcher::index (void) {
+	FileDispatcher::Index (void) {
 		LineIndexer * indexer = new LineIndexer (this, this->fp, this->marks);
 		this->addWorker (indexer);
 	}
 
 	bool
-	FileDispatcher::open (const std::string & filename) {
+	FileDispatcher::OpenFile (const std::string & filename) {
 		if (filename.length() == 0)
 			return false;
 
@@ -82,7 +82,7 @@ namespace largefile {
 	}
 
 	bool 
-	FileDispatcher::close (void) {
+	FileDispatcher::Close (void) {
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp);
 		if (this->fp == NULL)
 			return false;
@@ -94,15 +94,13 @@ namespace largefile {
   
 	void *
 	FileDispatcher::run (void * null) {
-		this->running = true;
-
-		this->index();
+		this->Index();
 		
-		while (this->running == true) {
+		while (this->isRunning() == true) {
 			this->inputQueue.lock();
       
 			while (this->inputQueue.size() > 0) {
-				if (this->running == false)
+				if (this->isRunning() == false)
 					break;
 
 				this->pro->onReadComplete (this->inputQueue.pop());
@@ -129,7 +127,6 @@ namespace largefile {
 
 	void *
 	LineIndexer::run (void * null) {
-		this->running = true;
 		int ch, index = 0;
 		off64_t cursor = 0, count = 0, byte_beg = 0;
 
@@ -164,7 +161,6 @@ namespace largefile {
 
 		std::cout<<"ms: "<<((((end.tv_sec-start.tv_sec) * 1000) + ((end.tv_usec-start.tv_usec)/1000.0)) + 0.5)<<"\n";
 		
-		this->running = false;
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}
@@ -186,7 +182,6 @@ namespace largefile {
 
 	void *
 	LineReader::run (void * null) {
-		this->running = false;
 		char buf[4096];
 
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
@@ -220,7 +215,6 @@ namespace largefile {
 
 		fseeko64 (this->fp, start, SEEK_SET);
 		
-		this->running = false;
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 8f3081d..3d939a2 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -45,12 +45,12 @@ namespace largefile {
 		FileDispatcher (int e, proactor::Proactor * pro);
 		virtual ~FileDispatcher (void);
 
-		bool open (const std::string & filename);
-		bool close (void);
+		bool OpenFile (const std::string & filename);
+		bool Close (void);
 		void * run (void * null);
 
-		void read (off64_t start, off64_t N);
-		void index (void);
+		void Read (off64_t start, off64_t N);
+		void Index (void);
 
 		inline bool isIndexed(void) const { return (this->marks[LINE_INDEX_MAX-1].line != -1); }
 	};
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index efe81ae..43f047c 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -51,7 +51,7 @@ GotoDialogResponseCallback (GtkWidget * dialog, gint response, gpointer data) {
 		const gchar * value = gtk_entry_get_text ( GTK_ENTRY (entry) );
 
 		if (value && *value != '\0') {
-			lf->read (lf->workbook()->focus_sheet, atol (value) - 1, 1000);
+			lf->Read (lf->workbook()->focus_sheet, atol (value) - 1, 1000);
 		}
 
 		gtk_entry_set_text (GTK_ENTRY (entry), "");
@@ -62,6 +62,7 @@ GotoDialogResponseCallback (GtkWidget * dialog, gint response, gpointer data) {
 
 static gint
 GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
+	gint result = FALSE;
 	static GtkWidget * goto_dialog = NULL;
 	Largefile * lf = (Largefile *)data;
 	Workbook * wb = lf->workbook();
@@ -69,8 +70,6 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 
 	// Only create the dialog the first time we run this method. 
 	if (goto_dialog == NULL) {
-		gdk_threads_enter ();
-		
 		goto_dialog = gtk_dialog_new_with_buttons ("Goto position ", GTK_WINDOW (window),
 																 (GtkDialogFlags) (GTK_DIALOG_MODAL | GTK_DIALOG_NO_SEPARATOR),
 																 GTK_STOCK_OK,
@@ -87,8 +86,6 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 		gtk_box_pack_start (GTK_BOX (box), entry, TRUE, TRUE, 0);
 				
 		gtk_widget_show_all (box);
-
-		gdk_threads_leave();
 		
 		g_signal_connect (G_OBJECT (goto_dialog), "response", G_CALLBACK (GotoDialogResponseCallback), lf);
 		
@@ -104,30 +101,30 @@ GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	switch (event->keyval) {
 		case GDK_F1: {
 			if (sheet != NULL) {
-				gdk_threads_enter();
 				gtk_widget_show_all (goto_dialog);
-				gdk_threads_leave();
 			}
 		}
 		break;
 		
 		case GDK_Page_Up: {
-			lf->read(sheet, cursor, 100);
+			lf->Read (sheet, cursor, 100);
 			cursor += 100;
 		}
-		return TRUE;
-
+		result = TRUE;
+		break;
+		
 		case GDK_Page_Down: {
 			if (cursor <= 100)
 				cursor = 0;
 			else
 				cursor -= 100;
 			
-			lf->read(sheet, cursor, 100);
+			lf->Read (sheet, cursor, 100);
 		}
-		return TRUE;
+		result = TRUE;
+		break;
 	}
-	return FALSE;
+	return result;
 }
 
 Largefile::Largefile (Application * appstate, Handle * platform)
@@ -160,7 +157,7 @@ Largefile::~Largefile (void) {
 }
 
 bool
-Largefile::read (Sheet * sheet, off64_t start, off64_t N) {
+Largefile::Read (Sheet * sheet, off64_t start, off64_t N) {
 	this->lock();
 	std::string key = sheet->name;
 	
@@ -171,13 +168,13 @@ Largefile::read (Sheet * sheet, off64_t start, off64_t N) {
 	}
 
 	FileDispatcher * fd = it->second;
-	fd->read (start, N);
+	fd->Read (start, N);
 	this->unlock();
 	return true;
 }
 
 bool
-Largefile::open_file (Sheet * sheet, const std::string & filename) {
+Largefile::OpenFile (Sheet * sheet, const std::string & filename) {
 	this->lock();
 	
 	int fdEventId = proactor::Event::uniqueEventId();
@@ -190,7 +187,7 @@ Largefile::open_file (Sheet * sheet, const std::string & filename) {
 		return false;
 	}
 
-	if (fd->open (filename) == false) {
+	if (fd->OpenFile (filename) == false) {
 		g_critical ("Failed opening %s", filename.c_str());
 		this->unlock();
 		return false;
@@ -209,7 +206,7 @@ Largefile::open_file (Sheet * sheet, const std::string & filename) {
 }
 
 bool
-Largefile::exit_file (const std::string & filename) {
+Largefile::CloseFile (const std::string & filename) {
 	this->lock();
 	
 	FilenameMap::iterator it = this->mapping.find(filename);
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
index a549d6b..149f718 100755
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -38,9 +38,9 @@ namespace largefile {
 		Largefile (Application * appstate, Handle * platform);
 		virtual ~Largefile (void);
 
-		bool open_file (Sheet * sheet, const std::string & filename);
-		bool exit_file (const std::string & filename);
-		bool read (Sheet * sheet, off64_t start, off64_t N);
+		bool OpenFile (Sheet * sheet, const std::string & filename);
+		bool CloseFile (const std::string & filename);
+		bool Read (Sheet * sheet, off64_t start, off64_t N);
 	};
 
 }
diff --git a/src/largefile/PluginFactory.cpp b/src/largefile/PluginFactory.cpp
new file mode 100644
index 0000000..4f7c90e
--- /dev/null
+++ b/src/largefile/PluginFactory.cpp
@@ -0,0 +1,108 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <iostream>
+#include <gtkworkbook/workbook.h>
+#include <concurrent/ThreadArgs.hpp>
+#include <gtk/gtk.h>
+#include "Largefile.hpp"
+#include "../config.h"
+#include "../Application.hpp"
+
+using largefile::Largefile;
+
+static void
+CSVOpenDialogCallback (GtkWidget * w, gpointer data) {
+	GtkWidget * open_dialog = NULL;
+	Largefile * lf = (Largefile *)data;
+	open_dialog = gtk_file_chooser_dialog_new ("Open CSV File",
+															 GTK_WINDOW (lf->app()->gtkwindow()),
+															 GTK_FILE_CHOOSER_ACTION_OPEN,
+															 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+															 GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+															 NULL);  
+  
+	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (open_dialog), TRUE);
+				
+	if (gtk_dialog_run (GTK_DIALOG (open_dialog)) == GTK_RESPONSE_ACCEPT) {
+		gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (open_dialog));
+
+		Sheet * sheet = lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
+
+		if (sheet == NULL) {
+			g_warning ("Failed adding new sheet because one already exists");
+		}
+		else {
+			if (lf->OpenFile (sheet, filename) == true) {
+				// STUB: Do something magical.
+			}
+			else {
+				// STUB: The opening of the file failed. Do something meaningful here.
+			}
+		}
+		
+		g_free (filename);
+	}
+
+	gtk_widget_destroy (open_dialog);
+}
+
+static GtkWidget *
+CreateLargefileMenu (Application * appstate, Largefile * lf, GtkWidget * window) {
+	GtkWidget * lfmenu = gtk_menu_new();
+	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
+	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
+	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
+
+	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
+							G_CALLBACK (CSVOpenDialogCallback), lf);
+	
+	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
+	return lfmenu_item;
+}
+
+static GtkWidget *
+BuildNotebookLayout (Application * app, Largefile * lf) {
+	Workbook * wb = lf->workbook();
+	GtkWidget * gtk_menu = app->gtkmenu();
+	GtkWidget * box = gtk_vbox_new (FALSE, 0);
+	GtkWidget * largefile_menu = CreateLargefileMenu (app, lf, app->gtkwindow());
+	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
+
+	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
+
+	wb->signals[SIG_WORKBOOK_CHANGED] = app->signals[Application::SHEET_CHANGED];
+	wb->gtk_box = box;
+
+	gtk_box_pack_start (GTK_BOX (app->gtkvbox()), box, FALSE, FALSE, 0);
+
+	return box;
+}
+
+extern "C" {
+  Plugin *
+  PluginFactoryCreate (Application * appstate, Handle * platform) {
+    ASSERT (appstate != NULL);
+    ASSERT (platform != NULL);
+	 Largefile * lf = new Largefile (appstate, platform);
+	 
+	 GtkWidget * box = BuildNotebookLayout (appstate, lf);
+	 gtk_widget_show (box);
+    return lf;
+  }
+} 
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
deleted file mode 100755
index a8a0d0c..0000000
--- a/src/largefile/plugin_main.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <iostream>
-#include <gtkworkbook/workbook.h>
-#include <concurrent/ThreadArgs.hpp>
-#include <gtk/gtk.h>
-#include "Largefile.hpp"
-#include "../config.h"
-#include "../Application.hpp"
-
-using largefile::Largefile;
-
-static void
-CSVOpenDialogCallback (GtkWidget * w, gpointer data) {
-	GtkWidget * open_dialog = NULL;
-	Largefile * lf = (Largefile *)data;
-
-	gdk_threads_enter();
-	
-	open_dialog = gtk_file_chooser_dialog_new ("Open CSV File",
-															 GTK_WINDOW (lf->app()->gtkwindow()),
-															 GTK_FILE_CHOOSER_ACTION_OPEN,
-															 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-															 GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-															 NULL);  
-  
-	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (open_dialog), TRUE);
-				
-	if (gtk_dialog_run (GTK_DIALOG (open_dialog)) == GTK_RESPONSE_ACCEPT) {
-		gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (open_dialog));
-
-		Sheet * sheet = lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
-
-		if (sheet == NULL) {
-			g_warning ("Failed adding new sheet because one already exists");
-		}
-		else {
-			if (lf->open_file (sheet, filename) == true) {
-				// STUB: Do something magical.
-			}
-			else {
-				// STUB: The opening of the file failed. Do something meaningful here.
-			}
-		}
-		
-		g_free (filename);
-	}
-
-	gtk_widget_destroy (open_dialog);
-	gdk_threads_leave();
-}
-
-static GtkWidget *
-CreateLargefileMenu (Application * appstate, Largefile * lf, GtkWidget * window) {
-	GtkWidget * lfmenu = gtk_menu_new();
-	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
-	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
-	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
-
-	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
-							G_CALLBACK (CSVOpenDialogCallback), lf);
-	
-	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
-	return lfmenu_item;
-}
-
-static GtkWidget *
-BuildNotebookLayout (Application * app, Largefile * lf) {
-	Workbook * wb = lf->workbook();
-	GtkWidget * gtk_menu = app->gtkmenu();
-	GtkWidget * box = gtk_vbox_new (FALSE, 0);
-	GtkWidget * largefile_menu = CreateLargefileMenu (app, lf, app->gtkwindow());
-	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
-
-	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
-
-	wb->signals[SIG_WORKBOOK_CHANGED] = app->signals[Application::SHEET_CHANGED];
-	wb->gtk_box = box;
-
-	gtk_box_pack_start (GTK_BOX (app->gtkvbox()), box, FALSE, FALSE, 0);
-
-	return box;
-}
-
-extern "C" {
-  Plugin *
-  plugin_main (Application * appstate, Handle * platform) {
-    ASSERT (appstate != NULL);
-    ASSERT (platform != NULL);
-	 Largefile * lf = new Largefile (appstate, platform);
-
-	 gdk_threads_enter();
-	 
-	 GtkWidget * box = BuildNotebookLayout (appstate, lf);
-	 gtk_widget_show (box);
-
-	 gdk_threads_leave();
-    return lf;
-  }
-} 
diff --git a/src/main.cpp b/src/main.cpp
index 04ca1a9..a1d9460 100755
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -21,8 +21,10 @@
 
 int
 main (int argc, char ** argv) {
-	if (!g_thread_supported())
+	if (!g_thread_supported()) {
 		g_thread_init (NULL);
+		gdk_threads_init();
+	}
 	
 	Application app (argc, &argv);
 	return app.run();

commit 1334e7193de2d334350944bab39924aed0c5b33d
Author: John Bellone <jvb4@njit.edu>
Date:   Tue Jul 21 15:34:16 2009 -0400

    (1) Added locks to Dispatcher.cc.
    (2) Moved locks in libgtkworkbook

diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
index c431b72..77dd7c9 100755
--- a/gtkworkbook/sheet.c
+++ b/gtkworkbook/sheet.c
@@ -209,15 +209,13 @@ sheet_method_load (Sheet * sheet, const gchar * filepath)
 {
 	ASSERT (sheet != NULL);
 
-	if (IS_NULLSTR (filepath))
-	{
+	if (IS_NULLSTR (filepath)) {
       g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
       return FALSE;
 	}
 
 	FILE * fp = NULL;
-	if ((fp = fopen (filepath, "rb")) == NULL)
-	{
+	if ((fp = fopen (filepath, "rb")) == NULL) {
       g_warning ("%s: failed opening file '%s' for reading", 
 					  __FUNCTION__,
 					  filepath);
@@ -225,14 +223,14 @@ sheet_method_load (Sheet * sheet, const gchar * filepath)
 	}
 
 	gdk_threads_enter ();
+	
 	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
 	struct geometryFileHeader header = {-1,-1,-1};
 	struct geometryFileEntry entry = {-1,-1,-1};
  
 	fread ((void *)&header, sizeof (struct geometryFileHeader), 1, fp);
 
-	if (header.fileVersion != GEOMETRY_FILE_VERSION)
-	{
+	if (header.fileVersion != GEOMETRY_FILE_VERSION) {
       g_warning ("Geometry file version %d is not accepted. (%d)",
 					  header.fileVersion, GEOMETRY_FILE_VERSION);
       FCLOSE (fp);
@@ -272,19 +270,16 @@ sheet_method_load (Sheet * sheet, const gchar * filepath)
 }
 
 static gboolean
-sheet_method_save (Sheet * sheet, const gchar * filepath)
-{
+sheet_method_save (Sheet * sheet, const gchar * filepath) {
 	ASSERT (sheet != NULL);
 
-	if (IS_NULLSTR (filepath))
-	{
+	if (IS_NULLSTR (filepath)) {
       g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
       return FALSE;
 	}
 
 	FILE * fp = NULL;
-	if ((fp = fopen (filepath, "wb")) == NULL)
-	{
+	if ((fp = fopen (filepath, "wb")) == NULL) {
       g_warning ("%s: failed opening file '%s' for writing", 
 					  __FUNCTION__, 
 					  filepath);
@@ -292,33 +287,29 @@ sheet_method_save (Sheet * sheet, const gchar * filepath)
 	}
   
 	gdk_threads_enter ();
+
 	GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
-	struct geometryFileHeader header =
-		{
-			GEOMETRY_FILE_VERSION,
-			GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
-			GTK_SHEET (sheet->gtk_sheet)->maxalloccol
-		};
+	struct geometryFileHeader header = {
+		GEOMETRY_FILE_VERSION,
+		GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
+		GTK_SHEET (sheet->gtk_sheet)->maxalloccol
+	};
 
 	fwrite ((void *)&header, sizeof(struct geometryFileHeader), 1, fp);
 
-	for (gint ii = 0; ii <= header.maxRow; ii++)
-	{
-      for (gint jj = 0; jj <= header.maxColumn; jj++)
-		{
+	for (gint ii = 0; ii <= header.maxRow; ii++) {
+      for (gint jj = 0; jj <= header.maxColumn; jj++) {
 			GtkSheetCell * cell = data[ii][jj];
 
-			if (!IS_NULL (cell) && !IS_NULLSTR(cell->text))
-			{
-				struct geometryFileEntry entry =
-					{
-						cell->row,
-						cell->col,
-						strlen (cell->text),
-						cell->attributes->is_visible,
-						cell->attributes->is_editable,
-						cell->attributes->justification
-					};
+			if (!IS_NULL (cell) && !IS_NULLSTR(cell->text)) {
+				struct geometryFileEntry entry = {
+					cell->row,
+					cell->col,
+					strlen (cell->text),
+					cell->attributes->is_visible,
+					cell->attributes->is_editable,
+					cell->attributes->justification
+				};
 
 				entry.cellForeground.pixel = cell->attributes->foreground.pixel;
 				entry.cellForeground.red = cell->attributes->foreground.red;
@@ -346,8 +337,7 @@ sheet_method_save (Sheet * sheet, const gchar * filepath)
    @sheet: A pointer to the Sheet object.
    @attention: The attention level. */
 static void 
-sheet_method_set_attention (Sheet * sheet, gint attention)
-{
+sheet_method_set_attention (Sheet * sheet, gint attention) {
 	ASSERT (sheet != NULL);
 	gdk_threads_enter ();
 
@@ -365,8 +355,7 @@ sheet_method_set_attention (Sheet * sheet, gint attention)
 /* @description: This method destroys the Sheet object.
    @sheet: A pointer to the object that will be destroyed. */
 static void
-sheet_method_destroy (Sheet * sheet)
-{
+sheet_method_destroy (Sheet * sheet) {
 	ASSERT (sheet != NULL);
 	gdk_threads_enter ();
 
@@ -381,8 +370,7 @@ sheet_method_destroy (Sheet * sheet)
    object. This should only be called from sheet->destroy()
    @sheet: A pointer to the Sheet object that will be freed. */
 static void
-sheet_object_free (Sheet * sheet)
-{
+sheet_object_free (Sheet * sheet) {
 	ASSERT (sheet != NULL);
 
 	FREE (sheet->name);
@@ -393,8 +381,7 @@ sheet_object_free (Sheet * sheet)
 static void
 sheet_method_apply_cellrange (Sheet * sheet, 
 										const GtkSheetRange * range,
-										const CellAttributes * attrib)
-{
+										const CellAttributes * attrib) {
 	ASSERT (sheet != NULL);
 	g_return_if_fail (range != NULL);
 	g_return_if_fail (attrib != NULL);
@@ -410,7 +397,8 @@ sheet_method_apply_cellrow (Sheet * sheet,
 									 gint size) {
 	ASSERT (sheet != NULL);
 	g_return_if_fail (array != NULL);
-
+	gdk_threads_enter();
+	
 	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
 	GtkSheetCell ** cell;
 	Cell * item;
@@ -418,8 +406,6 @@ sheet_method_apply_cellrow (Sheet * sheet,
 	if (row > gtksheet->maxrow || row < 0) return;
 	if (size > gtksheet->maxcol || size < 0) return;
 
-	gdk_threads_enter();	
-
 	for (int col = 0; col < size; col++) {
 		item = array[col]; 
 		cell = &gtksheet->data[row][col];
@@ -455,10 +441,9 @@ sheet_method_apply_cellarray (Sheet * sheet,
 {
 	ASSERT (sheet != NULL);
 	g_return_if_fail (array != NULL);
-
-	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
-
 	gdk_threads_enter ();
+	
+	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
 
 	/* We'll see how this performs for now. In the future we may want to go
 		directly into the GtkSheet structures to get a little more performance
@@ -498,7 +483,6 @@ sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
 {
 	ASSERT (sheet != NULL);
 	g_return_if_fail (cell != NULL);
-
 	gdk_threads_enter ();
 
 	if (sheet->has_focus == FALSE)
@@ -591,8 +575,8 @@ sheet_method_set_cell (Sheet * sheet,
 							  const gchar * value)
 {
 	ASSERT (sheet != NULL);
-
 	gdk_threads_enter ();
+
 	if (sheet->has_focus == FALSE)
 		sheet->notices++;
 	gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet), 
@@ -600,5 +584,6 @@ sheet_method_set_cell (Sheet * sheet,
 							  col, 
 							  GTK_JUSTIFY_LEFT, 
 							  value);
+
 	gdk_threads_leave ();
 }
diff --git a/shared/proactor/Dispatcher.cc b/shared/proactor/Dispatcher.cc
index c7a9ded..ec23069 100755
--- a/shared/proactor/Dispatcher.cc
+++ b/shared/proactor/Dispatcher.cc
@@ -28,27 +28,34 @@ namespace proactor {
    
 	bool
 	Dispatcher::addWorker (Worker * w) {
+		this->workers.lock();
+		
 		WorkerListType::iterator it = std::find (this->workers.begin(),
 															  this->workers.end(),
 															  w);
 		if (it == this->workers.end()) {
 			this->workers.push_back (w);
+			this->workers.unlock();
 			return w->start();
       }
+		this->workers.unlock();
 		return false;
 	}
   
 	bool
 	Dispatcher::removeWorker (Worker * w) {
+		this->workers.lock();
+		
 		WorkerListType::iterator it = std::find (this->workers.begin(),
 															  this->workers.end(),
 															  w);
-
-		if (it == this->workers.end())
-			return false;
-  
-		this->workers.erase (it);
-		return true;
+		bool result = false;
+		if (it != this->workers.end()) {
+			this->workers.erase (it);
+			result = true;
+		}
+		this->workers.unlock();
+		return result;
 	}
 
 } // end of namesapce
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index ccd65f4..efe81ae 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -44,8 +44,6 @@ AppendProcessId (const gchar * pre) {
 static void
 GotoDialogResponseCallback (GtkWidget * dialog, gint response, gpointer data) {
 	Largefile * lf = (Largefile *)data;
-
-	gdk_threads_enter();
 	
 	if (response == GTK_RESPONSE_OK) {
 		GList * children = gtk_container_get_children ( GTK_CONTAINER (GTK_DIALOG(dialog)->vbox) );
@@ -60,8 +58,6 @@ GotoDialogResponseCallback (GtkWidget * dialog, gint response, gpointer data) {
 	}
 	
 	gtk_widget_hide_all (dialog);
-
-	gdk_threads_leave();
 }
 
 static gint

commit 3c991094cbf45cb3a006f2985015cd625fe4878e
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 17:11:23 2009 -0400

    (1) Modified formatting in proactor libraries for emacs.
    (2) Attempting to track down issue with crash bug when reading with Goto.
    Some type of synchronization issue with X.
    (3) Renamed callbacks to be more descriptive.

diff --git a/gtkworkbook/cell.c b/gtkworkbook/cell.c
index 514723a..e3f7870 100755
--- a/gtkworkbook/cell.c
+++ b/gtkworkbook/cell.c
@@ -37,34 +37,34 @@ static void cell_method_set_range (Cell *, const GtkSheetRange *);
 Cell *
 cell_new (void)
 {
-  Cell * cell = cell_object_init ();
-  return cell;
+	Cell * cell = cell_object_init ();
+	return cell;
 }
 
 /* @description: This function is the Cell object's constructor. */
 static Cell *
 cell_object_init (void)
 {
-  Cell * cell = NEW (Cell);
-
-  cell->value = g_string_new_len ("", 4096);
-  cell->attributes.bgcolor = g_string_new_len ("", 1024);
-  cell->attributes.fgcolor = g_string_new_len ("", 1024);
-
-  /* Methods */
-  cell->set_fgcolor = cell_method_set_fgcolor;
-  cell->set_bgcolor = cell_method_set_bgcolor;
-  cell->set_attributes = cell_method_set_attributes;
-  cell->set_range = cell_method_set_range;
-  cell->set_value = cell_method_set_value;
-  cell->set_value_length = cell_method_set_value_length;
-  cell->set_column = cell_method_set_column;
-  cell->set_row = cell_method_set_row;
-  cell->set = cell_method_set_all;
-  cell->set_justification = cell_method_set_justification;
-  cell->destroy = cell_method_destroy;
-
-  return cell;
+	Cell * cell = NEW (Cell);
+
+	cell->value = g_string_new_len ("", 4096);
+	cell->attributes.bgcolor = g_string_new_len ("", 1024);
+	cell->attributes.fgcolor = g_string_new_len ("", 1024);
+
+	/* Methods */
+	cell->set_fgcolor = cell_method_set_fgcolor;
+	cell->set_bgcolor = cell_method_set_bgcolor;
+	cell->set_attributes = cell_method_set_attributes;
+	cell->set_range = cell_method_set_range;
+	cell->set_value = cell_method_set_value;
+	cell->set_value_length = cell_method_set_value_length;
+	cell->set_column = cell_method_set_column;
+	cell->set_row = cell_method_set_row;
+	cell->set = cell_method_set_all;
+	cell->set_justification = cell_method_set_justification;
+	cell->destroy = cell_method_destroy;
+
+	return cell;
 }
 
 /* @description: This object frees the memory created by the Cell object.
@@ -72,12 +72,12 @@ cell_object_init (void)
 static void
 cell_object_free (Cell * cell)
 {
-  ASSERT (cell != NULL);
+	ASSERT (cell != NULL);
 
-  g_string_free (cell->value, TRUE);
-  g_string_free (cell->attributes.fgcolor, TRUE);
-  g_string_free (cell->attributes.bgcolor, TRUE);
-  FREE (cell);
+	g_string_free (cell->value, TRUE);
+	g_string_free (cell->attributes.fgcolor, TRUE);
+	g_string_free (cell->attributes.bgcolor, TRUE);
+	FREE (cell);
 }
 
 /* @description: This method sets a cell in the GtkSheet with the attributes
@@ -87,14 +87,14 @@ cell_object_free (Cell * cell)
    @value: A string value to what should be set in the Cell. */
 static void
 cell_method_set_all (Cell * cell, 
-		     gint row, gint column, 
-		     const gchar * value)
+							gint row, gint column, 
+							const gchar * value)
 {
-  ASSERT (cell != NULL);
+	ASSERT (cell != NULL);
 
-  g_string_assign (cell->value, value);
-  cell->row = row;
-  cell->column = column;  
+	g_string_assign (cell->value, value);
+	cell->row = row;
+	cell->column = column;  
 }
 
 /* @description: This method sets the justification of the specified Cell
@@ -102,107 +102,107 @@ cell_method_set_all (Cell * cell,
    @justification: The GtkJustification value for the cell. */
 static void
 cell_method_set_justification (Cell * cell, 
-			       GtkJustification justification)
+										 GtkJustification justification)
 {
-  ASSERT (cell != NULL);
-  cell->attributes.justification = justification;
+	ASSERT (cell != NULL);
+	cell->attributes.justification = justification;
 }
 
 /* @description: The method sets the row of the Cell object.
    @row: Integer value of the row. */
 static void
 cell_method_set_row (Cell * cell, 
-		     gint row)
+							gint row)
 {
-  ASSERT (cell != NULL);
-  cell->row = row;
-  cell->range.row0 = cell->range.rowi = row;
+	ASSERT (cell != NULL);
+	cell->row = row;
+	cell->range.row0 = cell->range.rowi = row;
 }
 
 /* @description: The method sets the column of the Cell object.
    @column: Integer value fo the column. */
 static void
 cell_method_set_column (Cell * cell, 
-			gint column)
+								gint column)
 {
-  ASSERT (cell != NULL);
-  cell->column = column;
-  cell->range.col0 = cell->range.coli = column;
+	ASSERT (cell != NULL);
+	cell->column = column;
+	cell->range.col0 = cell->range.coli = column;
 }
 
 /* @description: This method sets the bgcolor of the Cell object.
    @color: String value of the color, e.g. white, blue, red. */
 static void
 cell_method_set_bgcolor (Cell * cell, 
-			 const gchar * color)
+								 const gchar * color)
 {
-  ASSERT (cell != NULL);
+	ASSERT (cell != NULL);
 
-  g_string_assign (cell->attributes.bgcolor, color);
+	g_string_assign (cell->attributes.bgcolor, color);
 }
 
 /* @description: This method sets the fgcolor of the Cell object.
    @color: String value of the color, e.g. white, blue, red. */
 static void 
 cell_method_set_fgcolor (Cell * cell, 
-			 const gchar *color)
+								 const gchar *color)
 {
-  ASSERT (cell != NULL);
+	ASSERT (cell != NULL);
   
-  g_string_assign (cell->attributes.fgcolor, color);
+	g_string_assign (cell->attributes.fgcolor, color);
 }
 
 /* @description: This method sets the range of the Cell object.
    @range: A pointer to a GtkSheetRange object. */
 static void
 cell_method_set_range (Cell * cell, 
-		       const GtkSheetRange * range)
+							  const GtkSheetRange * range)
 {
-  ASSERT (cell != NULL); ASSERT (range != NULL);
+	ASSERT (cell != NULL); ASSERT (range != NULL);
   
-  cell->range.row0 = range->row0;
-  cell->range.col0 = range->col0;
-  cell->range.rowi = range->rowi;
-  cell->range.coli = range->coli;
+	cell->range.row0 = range->row0;
+	cell->range.col0 = range->col0;
+	cell->range.rowi = range->rowi;
+	cell->range.coli = range->coli;
 }
 
 /* @description: This method sets the attributes of the Cell object.
    @attrib: A pointer to the Cell Attributes object. */
 static void
 cell_method_set_attributes (Cell * cell, 
-			    const CellAttributes * attrib)
+									 const CellAttributes * attrib)
 {
-  ASSERT (cell != NULL); ASSERT (attrib != NULL);
+	ASSERT (cell != NULL); ASSERT (attrib != NULL);
 
-  cell->attributes.justification = attrib->justification;
+	cell->attributes.justification = attrib->justification;
  
-  g_string_assign (cell->attributes.fgcolor, attrib->fgcolor->str);
-  g_string_assign (cell->attributes.bgcolor, attrib->bgcolor->str);
+	g_string_assign (cell->attributes.fgcolor, attrib->fgcolor->str);
+	g_string_assign (cell->attributes.bgcolor, attrib->bgcolor->str);
 }
 
 /* @description: This method sets the text value of the Cell object.
    @value: This is a string pointer to the value. */
 static void
 cell_method_set_value (Cell * cell, 
-		       const gchar * value)
+							  const gchar * value)
 {
-  ASSERT (cell != NULL);
+	ASSERT (cell != NULL);
   
-  g_string_assign (cell->value, value);
+	g_string_assign (cell->value, value);
 }
 
 static void
 cell_method_set_value_length (Cell * cell, void * s, size_t length) {
-  ASSERT (cell != NULL);
+	ASSERT (cell != NULL);
 
-  g_string_assign (cell->value, "");
-  g_string_append_len (cell->value, (const char *)s, length);
+	g_string_assign (cell->value, "");
+	g_string_append_len (cell->value, (const char *)s, length);
 }
 
 static void
 cell_method_destroy (Cell * cell)
 {
-  g_return_if_fail (cell != NULL);
+	g_return_if_fail (cell != NULL);
 
-  cell_object_free (cell);
+	cell_object_free (cell);
 }
diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
index ef58d2d..c431b72 100755
--- a/gtkworkbook/sheet.c
+++ b/gtkworkbook/sheet.c
@@ -119,9 +119,13 @@ Sheet *
 sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
 {
 	ASSERT (book != NULL);
-  
+
+	gdk_threads_enter();
+	
 	Sheet * sheet = sheet_object_init (book, label, rows, columns);
 
+	gdk_threads_leave();
+	
 	/* STUB: Perform anything that is based on a style here. */
 
 	return sheet;
@@ -137,7 +141,6 @@ sheet_object_init (Workbook * book,
 						 const gchar * label, 
 						 gint rows, gint columns)
 {
-	gdk_threads_enter ();
 	Sheet * sheet = NEW (Sheet);
 
 	/* Create the sheet containers and GtkSheet object. */
@@ -197,8 +200,6 @@ sheet_object_init (Workbook * book,
 		*/
 	}
 
-	gdk_threads_leave ();
-	
 	gtk_widget_show_all (sheet->gtk_box);
 	return sheet;
 }
@@ -417,16 +418,17 @@ sheet_method_apply_cellrow (Sheet * sheet,
 	if (row > gtksheet->maxrow || row < 0) return;
 	if (size > gtksheet->maxcol || size < 0) return;
 
-	gdk_threads_enter();
+	gdk_threads_enter();	
 
 	for (int col = 0; col < size; col++) {
 		item = array[col]; 
 		cell = &gtksheet->data[row][col];
-    
+
 		gtk_sheet_set_cell_text (gtksheet,
 										 row,
 										 col,
 										 item->value->str);
+			
 		/*
 		  if (*cell == NULL)
 		  (*cell) = gtk_sheet_cell_new();
@@ -442,7 +444,7 @@ sheet_method_apply_cellrow (Sheet * sheet,
 
 		item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
 	}
-
+	
 	gdk_threads_leave();
 }
 
diff --git a/gtkworkbook/workbook.c b/gtkworkbook/workbook.c
index aff8be0..c6107fe 100755
--- a/gtkworkbook/workbook.c
+++ b/gtkworkbook/workbook.c
@@ -49,7 +49,10 @@ workbook_open (GtkWidget * window, const gchar * filename)
 		At this point we would load up the configuration files for the styles,
 		sheets and plugins to be loaded then this would all be executed here. */
 
+	gdk_threads_enter();
 	Workbook * book = workbook_object_init (window, filename);
+	gdk_threads_leave();
+	
 	return book;
 }
 
@@ -183,7 +186,9 @@ workbook_method_move_sheet (Workbook * wb,
 					  sheet->name, wb->filename);
       return FALSE;
 	}
-  
+
+	gdk_threads_enter ();
+	
 	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
 												  sh->gtk_box);
 	if (page == -1)
@@ -195,8 +200,7 @@ workbook_method_move_sheet (Workbook * wb,
 
 	if (after == TRUE)  page++;
 	else                page--;
-
-	gdk_threads_enter ();
+	
 	gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
 										 sheet->gtk_box,
 										 page);
@@ -216,7 +220,7 @@ workbook_object_init (GtkWidget * window, const gchar * filename)
 	book->signals[SIG_WORKBOOK_CHANGED] = NULL;
 
 	/* Set up the notebook */
-	gdk_threads_enter ();
+
 	book->gtk_notebook = gtk_notebook_new ();
   
 	GtkNotebook * notebook = GTK_NOTEBOOK (book->gtk_notebook);
@@ -229,8 +233,6 @@ workbook_object_init (GtkWidget * window, const gchar * filename)
 
 	gtk_widget_show_all (book->gtk_notebook);
 
-	gdk_threads_leave ();
-
 	/* Members */
 	book->sheet_first = book->sheet_last = NULL;
 	book->next = book->prev = NULL;
diff --git a/shared/proactor/InputDispatcher.cc b/shared/proactor/InputDispatcher.cc
index a46febc..438abbe 100755
--- a/shared/proactor/InputDispatcher.cc
+++ b/shared/proactor/InputDispatcher.cc
@@ -21,46 +21,46 @@
 
 namespace proactor {
 
-  InputDispatcher::~InputDispatcher (void) {
-	  this->inputQueue.lock();
-	  while (this->inputQueue.size() > 0)
-		  this->inputQueue.pop();
-	  this->inputQueue.unlock();
-  }
+	InputDispatcher::~InputDispatcher (void) {
+		this->inputQueue.lock();
+		while (this->inputQueue.size() > 0)
+			this->inputQueue.pop();
+		this->inputQueue.unlock();
+	}
 
-  void *
-  InputDispatcher::stop (void) {
-    WorkerListType::iterator it = this->workers.begin();
-    while (it != this->workers.end()) {
-      (*it)->stop();
-      it = this->workers.erase(it);
-    }
-    return Thread::stop();
-  }
+	void *
+	InputDispatcher::stop (void) {
+		WorkerListType::iterator it = this->workers.begin();
+		while (it != this->workers.end()) {
+			(*it)->stop();
+			it = this->workers.erase(it);
+		}
+		return Thread::stop();
+	}
 
-  void *
-  InputDispatcher::run (void * null) {
-    this->running = true;
+	void *
+	InputDispatcher::run (void * null) {
+		this->running = true;
 
-    while (this->running == true) {
-      // Dispatch all of the input items on the queue.
-      this->inputQueue.lock();
+		while (this->running == true) {
+			// Dispatch all of the input items on the queue.
+			this->inputQueue.lock();
 
-      while (this->inputQueue.size() > 0) {
+			while (this->inputQueue.size() > 0) {
 
-	if (this->running == false)
-	  break;
+				if (this->running == false)
+					break;
 
-	// For right now all we're doing is pushing up the chain.
-	this->pro->onReadComplete ( this->inputQueue.pop() );
-      }
+				// For right now all we're doing is pushing up the chain.
+				this->pro->onReadComplete ( this->inputQueue.pop() );
+			}
 
-      this->inputQueue.unlock();
+			this->inputQueue.unlock();
 
-      Thread::sleep(100);
-    }
+			Thread::sleep(100);
+		}
   
-    return NULL; 
-  }
+		return NULL; 
+	}
 
 } // end of namespace
diff --git a/shared/proactor/InputDispatcher.hpp b/shared/proactor/InputDispatcher.hpp
index ee49202..3129154 100755
--- a/shared/proactor/InputDispatcher.hpp
+++ b/shared/proactor/InputDispatcher.hpp
@@ -24,29 +24,33 @@
 
 namespace proactor {
 
-  class Proactor;
+	class Proactor;
 
-  class InputDispatcher : public EventDispatcher {
-  protected:
-    typedef concurrent::Queue<Event> InputQueueType;
+	class InputDispatcher : public EventDispatcher {
+	protected:
+		typedef concurrent::Queue<Event> InputQueueType;
 
-    Proactor * pro;
-    InputQueueType inputQueue;
-  public:
-    virtual ~InputDispatcher (void);
+		Proactor * pro;
+		InputQueueType inputQueue;
+	public:
+		virtual ~InputDispatcher (void);
 
-    void * stop (void);
+		void * stop (void);
     
-    inline void onReadComplete (const char * buf) {
-      this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
-    }
+		inline void onReadComplete (const char * buf) {
+			this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
+		}
 
-    inline void onReadComplete (std::string buf) {
-      this->inputQueue.push ( Event (getEventId(), buf) );
-    }
+		inline void onReadComplete (const std::string & buf) {
+			this->inputQueue.push ( Event (getEventId(), std::string (buf) ) );
+		}
 
-    void * run (void * null);
-  };
+		inline void onReadComplete (std::string buf) {
+			this->inputQueue.push ( Event (getEventId(), std::string (buf) ) );
+		}
+
+		void * run (void * null);
+	};
 
 } // end of namespace
 
diff --git a/shared/proactor/Proactor.cc b/shared/proactor/Proactor.cc
index 2085c63..17aeb5a 100755
--- a/shared/proactor/Proactor.cc
+++ b/shared/proactor/Proactor.cc
@@ -22,138 +22,138 @@
 
 namespace proactor {
 
-  Proactor::Proactor (void) {
-  }
-
-  Proactor::~Proactor (void) {
-    // Remove all of the lists of event handlers.
-    {
-      EventMapType::iterator it = this->eventsToHandlers.begin();
-      while (it != this->eventsToHandlers.end()) {
-	  WorkerListType * q = (it->second);
-	  delete q;
-	  it++;
+	Proactor::Proactor (void) {
 	}
-    }
+
+	Proactor::~Proactor (void) {
+		// Remove all of the lists of event handlers.
+		{
+			EventMapType::iterator it = this->eventsToHandlers.begin();
+			while (it != this->eventsToHandlers.end()) {
+				WorkerListType * q = (it->second);
+				delete q;
+				it++;
+			}
+		}
  
-    // Handle the dispatchers that have not been manually removed.
-    {
-      DispatcherList::iterator it = this->dispatchers.begin();
-      while (it != this->dispatchers.end())
-	{
-	  Dispatcher * d = (*it);
-	  delete d;
-	  it++;
-	}
-    }
+		// Handle the dispatchers that have not been manually removed.
+		{
+			DispatcherList::iterator it = this->dispatchers.begin();
+			while (it != this->dispatchers.end())
+			{
+				Dispatcher * d = (*it);
+				delete d;
+				it++;
+			}
+		}
   
-  }
+	}
 
-  bool
-  Proactor::addWorker (int e, Worker * job) {
-    this->eventsToHandlers.lock();
-    {
-      EventMapType::iterator it = this->eventsToHandlers.find (e);
+	bool
+	Proactor::addWorker (int e, Worker * job) {
+		this->eventsToHandlers.lock();
+		{
+			EventMapType::iterator it = this->eventsToHandlers.find (e);
   
-      if (it == this->eventsToHandlers.end())
-	this->eventsToHandlers[e] = new WorkerListType;  
-      this->eventsToHandlers[e]->push_back (job);
-    }
-    this->eventsToHandlers.unlock();
-
-    return job->start();
-  }
-
-  void
-  Proactor::onReadComplete (Event e) {
-    this->events.push (e);
-  }
-
-  void 
-  Proactor::onReadComplete (int e, const char * buf) {
-    this->events.push ( Event (e, std::string (buf)) );   
-  }
-
-  bool
-  Proactor::removeWorker (int e, Worker * job) {
-    bool result = false;
-
-    this->eventsToHandlers.lock();
-    {
-      WorkerListType::iterator it = 
-	std::find (this->eventsToHandlers[e]->begin(),
-		   this->eventsToHandlers[e]->end(),
-		   job);
-    
-      if (it != this->eventsToHandlers[e]->end())
-	{
-	  this->eventsToHandlers[e]->erase (it);
-	  result = true;
+			if (it == this->eventsToHandlers.end())
+				this->eventsToHandlers[e] = new WorkerListType;  
+			this->eventsToHandlers[e]->push_back (job);
+		}
+		this->eventsToHandlers.unlock();
+
+		return job->start();
 	}
-    }
-    this->eventsToHandlers.unlock();
+
+	void
+	Proactor::onReadComplete (Event e) {
+		this->events.push (e);
+	}
+
+	void 
+	Proactor::onReadComplete (int e, const char * buf) {
+		this->events.push ( Event (e, std::string (buf)) );   
+	}
+
+	bool
+	Proactor::removeWorker (int e, Worker * job) {
+		bool result = false;
+
+		this->eventsToHandlers.lock();
+		{
+			WorkerListType::iterator it = 
+				std::find (this->eventsToHandlers[e]->begin(),
+							  this->eventsToHandlers[e]->end(),
+							  job);
+    
+			if (it != this->eventsToHandlers[e]->end())
+			{
+				this->eventsToHandlers[e]->erase (it);
+				result = true;
+			}
+		}
+		this->eventsToHandlers.unlock();
    
-    return result;
-  }
-
-  void
-  Proactor::addDispatcher (Dispatcher * d) {
-    this->dispatchers.push_back (d);
-  }
-
-  bool
-  Proactor::removeDispatcher (Dispatcher * d) {
-    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
-					     this->dispatchers.end(),
-					     d);
-
-    if (it == this->dispatchers.end())
-      return false;
+		return result;
+	}
+
+	void
+	Proactor::addDispatcher (Dispatcher * d) {
+		this->dispatchers.push_back (d);
+	}
+
+	bool
+	Proactor::removeDispatcher (Dispatcher * d) {
+		DispatcherList::iterator it = std::find (this->dispatchers.begin(),
+															  this->dispatchers.end(),
+															  d);
+
+		if (it == this->dispatchers.end())
+			return false;
   
-    this->dispatchers.erase (it);
-    return true;
-  }
+		this->dispatchers.erase (it);
+		return true;
+	}
 
-  void *
-  Proactor::run (void * null) {
-    this->running = true;
+	void *
+	Proactor::run (void * null) {
+		this->running = true;
   
-    WorkerListType::iterator it;
+		WorkerListType::iterator it;
 
-    while (this->running == true) {
-	this->events.lock();
+		while (this->running == true) {
+			this->events.lock();
 
-	while (this->events.size() > 0) {
+			while (this->events.size() > 0) {
 
-	  if (this->running == false)
-	    break;
+				if (this->running == false)
+					break;
 
-	    Event e = this->events.pop();
+				Event e = this->events.pop();
 
-	    // We are throwing events with no handlers to catch them.
-	    if (this->eventsToHandlers.find (e.id) == 
-		this->eventsToHandlers.end())
-	      continue;
+				// We are throwing events with no handlers to catch them.
+				if (this->eventsToHandlers.find (e.id) == 
+					 this->eventsToHandlers.end())
+					continue;
  
-	    it = this->eventsToHandlers[e.id]->begin();
+				it = this->eventsToHandlers[e.id]->begin();
 	  
-	    while (it != this->eventsToHandlers[e.id]->end()) {
+				while (it != this->eventsToHandlers[e.id]->end()) {
 
-	      if (this->running == false)
-		break;
+					if (this->running == false)
+						break;
 
-		Worker * j = (*it);
+					Worker * j = (*it);
 	      
-		j->pushInputQueue (e.buf);
+					j->pushInputQueue (e.buf);
 		      
-		it++;
-	      }
-	  }
-	this->events.unlock();
+					it++;
+				}
+			}
+			this->events.unlock();
       
-	Thread::sleep(100);
+			Thread::sleep(100);
       }
-    return NULL;
-  }
+		return NULL;
+	}
 
 } // end of namespace
diff --git a/shared/proactor/Proactor.hpp b/shared/proactor/Proactor.hpp
index 793647c..fc90f59 100755
--- a/shared/proactor/Proactor.hpp
+++ b/shared/proactor/Proactor.hpp
@@ -30,33 +30,33 @@
 
 namespace proactor {
 
-  class Proactor : public Dispatcher {
-  private:
-    typedef concurrent::List<Dispatcher *> DispatcherList;
-    typedef concurrent::Map<int, WorkerListType *> EventMapType;
-    typedef concurrent::Queue<Event> EventQueueType;
-
-    EventMapType eventsToHandlers;
-    DispatcherList dispatchers;
-    EventQueueType events;
-  public:
-    Proactor (void);
-    virtual ~Proactor (void);
-
-    bool addWorker (int e, Worker * w);
-    bool removeWorker (int e, Worker * w);
-    void addDispatcher (Dispatcher * d);
-    bool removeDispatcher (Dispatcher * d);
+	class Proactor : public Dispatcher {
+	private:
+		typedef concurrent::List<Dispatcher *> DispatcherList;
+		typedef concurrent::Map<int, WorkerListType *> EventMapType;
+		typedef concurrent::Queue<Event> EventQueueType;
+
+		EventMapType eventsToHandlers;
+		DispatcherList dispatchers;
+		EventQueueType events;
+	public:
+		Proactor (void);
+		virtual ~Proactor (void);
+
+		bool addWorker (int e, Worker * w);
+		bool removeWorker (int e, Worker * w);
+		void addDispatcher (Dispatcher * d);
+		bool removeDispatcher (Dispatcher * d);
     
-    void * run (void * null);
+		void * run (void * null);
  
-    void onReadComplete (Event e);
-    void onReadComplete (int e, const char * buf);
+		void onReadComplete (Event e);
+		void onReadComplete (int e, const char * buf);
 
-    inline const std::string & peekInputQueue (void) {
-      return (this->events.front()).buf;
-    }
-  };
+		inline const std::string & peekInputQueue (void) {
+			return (this->events.front()).buf;
+		}
+	};
 
 } // end of namespace
 
diff --git a/shared/proactor/Worker.hpp b/shared/proactor/Worker.hpp
index 481cae1..5b5efe9 100755
--- a/shared/proactor/Worker.hpp
+++ b/shared/proactor/Worker.hpp
@@ -36,8 +36,8 @@ namespace proactor {
   public:
     virtual ~Worker (void);
 
-    inline void pushInputQueue (std::string buf) {
-      this->inputQueue.push (buf);
+    inline void pushInputQueue (const std::string & buf) {
+		 this->inputQueue.push (std::string (buf));
     }
   };
 
diff --git a/src/Application.cpp b/src/Application.cpp
index c5f9698..c44724b 100755
--- a/src/Application.cpp
+++ b/src/Application.cpp
@@ -217,7 +217,7 @@ Application::open_extension (const gchar * filename, gboolean absolute_path) {
 
 	Plugin * plugin = NULL;
 	if ((plugin = this->load_plugin (fname)) != NULL) {
-
+		
 		if (plugin->workbook() == NULL) {
 			g_critical ("Plugin returned a NULL pointer instead of allocated"
 							" workbook.");
diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index 8ff32c7..c63a8fc 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -143,6 +143,7 @@ namespace largefile {
 
 					concurrent::Thread::sleep(5);
 				}
+				
 			}	
 			concurrent::Thread::sleep(5);
 		}
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 6b62358..de286d0 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -143,6 +143,7 @@ namespace largefile {
 		// going to get away from having to sequentially read this file in, but once we
 		// have line numbers we can jump throughout the file pretty quickly.
 		while ((ch = fgetc(this->fp)) != EOF) {
+			
 			if (ch=='\n') count++;
 
   			if (this->marks[index].byte == cursor++) {
@@ -153,6 +154,7 @@ namespace largefile {
 				
 				if (index == LINE_INDEX_MAX)
 					break;
+				
 			}
 
 			if (ch=='\n') byte_beg = cursor + 1;
@@ -213,7 +215,7 @@ namespace largefile {
 			if (std::fgets (buf, 4096, this->fp) == NULL)		
 				break;
       
-			this->dispatcher->onReadComplete (std::string (buf));
+			this->dispatcher->onReadComplete (buf);
 		}
 
 		fseeko64 (this->fp, start, SEEK_SET);
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index cbb4a8e..ccd65f4 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -35,26 +35,83 @@ using namespace largefile;
    uses the pid of the process as its suffix. 
    @pre: The prefix (should be a file path, obviously). */
 static std::string
-append_pidname (const gchar * pre) {
+AppendProcessId (const gchar * pre) {
   std::stringstream s;
   s << pre << getppid();
   return s.str();
 }
 
+static void
+GotoDialogResponseCallback (GtkWidget * dialog, gint response, gpointer data) {
+	Largefile * lf = (Largefile *)data;
+
+	gdk_threads_enter();
+	
+	if (response == GTK_RESPONSE_OK) {
+		GList * children = gtk_container_get_children ( GTK_CONTAINER (GTK_DIALOG(dialog)->vbox) );
+		GtkWidget * entry = (GtkWidget *)g_list_nth_data (children, 0);
+		const gchar * value = gtk_entry_get_text ( GTK_ENTRY (entry) );
+
+		if (value && *value != '\0') {
+			lf->read (lf->workbook()->focus_sheet, atol (value) - 1, 1000);
+		}
+
+		gtk_entry_set_text (GTK_ENTRY (entry), "");
+	}
+	
+	gtk_widget_hide_all (dialog);
+
+	gdk_threads_leave();
+}
+
 static gint
-key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
+GtkKeypressCallback (GtkWidget * window, GdkEventKey * event, gpointer data) {
+	static GtkWidget * goto_dialog = NULL;
 	Largefile * lf = (Largefile *)data;
 	Workbook * wb = lf->workbook();
 	Sheet * sheet = wb->focus_sheet;
+
+	// Only create the dialog the first time we run this method. 
+	if (goto_dialog == NULL) {
+		gdk_threads_enter ();
 		
+		goto_dialog = gtk_dialog_new_with_buttons ("Goto position ", GTK_WINDOW (window),
+																 (GtkDialogFlags) (GTK_DIALOG_MODAL | GTK_DIALOG_NO_SEPARATOR),
+																 GTK_STOCK_OK,
+																 GTK_RESPONSE_OK,
+																 GTK_STOCK_CANCEL,
+																 GTK_RESPONSE_CANCEL,
+																 NULL);
+		
+		GtkWidget * box = GTK_DIALOG (goto_dialog)->vbox;
+		GtkWidget * entry = gtk_entry_new_with_max_length (30);
+
+		gtk_box_set_spacing (GTK_BOX (box), 18);
+			
+		gtk_box_pack_start (GTK_BOX (box), entry, TRUE, TRUE, 0);
+				
+		gtk_widget_show_all (box);
+
+		gdk_threads_leave();
+		
+		g_signal_connect (G_OBJECT (goto_dialog), "response", G_CALLBACK (GotoDialogResponseCallback), lf);
+		
+		g_signal_connect (G_OBJECT (goto_dialog), "delete-event",
+								G_CALLBACK (gtk_widget_hide_on_delete), NULL);
+		
+	}	
+	
 	//	int vposition = std::abs((int)gtksheet->vadjustment->value);
 	static off64_t cursor = 0;
 	//	float N = vposition, K = 24388, V = (N/K);
 	
 	switch (event->keyval) {
 		case GDK_F1: {
-		
-			//lf->read(sheet, 1012121,1000);
+			if (sheet != NULL) {
+				gdk_threads_enter();
+				gtk_widget_show_all (goto_dialog);
+				gdk_threads_leave();
+			}
 		}
 		break;
 		
@@ -91,16 +148,16 @@ Largefile::Largefile (Application * appstate, Handle * platform)
 	}
 	
 	std::string logname = std::string (logpath->value).append("/");
-	logname.append (append_pidname("largefile.").append(".log"));
+	logname.append (AppendProcessId("largefile.").append(".log"));
 	
 	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
 		g_critical ("Failed opening file '%s' for packet logging; exiting"
 					" thread", logname.c_str());
 		return;
     }
-
+	
 	gtk_signal_connect (GTK_OBJECT (this->wb->gtk_window), "key_press_event",
-							  GTK_SIGNAL_FUNC (key_press_callback), this);
+							  GTK_SIGNAL_FUNC (GtkKeypressCallback), this);
 }
 
 Largefile::~Largefile (void) {
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 4d0f8e0..a8a0d0c 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -27,61 +27,65 @@
 using largefile::Largefile;
 
 static void
-open_csv_file (GtkWidget * w, gpointer data) {
-  Largefile * lf = (Largefile *)data;
-  
-  GtkWidget * dialog = gtk_file_chooser_dialog_new ("Open File",
-																	 GTK_WINDOW (lf->app()->gtkwindow()),
-																	 GTK_FILE_CHOOSER_ACTION_OPEN,
-																	 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-																	 GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-																	 NULL);  
-  
-  gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (dialog), TRUE);
-  
-  if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
-    gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
-
-	 Sheet * sheet = lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
-
-	 if (sheet == NULL) {
-		 g_warning ("Failed adding new sheet because one already exists");
-	 }
-	 else {
-	 	 if (lf->open_file (sheet, filename) == true) {
-			 // STUB: Do something magical.
-		 }
-		 else {
-			 // STUB: The opening of the file failed. Do something meaningful here.
-		 }
-	 }
-	 
-    g_free (filename);
-  }
+CSVOpenDialogCallback (GtkWidget * w, gpointer data) {
+	GtkWidget * open_dialog = NULL;
+	Largefile * lf = (Largefile *)data;
 
-	gtk_widget_destroy (dialog);
+	gdk_threads_enter();
+	
+	open_dialog = gtk_file_chooser_dialog_new ("Open CSV File",
+															 GTK_WINDOW (lf->app()->gtkwindow()),
+															 GTK_FILE_CHOOSER_ACTION_OPEN,
+															 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+															 GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+															 NULL);  
+  
+	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (open_dialog), TRUE);
+				
+	if (gtk_dialog_run (GTK_DIALOG (open_dialog)) == GTK_RESPONSE_ACCEPT) {
+		gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (open_dialog));
+
+		Sheet * sheet = lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
+
+		if (sheet == NULL) {
+			g_warning ("Failed adding new sheet because one already exists");
+		}
+		else {
+			if (lf->open_file (sheet, filename) == true) {
+				// STUB: Do something magical.
+			}
+			else {
+				// STUB: The opening of the file failed. Do something meaningful here.
+			}
+		}
+		
+		g_free (filename);
+	}
+
+	gtk_widget_destroy (open_dialog);
+	gdk_threads_leave();
 }
 
 static GtkWidget *
-largefile_mainmenu_new (Application * appstate, Largefile * lf, GtkWidget * window) {
+CreateLargefileMenu (Application * appstate, Largefile * lf, GtkWidget * window) {
 	GtkWidget * lfmenu = gtk_menu_new();
 	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
 	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
 	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
 
 	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
-							G_CALLBACK (open_csv_file), lf);
+							G_CALLBACK (CSVOpenDialogCallback), lf);
 	
 	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
 	return lfmenu_item;
 }
 
 static GtkWidget *
-build_layout (Application * app, Largefile * lf) {
+BuildNotebookLayout (Application * app, Largefile * lf) {
 	Workbook * wb = lf->workbook();
 	GtkWidget * gtk_menu = app->gtkmenu();
 	GtkWidget * box = gtk_vbox_new (FALSE, 0);
-	GtkWidget * largefile_menu = largefile_mainmenu_new (app, lf, app->gtkwindow());
+	GtkWidget * largefile_menu = CreateLargefileMenu (app, lf, app->gtkwindow());
 	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
 
 	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
@@ -101,8 +105,12 @@ extern "C" {
     ASSERT (platform != NULL);
 	 Largefile * lf = new Largefile (appstate, platform);
 
-	 GtkWidget * box = build_layout (appstate, lf);
-	 gtk_widget_show (box);	 
+	 gdk_threads_enter();
+	 
+	 GtkWidget * box = BuildNotebookLayout (appstate, lf);
+	 gtk_widget_show (box);
+
+	 gdk_threads_leave();
     return lf;
   }
 } 

commit 0d21d016a45e00ae9248d7ddec16e81c405c382e
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 11:45:02 2009 -0400

    (1) Added g_thread_supported() check in main.cpp; this fixes lock issue inside of
    libgtkworkbook.
    (2) Added locks back into sheet.c

diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
index 10b639c..ef58d2d 100755
--- a/gtkworkbook/sheet.c
+++ b/gtkworkbook/sheet.c
@@ -137,7 +137,7 @@ sheet_object_init (Workbook * book,
 						 const gchar * label, 
 						 gint rows, gint columns)
 {
-	/*gdk_threads_enter ();*/
+	gdk_threads_enter ();
 	Sheet * sheet = NEW (Sheet);
 
 	/* Create the sheet containers and GtkSheet object. */
@@ -197,7 +197,7 @@ sheet_object_init (Workbook * book,
 		*/
 	}
 
-	/*gdk_threads_leave ();*/
+	gdk_threads_leave ();
 	
 	gtk_widget_show_all (sheet->gtk_box);
 	return sheet;
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index 3355b30..cbb4a8e 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -53,7 +53,8 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	
 	switch (event->keyval) {
 		case GDK_F1: {
-			lf->read(sheet, 1012121,1000);
+		
+			//lf->read(sheet, 1012121,1000);
 		}
 		break;
 		
diff --git a/src/main.cpp b/src/main.cpp
index 3dfd78d..04ca1a9 100755
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -1,7 +1,29 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Application.hpp"
+#include <glib/gthread.h>
 
 int
 main (int argc, char ** argv) {
+	if (!g_thread_supported())
+		g_thread_init (NULL);
+	
 	Application app (argc, &argv);
 	return app.run();
 }

commit b3f5c36747b282da329b67ca3a2ebae3b71bdb8e
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 11:35:34 2009 -0400

    Updated TODO entry.

diff --git a/TODO b/TODO
index d09bbe7..c4f1efc 100755
--- a/TODO
+++ b/TODO
@@ -2,12 +2,13 @@ TODO for GTKWorkbook
 
 * Application
 	- Bugs
-		o Probable issue with new plugin architecture unloading library inside
+		o Possible issue with new plugin architecture unloading library inside
 		  the object's destructor. 
-		o Segementation fault on graceful exit of application.
 * largefile
 	- Bugs	
-		o Possible heap memory corruption happening in current working branch.	
+		o Likely heap corruption inside of commented out GtkSheet management code
+		  which was yanked from GtkExtra distribution. This needs to be run inside
+		  of heap profiler for testing.
 	- Priorities (before merge)
 		o Absolute line goto dialog
 		o Index indicator

commit 97d0779cb0128c25cfc9c02edc901f26082de1dc
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 11:32:49 2009 -0400

    Fixed merge leftovers from largefile branch.

diff --git a/gtkworkbook/workbook.c b/gtkworkbook/workbook.c
index 7844298..aff8be0 100755
--- a/gtkworkbook/workbook.c
+++ b/gtkworkbook/workbook.c
@@ -79,28 +79,13 @@ workbook_method_addnewsheet (Workbook * book,
 
 	sheet = sheet_new (book, label, rows, cols);
 
-<<<<<<< HEAD:workbook/workbook.c
-	LINK_OBJECT (book->sheet_first,
-					 book->sheet_last, 
-					 sheet);
-
-	/* We are the first and only sheet; make sure we are set to have focus. */
-	/* BUGFIX: This was in the wrong place... needs to be below LINK_OBJECT */
-	if ((book->sheet_first == sheet))
-	{
-      sheet->has_focus = TRUE;
-      book->focus_sheet = sheet;
-	}
-
-=======
 	LINK_OBJECT (book->sheet_first, book->sheet_last, sheet);
 
 	if (IS_NULL (book->focus_sheet)) {
 		sheet->has_focus = TRUE;
 		book->focus_sheet = sheet;
 	}
-	
->>>>>>> e749749c2b8e3b9d700ffd4ce1f0096c46fb5493:gtkworkbook/workbook.c
+
 	return sheet;
 }
 
@@ -241,11 +226,9 @@ workbook_object_init (GtkWidget * window, const gchar * filename)
 	gtk_notebook_set_show_tabs (notebook, TRUE);
 	gtk_notebook_set_show_border (notebook, TRUE);
 	gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
-<<<<<<< HEAD:workbook/workbook.c
-	gtk_widget_show (book->gtk_notebook);
-=======
+
 	gtk_widget_show_all (book->gtk_notebook);
->>>>>>> e749749c2b8e3b9d700ffd4ce1f0096c46fb5493:gtkworkbook/workbook.c
+
 	gdk_threads_leave ();
 
 	/* Members */

commit 614d77e9d6007472fcc9b01417b5f2728e8c3675
Merge: a03216b... e749749...
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 11:29:20 2009 -0400

    Merge branch 'working' into largefile
    
    Conflicts:
    	.gitignore
    	gtkworkbook/workbook.c
    	src/application.c
    	src/application.h
    	src/largefile/plugin_main.cpp
    	src/largefile/thread_main.cpp
    	workbook/sheet.c

commit a03216b129e5694f95c3062deeac1c277117a03d
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 11:24:20 2009 -0400

    Revert "Added entry to .gitignore file."
    
    This reverts commit 2be436810b7d2d05100603d9286af327d3721be3.

diff --git a/.gitignore b/.gitignore
index 6f5f9d5..bf37f2d 100755
--- a/.gitignore
+++ b/.gitignore
@@ -5,5 +5,4 @@ bin/
 lib/
 csv/libcsv.*
 massif*
-*.log
-\#*\#
\ No newline at end of file
+*.log
\ No newline at end of file

commit e749749c2b8e3b9d700ffd4ce1f0096c46fb5493
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 11:12:59 2009 -0400

    (1) Removed gtk_sheet growing methods because they seem to be triggering a
    heap problem after all. This will be added to the TODO file.
    (2) Modified CsvParser to accept Sheet pointer instead of Workbook pointer.
    (3) Modified Largefile to track FileDispatcher(s) in the filename map instead
    of event identifiers.

diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
index 172602b..10b639c 100755
--- a/gtkworkbook/sheet.c
+++ b/gtkworkbook/sheet.c
@@ -57,7 +57,7 @@ struct geometryFileEntry {
 	GdkColor cellForeground;
 	GdkColor cellBackground;
 };
-
+/*
 static GtkSheetCell *
 gtk_sheet_cell_new (void) {
 	GtkSheetCell * cell = g_new (GtkSheetCell, 1);
@@ -108,7 +108,7 @@ CheckBounds (GtkSheet * tbl, gint row, gint col) {
 	if (row > tbl->maxallocrow) newrows = row - tbl->maxallocrow;
 	if (newrows > 0 || newcols > 0) GrowSheet (tbl, newrows, newcols);
 }
-
+*/
 /* @description: This method creates a new Sheet object and returns the
    pointer to that object. It calls the constructor function to do so.
    @book: A pointer to the Workbook that the object will be a part of.
@@ -191,8 +191,10 @@ sheet_object_init (Workbook * book,
 	/* Connect any signals that we need to. */
 	if (!IS_NULL (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]))
 	{
+		/*
       gtk_signal_connect (GTK_OBJECT (sheet->gtk_sheet), "changed",
 								  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]), sheet);
+		*/
 	}
 
 	/*gdk_threads_leave ();*/
diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index 9a72de7..8ff32c7 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -1,20 +1,20 @@
 /*
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "CsvParser.hpp"
 #include <gtkworkbook/sheet.h>
@@ -24,132 +24,130 @@
 
 namespace largefile {
 
-  struct csv_column {
-	Sheet * sheet;
-	Cell ** array;
-	int & array_max;
-	int & array_size;
-	int row;
-	int field;
-	char * value;
-  };
-
-  /* This structure is due to the libcsv parser; it uses function pointers to
-     do any work inside of an actual tuple. So the cb1 is called after a field
-     is parsed and cb2 is called after a tuple/row is parsed. */
-  static void 
-  cb1 (void * s, size_t length, void * data) {
-	struct csv_column * column = (struct csv_column *) data;
-	int & array_max = column->array_max;
-
-	// Resize the cell array here.
-	if (column->field >= array_max) {
-	  int max = (2 * array_max);
-	  (column->array) = (Cell **) g_realloc ((column->array),max*sizeof (Cell*));
-
-	  for (int ii = array_max; ii < max; ii++)
-	    (column->array)[ii] = NULL;
-	}
+	struct csv_column {
+		Sheet * sheet;
+		Cell ** array;
+		int & array_max;
+		int & array_size;
+		int row;
+		int field;
+		char * value;
+	};
+
+	/* This structure is due to the libcsv parser; it uses function pointers to
+		do any work inside of an actual tuple. So the cb1 is called after a field
+		is parsed and cb2 is called after a tuple/row is parsed. */
+	static void 
+	cb1 (void * s, size_t length, void * data) {
+		struct csv_column * column = (struct csv_column *) data;
+		int & array_max = column->array_max;
+
+		// Resize the cell array here.
+		if (column->field >= array_max) {
+			int max = (2 * array_max);
+			(column->array) = (Cell **) g_realloc ((column->array),max*sizeof (Cell*));
+
+			for (int ii = array_max; ii < max; ii++)
+				(column->array)[ii] = NULL;
+		}
 	
-	if ((column->array)[column->field] == NULL)
-	  (column->array)[column->field] = cell_new();
-
-	Cell * cell = (column->array)[column->field];
-	cell->set_row (cell, column->row);
-	cell->set_column (cell, column->field++);
-	cell->set_value_length (cell, s, length);
-  }
+		if ((column->array)[column->field] == NULL)
+			(column->array)[column->field] = cell_new();
+
+		Cell * cell = (column->array)[column->field];
+		cell->set_row (cell, column->row);
+		cell->set_column (cell, column->field++);
+		cell->set_value_length (cell, s, length);
+	}
   
-  static void
-  cb2 (int c, void * data) {
-    struct csv_column * column = (struct csv_column *)data;
-    column->row++;
-    column->array_size = column->field - 1;
-    column->field = 0;
-  }
-
-  CsvParser::CsvParser (Workbook * wb,
-			FILE * log,
-			int verbosity,
-			int maxOfFields) {
-    this->wb = wb;
-    this->log = log;
-    this->verbosity = verbosity;
-    this->sizeOfFields = 0;
-    this->maxOfFields = maxOfFields;
-    this->fields = (Cell **) g_malloc (maxOfFields*sizeof (Cell*));
-
-    for (int ii = 0; ii < this->maxOfFields; ii++)
-      this->fields[ii] = NULL;
-  }
-
-  CsvParser::~CsvParser (void) {
-    for (int ii = 0; ii < this->maxOfFields; ii++) {
-      if (this->fields[ii])
-	    (this->fields[ii])->destroy (this->fields[ii]);
+	static void
+	cb2 (int c, void * data) {
+		struct csv_column * column = (struct csv_column *)data;
+		column->row++;
+		column->array_size = column->field - 1;
+		column->field = 0;
 	}
-    
-    g_free (this->fields);
-  }
-
-  void *
-  CsvParser::run (void * null) {
-    this->running = true;
-    std::queue<std::string> queue;
-    struct csv_parser csv;
-    struct csv_column column = {this->wb->sheet_first,
-				this->fields,
-				this->maxOfFields,
-				this->sizeOfFields,
-				0,
-				0,
-				new char [1024]};
-    
-    if (csv_init (&csv, CSV_STRICT) != 0) {
-      std::cerr << "Failed initializing libcsv parser library\n";
-      return NULL;
-    }
-
-    while (this->running == true) {
-      if (this->inputQueue.size() > 0) {
-	
-	// Lock, copy, clear, unlock. - Free this up.
-	this->inputQueue.lock();
-	this->inputQueue.copy (queue);
-	this->inputQueue.clear();
-	this->inputQueue.unlock();
-
-	while (queue.size() > 0) {
-	  std::string buf = queue.front(); queue.pop();
-	  size_t bytes = buf.length();
 
-	  if (this->running == false)
-	    break;
-
-	  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
-	    if (csv_error (&csv) == CSV_EPARSE) {
-	      std::cerr << "Parsing error on input: "<<"\n";
-	      continue;
-	    }
-	  }
-
-	  csv_fini (&csv, cb1, cb2, &column);
+	CsvParser::CsvParser (Sheet * sheet,
+								 FILE * log,
+								 int verbosity,
+								 int maxOfFields)
+		: sheet(sheet), log (log), maxOfFields (maxOfFields) {
+		this->wb = sheet->workbook;
+		this->sizeOfFields = 0;
+		this->fields = (Cell **) g_malloc (maxOfFields*sizeof (Cell*));
+
+		for (int ii = 0; ii < this->maxOfFields; ii++)
+			this->fields[ii] = NULL;
+	}
 
-	  this->wb->sheet_first->apply_row (this->wb->sheet_first,
-					    this->fields,
-					    column.row - 1,
-					    this->sizeOfFields);
+	CsvParser::~CsvParser (void) {
+		for (int ii = 0; ii < this->maxOfFields; ii++) {
+			if (this->fields[ii])
+				(this->fields[ii])->destroy (this->fields[ii]);
+		}
+    
+		g_free (this->fields);
+	}
 
-	  if (column.row >= (column.sheet)->max_rows)
-	    column.row = 0;
+	void *
+	CsvParser::run (void * null) {
+		this->running = true;
+		std::queue<std::string> queue;
+		struct csv_parser csv;
+		struct csv_column column = {sheet,
+											 this->fields,
+											 this->maxOfFields,
+											 this->sizeOfFields,
+											 0,
+											 0,
+											 new char [1024]};
+    
+		if (csv_init (&csv, CSV_STRICT) != 0) {
+			std::cerr << "Failed initializing libcsv parser library\n";
+			return NULL;
+		}
 
-	  concurrent::Thread::sleep(5);
+		while (this->running == true) {
+			if (this->inputQueue.size() > 0) {
+	
+				// Lock, copy, clear, unlock. - Free this up.
+				this->inputQueue.lock();
+				this->inputQueue.copy (queue);
+				this->inputQueue.clear();
+				this->inputQueue.unlock();
+
+				while (queue.size() > 0) {
+					std::string buf = queue.front(); queue.pop();
+					size_t bytes = buf.length();
+
+					if (this->running == false)
+						break;
+
+					if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
+						if (csv_error (&csv) == CSV_EPARSE) {
+							std::cerr << "Parsing error on input: "<<"\n";
+							continue;
+						}
+					}
+
+					csv_fini (&csv, cb1, cb2, &column);
+
+					sheet->apply_row (sheet,
+											this->fields,
+											column.row - 1,
+											this->sizeOfFields);
+
+					if (column.row >= (column.sheet)->max_rows)
+						column.row = 0;
+
+					concurrent::Thread::sleep(5);
+				}
+			}	
+			concurrent::Thread::sleep(5);
+		}
+
+		return NULL;
 	}
-      }	
-      concurrent::Thread::sleep(5);
-    }
-
-    return NULL;
-  }
 
 } // end of namespace
diff --git a/src/largefile/CsvParser.hpp b/src/largefile/CsvParser.hpp
index 759768e..2bc251e 100755
--- a/src/largefile/CsvParser.hpp
+++ b/src/largefile/CsvParser.hpp
@@ -1,20 +1,20 @@
 /*
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #ifndef HPP_LF_CSVPARSER
 #define HPP_LF_CSVPARSER
@@ -26,20 +26,21 @@
 
 namespace largefile {
 
-  class CsvParser : public proactor::Worker {
-  private:
-    Workbook * wb;
-    Cell ** fields;
-    FILE * log;
-    int verbosity;
-    int maxOfFields;
-    int sizeOfFields;
-  public:
-    CsvParser (Workbook * wb, FILE * log, int verbosity, int maxOfFields = 10);
-    virtual ~CsvParser (void);
-
-    void * run (void * null);
-  };
+	class CsvParser : public proactor::Worker {
+	private:
+		Sheet * sheet;
+		Workbook * wb;
+		Cell ** fields;
+		FILE * log;
+		int verbosity;
+		int maxOfFields;
+		int sizeOfFields;
+	public:
+		CsvParser (Sheet * sheet, FILE * log, int verbosity, int maxOfFields = 10);
+		virtual ~CsvParser (void);
+
+		void * run (void * null);
+	};
 
 } // end of namespace
 
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index b4a7ce1..3355b30 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -43,23 +43,22 @@ append_pidname (const gchar * pre) {
 
 static gint
 key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
-	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
-	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
-	//Workbook * wb = (Workbook *)arguments->at(1);
-	//GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
-
+	Largefile * lf = (Largefile *)data;
+	Workbook * wb = lf->workbook();
+	Sheet * sheet = wb->focus_sheet;
+		
 	//	int vposition = std::abs((int)gtksheet->vadjustment->value);
 	static off64_t cursor = 0;
 	//	float N = vposition, K = 24388, V = (N/K);
 	
 	switch (event->keyval) {
 		case GDK_F1: {
-			fd->read(1012121,1000);
+			lf->read(sheet, 1012121,1000);
 		}
 		break;
 		
 		case GDK_Page_Up: {
-			fd->read(cursor, 100);
+			lf->read(sheet, cursor, 100);
 			cursor += 100;
 		}
 		return TRUE;
@@ -70,7 +69,7 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 			else
 				cursor -= 100;
 			
-			fd->read(cursor, 100);
+			lf->read(sheet, cursor, 100);
 		}
 		return TRUE;
 	}
@@ -98,18 +97,38 @@ Largefile::Largefile (Application * appstate, Handle * platform)
 					" thread", logname.c_str());
 		return;
     }
+
+	gtk_signal_connect (GTK_OBJECT (this->wb->gtk_window), "key_press_event",
+							  GTK_SIGNAL_FUNC (key_press_callback), this);
 }
 
 Largefile::~Largefile (void) {
 }
 
 bool
-Largefile::open_file (const std::string & filename) {
+Largefile::read (Sheet * sheet, off64_t start, off64_t N) {
+	this->lock();
+	std::string key = sheet->name;
+	
+	FilenameMap::iterator it = this->mapping.find (key);
+	if (it == this->mapping.end()) {
+		this->unlock();
+		return false;
+	}
+
+	FileDispatcher * fd = it->second;
+	fd->read (start, N);
+	this->unlock();
+	return true;
+}
+
+bool
+Largefile::open_file (Sheet * sheet, const std::string & filename) {
 	this->lock();
 	
 	int fdEventId = proactor::Event::uniqueEventId();
 	FileDispatcher * fd = new FileDispatcher (fdEventId, appstate->proactor());
-	CsvParser * csv = new CsvParser (this->wb, this->pktlog, 0, 20);
+	CsvParser * csv = new CsvParser (sheet, this->pktlog, 0, 20);
 
 	if (appstate->proactor()->addWorker (fdEventId, csv) == false) {
 		g_critical ("Failed starting CsvParser for file %s", filename.c_str());
@@ -129,7 +148,7 @@ Largefile::open_file (const std::string & filename) {
 		return false;
 	}
 
-	this->mapping.insert (std::make_pair (std::string(filename), fdEventId));
+	this->mapping.insert (std::make_pair (std::string(filename), fd));
 	
 	this->unlock();
 	return true;
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
index 4e3e45e..a549d6b 100755
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -1,24 +1,48 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_LARGEFILE
 #define HPP_LARGEFILE
 
 #include <map>
 #include <string>
+#include "File.hpp"
 #include "../Plugin.hpp"
 #include "../Application.hpp"
 #include "../config.h"
 
-class Largefile : public Plugin {
-private:
-	typedef std::map<std::string,int> FilenameMap;
+namespace largefile {
+
+	class Largefile : public Plugin {
+	private:
+		typedef std::map<std::string,FileDispatcher *> FilenameMap;
 	
-	FILE * pktlog;
-	FilenameMap mapping;
-public:
-	Largefile (Application * appstate, Handle * platform);
-	virtual ~Largefile (void);
-
-	bool open_file (const std::string & filename);
-	bool exit_file (const std::string & filename);
-};
+		FILE * pktlog;
+		FilenameMap mapping;
+	public:
+		Largefile (Application * appstate, Handle * platform);
+		virtual ~Largefile (void);
+
+		bool open_file (Sheet * sheet, const std::string & filename);
+		bool exit_file (const std::string & filename);
+		bool read (Sheet * sheet, off64_t start, off64_t N);
+	};
+
+}
 	
 #endif
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 2f2ee74..c677ff4 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -24,8 +24,7 @@
 #include "../config.h"
 #include "../Application.hpp"
 
-/* Prototypes */
-extern void thread_main (ThreadArgs *);
+using largefile::Largefile;
 
 static void
 open_csv_file (GtkWidget * w, gpointer data) {
@@ -43,11 +42,18 @@ open_csv_file (GtkWidget * w, gpointer data) {
   if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
     gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
 
-	 if (lf->open_file (filename) == true) {
-		 lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
+	 Sheet * sheet = lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
+
+	 if (sheet == NULL) {
+		 g_warning ("Failed adding new sheet because one already exists");
 	 }
 	 else {
-		 // STUB: The opening of the file failed. Do something meaningful here.
+	 	 if (lf->open_file (sheet, filename) == true) {
+			 // STUB: Do something magical.
+		 }
+		 else {
+			 // STUB: The opening of the file failed. Do something meaningful here.
+		 }
 	 }
 	 
     g_free (filename);
@@ -64,7 +70,7 @@ largefile_mainmenu_new (Application * appstate, Largefile * lf, GtkWidget * wind
 	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
 
 	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
-							G_CALLBACK (open_csv_file), (gpointer)lf);
+							G_CALLBACK (open_csv_file), lf);
 	
 	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
 	return lfmenu_item;

commit 779b955791577da2c0d4a82b9a66082db2b233af
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 10:47:03 2009 -0400

    Removed thread_main.cpp which was left over from old plugin architecture.

diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
deleted file mode 100755
index 67d9250..0000000
--- a/src/largefile/thread_main.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <gdk/gdkkeysyms.h>
-#include <gtkworkbook/workbook.h>
-#include <concurrent/Thread.hpp>
-#include <concurrent/ThreadArgs.hpp>
-#include <concurrent/ScopedMemoryLock.hpp>
-#include <proactor/Proactor.hpp>
-#include <proactor/Event.hpp>
-#include <gtkextra/gtksheet.h>
-#include <fstream>
-#include <iostream>
-#include <string>
-#include <sstream>
-#include "File.hpp"
-#include "CsvParser.hpp"
-#include "../config.h"
-
-using namespace largefile;
-
-/* @description: This method creates a filename with the prefix supplied and
-   uses the pid of the process as its suffix. 
-   @pre: The prefix (should be a file path, obviously). */
-static std::string
-append_pidname (const gchar * pre) {
-  std::stringstream s;
-  s << pre << getppid();
-  return s.str();
-}
-
-static gint
-key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
-	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
-	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
-	//Workbook * wb = (Workbook *)arguments->at(1);
-	//GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
-
-	//int vposition = std::abs((int)gtksheet->vadjustment->value);
-	static off64_t cursor = 0;
-	//	float N = vposition, K = 24388, V = (N/K);
-	
-	switch (event->keyval) {
-		case GDK_F1: {
-			fd->read(1012121,1000);
-		}
-		break;
-		
-		case GDK_Page_Up: {
-			fd->read(cursor, 100);
-			cursor += 100;
-		}
-		return TRUE;
-
-		case GDK_Page_Down: {
-			if (cursor <= 100)
-				cursor = 0;
-			else
-				cursor -= 100;
-			
-			fd->read(cursor, 100);
-		}
-		return TRUE;
-	}
-	return FALSE;
-}
-	
-void
-thread_main (ThreadArgs * args) {
-	Workbook * wb = (Workbook *)args->at(0);
-	Config * cfg  = (Config *)args->at(1);
-	gboolean * SHUTDOWN = (gboolean *)args->at(2);
-	ConfigPair * logpath = cfg->get_pair (cfg, "largefile", "log", "path");
-	if (IS_NULL (logpath)) {
-		g_critical ("Failed loading log->path from configuration file; "
-					"exiting thread");
-		return;
-	}
-
-	FILE * pktlog = NULL;
-	std::string logname = std::string (logpath->value).append("/");
-	logname.append (append_pidname("largefile.").append(".log"));
-
-	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
-		g_critical ("Failed opening file '%s' for packet logging; exiting"
-					" thread", logname.c_str());
-		return;
-    }
-
-	int fdEventId = proactor::Event::uniqueEventId(); 
-	proactor::Proactor proactor;
-	FileDispatcher fdispatcher (fdEventId, &proactor);
-	CsvParser csv_parser (wb, pktlog, 0, 20);
-
-	if (proactor.start() == false) {
-		g_critical ("Failed starting Proactor; exiting thread.");
-		return;
-	}
-
-	if (proactor.addWorker (fdEventId, &csv_parser) == false) {
-		g_critical ("Failed starting CsvParser; exiting thread.");
-		return;
-	}
-
-	if (fdispatcher.open ("/home/jbellone/largefile.csv") == false) {
-		g_critical ("Failed opening /home/johnb/largefile.csv");
-		return;
-	}
-
-	if (fdispatcher.start() == false) {
-		g_critical ("Failed starting file dispatcher; exiting thread.");
-		return;
-	}
-	
-	std::vector<gpointer> signal_arguments;
-	signal_arguments.push_back( (gpointer)&fdispatcher );
-	signal_arguments.push_back( (gpointer)wb );
-	
-	gtk_signal_connect (GTK_OBJECT (wb->gtk_window), "key_press_event",
-							  GTK_SIGNAL_FUNC (key_press_callback),
-							  (gpointer)&signal_arguments);
-
-	while (*SHUTDOWN == FALSE) {
-		concurrent::Thread::sleep (100);
-	}
-
-	csv_parser.stop();
-  
-	FCLOSE (pktlog);
-	delete args;
-}

commit f6c7be88207eeea4481833108826cfd9d289b075
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 10:14:14 2009 -0400

    (1) gtk_main_quit() was being called twice. The second call to Application->shutdown()
    was removed from the Application destructor.

diff --git a/src/Application.cpp b/src/Application.cpp
index 29ae714..c5f9698 100755
--- a/src/Application.cpp
+++ b/src/Application.cpp
@@ -186,8 +186,6 @@ Application::~Application (void) {
 	}
 	
 	FREE (this->absolute_path);
-
-	this->shutdown();
 }
 
 Plugin *

commit 57886503759fb0af4a08ba4a3c681e5da3bdc4e9
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 10:09:10 2009 -0400

    (1) Fixed gtk_widget_show_all issue not presenting the sheet's vertical box.
    (2) Fixed issue with labels not appearing until sheet switched.

diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
index 6c890f6..172602b 100755
--- a/gtkworkbook/sheet.c
+++ b/gtkworkbook/sheet.c
@@ -137,12 +137,11 @@ sheet_object_init (Workbook * book,
 						 const gchar * label, 
 						 gint rows, gint columns)
 {
-	gdk_threads_enter ();
+	/*gdk_threads_enter ();*/
 	Sheet * sheet = NEW (Sheet);
 
 	/* Create the sheet containers and GtkSheet object. */
 	sheet->gtk_box = gtk_vbox_new (FALSE, 1);
-	gtk_widget_show (sheet->gtk_box);
 
 	GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
 	gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
@@ -157,7 +156,6 @@ sheet_object_init (Workbook * book,
 	gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
 	gtk_container_add (GTK_CONTAINER (scrolled_window),
 							 GTK_WIDGET (sheet->gtk_sheet));
-	gtk_widget_show_all (sheet->gtk_sheet);
 
 	/* We should be able to use sheet->gtk_box now throughout all of our
 		tests when iterating through a GtkNotebook structure. The page number
@@ -166,6 +164,7 @@ sheet_object_init (Workbook * book,
 	sheet->page = gtk_notebook_append_page (GTK_NOTEBOOK (book->gtk_notebook),
 														 sheet->gtk_box,
 														 sheet->gtk_label);
+
 	/* Members */
 	sheet->workbook = book;
 	sheet->name = g_strdup (label);
@@ -196,7 +195,9 @@ sheet_object_init (Workbook * book,
 								  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]), sheet);
 	}
 
-	gdk_threads_leave ();
+	/*gdk_threads_leave ();*/
+	
+	gtk_widget_show_all (sheet->gtk_box);
 	return sheet;
 }
 
diff --git a/gtkworkbook/workbook.c b/gtkworkbook/workbook.c
index 2e596fe..4dfe603 100755
--- a/gtkworkbook/workbook.c
+++ b/gtkworkbook/workbook.c
@@ -25,15 +25,15 @@ static void workbook_method_destroy (Workbook *);
 static Workbook *workbook_object_init (GtkWidget *, const gchar *);
 static Workbook *workbook_object_free (Workbook *);
 static Sheet *workbook_method_addnewsheet (Workbook *, 
-					   const gchar *, 
-					   gint, gint);
+														 const gchar *, 
+														 gint, gint);
 static Sheet *workbook_method_get_sheet (Workbook *, const gchar *);
 static void workbook_method_remove_sheet (Workbook *, Sheet *);
 static gboolean workbook_method_move_sheet_index (Workbook *, Sheet *, gint);
 static gboolean workbook_method_move_sheet (Workbook *, 
-					    Sheet *,
-					    const gchar *,
-					    gboolean);
+														  Sheet *,
+														  const gchar *,
+														  gboolean);
 
 /* @description: This method "opens" a Workbook. In the future it will load
    a Workbook from a specified filename (which will most likely be a GZIP
@@ -43,14 +43,14 @@ static gboolean workbook_method_move_sheet (Workbook *,
 Workbook *
 workbook_open (GtkWidget * window, const gchar * filename)
 {
-  ASSERT (window != NULL);
+	ASSERT (window != NULL);
 
-  /* STUB: A workbook is opened here from some form of an archived file.
-     At this point we would load up the configuration files for the styles,
-     sheets and plugins to be loaded then this would all be executed here. */
+	/* STUB: A workbook is opened here from some form of an archived file.
+		At this point we would load up the configuration files for the styles,
+		sheets and plugins to be loaded then this would all be executed here. */
 
-  Workbook * book = workbook_object_init (window, filename);
-  return book;
+	Workbook * book = workbook_object_init (window, filename);
+	return book;
 }
 
 /* @description: This method adds a new Sheet to the Workbook object. The
@@ -63,35 +63,30 @@ workbook_open (GtkWidget * window, const gchar * filename)
    @cols: Number of columns the GtkSheet object should have.*/
 static Sheet *
 workbook_method_addnewsheet (Workbook * book,
-			     const gchar * label, 
-			     gint rows, 
-			     gint cols)
+									  const gchar * label, 
+									  gint rows, 
+									  gint cols)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
 
-  Sheet * sheet = book->get_sheet (book, label);
-  if (sheet != NULL) 
-    {
+	Sheet * sheet = book->get_sheet (book, label);
+	if (sheet != NULL) 
+	{
       g_warning ("Cannot create '%s' because it already exists", 
-		 label);
+					  label);
       return NULL;
-    }
+	}
 
-  sheet = sheet_new (book, label, rows, cols);
+	sheet = sheet_new (book, label, rows, cols);
 
-  LINK_OBJECT (book->sheet_first,
-	       book->sheet_last, 
-	       sheet);
+	LINK_OBJECT (book->sheet_first, book->sheet_last, sheet);
 
-  /* We are the first and only sheet; make sure we are set to have focus. */
-  /* BUGFIX: This was in the wrong place... needs to be below LINK_OBJECT */
-  if ((book->sheet_first == sheet) && IS_NULL (book->sheet_last))
-    {
-      sheet->has_focus = TRUE;
-      book->focus_sheet = sheet;
-    }
-
-  return sheet;
+	if (IS_NULL (book->focus_sheet)) {
+		sheet->has_focus = TRUE;
+		book->focus_sheet = sheet;
+	}
+	
+	return sheet;
 }
 
 /* @description: This method performs a search of all the Workbooks and
@@ -101,20 +96,20 @@ workbook_method_addnewsheet (Workbook * book,
 static Sheet *
 workbook_method_get_sheet (Workbook * wb, const gchar * sheet)
 {
-  ASSERT (wb != NULL);
+	ASSERT (wb != NULL);
 
-  if (!IS_NULLSTR (sheet))
-    {
+	if (!IS_NULLSTR (sheet))
+	{
       ITERATE_BEGIN (Sheet, wb->sheet_first);
       {
-	if (!sheet) return NULL;
-	if (!strcmp (sheet, it->name))
-	  return it;
+			if (!sheet) return NULL;
+			if (!strcmp (sheet, it->name))
+				return it;
       }
       ITERATE_END ();
-    }
+	}
 
-  return NULL;
+	return NULL;
 }
 
 /* @description: This method removes a Sheet object from the Workbook. It also
@@ -124,33 +119,33 @@ workbook_method_get_sheet (Workbook * wb, const gchar * sheet)
 static void
 workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
 {
-  ASSERT (wb != NULL);
+	ASSERT (wb != NULL);
 
-  if (sheet->workbook != wb)
-    {
+	if (sheet->workbook != wb)
+	{
       g_warning ("'%s' does not belong to workbook '%s'",
-		 sheet->name, wb->filename);
+					  sheet->name, wb->filename);
       return;
-    }
+	}
   
-  ITERATE_BEGIN (Sheet, wb->sheet_first);
-  {
-    /* Remove the sheet from the GtkNotebook */
-    if (it == sheet)
+	ITERATE_BEGIN (Sheet, wb->sheet_first);
+	{
+		/* Remove the sheet from the GtkNotebook */
+		if (it == sheet)
       {
-	gdk_threads_enter ();
-	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
-					   sheet->gtk_box);
-	gtk_notebook_remove_page (GTK_NOTEBOOK (wb->gtk_notebook), page); 
-	gtk_widget_queue_draw (wb->gtk_notebook);
-	gdk_threads_leave ();
-	return;
+			gdk_threads_enter ();
+			gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
+														  sheet->gtk_box);
+			gtk_notebook_remove_page (GTK_NOTEBOOK (wb->gtk_notebook), page); 
+			gtk_widget_queue_draw (wb->gtk_notebook);
+			gdk_threads_leave ();
+			return;
       }
-  }
-  ITERATE_END ();
+	}
+	ITERATE_END ();
 
-  g_warning ("Sheet '%s' was not found inside of workbook '%s'", 
-	     sheet->name, wb->filename);
+	g_warning ("Sheet '%s' was not found inside of workbook '%s'", 
+				  sheet->name, wb->filename);
 }
 
 /* @description: This method moves the Sheet's GtkSheet tab inside of the
@@ -161,52 +156,52 @@ workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
 static gboolean
 workbook_method_move_sheet_index (Workbook * wb, Sheet * sheet, gint index)
 {
-  gdk_threads_enter ();
-  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
-			      sheet->gtk_box,
-			      index);
-  gdk_threads_leave ();
-  return TRUE;
+	gdk_threads_enter ();
+	gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
+										 sheet->gtk_box,
+										 index);
+	gdk_threads_leave ();
+	return TRUE;
 }
 
 static gboolean
 workbook_method_move_sheet (Workbook * wb, 
-			    Sheet * sheet, 
-			    const gchar * id,
-			    gboolean after)
+									 Sheet * sheet, 
+									 const gchar * id,
+									 gboolean after)
 {
-  ASSERT (wb != NULL);
-  ASSERT (sheet != NULL);
+	ASSERT (wb != NULL);
+	ASSERT (sheet != NULL);
 
-  if (IS_NULLSTR (id))
-    return FALSE;
+	if (IS_NULLSTR (id))
+		return FALSE;
 
-  Sheet * sh = wb->get_sheet (wb, id);
-  if (IS_NULL (sh))
-    {
+	Sheet * sh = wb->get_sheet (wb, id);
+	if (IS_NULL (sh))
+	{
       g_warning ("Sheet '%s' does not exist in workbook '%s'", 
-		 sheet->name, wb->filename);
+					  sheet->name, wb->filename);
       return FALSE;
-    }
+	}
   
-  gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
-				     sh->gtk_box);
-  if (page == -1)
-    {
+	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
+												  sh->gtk_box);
+	if (page == -1)
+	{
       g_warning ("Sheet '%s' does not appear to be in workbook '%s' notebook",
-		 sheet->name, wb->filename);
+					  sheet->name, wb->filename);
       return FALSE;
-    }
+	}
 
-  if (after == TRUE)  page++;
-  else                page--;
+	if (after == TRUE)  page++;
+	else                page--;
 
-  gdk_threads_enter ();
-  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
-			      sheet->gtk_box,
-			      page);
-  gdk_threads_leave ();
-  return TRUE;
+	gdk_threads_enter ();
+	gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
+										 sheet->gtk_box,
+										 page);
+	gdk_threads_leave ();
+	return TRUE;
 }
 
 /* @description: This is a Workbook object's constructor. 
@@ -215,41 +210,41 @@ workbook_method_move_sheet (Workbook * wb,
 static Workbook *
 workbook_object_init (GtkWidget * window, const gchar * filename)
 {
-  Workbook * book = NEW (Workbook);
+	Workbook * book = NEW (Workbook);
 
-  /* Set up the signals. */
-  book->signals[SIG_WORKBOOK_CHANGED] = NULL;
+	/* Set up the signals. */
+	book->signals[SIG_WORKBOOK_CHANGED] = NULL;
 
-  /* Set up the notebook */
-  gdk_threads_enter ();
-  book->gtk_notebook = gtk_notebook_new ();
+	/* Set up the notebook */
+	gdk_threads_enter ();
+	book->gtk_notebook = gtk_notebook_new ();
   
-  GtkNotebook * notebook = GTK_NOTEBOOK (book->gtk_notebook);
-
-  gtk_notebook_set_tab_pos (notebook, GTK_POS_BOTTOM);
-  gtk_notebook_popup_enable (notebook);
-  gtk_notebook_set_show_tabs (notebook, TRUE);
-  gtk_notebook_set_show_border (notebook, TRUE);
-  gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
-  gtk_widget_show_all (book->gtk_notebook);
-  gdk_threads_leave ();
-
-  /* Members */
-  book->sheet_first = book->sheet_last = NULL;
-  book->next = book->prev = NULL;
-  book->focus_sheet = NULL;
-  book->gtk_window = window;
-  book->filename = g_strdup (filename);
+	GtkNotebook * notebook = GTK_NOTEBOOK (book->gtk_notebook);
+
+	gtk_notebook_set_tab_pos (notebook, GTK_POS_BOTTOM);
+	gtk_notebook_popup_enable (notebook);
+	gtk_notebook_set_show_tabs (notebook, TRUE);
+	gtk_notebook_set_show_border (notebook, TRUE);
+	gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
+	gtk_widget_show_all (book->gtk_notebook);
+	gdk_threads_leave ();
+
+	/* Members */
+	book->sheet_first = book->sheet_last = NULL;
+	book->next = book->prev = NULL;
+	book->focus_sheet = NULL;
+	book->gtk_window = window;
+	book->filename = g_strdup (filename);
     
-  /* Methods */
-  book->destroy = workbook_method_destroy;
-  book->add_new_sheet = workbook_method_addnewsheet;
-  book->get_sheet = workbook_method_get_sheet;
-  book->remove_sheet = workbook_method_remove_sheet;
-  book->move_sheet_index = workbook_method_move_sheet_index;
-  book->move_sheet = workbook_method_move_sheet;
-
-  return book;
+	/* Methods */
+	book->destroy = workbook_method_destroy;
+	book->add_new_sheet = workbook_method_addnewsheet;
+	book->get_sheet = workbook_method_get_sheet;
+	book->remove_sheet = workbook_method_remove_sheet;
+	book->move_sheet_index = workbook_method_move_sheet_index;
+	book->move_sheet = workbook_method_move_sheet;
+
+	return book;
 }
 
 /* @description: This method destroys the Workbook object and all of the
@@ -258,19 +253,19 @@ workbook_object_init (GtkWidget * window, const gchar * filename)
 static void
 workbook_method_destroy (Workbook * book)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
 
-  /* Wrap anything up here. */
-  Sheet * current = book->sheet_first, * next = NULL;
-  while (current)
-    {
+	/* Wrap anything up here. */
+	Sheet * current = book->sheet_first, * next = NULL;
+	while (current)
+	{
       next = current->next;
       current->destroy (current);
       current = next;
-    }
+	}
 
-  UNLINK_OBJECT (book);
-  workbook_object_free (book);
+	UNLINK_OBJECT (book);
+	workbook_object_free (book);
 }
 
 /* @description: This method frees the memory that the Workbook object has 
@@ -279,11 +274,11 @@ workbook_method_destroy (Workbook * book)
 static Workbook *
 workbook_object_free (Workbook * book)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
 
-  book->sheet_first = book->sheet_last = NULL;
+	book->sheet_first = book->sheet_last = NULL;
 
-  FREE (book->filename);
-  FREE (book);
-  return book;
+	FREE (book->filename);
+	FREE (book);
+	return book;
 }
diff --git a/src/Application.cpp b/src/Application.cpp
index 1ee3bf2..29ae714 100755
--- a/src/Application.cpp
+++ b/src/Application.cpp
@@ -92,9 +92,7 @@ signal_gtknotebook_switchpage (GtkNotebook * notebook,
 			it->notices = 0;
 	
 			/* Reset the label on the notebook tab to the object's name. */
-			gtk_notebook_set_tab_label_text (notebook,
-														it->gtk_box,
-														it->name);
+			gtk_notebook_set_tab_label_text (notebook, it->gtk_box, it->name);
 			book->focus_sheet = it;
 			break;
       }
@@ -221,20 +219,21 @@ Application::open_extension (const gchar * filename, gboolean absolute_path) {
 
 	Plugin * plugin = NULL;
 	if ((plugin = this->load_plugin (fname)) != NULL) {
+
 		if (plugin->workbook() == NULL) {
 			g_critical ("Plugin returned a NULL pointer instead of allocated"
 							" workbook.");
 			exit (1);
-		} else {
-			/* Attach all of the signals for the Workbook object. */
-			gtk_signal_connect (GTK_OBJECT (plugin->workbook()->gtk_notebook),
-									  "switch-page",
-									  (GtkSignalFunc)signal_gtknotebook_switchpage, 
-									  plugin->workbook());
-	  
-			this->workbooks.push_back (plugin->workbook());
 		}
+		
+		/* Attach all of the signals for the Workbook object. */
+		gtk_signal_connect (GTK_OBJECT (plugin->workbook()->gtk_notebook),
+								  "switch-page",
+								  (GtkSignalFunc)signal_gtknotebook_switchpage, 
+								  plugin->workbook());
+	
 		gtk_widget_show_all (this->gtk_menu);
+		this->workbooks.push_back (plugin->workbook());
 	}
 
 	FREE (fname);

commit f0abceb44b66fde1776be64ef3ec7d0132ac9df2
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 17 09:12:46 2009 -0400

    (1) Modified gtk_widget_show calls to perform gtk_widget_show_all.
    (2) Moved this->running in Thread.cc to be set before thread is executed.
    (3) Removed signals array (of function pointers) due to what seemed like a
    heap problem.
    (4) Uncommented GtkSheet growing functions in sheet.c, and fixed some formatting
    issues (tabs) in emacs.

diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
index 21e3244..6c890f6 100755
--- a/gtkworkbook/sheet.c
+++ b/gtkworkbook/sheet.c
@@ -28,89 +28,87 @@ static void sheet_method_set_cell (Sheet *, gint, gint, const gchar *);
 static void sheet_method_apply_cell (Sheet *, const Cell *);
 static void sheet_method_apply_cellarray (Sheet *, Cell **, gint);
 static void sheet_method_apply_cellrange (Sheet *, 
-					  const GtkSheetRange *,
-					  const CellAttributes *);
+														const GtkSheetRange *,
+														const CellAttributes *);
 static void sheet_method_range_set_background (Sheet *, 
-					       const GtkSheetRange *,
-					       const gchar *);
+															  const GtkSheetRange *,
+															  const gchar *);
 static void sheet_method_range_set_foreground (Sheet *,
-					       const GtkSheetRange *,
-					       const gchar *);
+															  const GtkSheetRange *,
+															  const gchar *);
 static void sheet_method_set_attention (Sheet *, gint);
 static gboolean sheet_method_load (Sheet *, const gchar *);
 static gboolean sheet_method_save (Sheet *, const gchar *);
 static void sheet_method_apply_cellrow (Sheet *, Cell **, gint, gint);
 
 struct geometryFileHeader {
-  gint fileVersion;
-  gint maxRow;
-  gint maxColumn;
+	gint fileVersion;
+	gint maxRow;
+	gint maxColumn;
 };
 
 struct geometryFileEntry {
-  gint cellRow;
-  gint cellCol;
-  gint cellTextLength;
-  gboolean cellIsVisible;
-  gboolean cellIsEditable;
-  GtkJustification cellJustification;
-  GdkColor cellForeground;
-  GdkColor cellBackground;
+	gint cellRow;
+	gint cellCol;
+	gint cellTextLength;
+	gboolean cellIsVisible;
+	gboolean cellIsEditable;
+	GtkJustification cellJustification;
+	GdkColor cellForeground;
+	GdkColor cellBackground;
 };
 
-/*
 static GtkSheetCell *
 gtk_sheet_cell_new (void) {
-  GtkSheetCell * cell = g_new (GtkSheetCell, 1);
-  cell->text = NULL;
-  cell->link = NULL;
-  cell->attributes = NULL;
-  return cell;
+	GtkSheetCell * cell = g_new (GtkSheetCell, 1);
+	cell->text = NULL;
+	cell->link = NULL;
+	cell->attributes = NULL;
+	return cell;
 }
-*/
-/*
+
 static void
 GrowSheet (GtkSheet * tbl, gint newrows, gint newcols) {
-  gint ii, jj, inirow, inicol;
+	gint ii, jj, inirow, inicol;
 
-  inirow = tbl->maxallocrow + 1;
-  inicol = tbl->maxalloccol + 1;
+	inirow = tbl->maxallocrow + 1;
+	inicol = tbl->maxalloccol + 1;
 
-  tbl->maxalloccol = tbl->maxalloccol + newcols;
-  tbl->maxallocrow = tbl->maxallocrow + newrows;
+	tbl->maxalloccol = tbl->maxalloccol + newcols;
+	tbl->maxallocrow = tbl->maxallocrow + newrows;
 
-  if (newrows > 0) {
-    tbl->data = (GtkSheetCell ***) g_realloc (tbl->data,
-					      (tbl->maxallocrow+1)*sizeof(GtkSheetCell**)+sizeof(double));
+	if (newrows > 0) {
+		tbl->data = (GtkSheetCell ***) g_realloc (tbl->data,
+																(tbl->maxallocrow+1)*sizeof(GtkSheetCell**)+sizeof(double));
 
-    for (ii = inirow; ii <= tbl->maxallocrow; ii++) {
-      tbl->data[ii] = (GtkSheetCell **) g_malloc ((tbl->maxcol+1)*sizeof(GtkSheetCell*)+sizeof(double));
+		for (ii = inirow; ii <= tbl->maxallocrow; ii++) {
+			tbl->data[ii] = (GtkSheetCell **) g_malloc ((tbl->maxcol+1)*sizeof(GtkSheetCell*)+sizeof(double));
 
-      for (jj = 0; jj < inicol; jj++)
-	tbl->data[ii][jj] = NULL;
-    }
-  }
+			for (jj = 0; jj < inicol; jj++)
+				tbl->data[ii][jj] = NULL;
+		}
+	}
 
-  if (newcols > 0) {
-    for (ii = 0; ii <= tbl->maxallocrow; ii++) {
-      tbl->data[ii] = (GtkSheetCell **) g_realloc (tbl->data[ii],
-						   (tbl->maxalloccol+1)*sizeof(GtkSheetCell*)+sizeof(double));
+	if (newcols > 0) {
+		for (ii = 0; ii <= tbl->maxallocrow; ii++) {
+			tbl->data[ii] = (GtkSheetCell **) g_realloc (tbl->data[ii],
+																		(tbl->maxalloccol+1)*sizeof(GtkSheetCell*)+sizeof(double));
 
-      for (jj = inicol; jj <= tbl->maxalloccol; jj++)
-	tbl->data[ii][jj] = NULL;
-    }
-  }
+			for (jj = inicol; jj <= tbl->maxalloccol; jj++)
+				tbl->data[ii][jj] = NULL;
+		}
+	}
 }
 
 static void
 CheckBounds (GtkSheet * tbl, gint row, gint col) {
-  gint newrows = 0, newcols = 0;
+	gint newrows = 0, newcols = 0;
 
-  if (col > tbl->maxalloccol) newcols = col - tbl->maxalloccol;
-  if (row > tbl->maxallocrow) newrows = row - tbl->maxallocrow;
-  if (newrows > 0 || newcols > 0) GrowSheet (tbl, newrows, newcols);
+	if (col > tbl->maxalloccol) newcols = col - tbl->maxalloccol;
+	if (row > tbl->maxallocrow) newrows = row - tbl->maxallocrow;
+	if (newrows > 0 || newcols > 0) GrowSheet (tbl, newrows, newcols);
 }
-*/
+
 /* @description: This method creates a new Sheet object and returns the
    pointer to that object. It calls the constructor function to do so.
    @book: A pointer to the Workbook that the object will be a part of.
@@ -120,13 +118,13 @@ CheckBounds (GtkSheet * tbl, gint row, gint col) {
 Sheet *
 sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
   
-  Sheet * sheet = sheet_object_init (book, label, rows, columns);
+	Sheet * sheet = sheet_object_init (book, label, rows, columns);
 
-  /* STUB: Perform anything that is based on a style here. */
+	/* STUB: Perform anything that is based on a style here. */
 
-  return sheet;
+	return sheet;
 }
 
 /* @description: This function is the Sheet's constructor. 
@@ -136,118 +134,116 @@ sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
    @cols: The amount of columns the GtkSheet widget should have. */
 static Sheet *
 sheet_object_init (Workbook * book,
-		   const gchar * label, 
-		   gint rows, gint columns)
+						 const gchar * label, 
+						 gint rows, gint columns)
 {
-  gdk_threads_enter ();
-  Sheet * sheet = NEW (Sheet);
+	gdk_threads_enter ();
+	Sheet * sheet = NEW (Sheet);
 
-  /* Create the sheet containers and GtkSheet object. */
-  sheet->gtk_box = gtk_vbox_new (FALSE, 1);
-  gtk_widget_show (sheet->gtk_box);
+	/* Create the sheet containers and GtkSheet object. */
+	sheet->gtk_box = gtk_vbox_new (FALSE, 1);
+	gtk_widget_show (sheet->gtk_box);
 
-  GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
-  gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
-				  GTK_POLICY_AUTOMATIC,
-				  GTK_POLICY_AUTOMATIC);
-  gtk_widget_show (scrolled_window);
+	GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
+	gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
+	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
+											  GTK_POLICY_AUTOMATIC,
+											  GTK_POLICY_AUTOMATIC);
+	gtk_widget_show (scrolled_window);
 
-  sheet->gtk_label = gtk_label_new (label);
+	sheet->gtk_label = gtk_label_new (label);
   
-  sheet->gtk_sheet = gtk_sheet_new (rows, columns, label);
-  gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
-  gtk_container_add (GTK_CONTAINER (scrolled_window),
-		     GTK_WIDGET (sheet->gtk_sheet));
-  gtk_widget_show (sheet->gtk_sheet);
-
-  /* We should be able to use sheet->gtk_box now throughout all of our
-     tests when iterating through a GtkNotebook structure. The page number
-     will change when something is removed (or reordered). The pointer will
-     stay the same. */
-  sheet->page = gtk_notebook_append_page (GTK_NOTEBOOK (book->gtk_notebook),
-					  sheet->gtk_box,
-					  sheet->gtk_label);
-  /* Members */
-  sheet->workbook = book;
-  sheet->name = g_strdup (label);
-  sheet->attention = 0;
-  sheet->notices = 0;
-  sheet->has_focus = FALSE;
-  sheet->next = sheet->prev = NULL;
-  sheet->max_rows = rows;
-  sheet->max_columns = columns;
-
-  /* Methods */
-  sheet->destroy = sheet_method_destroy;
-  sheet->set_cell = sheet_method_set_cell;
-  sheet->apply_range = sheet_method_apply_cellrange;
-  sheet->apply_array = sheet_method_apply_cellarray;
-  sheet->apply_cell = sheet_method_apply_cell;
-  sheet->apply_row = sheet_method_apply_cellrow;
-  sheet->range_set_foreground = sheet_method_range_set_foreground;
-  sheet->range_set_background = sheet_method_range_set_background;
-  sheet->set_attention = sheet_method_set_attention;
-  sheet->save = sheet_method_save;
-  sheet->load = sheet_method_load;
-
-  /* Connect any signals that we need to. */
-  if (!IS_NULL (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]))
-    {
-      gtk_signal_connect (GTK_OBJECT (sheet->gtk_sheet),
-			  "changed",
-		  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]),
-			  (gpointer)sheet);
-    }
-
-  gdk_threads_leave ();
-  return sheet;
+	sheet->gtk_sheet = gtk_sheet_new (rows, columns, label);
+	gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
+	gtk_container_add (GTK_CONTAINER (scrolled_window),
+							 GTK_WIDGET (sheet->gtk_sheet));
+	gtk_widget_show_all (sheet->gtk_sheet);
+
+	/* We should be able to use sheet->gtk_box now throughout all of our
+		tests when iterating through a GtkNotebook structure. The page number
+		will change when something is removed (or reordered). The pointer will
+		stay the same. */
+	sheet->page = gtk_notebook_append_page (GTK_NOTEBOOK (book->gtk_notebook),
+														 sheet->gtk_box,
+														 sheet->gtk_label);
+	/* Members */
+	sheet->workbook = book;
+	sheet->name = g_strdup (label);
+	sheet->attention = 0;
+	sheet->notices = 0;
+	sheet->has_focus = FALSE;
+	sheet->next = sheet->prev = NULL;
+	sheet->max_rows = rows;
+	sheet->max_columns = columns;
+
+	/* Methods */
+	sheet->destroy = sheet_method_destroy;
+	sheet->set_cell = sheet_method_set_cell;
+	sheet->apply_range = sheet_method_apply_cellrange;
+	sheet->apply_array = sheet_method_apply_cellarray;
+	sheet->apply_cell = sheet_method_apply_cell;
+	sheet->apply_row = sheet_method_apply_cellrow;
+	sheet->range_set_foreground = sheet_method_range_set_foreground;
+	sheet->range_set_background = sheet_method_range_set_background;
+	sheet->set_attention = sheet_method_set_attention;
+	sheet->save = sheet_method_save;
+	sheet->load = sheet_method_load;
+
+	/* Connect any signals that we need to. */
+	if (!IS_NULL (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]))
+	{
+      gtk_signal_connect (GTK_OBJECT (sheet->gtk_sheet), "changed",
+								  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]), sheet);
+	}
+
+	gdk_threads_leave ();
+	return sheet;
 }
 
 static gboolean
 sheet_method_load (Sheet * sheet, const gchar * filepath)
 {
-  ASSERT (sheet != NULL);
+	ASSERT (sheet != NULL);
 
-  if (IS_NULLSTR (filepath))
-    {
+	if (IS_NULLSTR (filepath))
+	{
       g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
       return FALSE;
-    }
+	}
 
-  FILE * fp = NULL;
-  if ((fp = fopen (filepath, "rb")) == NULL)
-    {
+	FILE * fp = NULL;
+	if ((fp = fopen (filepath, "rb")) == NULL)
+	{
       g_warning ("%s: failed opening file '%s' for reading", 
-		 __FUNCTION__,
-		 filepath);
+					  __FUNCTION__,
+					  filepath);
       return FALSE;
-    }
+	}
 
-  gdk_threads_enter ();
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
-  struct geometryFileHeader header = {-1,-1,-1};
-  struct geometryFileEntry entry = {-1,-1,-1};
+	gdk_threads_enter ();
+	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+	struct geometryFileHeader header = {-1,-1,-1};
+	struct geometryFileEntry entry = {-1,-1,-1};
  
-  fread ((void *)&header, sizeof (struct geometryFileHeader), 1, fp);
+	fread ((void *)&header, sizeof (struct geometryFileHeader), 1, fp);
 
-  if (header.fileVersion != GEOMETRY_FILE_VERSION)
-    {
+	if (header.fileVersion != GEOMETRY_FILE_VERSION)
+	{
       g_warning ("Geometry file version %d is not accepted. (%d)",
-		 header.fileVersion, GEOMETRY_FILE_VERSION);
+					  header.fileVersion, GEOMETRY_FILE_VERSION);
       FCLOSE (fp);
       gdk_threads_leave ();
       return FALSE;
-    }
+	}
 
-  while (fread ((void *)&entry, sizeof (struct geometryFileEntry), 1, fp) > 0)
-    {
+	while (fread ((void *)&entry, sizeof (struct geometryFileEntry), 1, fp) > 0)
+	{
       gchar * text = g_strndup ("", entry.cellTextLength);
       fread ((void *)text, sizeof (gchar), entry.cellTextLength, fp);
       gtk_sheet_set_cell_text (gtksheet, 
-			       entry.cellRow, 
-			       entry.cellCol, 
-			       text);
+										 entry.cellRow, 
+										 entry.cellCol, 
+										 text);
       
       GtkSheetCell ** cell = &gtksheet->data[entry.cellRow][entry.cellCol];
       
@@ -264,82 +260,82 @@ sheet_method_load (Sheet * sheet, const gchar * filepath)
       (*cell)->attributes->background.blue = entry.cellBackground.blue;
 
       FREE (text);
-    }
+	}
 
-  FCLOSE (fp);
-  gdk_threads_leave ();
-  return TRUE;
+	FCLOSE (fp);
+	gdk_threads_leave ();
+	return TRUE;
 }
 
 static gboolean
 sheet_method_save (Sheet * sheet, const gchar * filepath)
 {
-  ASSERT (sheet != NULL);
+	ASSERT (sheet != NULL);
 
-  if (IS_NULLSTR (filepath))
-    {
+	if (IS_NULLSTR (filepath))
+	{
       g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
       return FALSE;
-    }
+	}
 
-  FILE * fp = NULL;
-  if ((fp = fopen (filepath, "wb")) == NULL)
-    {
+	FILE * fp = NULL;
+	if ((fp = fopen (filepath, "wb")) == NULL)
+	{
       g_warning ("%s: failed opening file '%s' for writing", 
-		 __FUNCTION__, 
-		 filepath);
+					  __FUNCTION__, 
+					  filepath);
       return FALSE;
-    }
+	}
   
-  gdk_threads_enter ();
-  GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
-  struct geometryFileHeader header =
-    {
-      GEOMETRY_FILE_VERSION,
-      GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
-      GTK_SHEET (sheet->gtk_sheet)->maxalloccol
-    };
-
-  fwrite ((void *)&header, sizeof(struct geometryFileHeader), 1, fp);
-
-  for (gint ii = 0; ii <= header.maxRow; ii++)
-    {
-      for (gint jj = 0; jj <= header.maxColumn; jj++)
-	{
-	  GtkSheetCell * cell = data[ii][jj];
-
-	  if (!IS_NULL (cell) && !IS_NULLSTR(cell->text))
-	    {
-	      struct geometryFileEntry entry =
+	gdk_threads_enter ();
+	GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
+	struct geometryFileHeader header =
 		{
-		  cell->row,
-		  cell->col,
-		  strlen (cell->text),
-		  cell->attributes->is_visible,
-		  cell->attributes->is_editable,
-		  cell->attributes->justification
+			GEOMETRY_FILE_VERSION,
+			GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
+			GTK_SHEET (sheet->gtk_sheet)->maxalloccol
 		};
 
-	      entry.cellForeground.pixel = cell->attributes->foreground.pixel;
-	      entry.cellForeground.red = cell->attributes->foreground.red;
-	      entry.cellForeground.green = cell->attributes->foreground.green;
-	      entry.cellForeground.blue = cell->attributes->foreground.blue;
-	      entry.cellBackground.pixel = cell->attributes->background.pixel;
-	      entry.cellBackground.red = cell->attributes->background.red;
-	      entry.cellBackground.green = cell->attributes->background.green;
-	      entry.cellBackground.blue = cell->attributes->background.blue;
-
-	      fwrite ((void *)&entry, 
-		      sizeof (struct geometryFileEntry), 1, fp);
-	      fwrite ((void *)cell->text, 
-		      sizeof (gchar), entry.cellTextLength, fp);
-	    }
+	fwrite ((void *)&header, sizeof(struct geometryFileHeader), 1, fp);
+
+	for (gint ii = 0; ii <= header.maxRow; ii++)
+	{
+      for (gint jj = 0; jj <= header.maxColumn; jj++)
+		{
+			GtkSheetCell * cell = data[ii][jj];
+
+			if (!IS_NULL (cell) && !IS_NULLSTR(cell->text))
+			{
+				struct geometryFileEntry entry =
+					{
+						cell->row,
+						cell->col,
+						strlen (cell->text),
+						cell->attributes->is_visible,
+						cell->attributes->is_editable,
+						cell->attributes->justification
+					};
+
+				entry.cellForeground.pixel = cell->attributes->foreground.pixel;
+				entry.cellForeground.red = cell->attributes->foreground.red;
+				entry.cellForeground.green = cell->attributes->foreground.green;
+				entry.cellForeground.blue = cell->attributes->foreground.blue;
+				entry.cellBackground.pixel = cell->attributes->background.pixel;
+				entry.cellBackground.red = cell->attributes->background.red;
+				entry.cellBackground.green = cell->attributes->background.green;
+				entry.cellBackground.blue = cell->attributes->background.blue;
+
+				fwrite ((void *)&entry, 
+						  sizeof (struct geometryFileEntry), 1, fp);
+				fwrite ((void *)cell->text, 
+						  sizeof (gchar), entry.cellTextLength, fp);
+			}
+		}
 	}
-    }
 
-  FCLOSE (fp);
-  gdk_threads_leave ();
-  return TRUE;
+	FCLOSE (fp);
+	gdk_threads_leave ();
+	return TRUE;
 }
 
 /* @description: This method sets the attention level of the Sheet.
@@ -348,18 +344,18 @@ sheet_method_save (Sheet * sheet, const gchar * filepath)
 static void 
 sheet_method_set_attention (Sheet * sheet, gint attention)
 {
-  ASSERT (sheet != NULL);
-  gdk_threads_enter ();
+	ASSERT (sheet != NULL);
+	gdk_threads_enter ();
 
-  sheet->attention = attention;
+	sheet->attention = attention;
 
-  /* Do something funky to show that you should be looking at ME!
-     Oh, GtkNotebook tab, why are thou so vain? */
-  if ((sheet->has_focus == FALSE) && (sheet->notices > 0)) {
+	/* Do something funky to show that you should be looking at ME!
+		Oh, GtkNotebook tab, why are thou so vain? */
+	if ((sheet->has_focus == FALSE) && (sheet->notices > 0)) {
       
-    }
+	}
 
-  gdk_threads_leave ();
+	gdk_threads_leave ();
 }
 
 /* @description: This method destroys the Sheet object.
@@ -367,14 +363,14 @@ sheet_method_set_attention (Sheet * sheet, gint attention)
 static void
 sheet_method_destroy (Sheet * sheet)
 {
-  ASSERT (sheet != NULL);
-  gdk_threads_enter ();
+	ASSERT (sheet != NULL);
+	gdk_threads_enter ();
 
-  DOUBLE_UNLINK (sheet);
+	DOUBLE_UNLINK (sheet);
 
-  sheet_object_free (sheet);
+	sheet_object_free (sheet);
 
-  gdk_threads_leave ();
+	gdk_threads_leave ();
 }
 
 /* @description: This method frees the memory that was used by the Sheet
@@ -383,108 +379,108 @@ sheet_method_destroy (Sheet * sheet)
 static void
 sheet_object_free (Sheet * sheet)
 {
-  ASSERT (sheet != NULL);
+	ASSERT (sheet != NULL);
 
-  FREE (sheet->name);
-  FREE (sheet);
-  return;
+	FREE (sheet->name);
+	FREE (sheet);
+	return;
 }
 
 static void
 sheet_method_apply_cellrange (Sheet * sheet, 
-			      const GtkSheetRange * range,
-			      const CellAttributes * attrib)
+										const GtkSheetRange * range,
+										const CellAttributes * attrib)
 {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (range != NULL);
-  g_return_if_fail (attrib != NULL);
-  gdk_threads_enter ();
+	ASSERT (sheet != NULL);
+	g_return_if_fail (range != NULL);
+	g_return_if_fail (attrib != NULL);
+	gdk_threads_enter ();
 
-  gdk_threads_leave ();
+	gdk_threads_leave ();
 }
 
 static void
 sheet_method_apply_cellrow (Sheet * sheet,
-			    Cell ** array,
-			    gint row,
-			    gint size) {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (array != NULL);
+									 Cell ** array,
+									 gint row,
+									 gint size) {
+	ASSERT (sheet != NULL);
+	g_return_if_fail (array != NULL);
 
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
-  GtkSheetCell ** cell;
-  Cell * item;
+	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+	GtkSheetCell ** cell;
+	Cell * item;
 
-  if (row > gtksheet->maxrow || row < 0) return;
-  if (size > gtksheet->maxcol || size < 0) return;
+	if (row > gtksheet->maxrow || row < 0) return;
+	if (size > gtksheet->maxcol || size < 0) return;
 
-  gdk_threads_enter();
+	gdk_threads_enter();
 
-  for (int col = 0; col < size; col++) {
-    item = array[col]; 
-    cell = &gtksheet->data[row][col];
+	for (int col = 0; col < size; col++) {
+		item = array[col]; 
+		cell = &gtksheet->data[row][col];
     
-    gtk_sheet_set_cell_text (gtksheet,
-			     row,
-			     col,
-			     item->value->str);
-    /*
-    if (*cell == NULL)
-      (*cell) = gtk_sheet_cell_new();
+		gtk_sheet_set_cell_text (gtksheet,
+										 row,
+										 col,
+										 item->value->str);
+		/*
+		  if (*cell == NULL)
+		  (*cell) = gtk_sheet_cell_new();
       
-    (*cell)->row = row;
-    (*cell)->col = col;
+		  (*cell)->row = row;
+		  (*cell)->col = col;
 
-    if ((*cell)->text)
-      g_free ((*cell)->text);
+		  if ((*cell)->text)
+		  g_free ((*cell)->text);
       
-    (*cell)->text = g_strdup (item->value->str);
-    */
+		  (*cell)->text = g_strdup (item->value->str);
+		*/
 
-    item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
-  }
+		item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
+	}
 
-  gdk_threads_leave();
+	gdk_threads_leave();
 }
 
 static void
 sheet_method_apply_cellarray (Sheet * sheet, 
-			      Cell ** array,
-			      gint size)
+										Cell ** array,
+										gint size)
 {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (array != NULL);
+	ASSERT (sheet != NULL);
+	g_return_if_fail (array != NULL);
 
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
 
-  gdk_threads_enter ();
+	gdk_threads_enter ();
 
-  /* We'll see how this performs for now. In the future we may want to go
-     directly into the GtkSheet structures to get a little more performance
-     boost (mainly because we should not have to check all the bounds each
-     time we want to update). */
-  for (gint ii = 0; ii < size; ii++) {
-    Cell * cell = array[ii];
+	/* We'll see how this performs for now. In the future we may want to go
+		directly into the GtkSheet structures to get a little more performance
+		boost (mainly because we should not have to check all the bounds each
+		time we want to update). */
+	for (gint ii = 0; ii < size; ii++) {
+		Cell * cell = array[ii];
 
-    gtk_sheet_set_cell_text (gtksheet,
-			     cell->row,
-			     cell->column,
-			     cell->value->str);
+		gtk_sheet_set_cell_text (gtksheet,
+										 cell->row,
+										 cell->column,
+										 cell->value->str);
 
-    if (!IS_NULLSTR (cell->attributes.bgcolor->str))
-      sheet->range_set_background (sheet, 
-				   &cell->range, 
-				   cell->attributes.bgcolor->str);
+		if (!IS_NULLSTR (cell->attributes.bgcolor->str))
+			sheet->range_set_background (sheet, 
+												  &cell->range, 
+												  cell->attributes.bgcolor->str);
 
-    if (!IS_NULLSTR (cell->attributes.fgcolor->str))
-      sheet->range_set_foreground (sheet, 
-				   &cell->range, 
-				   cell->attributes.fgcolor->str);
+		if (!IS_NULLSTR (cell->attributes.fgcolor->str))
+			sheet->range_set_foreground (sheet, 
+												  &cell->range, 
+												  cell->attributes.fgcolor->str);
 
-    cell->value->str[0] = cell->attributes.bgcolor->str[0] = cell->attributes.fgcolor->str[0] = 0;
-  }
+		cell->value->str[0] = cell->attributes.bgcolor->str[0] = cell->attributes.fgcolor->str[0] = 0;
+	}
 
-  gdk_threads_leave ();
+	gdk_threads_leave ();
 }
 
 /* @description: This method applies the settings from a Cell object into the
@@ -495,35 +491,35 @@ sheet_method_apply_cellarray (Sheet * sheet,
 static void
 sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
 {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (cell != NULL);
-
-  gdk_threads_enter ();
-
-  if (sheet->has_focus == FALSE)
-    sheet->notices++;
-
-  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet),
-		      cell->row,
-		      cell->column,
-		      cell->attributes.justification,
-		      cell->value->str);
-  gdk_threads_leave ();
-
-  if (!IS_NULLSTR (cell->attributes.bgcolor->str))
-    sheet->range_set_background (sheet, 
-				 &cell->range, 
-				 cell->attributes.bgcolor->str);
-
-  if (!IS_NULLSTR (cell->attributes.fgcolor->str))
-    sheet->range_set_foreground (sheet, 
-				 &cell->range, 
-				 cell->attributes.fgcolor->str);
-
-  /* Clear all of the strings */
-  g_string_assign (cell->value, "");
-  g_string_assign (cell->attributes.bgcolor, "");
-  g_string_assign (cell->attributes.fgcolor, "");
+	ASSERT (sheet != NULL);
+	g_return_if_fail (cell != NULL);
+
+	gdk_threads_enter ();
+
+	if (sheet->has_focus == FALSE)
+		sheet->notices++;
+
+	gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet),
+							  cell->row,
+							  cell->column,
+							  cell->attributes.justification,
+							  cell->value->str);
+	gdk_threads_leave ();
+
+	if (!IS_NULLSTR (cell->attributes.bgcolor->str))
+		sheet->range_set_background (sheet, 
+											  &cell->range, 
+											  cell->attributes.bgcolor->str);
+
+	if (!IS_NULLSTR (cell->attributes.fgcolor->str))
+		sheet->range_set_foreground (sheet, 
+											  &cell->range, 
+											  cell->attributes.fgcolor->str);
+
+	/* Clear all of the strings */
+	g_string_assign (cell->value, "");
+	g_string_assign (cell->attributes.bgcolor, "");
+	g_string_assign (cell->attributes.fgcolor, "");
 }
 
 /* @description: This method changes the background of a range of cells. 
@@ -534,22 +530,22 @@ sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
    green, etc). */
 static void
 sheet_method_range_set_background (Sheet * sheet, 
-				   const GtkSheetRange * range,
-				   const gchar * desc)
+											  const GtkSheetRange * range,
+											  const gchar * desc)
 {
-  ASSERT (sheet != NULL); ASSERT (range != NULL);
-  GdkColor color;
-
-  /* The color needs to be taken from the colormap; there is an alternative
-     way to do this if we use #rgb or #rrggbb formats. */
-  gdk_threads_enter ();
-  gdk_color_parse (desc, &color);
-  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
-		   &color);
+	ASSERT (sheet != NULL); ASSERT (range != NULL);
+	GdkColor color;
+
+	/* The color needs to be taken from the colormap; there is an alternative
+		way to do this if we use #rgb or #rrggbb formats. */
+	gdk_threads_enter ();
+	gdk_color_parse (desc, &color);
+	gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
+						  &color);
   
-  gtk_sheet_range_set_background (GTK_SHEET (sheet->gtk_sheet),
-				  range, &color);
-  gdk_threads_leave ();
+	gtk_sheet_range_set_background (GTK_SHEET (sheet->gtk_sheet),
+											  range, &color);
+	gdk_threads_leave ();
 }
 
 /* @description: This method changes the foreground color over a range of
@@ -560,23 +556,23 @@ sheet_method_range_set_background (Sheet * sheet,
    @desc: The string representation of the color (e.g. white, green, blue). */
 static void
 sheet_method_range_set_foreground (Sheet * sheet, 
-				   const GtkSheetRange * range,
-				   const gchar * desc)
+											  const GtkSheetRange * range,
+											  const gchar * desc)
 {
-  ASSERT (sheet != NULL); ASSERT (range != NULL);
-  GdkColor color;
+	ASSERT (sheet != NULL); ASSERT (range != NULL);
+	GdkColor color;
   
    /* The color needs to be taken from the colormap; there is an alternative
-     way to do this if we use #rgb or #rrggbb formats. */
-  gdk_threads_enter ();
-  gdk_color_parse (desc, &color);
-  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
-		   &color);
+		way to do this if we use #rgb or #rrggbb formats. */
+	gdk_threads_enter ();
+	gdk_color_parse (desc, &color);
+	gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
+						  &color);
       
-  gtk_sheet_range_set_foreground (GTK_SHEET (sheet->gtk_sheet),
-				  range, &color);
-  gdk_threads_leave ();
- }
+	gtk_sheet_range_set_foreground (GTK_SHEET (sheet->gtk_sheet),
+											  range, &color);
+	gdk_threads_leave ();
+}
 
 /* @description: This method manually sets a GtkSheet cell's value. It does
    not require the use of the Cell object.
@@ -586,18 +582,18 @@ sheet_method_range_set_foreground (Sheet * sheet,
    @value: The text string to be applied to the cell. */
 static void 
 sheet_method_set_cell (Sheet * sheet,
-		       gint row, gint col,
-		       const gchar * value)
+							  gint row, gint col,
+							  const gchar * value)
 {
-  ASSERT (sheet != NULL);
-
-  gdk_threads_enter ();
-  if (sheet->has_focus == FALSE)
-    sheet->notices++;
-  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet), 
-		      row, 
-		      col, 
-		      GTK_JUSTIFY_LEFT, 
-		      value);
-  gdk_threads_leave ();
+	ASSERT (sheet != NULL);
+
+	gdk_threads_enter ();
+	if (sheet->has_focus == FALSE)
+		sheet->notices++;
+	gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet), 
+							  row, 
+							  col, 
+							  GTK_JUSTIFY_LEFT, 
+							  value);
+	gdk_threads_leave ();
 }
diff --git a/gtkworkbook/workbook.c b/gtkworkbook/workbook.c
index 6fbe5a0..2e596fe 100755
--- a/gtkworkbook/workbook.c
+++ b/gtkworkbook/workbook.c
@@ -231,7 +231,7 @@ workbook_object_init (GtkWidget * window, const gchar * filename)
   gtk_notebook_set_show_tabs (notebook, TRUE);
   gtk_notebook_set_show_border (notebook, TRUE);
   gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
-  gtk_widget_show (book->gtk_notebook);
+  gtk_widget_show_all (book->gtk_notebook);
   gdk_threads_leave ();
 
   /* Members */
diff --git a/shared/concurrent/Thread.cc b/shared/concurrent/Thread.cc
index 5b7f143..dbb4b72 100755
--- a/shared/concurrent/Thread.cc
+++ b/shared/concurrent/Thread.cc
@@ -94,6 +94,8 @@ namespace concurrent {
 		if (this->running == true)
 			return false;
 
+		this->running = true;
+		
 		if (this->runner != NULL) {
 			if (pthread_create (&this->thread,
 									  NULL,
@@ -109,7 +111,6 @@ namespace concurrent {
 				return false;
 		}
 
-		this->running = true;
 		return true;
 	}
 
diff --git a/src/Application.cpp b/src/Application.cpp
index cc7ff6c..1ee3bf2 100755
--- a/src/Application.cpp
+++ b/src/Application.cpp
@@ -229,8 +229,8 @@ Application::open_extension (const gchar * filename, gboolean absolute_path) {
 			/* Attach all of the signals for the Workbook object. */
 			gtk_signal_connect (GTK_OBJECT (plugin->workbook()->gtk_notebook),
 									  "switch-page",
-									  (GtkSignalFunc)this->signals[NOTEBOOK_SWITCHED], 
-									  (gpointer)plugin->workbook());
+									  (GtkSignalFunc)signal_gtknotebook_switchpage, 
+									  plugin->workbook());
 	  
 			this->workbooks.push_back (plugin->workbook());
 		}
@@ -288,16 +288,16 @@ Application::init (int argc, char *** argv) {
 	
 	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
 							  "destroy",
-							  G_CALLBACK (this->signals[DESTROY_EVENT]),
-							  (gpointer)this);
+							  G_CALLBACK (signal_destroy_event),
+							  this);
 	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
 							  "delete_event",
-							  G_CALLBACK (this->signals[DELETE_EVENT]),
+							  G_CALLBACK (signal_delete_event),
 							  NULL);
   
 	/* Set the initial size of the application; we could load this
 		from a configuration file eventually. */
-	gtk_widget_set_usize (this->gtk_window, 1024, 768);
+	gtk_widget_set_usize (this->gtk_window, 1024, 800);
   
 	/* Attach the window box to the window and present to the screen. */
 	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);

commit 418da8c27f49502d59a2be5596afa1ffb61dd021
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 10 15:52:06 2009 -0400

    Removed the need for plugins to have the same library depedencies as the parent executable.

diff --git a/Makefile b/Makefile
index d903311..5f2d79a 100755
--- a/Makefile
+++ b/Makefile
@@ -13,13 +13,15 @@ libgtkworkbookshared:
 	${MAKE} shared/ all
 
 gtkworkbook:
-	${MD} OBJS/realtime
+	${MD} OBJS/realtime ${MD}/largefile
 	$(MAKE) src/ all
+	$(MAKE) src/largefile all
 
 clean:
 	${MAKE} shared/ clean
 	${MAKE} gtkworkbook/ clean
 	$(MAKE) src/ clean
+	$(MAKE) src/largefile clean
 
 install: all
 	${MAKE} shared/ install
diff --git a/Makefile.base b/Makefile.base
index dbec46b..e767ae2 100755
--- a/Makefile.base
+++ b/Makefile.base
@@ -35,5 +35,5 @@ LIBS += -L${LIBDIR}
 LIBS += -Wl,-rpath ${LIBDIR}
 LIBS += `pkg-config gtk+-2.0 glib-2.0 --libs`
 
-CCFLAGS=-g -O0 -std=c99 -Wall -pthread
-CXFLAGS=-g -O0 -Wall -Wno-write-strings
\ No newline at end of file
+CCFLAGS=-g -std=c99 -Wall -pthread
+CXFLAGS=-g -Wall -Wno-write-strings
\ No newline at end of file
diff --git a/TODO b/TODO
index 385a513..d09bbe7 100755
--- a/TODO
+++ b/TODO
@@ -1,22 +1,27 @@
 TODO for GTKWorkbook
 
 * Application
-	- Convert the structures to C++ classes for autotools merge.
+	- Bugs
+		o Probable issue with new plugin architecture unloading library inside
+		  the object's destructor. 
+		o Segementation fault on graceful exit of application.
 * largefile
-	- Bug fixes
-		o Offset by one for file dispatcher read() method
-		o Integer problem (total line offset) needs to be fixed
+	- Bugs	
+		o Possible heap memory corruption happening in current working branch.	
 	- Priorities (before merge)
 		o Absolute line goto dialog
 		o Index indicator
 		o Panning/Paging controls
 		o Move shared library into application folder
+		o Page up, page down for panning
+		o Control + G for GOTO line
+		o Control + O for percentage offset
+		o Control + I for index up to line
 	- Priorities (after merge)
 		o Framebuffering and Caching
 		o Statistics on writing to screen, reading, and panning/paging
 		o Staging for the indexer... N percentile increments
 	- Merge
-		o Autotools merge happens *before* largefile merge
 		o Largefile merge happens into an autotools branch
 		o Final merge back into the master branch
 	- Release
@@ -24,11 +29,5 @@ TODO for GTKWorkbook
 		o Largefile must be merged into autotools
 	- Documentation	
 		o Point release after main beta release
-
-* Visualization 
-	- Controls
-		o Page up, page down for panning
-		o Control + G for GOTO line
-		o Control + O for percentage offset
-		o Control + I for index up to line
+	
 	
\ No newline at end of file
diff --git a/src/Application.cpp b/src/Application.cpp
index 2f1251a..cc7ff6c 100755
--- a/src/Application.cpp
+++ b/src/Application.cpp
@@ -1,3 +1,21 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Application.hpp"
 #include "Plugin.hpp"
 #include <cstring>
@@ -112,8 +130,8 @@ signal_gtksheet_changed (GtkWidget * gtksheet,
    @p: NULL */
 static guint
 signal_delete_event (GtkWindow * window, 
-											GdkEvent * event,
-											gpointer p) {
+							GdkEvent * event,
+							gpointer p) {
 	GtkWidget * dialog 
 		= gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
 										  GTK_MESSAGE_QUESTION,
@@ -216,6 +234,7 @@ Application::open_extension (const gchar * filename, gboolean absolute_path) {
 	  
 			this->workbooks.push_back (plugin->workbook());
 		}
+		gtk_widget_show_all (this->gtk_menu);
 	}
 
 	FREE (fname);
@@ -265,10 +284,12 @@ Application::init (int argc, char *** argv) {
 
 	/* Create the window and connect two callback to the signals. */
 	this->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	this->gtk_menu = gtk_menu_bar_new();
+	
 	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
 							  "destroy",
 							  G_CALLBACK (this->signals[DESTROY_EVENT]),
-							  (gpointer *)this);
+							  (gpointer)this);
 	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
 							  "delete_event",
 							  G_CALLBACK (this->signals[DELETE_EVENT]),
@@ -281,6 +302,7 @@ Application::init (int argc, char *** argv) {
 	/* Attach the window box to the window and present to the screen. */
 	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
 	gtk_container_add (GTK_CONTAINER (this->gtk_window), window_box);
+	gtk_box_pack_start (GTK_BOX (window_box), this->gtk_menu, FALSE, FALSE, 0);
 	this->gtk_window_vbox = window_box;
   
 	gtk_widget_show_all (this->gtk_window);
diff --git a/src/Application.hpp b/src/Application.hpp
index 87c8377..a5d0834 100755
--- a/src/Application.hpp
+++ b/src/Application.hpp
@@ -1,3 +1,21 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_APPLICATION
 #define HPP_APPLICATION
 
diff --git a/src/Plugin.cpp b/src/Plugin.cpp
index da021ac..0ed0221 100755
--- a/src/Plugin.cpp
+++ b/src/Plugin.cpp
@@ -1,3 +1,21 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Plugin.hpp"
 
 Plugin::Plugin (Application * appstate, Handle * platform)
diff --git a/src/Plugin.hpp b/src/Plugin.hpp
index 74cc4b1..c78f644 100755
--- a/src/Plugin.hpp
+++ b/src/Plugin.hpp
@@ -22,6 +22,7 @@
 #include "Application.hpp"
 #include <dlfcn.h>
 #include <gtkworkbook/workbook.h>
+#include <concurrent/Mutex.hpp>
 #include <string>
 
 #ifdef WIN32
@@ -44,7 +45,7 @@ struct Handle {
 	PlatformHandle handle;
 };
 
-class Plugin {
+class Plugin : public concurrent::RecursiveMutex {
 protected:
 	Workbook * wb;
 	Application * appstate;
diff --git a/src/config.cpp b/src/config.cpp
index 882ed2a..5c1a591 100755
--- a/src/config.cpp
+++ b/src/config.cpp
@@ -25,8 +25,8 @@
 
 static Config *config_object_init (const gchar *);
 static ConfigPair *configpair_object_init (ConfigRow *, 
-					   const gchar *,
-					   const gchar *);
+														 const gchar *,
+														 const gchar *);
 static ConfigRow *configrow_object_init (ConfigBlock *, const gchar *);
 static ConfigBlock *configblock_object_init (Config *, const gchar *);
 static ConfigVector *configvector_object_init (ConfigRow *,const gchar *);
@@ -36,20 +36,20 @@ static void configpair_object_free (ConfigPair *);
 static void config_object_free (Config *);
 static void configvector_object_free (ConfigVector *);
 static ConfigVector *config_method_get_vector (Config *,
-					       const gchar *,
-					       const gchar *,
-					       const gchar *);
+															  const gchar *,
+															  const gchar *,
+															  const gchar *);
 static ConfigPair *config_method_get_pair (Config *,
-					   const gchar *,
-					   const gchar *,
-					   const gchar *);
+														 const gchar *,
+														 const gchar *,
+														 const gchar *);
 static ConfigBlock *config_method_get_block (Config *, const gchar *);
 static ConfigPair *configblock_method_get_pair (ConfigBlock *, 
-						const gchar *,
-						const gchar *);
+																const gchar *,
+																const gchar *);
 static ConfigRow *config_method_get_row (Config *,
-					 const gchar *, 
-					 const gchar *);
+													  const gchar *, 
+													  const gchar *);
 static ConfigRow *configblock_method_get_row (ConfigBlock *, const gchar *);
 static gchar *configrow_method_parse (ConfigRow *, gchar *);
 static void configrow_method_destroy (ConfigRow *);
@@ -58,8 +58,8 @@ static ConfigVector *configrow_method_get_vector (ConfigRow *, const gchar *);
 static void configpair_method_destroy (ConfigPair *);
 static void configblock_method_destroy (ConfigBlock *);
 static void configvector_method_destroy (ConfigVector *);
-static gint configvector_method_get_int (ConfigVector *, gint);
-static gchar *configvector_method_get (ConfigVector *, gint);
+static gint configvector_method_get_int (ConfigVector *, guint);
+static gchar *configvector_method_get (ConfigVector *, guint);
 static void configvector_method_add (ConfigVector *, const gchar *);
 static gchar *configblock_method_parse (ConfigBlock *, gchar *, FILE *);
 static void config_method_destroy (Config *);
@@ -70,543 +70,543 @@ static gint config_method_load (Config *, FILE *);
 ConfigBlock *
 configblock_new (Config * c, const gchar * tag)
 {
-  /* No NULL tags. */
-  if (IS_NULLSTR (tag)) return NULL;
-  return configblock_object_init (c, tag);
+	/* No NULL tags. */
+	if (IS_NULLSTR (tag)) return NULL;
+	return configblock_object_init (c, tag);
 }
 
 static gchar *
 configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
 {
-  ASSERT (block != NULL);
-  ASSERT (p != NULL);
+	ASSERT (block != NULL);
+	ASSERT (p != NULL);
 
-  if (!fp || feof (fp)) return FALSE;
+	if (!fp || feof (fp)) return FALSE;
 
-  gchar buf[1024], word[1024];
-  gchar * q = NULL;
-  g_stpcpy (word, p);
+	gchar buf[1024], word[1024];
+	gchar * q = NULL;
+	g_stpcpy (word, p);
 
-  /* This block of code makes sure that we indeed have an opening brace
-    to continue with parsing of the configuration file. */
-  do
-    {
+	/* This block of code makes sure that we indeed have an opening brace
+		to continue with parsing of the configuration file. */
+	do
+	{
       p = word;
       
       if (EXPECT (p, q, '{'))
-	{
-	  g_stpcpy (buf, q + 1);
-	  break;
-	} 
+		{
+			g_stpcpy (buf, q + 1);
+			break;
+		} 
 
       if (*q == '\0')
-	continue;
+			continue;
       return NULL;
-    } while (fgets (word, 1024, fp) != NULL);
+	} while (fgets (word, 1024, fp) != NULL);
 
-  /* Start actually parsing rows now. */
-  do 
-    {
+	/* Start actually parsing rows now. */
+	do 
+	{
       p = buf;
       do
-	{
-	  if (*p == '}')
-	    return p;
-	  else if (*p == '\n')
-	    {
-	      p++;
-	      continue;
-	    }
-	  else 
-	    {
-	      if ((q = parse (p, &word[0], 1024, ':')) != NULL)
 		{
-		  if (*(q+1) == ':')
-		    {
-		      ConfigRow * row 
-			= block->get_row (block, trim (&word[0]));
-		      
-		      if (row)
+			if (*p == '}')
+				return p;
+			else if (*p == '\n')
 			{
-			  fprintf (stderr, "**CONFIG**: row '%s' already"
-				   " defined in block '%s'; replacing\n",
-				   row->tag, block->tag);
-			  fflush (stderr);
-
-			  row->destroy (row);
+				p++;
+				continue;
 			}
+			else 
+			{
+				if ((q = parse (p, &word[0], 1024, ':')) != NULL)
+				{
+					if (*(q+1) == ':')
+					{
+						ConfigRow * row 
+							= block->get_row (block, trim (&word[0]));
+		      
+						if (row)
+						{
+							fprintf (stderr, "**CONFIG**: row '%s' already"
+										" defined in block '%s'; replacing\n",
+										row->tag, block->tag);
+							fflush (stderr);
+
+							row->destroy (row);
+						}
 
-		      row = configrow_new (block, trim (&word[0]));
+						row = configrow_new (block, trim (&word[0]));
 		    
-		      if ((p = row->parse (row, q+2)) == NULL)
-			{
-			  fprintf (stderr, "Error parsing line: %s", buf);
-			  fflush (stderr);
-			  return NULL;
+						if ((p = row->parse (row, q+2)) == NULL)
+						{
+							fprintf (stderr, "Error parsing line: %s", buf);
+							fflush (stderr);
+							return NULL;
+						}
+						break;
+					}
+				}
 			}
-		      break;
-		    }
-		}
-	    }
-	  fprintf (stderr, "Error in formatting on line: %s\n", buf);
-	  fflush (stderr);
-	  return NULL;
-	} while (*p != '\0');
-     } while (fgets (buf, 1024, fp) != NULL);
-  return NULL;
+			fprintf (stderr, "Error in formatting on line: %s\n", buf);
+			fflush (stderr);
+			return NULL;
+		} while (*p != '\0');
+	} while (fgets (buf, 1024, fp) != NULL);
+	return NULL;
 }
 
 static void
 configblock_method_destroy (ConfigBlock * block)
 {
-  ASSERT (block != NULL);
+	ASSERT (block != NULL);
 
-  DESTROY (ConfigRow, block->row_head);
-  SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
-		 block->cfg->block_tail, block);
+	DESTROY (ConfigRow, block->row_head);
+	SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
+						block->cfg->block_tail, block);
   
-  configblock_object_free (block);
+	configblock_object_free (block);
 }
 
 static ConfigRow *
 configblock_method_get_row (ConfigBlock * block, const gchar * row)
 {
-  ASSERT (block != NULL);
+	ASSERT (block != NULL);
 
-  if (!IS_NULLSTR (row))
-    {
+	if (!IS_NULLSTR (row))
+	{
       ITERATE_BEGIN (ConfigRow, block->row_head);
       {
-	if (!strcmp (it->tag, row))
-	  return it;
+			if (!strcmp (it->tag, row))
+				return it;
       }
       ITERATE_END ();
-    }
-  return NULL;
+	}
+	return NULL;
 }
 
 static ConfigPair *
 configblock_method_get_pair (ConfigBlock * block, 
-			     const gchar * row,
-			     const gchar * key)
+									  const gchar * row,
+									  const gchar * key)
 {
-  ASSERT (block != NULL);
+	ASSERT (block != NULL);
 
-  if (!IS_NULLSTR (row))
-    {
+	if (!IS_NULLSTR (row))
+	{
       ITERATE_BEGIN (ConfigRow, block->row_head);
       {
-	if (!strcmp (it->tag, row))
-	  return it->get_pair (it, key);
+			if (!strcmp (it->tag, row))
+				return it->get_pair (it, key);
       }
       ITERATE_END ();
-    }
-  return NULL;
+	}
+	return NULL;
 }
 
 static void
 configblock_object_free (ConfigBlock * block)
 {
-  ASSERT (block != NULL);
+	ASSERT (block != NULL);
 
-  FREE (block->tag);
+	FREE (block->tag);
   
-  FREE (block);
-  block = NULL;
+	FREE (block);
+	block = NULL;
 }
 
 static ConfigBlock *
 configblock_object_init (Config * c, const gchar * tag)
 {
-  ASSERT (c != NULL);
+	ASSERT (c != NULL);
 
-  ConfigBlock * b = NEW (ConfigBlock);
+	ConfigBlock * b = NEW (ConfigBlock);
 
-  /* Members */
-  b->cfg = c;
-  b->tag = g_strdup (tag);
-  b->next = NULL; 
-  b->row_head = b->row_tail = NULL;
+	/* Members */
+	b->cfg = c;
+	b->tag = g_strdup (tag);
+	b->next = NULL; 
+	b->row_head = b->row_tail = NULL;
   
-  /* Methods */
-  b->parse = configblock_method_parse;
-  b->destroy = configblock_method_destroy;
-  b->get_row = configblock_method_get_row;
-  b->get_pair = configblock_method_get_pair;
+	/* Methods */
+	b->parse = configblock_method_parse;
+	b->destroy = configblock_method_destroy;
+	b->get_row = configblock_method_get_row;
+	b->get_pair = configblock_method_get_pair;
 
-  SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
-  return b;
+	SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
+	return b;
 }
 
 Config *
 config_new (const gchar * filename)
 {
-  return config_object_init (filename);
+	return config_object_init (filename);
 }
 
 static void
 config_method_destroy (Config * c)
 {
-  ASSERT (c != NULL);
+	ASSERT (c != NULL);
 
-  DESTROY (ConfigBlock, c->block_head);
+	DESTROY (ConfigBlock, c->block_head);
   
-  config_object_free (c);
+	config_object_free (c);
 }
 
 static ConfigRow *
 config_method_get_row (Config * cfg, const gchar * block, const gchar * row)
 {
-  ASSERT (cfg != NULL);
+	ASSERT (cfg != NULL);
  
-  ConfigBlock * b = cfg->get_block (cfg, block);
-  if (b == NULL)
-    return NULL;
-  return b->get_row (b, row);
+	ConfigBlock * b = cfg->get_block (cfg, block);
+	if (b == NULL)
+		return NULL;
+	return b->get_row (b, row);
 }
 
 static ConfigBlock *
 config_method_get_block (Config * cfg, const gchar * block)
 {
-  ASSERT (cfg != NULL);
+	ASSERT (cfg != NULL);
 
-  if (!IS_NULLSTR (block))
-    {
+	if (!IS_NULLSTR (block))
+	{
       ITERATE_BEGIN (ConfigBlock, cfg->block_head);
       {
-	if (!strcmp (it->tag, block))
-	  return it;
+			if (!strcmp (it->tag, block))
+				return it;
       }
       ITERATE_END ();
-    }
-  return NULL;
+	}
+	return NULL;
 }
 
 static ConfigPair *
 config_method_get_pair (Config * cfg, 
-			const gchar * block, 
-			const gchar * row,
-			const gchar * pair)
+								const gchar * block, 
+								const gchar * row,
+								const gchar * pair)
 {
-  ASSERT (cfg != NULL);
+	ASSERT (cfg != NULL);
 
-  ConfigRow * r = cfg->get_row (cfg, block, row);
-  if (r == NULL)
-    return NULL;
-  return r->get_pair (r, pair);
+	ConfigRow * r = cfg->get_row (cfg, block, row);
+	if (r == NULL)
+		return NULL;
+	return r->get_pair (r, pair);
 }
 
 static ConfigVector *
 config_method_get_vector (Config * cfg,
-			  const gchar * block,
-			  const gchar * row,
-			  const gchar * vector)
+								  const gchar * block,
+								  const gchar * row,
+								  const gchar * vector)
 {
-  ASSERT (cfg != NULL);
+	ASSERT (cfg != NULL);
   
-  ConfigRow * r = cfg->get_row (cfg, block, row);
-  if (r == NULL)
-    return NULL;
-  return r->get_vector (r, vector);
+	ConfigRow * r = cfg->get_row (cfg, block, row);
+	if (r == NULL)
+		return NULL;
+	return r->get_vector (r, vector);
 }
 
 static void
 config_object_free (Config * c)
 {
-  ASSERT (c != NULL);
+	ASSERT (c != NULL);
 
-  FREE (c->filename);
+	FREE (c->filename);
 
-  FREE (c);
-  c = NULL;
+	FREE (c);
+	c = NULL;
 }
 
 static Config *
 config_object_init (const gchar * filename)
 {
-  Config * c = NEW (Config);
+	Config * c = NEW (Config);
 
-  /* Members */
-  c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
-  c->block_head = c->block_tail = NULL;
+	/* Members */
+	c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
+	c->block_head = c->block_tail = NULL;
 
-  /* Methods */
-  c->open = config_method_open;
-  c->save = config_method_save;
-  c->load = config_method_load;
-  c->close = config_method_destroy;
-  c->get_vector = config_method_get_vector;
-  c->get_row = config_method_get_row;
-  c->get_block = config_method_get_block;
-  c->get_pair = config_method_get_pair;
+	/* Methods */
+	c->open = config_method_open;
+	c->save = config_method_save;
+	c->load = config_method_load;
+	c->close = config_method_destroy;
+	c->get_vector = config_method_get_vector;
+	c->get_row = config_method_get_row;
+	c->get_block = config_method_get_block;
+	c->get_pair = config_method_get_pair;
 
-  return c;
+	return c;
 }
 
 static gint
 config_method_load (Config * c, FILE * fp)
 {
-  ASSERT (c != NULL);
+	ASSERT (c != NULL);
   
-  if (!fp || feof(fp))
-    {
+	if (!fp || feof(fp))
+	{
       /* STUB: log me? */
       return FALSE;
-    }
+	}
 
-  gchar * buf = (gchar *)g_malloc (sizeof (char) * 1024);
-  gchar word[1024];
-  gchar * p = NULL, * q = NULL, * r = NULL;
+	gchar * buf = (gchar *)g_malloc (sizeof (char) * 1024);
+	gchar word[1024];
+	gchar * p = NULL, * q = NULL, * r = NULL;
 
-  while ((p = fgets (buf, 1024, fp)) != NULL) {
+	while ((p = fgets (buf, 1024, fp)) != NULL) {
       r = buf + (strlen (buf) - 1);
  
       while (p && (p < r) && (*p != '\n'))
-	{
-	  if (*p == '%')
-	    {
-	      if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
-		/* STUB: exit parsing with a failure. */
-		g_free (buf);	
-		return FALSE;
-	      }
-
-	      if (strcmp (word, "block") == 0)
 		{
-		  if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
-		    g_free(buf);
-		    return FALSE;
-		  }
+			if (*p == '%')
+			{
+				if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
+					/* STUB: exit parsing with a failure. */
+					g_free (buf);	
+					return FALSE;
+				}
+
+				if (strcmp (word, "block") == 0)
+				{
+					if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+						g_free(buf);
+						return FALSE;
+					}
 		  
-		  /* Replace the block if it already exists. Throw error. */
-		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
-		  if (b)
-		    {
-		      fprintf (stderr, "**CONFIG**: block '%s' already"
-			       "exists. Destroying and replacing.\n", b->tag);
-		      fflush (stderr);
-		      b->destroy (b);
-		    }
-
-		  b = configblock_new (c, trim (&word[0]));
-
-		  if ((p = b->parse (b, q, fp)) == NULL) {
-		    g_free (buf);
-		    return FALSE;
-		  }
-		}
-	      else if (strcmp (word, "include") == 0)
-		{
-		  if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
-		    g_free (buf);
-		    return FALSE;
-		  }
-
-		  /* Include the file; we're going to load up this file
-		     first and then proceed with parsing. */
-		  FILE * ifp = NULL;
+					/* Replace the block if it already exists. Throw error. */
+					ConfigBlock * b = c->get_block (c, trim (&word[0]));
+					if (b)
+					{
+						fprintf (stderr, "**CONFIG**: block '%s' already"
+									"exists. Destroying and replacing.\n", b->tag);
+						fflush (stderr);
+						b->destroy (b);
+					}
+
+					b = configblock_new (c, trim (&word[0]));
+
+					if ((p = b->parse (b, q, fp)) == NULL) {
+						g_free (buf);
+						return FALSE;
+					}
+				}
+				else if (strcmp (word, "include") == 0)
+				{
+					if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+						g_free (buf);
+						return FALSE;
+					}
+
+					/* Include the file; we're going to load up this file
+						first and then proceed with parsing. */
+					FILE * ifp = NULL;
 		 
-		  if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
-		    {
-		      fprintf (stderr, "**CONFIG**: include '%s' does not"
-			       " seem to exist or unable to read.\n",
-			       word);
-		      fflush (stderr);
-		      continue;
-		    }
-
-		  c->load (c, ifp);
+					if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
+					{
+						fprintf (stderr, "**CONFIG**: include '%s' does not"
+									" seem to exist or unable to read.\n",
+									word);
+						fflush (stderr);
+						continue;
+					}
+
+					c->load (c, ifp);
+				}
+				else {
+					g_free (buf);
+					return FALSE;
+				}
+			}
+			/* BUGFIX: Need to check for tabs. */
+			else if ((*p != ' ') && (*p != '\t'))
+			{
+				/* STUB: error out */
+				g_free (buf);
+				return FALSE;
+			}
+
+			p++;
 		}
-	      else {
-		g_free (buf);
-		return FALSE;
-	      }
-	    }
-	  /* BUGFIX: Need to check for tabs. */
-	  else if ((*p != ' ') && (*p != '\t'))
-	    {
-	      /* STUB: error out */
-	      g_free (buf);
-	      return FALSE;
-	    }
-
-	  p++;
 	}
-    }
-  g_free (buf);
-  return TRUE;
+	g_free (buf);
+	return TRUE;
 }
 
 static gint
 config_method_save (Config * c, const gchar * filename)
 {
-  ASSERT (c != NULL);
+	ASSERT (c != NULL);
 
-  if (IS_NULLSTR (filename)) return FALSE;
+	if (IS_NULLSTR (filename)) return FALSE;
 
-  FILE * fp = NULL;
-  if ((fp = fopen (filename, "w")) == NULL)
-    {
+	FILE * fp = NULL;
+	if ((fp = fopen (filename, "w")) == NULL)
+	{
       /* STUB: log me? */
       return FALSE;
-    }
+	}
   
-  FCLOSE (fp);
-  return TRUE;
+	FCLOSE (fp);
+	return TRUE;
 }
 
 static gint
 config_method_open (Config * c)
 {
-  ASSERT (c != NULL);
+	ASSERT (c != NULL);
 
-  if (IS_NULLSTR (c->filename))
-    return FALSE;
+	if (IS_NULLSTR (c->filename))
+		return FALSE;
 
-  FILE * fp = NULL;
-  if ((fp = fopen (c->filename, "r")) == NULL)
-    {
+	FILE * fp = NULL;
+	if ((fp = fopen (c->filename, "r")) == NULL)
+	{
       /* STUB: log this? */
       return FALSE;
-    }
+	}
 
-  gint result = c->load (c, fp);
-  if (result == FALSE)
-    {
+	gint result = c->load (c, fp);
+	if (result == FALSE)
+	{
       /* STUB: log me? */
-    }
+	}
 
-  FCLOSE (fp);
-  return result;
+	FCLOSE (fp);
+	return result;
 }
 
 ConfigPair *
 configpair_new (ConfigRow * row, const gchar * key, const gchar * value)
 {
-  return configpair_object_init (row, key, value);
+	return configpair_object_init (row, key, value);
 }
 
 static ConfigPair *
 configpair_object_init (ConfigRow * row, 
-			const gchar * key,
-			const gchar * value)
+								const gchar * key,
+								const gchar * value)
 {
-  ASSERT (row != NULL);
-  ASSERT (!IS_NULLSTR (key));
+	ASSERT (row != NULL);
+	ASSERT (!IS_NULLSTR (key));
   
-  ConfigPair * pair = NEW (ConfigPair);
+	ConfigPair * pair = NEW (ConfigPair);
 
-  /* Members */
-  pair->row = row;
-  pair->key = g_strdup (key);
-  pair->next = NULL;
-  pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
+	/* Members */
+	pair->row = row;
+	pair->key = g_strdup (key);
+	pair->next = NULL;
+	pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
  
-  /* Methods */
-  pair->destroy = configpair_method_destroy;
+	/* Methods */
+	pair->destroy = configpair_method_destroy;
   
-  DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
-  return pair;
+	DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
+	return pair;
 }
 
 static void
 configpair_method_destroy (ConfigPair * pair)
 {
-  ASSERT (pair != NULL);
+	ASSERT (pair != NULL);
 
-  DOUBLE_UNLINK (pair);
+	DOUBLE_UNLINK (pair);
 
-  configpair_object_free (pair);
+	configpair_object_free (pair);
 }
 
 static void
 configpair_object_free (ConfigPair * pair)
 {
-  ASSERT (pair != NULL);
+	ASSERT (pair != NULL);
 
-  FREE (pair->key);
-  FREE (pair->value);
-  FREE (pair);
+	FREE (pair->key);
+	FREE (pair->value);
+	FREE (pair);
 }
 
 ConfigRow *
 configrow_new (ConfigBlock * block, const gchar * tag)
 {
-  return configrow_object_init (block, tag);
+	return configrow_object_init (block, tag);
 }
 
 static ConfigRow *
 configrow_object_init (ConfigBlock * block, const gchar * tag)
 {
-  if (IS_NULLSTR (tag)) return NULL;
+	if (IS_NULLSTR (tag)) return NULL;
 
-  ConfigRow * row = NEW (ConfigRow);
+	ConfigRow * row = NEW (ConfigRow);
   
-  /* Members */
-  row->block = block;
-  row->tag = g_strdup (tag);
-  row->next = NULL;
-  row->vector_head = row->vector_tail = NULL;
-  row->pair_head = row->pair_tail = NULL;
+	/* Members */
+	row->block = block;
+	row->tag = g_strdup (tag);
+	row->next = NULL;
+	row->vector_head = row->vector_tail = NULL;
+	row->pair_head = row->pair_tail = NULL;
 
-  /* Methods */
-  row->parse = configrow_method_parse;
-  row->destroy = configrow_method_destroy;
-  row->get_pair = configrow_method_get_pair;
-  row->get_vector = configrow_method_get_vector;
+	/* Methods */
+	row->parse = configrow_method_parse;
+	row->destroy = configrow_method_destroy;
+	row->get_pair = configrow_method_get_pair;
+	row->get_vector = configrow_method_get_vector;
 
-  SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
-  return row;
+	SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
+	return row;
 }
 
 static void
 configrow_object_free (ConfigRow *row)
 {
-  ASSERT (row != NULL);
+	ASSERT (row != NULL);
   
-  FREE (row->tag);
+	FREE (row->tag);
 
-  DESTROY (ConfigPair, row->pair_head);
-  DESTROY (ConfigVector, row->vector_head);
+	DESTROY (ConfigPair, row->pair_head);
+	DESTROY (ConfigVector, row->vector_head);
 
-  FREE (row);
+	FREE (row);
 }
 
 static ConfigPair *
 configrow_method_get_pair (ConfigRow * row, const gchar * key)
 {
-  ASSERT (row != NULL);
+	ASSERT (row != NULL);
 
-  if (!IS_NULLSTR (key))
-    {
+	if (!IS_NULLSTR (key))
+	{
       ITERATE_BEGIN (ConfigPair, row->pair_head);
       {
-	if (!strcmp (it->key, key))
-	  return it;
+			if (!strcmp (it->key, key))
+				return it;
       }
       ITERATE_END();
-    }
-  return NULL;
+	}
+	return NULL;
 }
 
 static ConfigVector *
 configrow_method_get_vector (ConfigRow * row, const gchar * key)
 {
-  ASSERT (row != NULL);
+	ASSERT (row != NULL);
 
-  if (!IS_NULLSTR (key))
-    {
+	if (!IS_NULLSTR (key))
+	{
       ConfigPair * pair = row->get_pair (row, key);
       if (IS_NULL (pair))
-	return NULL;
+			return NULL;
 
       /* If we have already parsed it there is no reason to do it 
-	 a second time. Check existing linked list and return the
-	 pointer if we have already allocated it. */
+			a second time. Check existing linked list and return the
+			pointer if we have already allocated it. */
       ITERATE_BEGIN (ConfigVector, row->vector_head);
       {
-	if (!strcmp (it->tag, key))
-	  return it;
+			if (!strcmp (it->tag, key))
+				return it;
       }
       ITERATE_END();
 
@@ -616,48 +616,48 @@ configrow_method_get_vector (ConfigRow * row, const gchar * key)
       gchar * q = pair->value + strlen (pair->value);
     
       do
-	{
-	  vec->add (vec, trim (&buf[0]));
-	} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
+		{
+			vec->add (vec, trim (&buf[0]));
+		} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
 
       return vec;
-    }
-  return NULL;
+	}
+	return NULL;
 }
 
 static gchar *
 configrow_method_parse (ConfigRow * row, gchar * p)
 {
-  ASSERT (row != NULL);
-  ASSERT (p != NULL);
+	ASSERT (row != NULL);
+	ASSERT (p != NULL);
 
-  gchar key[1024], value[1024];
-  gchar * q = NULL, * s = NULL;
+	gchar key[1024], value[1024];
+	gchar * q = NULL, * s = NULL;
 
-  do
-    {
-      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
+	do
 	{
-	  break;
-	}      
+      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
+		{
+			break;
+		}      
 
       if ((s = parse (q+1, &value[0], 1024, ';')) != NULL)
-	{
-	  ConfigPair * pair = row->get_pair (row, trim (&key[0]));
-	  if (pair)
-	    {
-	      fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
-		       " row '%s' block '%s'; replacing\n",
-		       pair->key, pair->value, row->tag, row->block->tag);
-	      fflush (stderr);
-	      pair->destroy (pair);
-	    }
-
-	  pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
-	}
+		{
+			ConfigPair * pair = row->get_pair (row, trim (&key[0]));
+			if (pair)
+			{
+				fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
+							" row '%s' block '%s'; replacing\n",
+							pair->key, pair->value, row->tag, row->block->tag);
+				fflush (stderr);
+				pair->destroy (pair);
+			}
+
+			pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
+		}
       p = s + 1;
-    } while (*p != '\n' && *p != '}' && *p != '\0');
-  return p;
+	} while (*p != '\n' && *p != '}' && *p != '\0');
+	return p;
 }
 
 static void 
@@ -667,93 +667,93 @@ configrow_method_destroy (ConfigRow * row)
 
    SINGLE_UNLINK (ConfigRow, row->block->row_head, row->block->row_tail, row);
 
-  configrow_object_free (row);
+	configrow_object_free (row);
 }
 
 ConfigVector *
 configvector_new (ConfigRow * row, const gchar * tag)
 {
-  ASSERT (row != NULL);
+	ASSERT (row != NULL);
 
-  /* No NULL Tags. */
-  if (IS_NULLSTR (tag)) return NULL;
-  return configvector_object_init (row, tag);
+	/* No NULL Tags. */
+	if (IS_NULLSTR (tag)) return NULL;
+	return configvector_object_init (row, tag);
 }
 
 static ConfigVector *
 configvector_object_init (ConfigRow * row, const gchar * tag)
 {
-  ASSERT (row != NULL);
+	ASSERT (row != NULL);
 
-  ConfigVector * vec = NEW (ConfigVector);
+	ConfigVector * vec = NEW (ConfigVector);
 
-  /* Members */
-  vec->row = row;
-  vec->tag = g_strdup (tag);
-  vec->next = vec->prev = NULL;
-  vec->array = g_ptr_array_sized_new (7);
+	/* Members */
+	vec->row = row;
+	vec->tag = g_strdup (tag);
+	vec->next = vec->prev = NULL;
+	vec->array = g_ptr_array_sized_new (7);
 
-  /* Methods */
-  vec->destroy = configvector_method_destroy;
-  vec->get_int = configvector_method_get_int;
-  vec->get = configvector_method_get;
-  vec->add = configvector_method_add;
+	/* Methods */
+	vec->destroy = configvector_method_destroy;
+	vec->get_int = configvector_method_get_int;
+	vec->get = configvector_method_get;
+	vec->add = configvector_method_add;
 
-  DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
-  return vec;
+	DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
+	return vec;
 }
 
 static void 
 configvector_object_free (ConfigVector * vec)
 {
-  ASSERT (vec != NULL);
+	ASSERT (vec != NULL);
 
-  FREE (vec->tag);
+	FREE (vec->tag);
 
-  if (vec->array != NULL)
-    g_ptr_array_free (vec->array, TRUE);
+	if (vec->array != NULL)
+		g_ptr_array_free (vec->array, TRUE);
 
-  FREE (vec);
+	FREE (vec);
 }
 
 static void
 configvector_method_destroy (ConfigVector * vec)
 {
-  ASSERT (vec != NULL);
+	ASSERT (vec != NULL);
 
-  DOUBLE_UNLINK (vec);
+	DOUBLE_UNLINK (vec);
 
-  configvector_object_free (vec);
+	configvector_object_free (vec);
 }
 
 static gchar *
-configvector_method_get (ConfigVector * vec, gint index)
+configvector_method_get (ConfigVector * vec, guint index)
 {
-  ASSERT (vec != NULL);
+	ASSERT (vec != NULL);
 
-  if (index >= vec->array->len) return NULL;
+	if (index >= vec->array->len) return NULL;
 
-  gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
-  return rvalue;
+	gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
+	return rvalue;
 }
 
 static gint
-configvector_method_get_int (ConfigVector * vec, gint index)
+configvector_method_get_int (ConfigVector * vec, guint index)
 {
-  ASSERT (vec != NULL);
+	ASSERT (vec != NULL);
 
-  if (index >= vec->array->len) return -1;
+	if (index >= vec->array->len) return -1;
 
-  gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
-  return atoi (rvalue);
+	gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
+	return atoi (rvalue);
 }
 
 static void
 configvector_method_add (ConfigVector * vec, const gchar * value)
 {
-  ASSERT (vec != NULL);
-  ASSERT (value != NULL);
+	ASSERT (vec != NULL);
+	ASSERT (value != NULL);
 
-  gchar * ptr = g_strdup (value);
-  g_ptr_array_add (vec->array, ptr);
+	gchar * ptr = g_strdup (value);
+	g_ptr_array_add (vec->array, ptr);
 }
diff --git a/src/config.h b/src/config.h
index a46192b..fddbe91 100755
--- a/src/config.h
+++ b/src/config.h
@@ -55,8 +55,8 @@ struct _ConfigVector
 
   /* Methods */
   void (*add) (ConfigVector *, const gchar *);
-  gint (*get_int) (ConfigVector *, gint);
-  gchar *(*get) (ConfigVector *, gint);
+  gint (*get_int) (ConfigVector *, guint);
+  gchar *(*get) (ConfigVector *, guint);
   void (*destroy) (ConfigVector *);
 };
 
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index 79f87a4..b4a7ce1 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -45,8 +45,8 @@ static gint
 key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
 	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
-	Workbook * wb = (Workbook *)arguments->at(1);
-	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
+	//Workbook * wb = (Workbook *)arguments->at(1);
+	//GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
 
 	//	int vposition = std::abs((int)gtksheet->vadjustment->value);
 	static off64_t cursor = 0;
@@ -80,6 +80,8 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 Largefile::Largefile (Application * appstate, Handle * platform)
 	: Plugin (appstate, platform) {
 
+	this->wb = workbook_open (appstate->gtkwindow(), "largefile");
+	
 	ConfigPair * logpath =
 		appstate->config()->get_pair (appstate->config(), "largefile", "log", "path");
 
@@ -103,38 +105,50 @@ Largefile::~Largefile (void) {
 
 bool
 Largefile::open_file (const std::string & filename) {
+	this->lock();
+	
 	int fdEventId = proactor::Event::uniqueEventId();
 	FileDispatcher * fd = new FileDispatcher (fdEventId, appstate->proactor());
 	CsvParser * csv = new CsvParser (this->wb, this->pktlog, 0, 20);
 
 	if (appstate->proactor()->addWorker (fdEventId, csv) == false) {
 		g_critical ("Failed starting CsvParser for file %s", filename.c_str());
+		this->unlock();
 		return false;
 	}
 
-	if (fd->open (filename.c_str()) == false) {
+	if (fd->open (filename) == false) {
 		g_critical ("Failed opening %s", filename.c_str());
+		this->unlock();
 		return false;
 	}
 
 	if (fd->start() == false) {
 		g_critical ("Failed starting file dispatcher for file %s", filename.c_str());
+		this->unlock();
 		return false;
 	}
 
-	this->mapping.insert (std::make_pair (filename, fdEventId));
+	this->mapping.insert (std::make_pair (std::string(filename), fdEventId));
+	
+	this->unlock();
 	return true;
 }
 
 bool
 Largefile::exit_file (const std::string & filename) {
+	this->lock();
+	
 	FilenameMap::iterator it = this->mapping.find(filename);
 	if (it == this->mapping.end()) {
 		// STUB: something meaningful here to mention that the file does not exist inside
 		// of the map. They're trying to exit from a file that seemingly has not been opened.
+		this->unlock();
 		return false;
 	}
 	// STUB: procedure for shutting down a file dispatcher and CsvParser.
 	this->mapping.erase (it);
+
+	this->unlock();
 	return true;
 }
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index d80c98b..49a9c0d 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -10,7 +10,7 @@ all: 	largefile
 
 largefile: ${OBJS}
 	${CX} ${_CXFLAGS} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread -lcsv -lgtkworkbookshared -lgtkworkbook
+	-lgthread-2.0 -lpthread -lcsv
 
 clean:		
 	${MD} ${OBJDIR}/largefile
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index cce51fe..2f2ee74 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -44,7 +44,7 @@ open_csv_file (GtkWidget * w, gpointer data) {
     gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
 
 	 if (lf->open_file (filename) == true) {
-		 std::cout << filename << "\n";
+		 lf->workbook()->add_new_sheet (lf->workbook(), filename, 1000, 20);
 	 }
 	 else {
 		 // STUB: The opening of the file failed. Do something meaningful here.
@@ -57,24 +57,25 @@ open_csv_file (GtkWidget * w, gpointer data) {
 }
 
 static GtkWidget *
-largefile_mainmenu_new (Application * appstate, GtkWidget * window) {
+largefile_mainmenu_new (Application * appstate, Largefile * lf, GtkWidget * window) {
 	GtkWidget * lfmenu = gtk_menu_new();
 	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
 	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
 	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
 
+	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
+							G_CALLBACK (open_csv_file), (gpointer)lf);
+	
 	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
-
-	gtk_widget_show_all (lfmenu);
-	return lfmenu;
+	return lfmenu_item;
 }
 
 static GtkWidget *
-build_layout (Application * app, Largefile * lf, Workbook * wb) {
+build_layout (Application * app, Largefile * lf) {
+	Workbook * wb = lf->workbook();
 	GtkWidget * gtk_menu = app->gtkmenu();
 	GtkWidget * box = gtk_vbox_new (FALSE, 0);
-	
-	GtkWidget * largefile_menu = largefile_mainmenu_new (app, app->gtkwindow());
+	GtkWidget * largefile_menu = largefile_mainmenu_new (app, lf, app->gtkwindow());
 	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
 
 	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
@@ -92,14 +93,8 @@ extern "C" {
     ASSERT (appstate != NULL);
     ASSERT (platform != NULL);
 	 Largefile * lf = new Largefile (appstate, platform);
-	 Workbook * wb = lf->workbook();
-	 
-    if ((wb = workbook_open (appstate->gtkwindow(), "largefile")) == NULL) {
-      g_critical ("Failed opening workbook; exiting largefile plugin");
-      return NULL;
-    }
-	 
-	 GtkWidget * box = build_layout (appstate, lf, wb);
+
+	 GtkWidget * box = build_layout (appstate, lf);
 	 gtk_widget_show (box);	 
     return lf;
   }
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 535eaa4..67d9250 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -48,10 +48,10 @@ static gint
 key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
 	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
-	Workbook * wb = (Workbook *)arguments->at(1);
-	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
+	//Workbook * wb = (Workbook *)arguments->at(1);
+	//GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
 
-	int vposition = std::abs((int)gtksheet->vadjustment->value);
+	//int vposition = std::abs((int)gtksheet->vadjustment->value);
 	static off64_t cursor = 0;
 	//	float N = vposition, K = 24388, V = (N/K);
 	

commit e42f7efd44a767e5489c090e6717768585638a9f
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 10 10:55:11 2009 -0400

    Forgot to include constructor inside of Largefile, and forgot -rdynamic flag.

diff --git a/Makefile b/Makefile
index 7d0a457..d903311 100755
--- a/Makefile
+++ b/Makefile
@@ -8,7 +8,7 @@ libgtkworkbook:
 	${MD} OBJS/libgtkworkbook
 	${MAKE} gtkworkbook/ all
 
-libgtkworkbook:
+libgtkworkbookshared:
 	${MD} OBJS/libgtkworkbookshared
 	${MAKE} shared/ all
 
diff --git a/src/Makefile b/src/Makefile
index 09d720f..642cef6 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -11,7 +11,7 @@ all: 	gtkworkbook
 	make -C largefile/ all
 
 gtkworkbook: ${OBJS}
-	${CX} -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
+	${CX} -rdynamic -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
 
 clean:		
 	${MD} ${OBJDIR}	
@@ -26,7 +26,7 @@ install: all
 	make -C largefile/ install
 
 ${OBJDIR}/%.o: %.cpp
-	${CX} ${INCS} -c ${CXFLAGS} $< -o $@
+	${CX} -rdynamic ${INCS} -c ${CXFLAGS} $< -o $@
 
 .cpp.o:
-	${CX} ${INCS} -c ${CXFLAGS} $<
+	${CX} -rdynamic ${INCS} -c ${CXFLAGS} $<
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
index ce177e3..79f87a4 100755
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -98,6 +98,9 @@ Largefile::Largefile (Application * appstate, Handle * platform)
     }
 }
 
+Largefile::~Largefile (void) {
+}
+
 bool
 Largefile::open_file (const std::string & filename) {
 	int fdEventId = proactor::Event::uniqueEventId();
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
index fd056e2..4e3e45e 100755
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -7,8 +7,6 @@
 #include "../Application.hpp"
 #include "../config.h"
 
-extern "C++" {
-
 class Largefile : public Plugin {
 private:
 	typedef std::map<std::string,int> FilenameMap;
@@ -22,7 +20,5 @@ public:
 	bool open_file (const std::string & filename);
 	bool exit_file (const std::string & filename);
 };
-
-}
 	
 #endif
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index deeb782..d80c98b 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.base
 
-INCS += -I${PROJDIR}/shared -I../
+INCS += -I/home/johnb/include -I${PROJDIR}/shared -I../
 SRCS=$(wildcard *.cpp) 
 OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
 
@@ -9,7 +9,7 @@ _CXFLAGS= -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
 all: 	largefile
 
 largefile: ${OBJS}
-	${CX} ${_CXFLAGS} -rdynamic -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
+	${CX} ${_CXFLAGS} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
 	-lgthread-2.0 -lpthread -lcsv -lgtkworkbookshared -lgtkworkbook
 
 clean:		
@@ -21,7 +21,7 @@ install: all
 	${CP} ${PROJDIR}/bin/largefile.so ${INSEXTDIR}/largefile.so
 
 ${OBJDIR}/largefile/%.o: %.cpp
-	${CX} ${_CXFLAGS} ${INCS} -c -rdynamic -fPIC ${CXFLAGS} $< -o $@
+	${CX} ${_CXFLAGS} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
 
 .cpp.o:
-	${CX} ${_CXFLAGS} ${INCS} -c -rdynamic -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
+	${CX} ${_CXFLAGS} ${INCS} -c -fPIC ${CXFLAGS} $<ls
\ No newline at end of file

commit 5a8bfb6a0e88772828204a9318fddad186eb23b2
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 10 10:40:07 2009 -0400

    Removed some locks from sheet.c which were causing a deadlock.

diff --git a/src/application.c b/src/application.c
index 1ae1711..526b31b 100755
--- a/src/application.c
+++ b/src/application.c
@@ -140,7 +140,7 @@ application_init (int * argc, char *** argv)
   
 	/* Set the initial size of the application; we could load this
 		from a configuration file eventually. */
-	gtk_widget_set_usize (appstate->gtk_window, 1024, 768);
+	gtk_widget_set_usize (appstate->gtk_window, 1024, 800);
   
 	/* Attach the window box to the window and present to the screen. */
 	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
diff --git a/src/application.h b/src/application.h
index 103ac49..fe24880 100755
--- a/src/application.h
+++ b/src/application.h
@@ -51,7 +51,8 @@ struct _ApplicationState
 	GtkWidget * gtk_window_vbox;
 	gchar * absolute_path;
 	gboolean * shutdown;
-
+	Workbook * active_workbook;
+	
 	/* Methods */
 	int (*run) (ApplicationState *);
 	void (*close) (ApplicationState *);
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index edd5692..5e8b972 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -27,56 +27,46 @@
 extern void thread_main (ThreadArgs *);
 
 static void
-exit_application (GtkWidget * w, gpointer data) {
-	ApplicationState * app = (ApplicationState *)data;
-	app->exit_application(app);
-}
-
-static void
 open_csv_file (GtkWidget * w, gpointer data) {
-  ApplicationState * app = (ApplicationState *)data;
+	ApplicationState * app = (ApplicationState *)data;
+	Workbook * wb = app->active_workbook;
    
-  GtkWidget * dialog = gtk_file_chooser_dialog_new ("Open File",
-						    GTK_WINDOW (app->gtk_window),
-						    GTK_FILE_CHOOSER_ACTION_OPEN,
-						    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-						    GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-						    NULL);  
+	GtkWidget * dialog = gtk_file_chooser_dialog_new ("Open File",
+																	  GTK_WINDOW (app->gtk_window),
+																	  GTK_FILE_CHOOSER_ACTION_OPEN,
+																	  GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+																	  GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+																	  NULL);  
   
-  gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (dialog), TRUE);
+	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (dialog), TRUE);
 
-  if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
-    gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
+		gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
 
+		wb->add_new_sheet (wb, filename, 1000, 20);
 	 
-	 
-    g_free (filename);
-  }
+		g_free (filename);
+	}
 
-  gtk_widget_destroy (dialog);
+	gtk_widget_destroy (dialog);
 }
 
 static GtkWidget *
 largefile_mainmenu_new (ApplicationState * appstate, GtkWidget * window) {
 	GtkWidget * menubar = gtk_menu_bar_new();
-	//GtkWidget * lfmenu = gtk_menu_new (); 
+	GtkWidget * lfmenu = gtk_menu_new();
 	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
 	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
-	GtkWidget * lfmenu_exit = gtk_image_menu_item_new_from_stock (GTK_STOCK_QUIT, NULL);
 
-	gtk_menu_shell_append (GTK_MENU_SHELL (menubar), lfmenu_open);
-	gtk_menu_shell_append (GTK_MENU_SHELL (menubar), lfmenu_exit);
+	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
 	
-	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), menubar);
+	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
 	
 	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
 							G_CALLBACK (open_csv_file), (gpointer)appstate);
-	
-	g_signal_connect (G_OBJECT (lfmenu_exit), "activate",
-							G_CALLBACK (exit_application), (gpointer)appstate);
-
-	//gtk_container_add (GTK_CONTAINER (menubar), lfmenu);
 
+	gtk_menu_shell_append (GTK_MENU_SHELL (menubar), lfmenu_item);
+	
 	gtk_widget_show_all (menubar);
 	return menubar;
 }
@@ -96,22 +86,22 @@ extern "C" {
     ASSERT (appstate != NULL);
     ASSERT (plugin != NULL);
 	
-    GtkWidget * box = build_layout (appstate, appstate->gtk_window);
 	 Workbook * wb = NULL;
     if ((wb = workbook_open (appstate->gtk_window, "largefile")) == NULL) {
       g_critical ("Failed opening workbook; exiting largefile plugin");
       return NULL;
     }
 
+	 appstate->active_workbook = wb;
+	 
+    GtkWidget * box = build_layout (appstate, appstate->gtk_window);
     gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
 
     wb->signals[SIG_WORKBOOK_CHANGED] = appstate->signals[SIG_SHEET_CHANGED];
         
     wb->gtk_box = box;
     
-    wb->add_new_sheet (wb, "sheet0", 1000, 20);
-
-    ThreadArgs args;
+	 ThreadArgs args;
     args.push_back ( (void *)wb );
     args.push_back ( (void *)appstate->cfg );
     args.push_back ( (void *)appstate->shutdown );
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index eb9e6c6..d5eff25 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -79,29 +79,9 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	}
 	return FALSE;
 }
-	
-void
-thread_main (ThreadArgs * args) {
-	Workbook * wb = (Workbook *)args->at(0);
-	Config * cfg  = (Config *)args->at(1);
-	gboolean * SHUTDOWN = (gboolean *)args->at(2);
-	ConfigPair * logpath = cfg->get_pair (cfg, "largefile", "log", "path");
-	if (IS_NULL (logpath)) {
-		g_critical ("Failed loading log->path from configuration file; "
-					"exiting thread");
-		return;
-	}
-
-	FILE * pktlog = NULL;
-	std::string logname = std::string (logpath->value).append("/");
-	logname.append (append_pidname("largefile.").append(".log"));
-
-	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
-		g_critical ("Failed opening file '%s' for packet logging; exiting"
-					" thread", logname.c_str());
-		return;
-    }
 
+static bool
+open_file (const gchar * filename, Workbook * wb, FILE * pktlog) {
 	int fdEventId = proactor::Event::uniqueEventId(); 
 	proactor::Proactor proactor;
 	FileDispatcher fdispatcher (fdEventId, &proactor);
@@ -109,22 +89,22 @@ thread_main (ThreadArgs * args) {
 
 	if (proactor.start() == false) {
 		g_critical ("Failed starting Proactor; exiting thread.");
-		return;
+		return false;
 	}
 
 	if (proactor.addWorker (fdEventId, &csv_parser) == false) {
 		g_critical ("Failed starting CsvParser; exiting thread.");
-		return;
+		return false;
 	}
 
 	if (fdispatcher.open ("/home/jbellone/largefile.csv") == false) {
 		g_critical ("Failed opening /home/johnb/largefile.csv");
-		return;
+		return false;
 	}
 
 	if (fdispatcher.start() == false) {
 		g_critical ("Failed starting file dispatcher; exiting thread.");
-		return;
+		return false;
 	}
 	
 	std::vector<gpointer> signal_arguments;
@@ -135,12 +115,36 @@ thread_main (ThreadArgs * args) {
 							  GTK_SIGNAL_FUNC (key_press_callback),
 							  (gpointer)&signal_arguments);
 
+	csv_parser.stop();
+	return true;
+}
+
+void
+thread_main (ThreadArgs * args) {
+	Workbook * wb = (Workbook *)args->at(0);
+	Config * cfg  = (Config *)args->at(1);
+	gboolean * SHUTDOWN = (gboolean *)args->at(2);
+	ConfigPair * logpath = cfg->get_pair (cfg, "largefile", "log", "path");
+	if (IS_NULL (logpath)) {
+		g_critical ("Failed loading log->path from configuration file; "
+					"exiting thread");
+		return;
+	}
+
+	FILE * pktlog = NULL;
+	std::string logname = std::string (logpath->value).append("/");
+	logname.append (append_pidname("largefile.").append(".log"));
+
+	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
+		g_critical ("Failed opening file '%s' for packet logging; exiting"
+					" thread", logname.c_str());
+		return;
+    }
+
 	while (*SHUTDOWN == FALSE) {
 		concurrent::Thread::sleep (100);
 	}
 
-	csv_parser.stop();
-  
 	FCLOSE (pktlog);
 	delete args;
 }
diff --git a/workbook/sheet.c b/workbook/sheet.c
index c379c26..a050be6 100755
--- a/workbook/sheet.c
+++ b/workbook/sheet.c
@@ -28,49 +28,49 @@ static void sheet_method_set_cell (Sheet *, gint, gint, const gchar *);
 static void sheet_method_apply_cell (Sheet *, const Cell *);
 static void sheet_method_apply_cellarray (Sheet *, Cell **, gint);
 static void sheet_method_apply_cellrange (Sheet *, 
-					  const GtkSheetRange *,
-					  const CellAttributes *);
+														const GtkSheetRange *,
+														const CellAttributes *);
 static void sheet_method_range_set_background (Sheet *, 
-					       const GtkSheetRange *,
-					       const gchar *);
+															  const GtkSheetRange *,
+															  const gchar *);
 static void sheet_method_range_set_foreground (Sheet *,
-					       const GtkSheetRange *,
-					       const gchar *);
+															  const GtkSheetRange *,
+															  const gchar *);
 static void sheet_method_set_attention (Sheet *, gint);
 static gboolean sheet_method_load (Sheet *, const gchar *);
 static gboolean sheet_method_save (Sheet *, const gchar *);
 static void sheet_method_apply_cellrow (Sheet *, Cell **, gint, gint);
 
 struct geometryFileHeader {
-  gint fileVersion;
-  gint maxRow;
-  gint maxColumn;
+	gint fileVersion;
+	gint maxRow;
+	gint maxColumn;
 };
 
 struct geometryFileEntry {
-  gint cellRow;
-  gint cellCol;
-  gint cellTextLength;
-  gboolean cellIsVisible;
-  gboolean cellIsEditable;
-  GtkJustification cellJustification;
-  GdkColor cellForeground;
-  GdkColor cellBackground;
+	gint cellRow;
+	gint cellCol;
+	gint cellTextLength;
+	gboolean cellIsVisible;
+	gboolean cellIsEditable;
+	GtkJustification cellJustification;
+	GdkColor cellForeground;
+	GdkColor cellBackground;
 };
 
 /*
-static GtkSheetCell *
-gtk_sheet_cell_new (void) {
+  static GtkSheetCell *
+  gtk_sheet_cell_new (void) {
   GtkSheetCell * cell = g_new (GtkSheetCell, 1);
   cell->text = NULL;
   cell->link = NULL;
   cell->attributes = NULL;
   return cell;
-}
+  }
 */
 /*
-static void
-GrowSheet (GtkSheet * tbl, gint newrows, gint newcols) {
+  static void
+  GrowSheet (GtkSheet * tbl, gint newrows, gint newcols) {
   gint ii, jj, inirow, inicol;
 
   inirow = tbl->maxallocrow + 1;
@@ -80,36 +80,36 @@ GrowSheet (GtkSheet * tbl, gint newrows, gint newcols) {
   tbl->maxallocrow = tbl->maxallocrow + newrows;
 
   if (newrows > 0) {
-    tbl->data = (GtkSheetCell ***) g_realloc (tbl->data,
-					      (tbl->maxallocrow+1)*sizeof(GtkSheetCell**)+sizeof(double));
+  tbl->data = (GtkSheetCell ***) g_realloc (tbl->data,
+  (tbl->maxallocrow+1)*sizeof(GtkSheetCell**)+sizeof(double));
 
-    for (ii = inirow; ii <= tbl->maxallocrow; ii++) {
-      tbl->data[ii] = (GtkSheetCell **) g_malloc ((tbl->maxcol+1)*sizeof(GtkSheetCell*)+sizeof(double));
+  for (ii = inirow; ii <= tbl->maxallocrow; ii++) {
+  tbl->data[ii] = (GtkSheetCell **) g_malloc ((tbl->maxcol+1)*sizeof(GtkSheetCell*)+sizeof(double));
 
-      for (jj = 0; jj < inicol; jj++)
-	tbl->data[ii][jj] = NULL;
-    }
+  for (jj = 0; jj < inicol; jj++)
+  tbl->data[ii][jj] = NULL;
+  }
   }
 
   if (newcols > 0) {
-    for (ii = 0; ii <= tbl->maxallocrow; ii++) {
-      tbl->data[ii] = (GtkSheetCell **) g_realloc (tbl->data[ii],
-						   (tbl->maxalloccol+1)*sizeof(GtkSheetCell*)+sizeof(double));
+  for (ii = 0; ii <= tbl->maxallocrow; ii++) {
+  tbl->data[ii] = (GtkSheetCell **) g_realloc (tbl->data[ii],
+  (tbl->maxalloccol+1)*sizeof(GtkSheetCell*)+sizeof(double));
 
-      for (jj = inicol; jj <= tbl->maxalloccol; jj++)
-	tbl->data[ii][jj] = NULL;
-    }
+  for (jj = inicol; jj <= tbl->maxalloccol; jj++)
+  tbl->data[ii][jj] = NULL;
+  }
+  }
   }
-}
 
-static void
-CheckBounds (GtkSheet * tbl, gint row, gint col) {
+  static void
+  CheckBounds (GtkSheet * tbl, gint row, gint col) {
   gint newrows = 0, newcols = 0;
 
   if (col > tbl->maxalloccol) newcols = col - tbl->maxalloccol;
   if (row > tbl->maxallocrow) newrows = row - tbl->maxallocrow;
   if (newrows > 0 || newcols > 0) GrowSheet (tbl, newrows, newcols);
-}
+  }
 */
 /* @description: This method creates a new Sheet object and returns the
    pointer to that object. It calls the constructor function to do so.
@@ -120,13 +120,13 @@ CheckBounds (GtkSheet * tbl, gint row, gint col) {
 Sheet *
 sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
   
-  Sheet * sheet = sheet_object_init (book, label, rows, columns);
+	Sheet * sheet = sheet_object_init (book, label, rows, columns);
 
-  /* STUB: Perform anything that is based on a style here. */
+	/* STUB: Perform anything that is based on a style here. */
 
-  return sheet;
+	return sheet;
 }
 
 /* @description: This function is the Sheet's constructor. 
@@ -136,118 +136,121 @@ sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
    @cols: The amount of columns the GtkSheet widget should have. */
 static Sheet *
 sheet_object_init (Workbook * book,
-		   const gchar * label, 
-		   gint rows, gint columns)
+						 const gchar * label, 
+						 gint rows, gint columns)
 {
-  gdk_threads_enter ();
-  Sheet * sheet = NEW (Sheet);
+	//gdk_threads_enter ();
+	Sheet * sheet = NEW (Sheet);
 
-  /* Create the sheet containers and GtkSheet object. */
-  sheet->gtk_box = gtk_vbox_new (FALSE, 1);
-  gtk_widget_show (sheet->gtk_box);
+	/* Create the sheet containers and GtkSheet object. */
+	sheet->gtk_box = gtk_vbox_new (FALSE, 0);
+	gtk_widget_show (sheet->gtk_box);
 
-  GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
-  gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
-				  GTK_POLICY_AUTOMATIC,
-				  GTK_POLICY_AUTOMATIC);
-  gtk_widget_show (scrolled_window);
+	GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
+	gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
+	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
+											  GTK_POLICY_AUTOMATIC,
+											  GTK_POLICY_AUTOMATIC);
+	gtk_widget_show (scrolled_window);
 
-  sheet->gtk_label = gtk_label_new (label);
+	sheet->gtk_label = gtk_label_new (label);
   
-  sheet->gtk_sheet = gtk_sheet_new (rows, columns, label);
-  gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
-  gtk_container_add (GTK_CONTAINER (scrolled_window),
-		     GTK_WIDGET (sheet->gtk_sheet));
-  gtk_widget_show (sheet->gtk_sheet);
-
-  /* We should be able to use sheet->gtk_box now throughout all of our
-     tests when iterating through a GtkNotebook structure. The page number
-     will change when something is removed (or reordered). The pointer will
-     stay the same. */
-  sheet->page = gtk_notebook_append_page (GTK_NOTEBOOK (book->gtk_notebook),
-					  sheet->gtk_box,
-					  sheet->gtk_label);
-  /* Members */
-  sheet->workbook = book;
-  sheet->name = g_strdup (label);
-  sheet->attention = 0;
-  sheet->notices = 0;
-  sheet->has_focus = FALSE;
-  sheet->next = sheet->prev = NULL;
-  sheet->max_rows = rows;
-  sheet->max_columns = columns;
-
-  /* Methods */
-  sheet->destroy = sheet_method_destroy;
-  sheet->set_cell = sheet_method_set_cell;
-  sheet->apply_range = sheet_method_apply_cellrange;
-  sheet->apply_array = sheet_method_apply_cellarray;
-  sheet->apply_cell = sheet_method_apply_cell;
-  sheet->apply_row = sheet_method_apply_cellrow;
-  sheet->range_set_foreground = sheet_method_range_set_foreground;
-  sheet->range_set_background = sheet_method_range_set_background;
-  sheet->set_attention = sheet_method_set_attention;
-  sheet->save = sheet_method_save;
-  sheet->load = sheet_method_load;
-
-  /* Connect any signals that we need to. */
-  if (!IS_NULL (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]))
-    {
+	sheet->gtk_sheet = gtk_sheet_new (rows, columns, label);
+	gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
+	gtk_container_add (GTK_CONTAINER (scrolled_window),
+							 GTK_WIDGET (sheet->gtk_sheet));
+	
+
+	/* We should be able to use sheet->gtk_box now throughout all of our
+		tests when iterating through a GtkNotebook structure. The page number
+		will change when something is removed (or reordered). The pointer will
+		stay the same. */
+	sheet->page = gtk_notebook_append_page (GTK_NOTEBOOK (book->gtk_notebook),
+														 sheet->gtk_box,
+														 sheet->gtk_label);
+
+	gtk_widget_show_all (book->gtk_notebook);
+	
+	/* Members */
+	sheet->workbook = book;
+	sheet->name = g_strdup (label);
+	sheet->attention = 0;
+	sheet->notices = 0;
+	sheet->has_focus = FALSE;
+	sheet->next = sheet->prev = NULL;
+	sheet->max_rows = rows;
+	sheet->max_columns = columns;
+
+	/* Methods */
+	sheet->destroy = sheet_method_destroy;
+	sheet->set_cell = sheet_method_set_cell;
+	sheet->apply_range = sheet_method_apply_cellrange;
+	sheet->apply_array = sheet_method_apply_cellarray;
+	sheet->apply_cell = sheet_method_apply_cell;
+	sheet->apply_row = sheet_method_apply_cellrow;
+	sheet->range_set_foreground = sheet_method_range_set_foreground;
+	sheet->range_set_background = sheet_method_range_set_background;
+	sheet->set_attention = sheet_method_set_attention;
+	sheet->save = sheet_method_save;
+	sheet->load = sheet_method_load;
+
+	/* Connect any signals that we need to. */
+	if (!IS_NULL (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]))
+	{
       gtk_signal_connect (GTK_OBJECT (sheet->gtk_sheet),
-			  "changed",
-		  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]),
-			  (gpointer)sheet);
-    }
+								  "changed",
+								  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]),
+								  (gpointer)sheet);
+	}
 
-  gdk_threads_leave ();
-  return sheet;
+	//gdk_threads_leave ();
+	return sheet;
 }
 
 static gboolean
 sheet_method_load (Sheet * sheet, const gchar * filepath)
 {
-  ASSERT (sheet != NULL);
+	ASSERT (sheet != NULL);
 
-  if (IS_NULLSTR (filepath))
-    {
+	if (IS_NULLSTR (filepath))
+	{
       g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
       return FALSE;
-    }
+	}
 
-  FILE * fp = NULL;
-  if ((fp = fopen (filepath, "rb")) == NULL)
-    {
+	FILE * fp = NULL;
+	if ((fp = fopen (filepath, "rb")) == NULL)
+	{
       g_warning ("%s: failed opening file '%s' for reading", 
-		 __FUNCTION__,
-		 filepath);
+					  __FUNCTION__,
+					  filepath);
       return FALSE;
-    }
+	}
 
-  gdk_threads_enter ();
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
-  struct geometryFileHeader header = {-1,-1,-1};
-  struct geometryFileEntry entry = {-1,-1,-1};
+	gdk_threads_enter ();
+	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+	struct geometryFileHeader header = {-1,-1,-1};
+	struct geometryFileEntry entry = {-1,-1,-1};
  
-  fread ((void *)&header, sizeof (struct geometryFileHeader), 1, fp);
+	fread ((void *)&header, sizeof (struct geometryFileHeader), 1, fp);
 
-  if (header.fileVersion != GEOMETRY_FILE_VERSION)
-    {
+	if (header.fileVersion != GEOMETRY_FILE_VERSION)
+	{
       g_warning ("Geometry file version %d is not accepted. (%d)",
-		 header.fileVersion, GEOMETRY_FILE_VERSION);
+					  header.fileVersion, GEOMETRY_FILE_VERSION);
       FCLOSE (fp);
       gdk_threads_leave ();
       return FALSE;
-    }
+	}
 
-  while (fread ((void *)&entry, sizeof (struct geometryFileEntry), 1, fp) > 0)
-    {
+	while (fread ((void *)&entry, sizeof (struct geometryFileEntry), 1, fp) > 0)
+	{
       gchar * text = g_strndup ("", entry.cellTextLength);
       fread ((void *)text, sizeof (gchar), entry.cellTextLength, fp);
       gtk_sheet_set_cell_text (gtksheet, 
-			       entry.cellRow, 
-			       entry.cellCol, 
-			       text);
+										 entry.cellRow, 
+										 entry.cellCol, 
+										 text);
       
       GtkSheetCell ** cell = &gtksheet->data[entry.cellRow][entry.cellCol];
       
@@ -264,82 +267,82 @@ sheet_method_load (Sheet * sheet, const gchar * filepath)
       (*cell)->attributes->background.blue = entry.cellBackground.blue;
 
       FREE (text);
-    }
+	}
 
-  FCLOSE (fp);
-  gdk_threads_leave ();
-  return TRUE;
+	FCLOSE (fp);
+	gdk_threads_leave ();
+	return TRUE;
 }
 
 static gboolean
 sheet_method_save (Sheet * sheet, const gchar * filepath)
 {
-  ASSERT (sheet != NULL);
+	ASSERT (sheet != NULL);
 
-  if (IS_NULLSTR (filepath))
-    {
+	if (IS_NULLSTR (filepath))
+	{
       g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
       return FALSE;
-    }
+	}
 
-  FILE * fp = NULL;
-  if ((fp = fopen (filepath, "wb")) == NULL)
-    {
+	FILE * fp = NULL;
+	if ((fp = fopen (filepath, "wb")) == NULL)
+	{
       g_warning ("%s: failed opening file '%s' for writing", 
-		 __FUNCTION__, 
-		 filepath);
+					  __FUNCTION__, 
+					  filepath);
       return FALSE;
-    }
+	}
   
-  gdk_threads_enter ();
-  GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
-  struct geometryFileHeader header =
-    {
-      GEOMETRY_FILE_VERSION,
-      GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
-      GTK_SHEET (sheet->gtk_sheet)->maxalloccol
-    };
-
-  fwrite ((void *)&header, sizeof(struct geometryFileHeader), 1, fp);
-
-  for (gint ii = 0; ii <= header.maxRow; ii++)
-    {
-      for (gint jj = 0; jj <= header.maxColumn; jj++)
-	{
-	  GtkSheetCell * cell = data[ii][jj];
-
-	  if (!IS_NULL (cell) && !IS_NULLSTR(cell->text))
-	    {
-	      struct geometryFileEntry entry =
+	gdk_threads_enter ();
+	GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
+	struct geometryFileHeader header =
 		{
-		  cell->row,
-		  cell->col,
-		  strlen (cell->text),
-		  cell->attributes->is_visible,
-		  cell->attributes->is_editable,
-		  cell->attributes->justification
+			GEOMETRY_FILE_VERSION,
+			GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
+			GTK_SHEET (sheet->gtk_sheet)->maxalloccol
 		};
 
-	      entry.cellForeground.pixel = cell->attributes->foreground.pixel;
-	      entry.cellForeground.red = cell->attributes->foreground.red;
-	      entry.cellForeground.green = cell->attributes->foreground.green;
-	      entry.cellForeground.blue = cell->attributes->foreground.blue;
-	      entry.cellBackground.pixel = cell->attributes->background.pixel;
-	      entry.cellBackground.red = cell->attributes->background.red;
-	      entry.cellBackground.green = cell->attributes->background.green;
-	      entry.cellBackground.blue = cell->attributes->background.blue;
-
-	      fwrite ((void *)&entry, 
-		      sizeof (struct geometryFileEntry), 1, fp);
-	      fwrite ((void *)cell->text, 
-		      sizeof (gchar), entry.cellTextLength, fp);
-	    }
+	fwrite ((void *)&header, sizeof(struct geometryFileHeader), 1, fp);
+
+	for (gint ii = 0; ii <= header.maxRow; ii++)
+	{
+      for (gint jj = 0; jj <= header.maxColumn; jj++)
+		{
+			GtkSheetCell * cell = data[ii][jj];
+
+			if (!IS_NULL (cell) && !IS_NULLSTR(cell->text))
+			{
+				struct geometryFileEntry entry =
+					{
+						cell->row,
+						cell->col,
+						strlen (cell->text),
+						cell->attributes->is_visible,
+						cell->attributes->is_editable,
+						cell->attributes->justification
+					};
+
+				entry.cellForeground.pixel = cell->attributes->foreground.pixel;
+				entry.cellForeground.red = cell->attributes->foreground.red;
+				entry.cellForeground.green = cell->attributes->foreground.green;
+				entry.cellForeground.blue = cell->attributes->foreground.blue;
+				entry.cellBackground.pixel = cell->attributes->background.pixel;
+				entry.cellBackground.red = cell->attributes->background.red;
+				entry.cellBackground.green = cell->attributes->background.green;
+				entry.cellBackground.blue = cell->attributes->background.blue;
+
+				fwrite ((void *)&entry, 
+						  sizeof (struct geometryFileEntry), 1, fp);
+				fwrite ((void *)cell->text, 
+						  sizeof (gchar), entry.cellTextLength, fp);
+			}
+		}
 	}
-    }
 
-  FCLOSE (fp);
-  gdk_threads_leave ();
-  return TRUE;
+	FCLOSE (fp);
+	gdk_threads_leave ();
+	return TRUE;
 }
 
 /* @description: This method sets the attention level of the Sheet.
@@ -348,18 +351,18 @@ sheet_method_save (Sheet * sheet, const gchar * filepath)
 static void 
 sheet_method_set_attention (Sheet * sheet, gint attention)
 {
-  ASSERT (sheet != NULL);
-  gdk_threads_enter ();
+	ASSERT (sheet != NULL);
+	gdk_threads_enter ();
 
-  sheet->attention = attention;
+	sheet->attention = attention;
 
-  /* Do something funky to show that you should be looking at ME!
-     Oh, GtkNotebook tab, why are thou so vain? */
-  if ((sheet->has_focus == FALSE) && (sheet->notices > 0)) {
+	/* Do something funky to show that you should be looking at ME!
+		Oh, GtkNotebook tab, why are thou so vain? */
+	if ((sheet->has_focus == FALSE) && (sheet->notices > 0)) {
       
-    }
+	}
 
-  gdk_threads_leave ();
+	gdk_threads_leave ();
 }
 
 /* @description: This method destroys the Sheet object.
@@ -367,14 +370,14 @@ sheet_method_set_attention (Sheet * sheet, gint attention)
 static void
 sheet_method_destroy (Sheet * sheet)
 {
-  ASSERT (sheet != NULL);
-  gdk_threads_enter ();
+	ASSERT (sheet != NULL);
+	gdk_threads_enter ();
 
-  DOUBLE_UNLINK (sheet);
+	DOUBLE_UNLINK (sheet);
 
-  sheet_object_free (sheet);
+	sheet_object_free (sheet);
 
-  gdk_threads_leave ();
+	gdk_threads_leave ();
 }
 
 /* @description: This method frees the memory that was used by the Sheet
@@ -383,108 +386,108 @@ sheet_method_destroy (Sheet * sheet)
 static void
 sheet_object_free (Sheet * sheet)
 {
-  ASSERT (sheet != NULL);
+	ASSERT (sheet != NULL);
 
-  FREE (sheet->name);
-  FREE (sheet);
-  return;
+	FREE (sheet->name);
+	FREE (sheet);
+	return;
 }
 
 static void
 sheet_method_apply_cellrange (Sheet * sheet, 
-			      const GtkSheetRange * range,
-			      const CellAttributes * attrib)
+										const GtkSheetRange * range,
+										const CellAttributes * attrib)
 {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (range != NULL);
-  g_return_if_fail (attrib != NULL);
-  gdk_threads_enter ();
+	ASSERT (sheet != NULL);
+	g_return_if_fail (range != NULL);
+	g_return_if_fail (attrib != NULL);
+	gdk_threads_enter ();
 
-  gdk_threads_leave ();
+	gdk_threads_leave ();
 }
 
 static void
 sheet_method_apply_cellrow (Sheet * sheet,
-			    Cell ** array,
-			    gint row,
-			    gint size) {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (array != NULL);
+									 Cell ** array,
+									 gint row,
+									 gint size) {
+	ASSERT (sheet != NULL);
+	g_return_if_fail (array != NULL);
 
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
-  GtkSheetCell ** cell;
-  Cell * item;
+	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+	GtkSheetCell ** cell;
+	Cell * item;
 
-  if (row > gtksheet->maxrow || row < 0) return;
-  if (size > gtksheet->maxcol || size < 0) return;
+	if (row > gtksheet->maxrow || row < 0) return;
+	if (size > gtksheet->maxcol || size < 0) return;
 
-  gdk_threads_enter();
+	gdk_threads_enter();
 
-  for (int col = 0; col < size; col++) {
-    item = array[col]; 
-    cell = &gtksheet->data[row][col];
+	for (int col = 0; col < size; col++) {
+		item = array[col]; 
+		cell = &gtksheet->data[row][col];
     
-    gtk_sheet_set_cell_text (gtksheet,
-			     row,
-			     col,
-			     item->value->str);
-    /*
-    if (*cell == NULL)
-      (*cell) = gtk_sheet_cell_new();
+		gtk_sheet_set_cell_text (gtksheet,
+										 row,
+										 col,
+										 item->value->str);
+		/*
+		  if (*cell == NULL)
+		  (*cell) = gtk_sheet_cell_new();
       
-    (*cell)->row = row;
-    (*cell)->col = col;
+		  (*cell)->row = row;
+		  (*cell)->col = col;
 
-    if ((*cell)->text)
-      g_free ((*cell)->text);
+		  if ((*cell)->text)
+		  g_free ((*cell)->text);
       
-    (*cell)->text = g_strdup (item->value->str);
-    */
+		  (*cell)->text = g_strdup (item->value->str);
+		*/
 
-    item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
-  }
+		item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
+	}
 
-  gdk_threads_leave();
+	gdk_threads_leave();
 }
 
 static void
 sheet_method_apply_cellarray (Sheet * sheet, 
-			      Cell ** array,
-			      gint size)
+										Cell ** array,
+										gint size)
 {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (array != NULL);
+	ASSERT (sheet != NULL);
+	g_return_if_fail (array != NULL);
 
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+	GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
 
-  gdk_threads_enter ();
+	gdk_threads_enter ();
 
-  /* We'll see how this performs for now. In the future we may want to go
-     directly into the GtkSheet structures to get a little more performance
-     boost (mainly because we should not have to check all the bounds each
-     time we want to update). */
-  for (gint ii = 0; ii < size; ii++) {
-    Cell * cell = array[ii];
+	/* We'll see how this performs for now. In the future we may want to go
+		directly into the GtkSheet structures to get a little more performance
+		boost (mainly because we should not have to check all the bounds each
+		time we want to update). */
+	for (gint ii = 0; ii < size; ii++) {
+		Cell * cell = array[ii];
 
-    gtk_sheet_set_cell_text (gtksheet,
-			     cell->row,
-			     cell->column,
-			     cell->value->str);
+		gtk_sheet_set_cell_text (gtksheet,
+										 cell->row,
+										 cell->column,
+										 cell->value->str);
 
-    if (!IS_NULLSTR (cell->attributes.bgcolor->str))
-      sheet->range_set_background (sheet, 
-				   &cell->range, 
-				   cell->attributes.bgcolor->str);
+		if (!IS_NULLSTR (cell->attributes.bgcolor->str))
+			sheet->range_set_background (sheet, 
+												  &cell->range, 
+												  cell->attributes.bgcolor->str);
 
-    if (!IS_NULLSTR (cell->attributes.fgcolor->str))
-      sheet->range_set_foreground (sheet, 
-				   &cell->range, 
-				   cell->attributes.fgcolor->str);
+		if (!IS_NULLSTR (cell->attributes.fgcolor->str))
+			sheet->range_set_foreground (sheet, 
+												  &cell->range, 
+												  cell->attributes.fgcolor->str);
 
-    cell->value->str[0] = cell->attributes.bgcolor->str[0] = cell->attributes.fgcolor->str[0] = 0;
-  }
+		cell->value->str[0] = cell->attributes.bgcolor->str[0] = cell->attributes.fgcolor->str[0] = 0;
+	}
 
-  gdk_threads_leave ();
+	gdk_threads_leave ();
 }
 
 /* @description: This method applies the settings from a Cell object into the
@@ -495,35 +498,35 @@ sheet_method_apply_cellarray (Sheet * sheet,
 static void
 sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
 {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (cell != NULL);
-
-  gdk_threads_enter ();
-
-  if (sheet->has_focus == FALSE)
-    sheet->notices++;
-
-  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet),
-		      cell->row,
-		      cell->column,
-		      cell->attributes.justification,
-		      cell->value->str);
-  gdk_threads_leave ();
-
-  if (!IS_NULLSTR (cell->attributes.bgcolor->str))
-    sheet->range_set_background (sheet, 
-				 &cell->range, 
-				 cell->attributes.bgcolor->str);
-
-  if (!IS_NULLSTR (cell->attributes.fgcolor->str))
-    sheet->range_set_foreground (sheet, 
-				 &cell->range, 
-				 cell->attributes.fgcolor->str);
-
-  /* Clear all of the strings */
-  g_string_assign (cell->value, "");
-  g_string_assign (cell->attributes.bgcolor, "");
-  g_string_assign (cell->attributes.fgcolor, "");
+	ASSERT (sheet != NULL);
+	g_return_if_fail (cell != NULL);
+
+	gdk_threads_enter ();
+
+	if (sheet->has_focus == FALSE)
+		sheet->notices++;
+
+	gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet),
+							  cell->row,
+							  cell->column,
+							  cell->attributes.justification,
+							  cell->value->str);
+	gdk_threads_leave ();
+
+	if (!IS_NULLSTR (cell->attributes.bgcolor->str))
+		sheet->range_set_background (sheet, 
+											  &cell->range, 
+											  cell->attributes.bgcolor->str);
+
+	if (!IS_NULLSTR (cell->attributes.fgcolor->str))
+		sheet->range_set_foreground (sheet, 
+											  &cell->range, 
+											  cell->attributes.fgcolor->str);
+
+	/* Clear all of the strings */
+	g_string_assign (cell->value, "");
+	g_string_assign (cell->attributes.bgcolor, "");
+	g_string_assign (cell->attributes.fgcolor, "");
 }
 
 /* @description: This method changes the background of a range of cells. 
@@ -534,22 +537,22 @@ sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
    green, etc). */
 static void
 sheet_method_range_set_background (Sheet * sheet, 
-				   const GtkSheetRange * range,
-				   const gchar * desc)
+											  const GtkSheetRange * range,
+											  const gchar * desc)
 {
-  ASSERT (sheet != NULL); ASSERT (range != NULL);
-  GdkColor color;
-
-  /* The color needs to be taken from the colormap; there is an alternative
-     way to do this if we use #rgb or #rrggbb formats. */
-  gdk_threads_enter ();
-  gdk_color_parse (desc, &color);
-  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
-		   &color);
+	ASSERT (sheet != NULL); ASSERT (range != NULL);
+	GdkColor color;
+
+	/* The color needs to be taken from the colormap; there is an alternative
+		way to do this if we use #rgb or #rrggbb formats. */
+	gdk_threads_enter ();
+	gdk_color_parse (desc, &color);
+	gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
+						  &color);
   
-  gtk_sheet_range_set_background (GTK_SHEET (sheet->gtk_sheet),
-				  range, &color);
-  gdk_threads_leave ();
+	gtk_sheet_range_set_background (GTK_SHEET (sheet->gtk_sheet),
+											  range, &color);
+	gdk_threads_leave ();
 }
 
 /* @description: This method changes the foreground color over a range of
@@ -560,23 +563,23 @@ sheet_method_range_set_background (Sheet * sheet,
    @desc: The string representation of the color (e.g. white, green, blue). */
 static void
 sheet_method_range_set_foreground (Sheet * sheet, 
-				   const GtkSheetRange * range,
-				   const gchar * desc)
+											  const GtkSheetRange * range,
+											  const gchar * desc)
 {
-  ASSERT (sheet != NULL); ASSERT (range != NULL);
-  GdkColor color;
+	ASSERT (sheet != NULL); ASSERT (range != NULL);
+	GdkColor color;
   
    /* The color needs to be taken from the colormap; there is an alternative
-     way to do this if we use #rgb or #rrggbb formats. */
-  gdk_threads_enter ();
-  gdk_color_parse (desc, &color);
-  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
-		   &color);
+		way to do this if we use #rgb or #rrggbb formats. */
+	gdk_threads_enter ();
+	gdk_color_parse (desc, &color);
+	gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
+						  &color);
       
-  gtk_sheet_range_set_foreground (GTK_SHEET (sheet->gtk_sheet),
-				  range, &color);
-  gdk_threads_leave ();
- }
+	gtk_sheet_range_set_foreground (GTK_SHEET (sheet->gtk_sheet),
+											  range, &color);
+	gdk_threads_leave ();
+}
 
 /* @description: This method manually sets a GtkSheet cell's value. It does
    not require the use of the Cell object.
@@ -586,18 +589,18 @@ sheet_method_range_set_foreground (Sheet * sheet,
    @value: The text string to be applied to the cell. */
 static void 
 sheet_method_set_cell (Sheet * sheet,
-		       gint row, gint col,
-		       const gchar * value)
+							  gint row, gint col,
+							  const gchar * value)
 {
-  ASSERT (sheet != NULL);
-
-  gdk_threads_enter ();
-  if (sheet->has_focus == FALSE)
-    sheet->notices++;
-  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet), 
-		      row, 
-		      col, 
-		      GTK_JUSTIFY_LEFT, 
-		      value);
-  gdk_threads_leave ();
+	ASSERT (sheet != NULL);
+
+	gdk_threads_enter ();
+	if (sheet->has_focus == FALSE)
+		sheet->notices++;
+	gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet), 
+							  row, 
+							  col, 
+							  GTK_JUSTIFY_LEFT, 
+							  value);
+	gdk_threads_leave ();
 }
diff --git a/workbook/workbook.c b/workbook/workbook.c
index 15bcc96..9ae9169 100755
--- a/workbook/workbook.c
+++ b/workbook/workbook.c
@@ -25,15 +25,15 @@ static void workbook_method_destroy (Workbook *);
 static Workbook *workbook_object_init (GtkWidget *, const gchar *);
 static Workbook *workbook_object_free (Workbook *);
 static Sheet *workbook_method_addnewsheet (Workbook *, 
-					   const gchar *, 
-					   gint, gint);
+														 const gchar *, 
+														 gint, gint);
 static Sheet *workbook_method_get_sheet (Workbook *, const gchar *);
 static void workbook_method_remove_sheet (Workbook *, Sheet *);
 static gboolean workbook_method_move_sheet_index (Workbook *, Sheet *, gint);
 static gboolean workbook_method_move_sheet (Workbook *, 
-					    Sheet *,
-					    const gchar *,
-					    gboolean);
+														  Sheet *,
+														  const gchar *,
+														  gboolean);
 
 /* @description: This method "opens" a Workbook. In the future it will load
    a Workbook from a specified filename (which will most likely be a GZIP
@@ -43,14 +43,14 @@ static gboolean workbook_method_move_sheet (Workbook *,
 Workbook *
 workbook_open (GtkWidget * window, const gchar * filename)
 {
-  ASSERT (window != NULL);
+	ASSERT (window != NULL);
 
-  /* STUB: A workbook is opened here from some form of an archived file.
-     At this point we would load up the configuration files for the styles,
-     sheets and plugins to be loaded then this would all be executed here. */
+	/* STUB: A workbook is opened here from some form of an archived file.
+		At this point we would load up the configuration files for the styles,
+		sheets and plugins to be loaded then this would all be executed here. */
 
-  Workbook * book = workbook_object_init (window, filename);
-  return book;
+	Workbook * book = workbook_object_init (window, filename);
+	return book;
 }
 
 /* @description: This method adds a new Sheet to the Workbook object. The
@@ -63,35 +63,35 @@ workbook_open (GtkWidget * window, const gchar * filename)
    @cols: Number of columns the GtkSheet object should have.*/
 static Sheet *
 workbook_method_addnewsheet (Workbook * book,
-			     const gchar * label, 
-			     gint rows, 
-			     gint cols)
+									  const gchar * label, 
+									  gint rows, 
+									  gint cols)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
 
-  Sheet * sheet = book->get_sheet (book, label);
-  if (sheet != NULL) 
-    {
+	Sheet * sheet = book->get_sheet (book, label);
+	if (sheet != NULL) 
+	{
       g_warning ("Cannot create '%s' because it already exists", 
-		 label);
+					  label);
       return NULL;
-    }
+	}
 
-  sheet = sheet_new (book, label, rows, cols);
+	sheet = sheet_new (book, label, rows, cols);
 
-  LINK_OBJECT (book->sheet_first,
-	       book->sheet_last, 
-	       sheet);
+	LINK_OBJECT (book->sheet_first,
+					 book->sheet_last, 
+					 sheet);
 
-  /* We are the first and only sheet; make sure we are set to have focus. */
-  /* BUGFIX: This was in the wrong place... needs to be below LINK_OBJECT */
-  if ((book->sheet_first == sheet) && IS_NULL (book->sheet_last))
-    {
+	/* We are the first and only sheet; make sure we are set to have focus. */
+	/* BUGFIX: This was in the wrong place... needs to be below LINK_OBJECT */
+	if ((book->sheet_first == sheet))
+	{
       sheet->has_focus = TRUE;
       book->focus_sheet = sheet;
-    }
+	}
 
-  return sheet;
+	return sheet;
 }
 
 /* @description: This method performs a search of all the Workbooks and
@@ -101,20 +101,20 @@ workbook_method_addnewsheet (Workbook * book,
 static Sheet *
 workbook_method_get_sheet (Workbook * wb, const gchar * sheet)
 {
-  ASSERT (wb != NULL);
+	ASSERT (wb != NULL);
 
-  if (!IS_NULLSTR (sheet))
-    {
+	if (!IS_NULLSTR (sheet))
+	{
       ITERATE_BEGIN (Sheet, wb->sheet_first);
       {
-	if (!sheet) return NULL;
-	if (!strcmp (sheet, it->name))
-	  return it;
+			if (!sheet) return NULL;
+			if (!strcmp (sheet, it->name))
+				return it;
       }
       ITERATE_END ();
-    }
+	}
 
-  return NULL;
+	return NULL;
 }
 
 /* @description: This method removes a Sheet object from the Workbook. It also
@@ -124,33 +124,33 @@ workbook_method_get_sheet (Workbook * wb, const gchar * sheet)
 static void
 workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
 {
-  ASSERT (wb != NULL);
+	ASSERT (wb != NULL);
 
-  if (sheet->workbook != wb)
-    {
+	if (sheet->workbook != wb)
+	{
       g_warning ("'%s' does not belong to workbook '%s'",
-		 sheet->name, wb->filename);
+					  sheet->name, wb->filename);
       return;
-    }
+	}
   
-  ITERATE_BEGIN (Sheet, wb->sheet_first);
-  {
-    /* Remove the sheet from the GtkNotebook */
-    if (it == sheet)
+	ITERATE_BEGIN (Sheet, wb->sheet_first);
+	{
+		/* Remove the sheet from the GtkNotebook */
+		if (it == sheet)
       {
-	gdk_threads_enter ();
-	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
-					   sheet->gtk_box);
-	gtk_notebook_remove_page (GTK_NOTEBOOK (wb->gtk_notebook), page); 
-	gtk_widget_queue_draw (wb->gtk_notebook);
-	gdk_threads_leave ();
-	return;
+			gdk_threads_enter ();
+			gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
+														  sheet->gtk_box);
+			gtk_notebook_remove_page (GTK_NOTEBOOK (wb->gtk_notebook), page); 
+			gtk_widget_queue_draw (wb->gtk_notebook);
+			gdk_threads_leave ();
+			return;
       }
-  }
-  ITERATE_END ();
+	}
+	ITERATE_END ();
 
-  g_warning ("Sheet '%s' was not found inside of workbook '%s'", 
-	     sheet->name, wb->filename);
+	g_warning ("Sheet '%s' was not found inside of workbook '%s'", 
+				  sheet->name, wb->filename);
 }
 
 /* @description: This method moves the Sheet's GtkSheet tab inside of the
@@ -161,52 +161,52 @@ workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
 static gboolean
 workbook_method_move_sheet_index (Workbook * wb, Sheet * sheet, gint index)
 {
-  gdk_threads_enter ();
-  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
-			      sheet->gtk_box,
-			      index);
-  gdk_threads_leave ();
-  return TRUE;
+	gdk_threads_enter ();
+	gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
+										 sheet->gtk_box,
+										 index);
+	gdk_threads_leave ();
+	return TRUE;
 }
 
 static gboolean
 workbook_method_move_sheet (Workbook * wb, 
-			    Sheet * sheet, 
-			    const gchar * id,
-			    gboolean after)
+									 Sheet * sheet, 
+									 const gchar * id,
+									 gboolean after)
 {
-  ASSERT (wb != NULL);
-  ASSERT (sheet != NULL);
+	ASSERT (wb != NULL);
+	ASSERT (sheet != NULL);
 
-  if (IS_NULLSTR (id))
-    return FALSE;
+	if (IS_NULLSTR (id))
+		return FALSE;
 
-  Sheet * sh = wb->get_sheet (wb, id);
-  if (IS_NULL (sh))
-    {
+	Sheet * sh = wb->get_sheet (wb, id);
+	if (IS_NULL (sh))
+	{
       g_warning ("Sheet '%s' does not exist in workbook '%s'", 
-		 sheet->name, wb->filename);
+					  sheet->name, wb->filename);
       return FALSE;
-    }
+	}
   
-  gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
-				     sh->gtk_box);
-  if (page == -1)
-    {
+	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
+												  sh->gtk_box);
+	if (page == -1)
+	{
       g_warning ("Sheet '%s' does not appear to be in workbook '%s' notebook",
-		 sheet->name, wb->filename);
+					  sheet->name, wb->filename);
       return FALSE;
-    }
+	}
 
-  if (after == TRUE)  page++;
-  else                page--;
+	if (after == TRUE)  page++;
+	else                page--;
 
-  gdk_threads_enter ();
-  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
-			      sheet->gtk_box,
-			      page);
-  gdk_threads_leave ();
-  return TRUE;
+	gdk_threads_enter ();
+	gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
+										 sheet->gtk_box,
+										 page);
+	gdk_threads_leave ();
+	return TRUE;
 }
 
 /* @description: This is a Workbook object's constructor. 
@@ -215,41 +215,41 @@ workbook_method_move_sheet (Workbook * wb,
 static Workbook *
 workbook_object_init (GtkWidget * window, const gchar * filename)
 {
-  Workbook * book = NEW (Workbook);
+	Workbook * book = NEW (Workbook);
 
-  /* Set up the signals. */
-  book->signals[SIG_WORKBOOK_CHANGED] = NULL;
+	/* Set up the signals. */
+	book->signals[SIG_WORKBOOK_CHANGED] = NULL;
 
-  /* Set up the notebook */
-  gdk_threads_enter ();
-  book->gtk_notebook = gtk_notebook_new ();
+	/* Set up the notebook */
+	gdk_threads_enter ();
+	book->gtk_notebook = gtk_notebook_new ();
   
-  GtkNotebook * notebook = GTK_NOTEBOOK (book->gtk_notebook);
-
-  gtk_notebook_set_tab_pos (notebook, GTK_POS_BOTTOM);
-  gtk_notebook_popup_enable (notebook);
-  gtk_notebook_set_show_tabs (notebook, TRUE);
-  gtk_notebook_set_show_border (notebook, TRUE);
-  gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
-  gtk_widget_show (book->gtk_notebook);
-  gdk_threads_leave ();
-
-  /* Members */
-  book->sheet_first = book->sheet_last = NULL;
-  book->next = book->prev = NULL;
-  book->focus_sheet = NULL;
-  book->gtk_window = window;
-  book->filename = g_strdup (filename);
+	GtkNotebook * notebook = GTK_NOTEBOOK (book->gtk_notebook);
+
+	gtk_notebook_set_tab_pos (notebook, GTK_POS_BOTTOM);
+	gtk_notebook_popup_enable (notebook);
+	gtk_notebook_set_show_tabs (notebook, TRUE);
+	gtk_notebook_set_show_border (notebook, TRUE);
+	gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
+	gtk_widget_show (book->gtk_notebook);
+	gdk_threads_leave ();
+
+	/* Members */
+	book->sheet_first = book->sheet_last = NULL;
+	book->next = book->prev = NULL;
+	book->focus_sheet = NULL;
+	book->gtk_window = window;
+	book->filename = g_strdup (filename);
     
-  /* Methods */
-  book->destroy = workbook_method_destroy;
-  book->add_new_sheet = workbook_method_addnewsheet;
-  book->get_sheet = workbook_method_get_sheet;
-  book->remove_sheet = workbook_method_remove_sheet;
-  book->move_sheet_index = workbook_method_move_sheet_index;
-  book->move_sheet = workbook_method_move_sheet;
-
-  return book;
+	/* Methods */
+	book->destroy = workbook_method_destroy;
+	book->add_new_sheet = workbook_method_addnewsheet;
+	book->get_sheet = workbook_method_get_sheet;
+	book->remove_sheet = workbook_method_remove_sheet;
+	book->move_sheet_index = workbook_method_move_sheet_index;
+	book->move_sheet = workbook_method_move_sheet;
+
+	return book;
 }
 
 /* @description: This method destroys the Workbook object and all of the
@@ -258,19 +258,19 @@ workbook_object_init (GtkWidget * window, const gchar * filename)
 static void
 workbook_method_destroy (Workbook * book)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
 
-  /* Wrap anything up here. */
-  Sheet * current = book->sheet_first, * next = NULL;
-  while (current)
-    {
+	/* Wrap anything up here. */
+	Sheet * current = book->sheet_first, * next = NULL;
+	while (current)
+	{
       next = current->next;
       current->destroy (current);
       current = next;
-    }
+	}
 
-  UNLINK_OBJECT (book);
-  workbook_object_free (book);
+	UNLINK_OBJECT (book);
+	workbook_object_free (book);
 }
 
 /* @description: This method frees the memory that the Workbook object has 
@@ -279,11 +279,11 @@ workbook_method_destroy (Workbook * book)
 static Workbook *
 workbook_object_free (Workbook * book)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
 
-  book->sheet_first = book->sheet_last = NULL;
+	book->sheet_first = book->sheet_last = NULL;
 
-  FREE (book->filename);
-  FREE (book);
-  return book;
+	FREE (book->filename);
+	FREE (book);
+	return book;
 }

commit 7ad035fea1f2f523c54f055fb2e2eb31cdab8a1c
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 10 09:48:19 2009 -0400

    Added temporary menu.

diff --git a/src/application.c b/src/application.c
index e8a7458..1ae1711 100755
--- a/src/application.c
+++ b/src/application.c
@@ -38,6 +38,7 @@ static Plugin* application_method_loadplugin (ApplicationState *,
 static void application_method_openextension (ApplicationState *,
 															 const gchar *,
 															 gboolean);
+static void application_method_exitapplication (ApplicationState *);
 static guint application_signal_gtknotebook_switchpage (GtkNotebook *,
 																		  GtkNotebookPage *,
 																		  gint,
@@ -315,7 +316,8 @@ application_object_init (void)
 	app->close = application_method_close;
 	app->load_plugin = application_method_loadplugin;
 	app->open_extension = application_method_openextension;
-
+	app->exit_application = application_method_exitapplication;
+	
 	return app;
 }
 
@@ -451,6 +453,24 @@ application_signal_destroy_event (GtkWidget *window, gpointer data)
 	return FALSE;
 }
 
+static void
+application_method_exitapplication (ApplicationState * app) {
+	GtkWidget * dialog 
+		= gtk_message_dialog_new (GTK_WINDOW (app->gtk_window), GTK_DIALOG_MODAL,
+										  GTK_MESSAGE_QUESTION,
+										  GTK_BUTTONS_YES_NO,
+										  "Are you sure that you want to quit?");
+	gtk_window_set_title (GTK_WINDOW (dialog), "Close Application");
+
+	gint result = gtk_dialog_run (GTK_DIALOG (dialog));
+	
+	gtk_widget_destroy (dialog);
+
+	if (result == GTK_RESPONSE_YES) {
+		application_signal_destroy_event (app->gtk_window, (gpointer)app);
+	}
+}
+
 /* @description: This method loads an extension from the filename
    provided. It also registers the plugin's method and calls it.
    @app: A pointer to the application state object.
diff --git a/src/application.h b/src/application.h
index 1df1b15..103ac49 100755
--- a/src/application.h
+++ b/src/application.h
@@ -57,6 +57,7 @@ struct _ApplicationState
 	void (*close) (ApplicationState *);
 	void (*open_extension) (ApplicationState *, const gchar *, gboolean);
 	Plugin *(*load_plugin) (ApplicationState *, const gchar *);
+	void (*exit_application) (ApplicationState *);
 };
 
 /* application.c */
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 34c7266..edd5692 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -27,10 +27,15 @@
 extern void thread_main (ThreadArgs *);
 
 static void
+exit_application (GtkWidget * w, gpointer data) {
+	ApplicationState * app = (ApplicationState *)data;
+	app->exit_application(app);
+}
+
+static void
 open_csv_file (GtkWidget * w, gpointer data) {
   ApplicationState * app = (ApplicationState *)data;
-  //Config * cfg = app->cfg;
-  
+   
   GtkWidget * dialog = gtk_file_chooser_dialog_new ("Open File",
 						    GTK_WINDOW (app->gtk_window),
 						    GTK_FILE_CHOOSER_ACTION_OPEN,
@@ -43,6 +48,8 @@ open_csv_file (GtkWidget * w, gpointer data) {
   if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
     gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
 
+	 
+	 
     g_free (filename);
   }
 
@@ -51,29 +58,35 @@ open_csv_file (GtkWidget * w, gpointer data) {
 
 static GtkWidget *
 largefile_mainmenu_new (ApplicationState * appstate, GtkWidget * window) {
-  GtkItemFactoryEntry menu_items[] = {
-    {"/_File",         NULL,		NULL, 		0, 	"<Branch>"},
-    {"/File/_Open",    "<CTRL>O",	(GtkItemFactoryCallback)open_csv_file,	0,	"<StockItem>", GTK_STOCK_OPEN},
-    {"/File/_Close",   "<CTRL>C",	NULL,		0,	"<Item>"},
-    {"/File/sep1",     NULL,		NULL,		0,	"<Separator>"},
-    {"/File/_Quit",    "<CTRL>Q", 	gtk_main_quit,	0,	"<StockItem>", GTK_STOCK_QUIT},
-  };
-  
-  gint nmenu_items = sizeof (menu_items) / sizeof (menu_items[0]);
-  GtkAccelGroup * accel 
-    = gtk_accel_group_new ();
+	GtkWidget * menubar = gtk_menu_bar_new();
+	//GtkWidget * lfmenu = gtk_menu_new (); 
+	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
+	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
+	GtkWidget * lfmenu_exit = gtk_image_menu_item_new_from_stock (GTK_STOCK_QUIT, NULL);
+
+	gtk_menu_shell_append (GTK_MENU_SHELL (menubar), lfmenu_open);
+	gtk_menu_shell_append (GTK_MENU_SHELL (menubar), lfmenu_exit);
 	
-  GtkItemFactory * item_factory 
-    = gtk_item_factory_new (GTK_TYPE_MENU_BAR, "<main>", accel);
-  
-  gtk_item_factory_create_items (item_factory, nmenu_items, menu_items, appstate);
+	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), menubar);
+	
+	g_signal_connect (G_OBJECT (lfmenu_open), "activate",
+							G_CALLBACK (open_csv_file), (gpointer)appstate);
+	
+	g_signal_connect (G_OBJECT (lfmenu_exit), "activate",
+							G_CALLBACK (exit_application), (gpointer)appstate);
 
-  gtk_window_add_accel_group (GTK_WINDOW (window), accel);
+	//gtk_container_add (GTK_CONTAINER (menubar), lfmenu);
 
-  GtkWidget * menu = gtk_item_factory_get_widget (item_factory, "<main>");
-  gtk_widget_show (menu);
+	gtk_widget_show_all (menubar);
+	return menubar;
+}
 
-  return menu;
+static GtkWidget *
+build_layout (ApplicationState * appstate, GtkWidget * gtk_window) {
+	GtkWidget * box = gtk_vbox_new (FALSE, 0);
+	GtkWidget * mainmenu = largefile_mainmenu_new (appstate, gtk_window);
+	gtk_box_pack_start (GTK_BOX (box), mainmenu, FALSE, FALSE, 0);
+	return box;
 }
 
 extern "C" {
@@ -83,11 +96,8 @@ extern "C" {
     ASSERT (appstate != NULL);
     ASSERT (plugin != NULL);
 	
-    GtkWidget * box = gtk_vbox_new (FALSE, 0);
-    GtkWidget * mainmenu = largefile_mainmenu_new (appstate, appstate->gtk_window);
-    gtk_box_pack_start (GTK_BOX (box), mainmenu, FALSE, FALSE, 0);
-
-    Workbook * wb = NULL;
+    GtkWidget * box = build_layout (appstate, appstate->gtk_window);
+	 Workbook * wb = NULL;
     if ((wb = workbook_open (appstate->gtk_window, "largefile")) == NULL) {
       g_critical ("Failed opening workbook; exiting largefile plugin");
       return NULL;
@@ -114,7 +124,7 @@ extern "C" {
     }
 
     gtk_box_pack_start (GTK_BOX (appstate->gtk_window_vbox), box, FALSE, FALSE, 0);
-    gtk_widget_show (box);	
+    gtk_widget_show_all (box);	
     return wb;
   }
 

commit 13e6f2fbc6fae989882c9cd9579fefa34df1630d
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jul 10 08:54:50 2009 -0400

    Renamed files and changed permissions.

diff --git a/src/Application.cc b/src/Application.cc
deleted file mode 100755
index 2f1251a..0000000
--- a/src/Application.cc
+++ /dev/null
@@ -1,345 +0,0 @@
-#include "Application.hpp"
-#include "Plugin.hpp"
-#include <cstring>
-
-/* @description: This method takes the argument and clears the string of
-   everything except for the directories. Therefore the return value would
-   be a string sans anything before the last directory delimiter '/'. */
-static gchar *
-munchpath (gchar * path_) {
-	gchar * path = g_strdup(path_);
-	path = g_strreverse (path);
-	gchar * p = path;
-
-	while (p && (*p != '\0')) { if (*p == '/') break; p++; }
-
-	gchar * str = g_strdup (p);
-	str = g_strreverse (str);
-	FREE (path);
-	return str;
-}
-
-static guint
-signal_gtknotebook_removed (GtkNotebook * notebook,
-									 GtkNotebookPage * page,
-									 gint page_num,
-									 Workbook * wb) {
-	ASSERT (wb != NULL);
-	return TRUE;
-}
-
-static guint
-signal_gtknotebook_reordered (GtkNotebook * notebook,
-										GtkNotebookPage * page,
-										gint page_num,
-										Workbook * wb) {
-	ASSERT (wb != NULL);
-	return TRUE;
-}
-
-/* @description: This is the callback for the GtkNotebook 'switch-page' 
-   signal. It is called every single time a user *clicks* on different
-   tab. This method is called *before* the drawing takes place.
-
-   This method iterates through the Sheets and updates where neccesary.
-
-   @notebook: This is a pointer to the notebook object. The object is
-   equal to the Workbook->gtk_notebook pointer.
-   @page:
-   @page_num: The number of the *new* page.
-   @book: The Workbook object associated with the GtkNotebook.*/
-static guint
-signal_gtknotebook_switchpage (GtkNotebook * notebook,
-										 GtkNotebookPage * page,
-										 gint page_num,
-										 Workbook * book) {
-	ASSERT (book != NULL);
-
-	/* Perform the "unfocus" on the old notebook tab. */
-	if (!IS_NULL (book->focus_sheet)) {
-      book->focus_sheet->has_focus = FALSE;
-      book->focus_sheet->notices = 0;
-	}
-
-	GtkWidget * widget = gtk_notebook_get_nth_page (notebook, page_num);
-
-	ITERATE_BEGIN (Sheet, book->sheet_first);
-	{
-		/* Once we find the right Sheet object we can perform what we need
-			to in order to change the "focus." Finally, set book pointer. */
-		if (it->gtk_box == widget)
-      {
-			it->page = page_num;
-			it->has_focus = TRUE;
-			it->notices = 0;
-	
-			/* Reset the label on the notebook tab to the object's name. */
-			gtk_notebook_set_tab_label_text (notebook,
-														it->gtk_box,
-														it->name);
-			book->focus_sheet = it;
-			break;
-      }
-	}
-	ITERATE_END ();
-	return TRUE;
-}
-
-static guint
-signal_gtksheet_changed (GtkWidget * gtksheet,
-								 gint row, gint column,
-								 Sheet * sheet) {
-	ASSERT (sheet != NULL);
-	ASSERT (sheet->workbook != NULL);
-
-	Workbook * wb = sheet->workbook;
-
-	if (sheet->notices > 0) {
-      gchar * label 
-			= g_strdup_printf ("%s (%d)", sheet->name, sheet->notices);
-      gtk_notebook_set_tab_label_text (GTK_NOTEBOOK (wb->gtk_notebook),
-													sheet->gtk_box,
-													label);
-      FREE (label);
-	}
-	return FALSE;
-}
-
-/* @description: This is the callback to GtkMain's "delete" event. This is
-   called when we attempt to close the application safely. 
-   @window: A pointer to the GtkWindow object.
-   @event: A pointer to the associated GdkEvent information.
-   @p: NULL */
-static guint
-signal_delete_event (GtkWindow * window, 
-											GdkEvent * event,
-											gpointer p) {
-	GtkWidget * dialog 
-		= gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
-										  GTK_MESSAGE_QUESTION,
-										  GTK_BUTTONS_YES_NO,
-										  "Are you sure that you want to quit?");
-	gtk_window_set_title (GTK_WINDOW (dialog), "Close Application");
-
-	gint result = gtk_dialog_run (GTK_DIALOG (dialog));
-  
-	gtk_widget_destroy (dialog);
-
-	return (result == GTK_RESPONSE_YES) ? FALSE : TRUE;
-}
-
-/* @description: This is the callback to the "destroy" signal that is
-   emitted from GtkMain. Any cleanup should be done here.
-   @window: A pointer to the GtkWindow object.
-   @data: NULL */
-static guint
-signal_destroy_event (GtkWidget *window, gpointer data)
-{
-	Application * app = (Application *)data;
-	app->shutdown();
-	return FALSE;
-}
-
-Application::Application (int argc, char *** argv) {
-	this->init (argc, argv);
-	this->cfg = NULL;
-	this->gtk_window = NULL;
-	this->gtk_menu = NULL;
-	this->gtk_window_vbox = NULL;
-	
-	/* Set up the signals. */
-	this->signals[NOTEBOOK_SWITCHED]
-		= (GSourceFunc)signal_gtknotebook_switchpage;
-	this->signals[NOTEBOOK_REORDERED]
-		= (GSourceFunc)signal_gtknotebook_reordered;
-	this->signals[NOTEBOOK_REMOVED]
-		= (GSourceFunc)signal_gtknotebook_removed;
-	this->signals[DESTROY_EVENT]
-		= (GSourceFunc)signal_destroy_event;
-	this->signals[DELETE_EVENT]
-		= (GSourceFunc)signal_delete_event;
-	this->signals[SHEET_CHANGED]
-		= (GSourceFunc)signal_gtksheet_changed;
-}
-
-Application::~Application (void) {
-	WorkbookList::iterator it = this->workbooks.begin();
-	while (it != this->workbooks.end()) {
-		(*it)->destroy ( (*it) ); (*it) = NULL;
-		it++;
-	}
-	
-	FREE (this->absolute_path);
-
-	this->shutdown();
-}
-
-Plugin *
-Application::load_plugin (const std::string filename) {
-	Plugin * plugin = Plugin::open_plugin (this, filename);
-
-	if (plugin) {
-		this->plugins.push_back (plugin);
-	}
-	return plugin;
-}
-
-void
-Application::shutdown(void) {
-	// STUB: shutdown the proactor threads here.
-	gtk_main_quit ();
-}
-
-void
-Application::open_extension (const gchar * filename, gboolean absolute_path) {
-	gchar * fname = NULL;
-
-	if (absolute_path) {
-		fname = g_strconcat (this->absolute_path, filename, NULL);
-	}
-	else {
-		fname = g_strdup (filename);
-	}
-
-	Plugin * plugin = NULL;
-	if ((plugin = this->load_plugin (fname)) != NULL) {
-		if (plugin->workbook() == NULL) {
-			g_critical ("Plugin returned a NULL pointer instead of allocated"
-							" workbook.");
-			exit (1);
-		} else {
-			/* Attach all of the signals for the Workbook object. */
-			gtk_signal_connect (GTK_OBJECT (plugin->workbook()->gtk_notebook),
-									  "switch-page",
-									  (GtkSignalFunc)this->signals[NOTEBOOK_SWITCHED], 
-									  (gpointer)plugin->workbook());
-	  
-			this->workbooks.push_back (plugin->workbook());
-		}
-	}
-
-	FREE (fname);
-}
-
-void
-Application::init (int argc, char *** argv) {
-	int c;
-	
-	if (!g_thread_supported ()) {
-      g_thread_init (NULL);
-      gdk_threads_init ();
-	}
-
-	this->absolute_path = ::munchpath (*argv[0]);
-	
-	/* This block parses the commandline for options. A better example on how
-		this code works can be found on the GNU website at the following URI:
-		http://gnu.org/software/libtool/manual/libc/Using-Getopt.html */
-	while ((c = getopt (argc, *argv, "c:")) != -1) {
-      switch (c) {
-			case 'c': {
-				Config * cfg = config_new (optarg);
-				if (!cfg)
-				{
-					g_critical ("Failed loading configuration file '%s';" 
-									" which was specified with -c argument\n", optarg);
-					exit (0);
-					break;
-				}
-				this->cfg = cfg;
-			}
-			break;
-
-			case '?': {
-				if (optopt == 'c') {
-					g_warning ("Option -c requires an argument in order to load"
-								  " a configuration file\n");
-				}
-			}
-			break;
-		}
-	}
-
-	gdk_threads_enter ();
-	gtk_init (&argc, argv);
-
-	/* Create the window and connect two callback to the signals. */
-	this->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
-							  "destroy",
-							  G_CALLBACK (this->signals[DESTROY_EVENT]),
-							  (gpointer *)this);
-	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
-							  "delete_event",
-							  G_CALLBACK (this->signals[DELETE_EVENT]),
-							  NULL);
-  
-	/* Set the initial size of the application; we could load this
-		from a configuration file eventually. */
-	gtk_widget_set_usize (this->gtk_window, 1024, 768);
-  
-	/* Attach the window box to the window and present to the screen. */
-	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
-	gtk_container_add (GTK_CONTAINER (this->gtk_window), window_box);
-	this->gtk_window_vbox = window_box;
-  
-	gtk_widget_show_all (this->gtk_window);
- 
-	gdk_threads_leave ();
-	
-	if (this->cfg) {
-		Config * cfg = this->cfg;
-      cfg->open (cfg);
-     
-      /* Load extensions */
-      ConfigRow * load = cfg->get_row (cfg, "application", "load");
-
-      /* Did a little bit of fixing here. We needed something to specify that
-			certain extensions will start automatically when the application is
-			started. */
-      if (!IS_NULL (load)) {
-			ConfigVector * ext = load->get_vector (load, "extensions");
-			gchar * block = NULL;
-			gint ii = 0;
-
-			if (IS_NULL (ext)) {
-				g_critical ("Config 'extensions' vector is NULL");
-				return;
-			}
-      
-			while ((block = ext->get(ext, ii)) != NULL) {
-				ConfigPair * run = cfg->get_pair (cfg, block, "onLoad", "run");
-	      
-				if (run && (strcmp (run->value, "1") == 0)) {
-					ConfigPair * filename 
-						= cfg->get_pair (cfg, block, "linux", "filename");
-
-					if (!IS_NULL (filename) && !IS_NULLSTR (filename->value)) {
-						gboolean RelativePath 
-							= (filename->value[0] == '/') ? FALSE : TRUE;
-
-						this->open_extension (filename->value, RelativePath);
-					}
-				}
-				ii++;
-			}
-		}
-	}
-}
-
-int
-Application::run (void) {
-	if (proactor()->start() == false) {
-		g_critical ("Failed to start the proactor thread; exiting application.");
-		return -1;
-	}
-	
-	/* Start the GTK+ main loop; make sure it is surrounded in the 
-		thread calls. GTK+ "releases" the current lock after every loop
-		interation. This allows us to call gdk_threads_enter/leave inside
-		of another thread. */
-	gdk_threads_enter ();
-	gtk_main();
-	gdk_threads_leave ();
-	return 0;
-}
diff --git a/src/Application.cpp b/src/Application.cpp
new file mode 100755
index 0000000..2f1251a
--- /dev/null
+++ b/src/Application.cpp
@@ -0,0 +1,345 @@
+#include "Application.hpp"
+#include "Plugin.hpp"
+#include <cstring>
+
+/* @description: This method takes the argument and clears the string of
+   everything except for the directories. Therefore the return value would
+   be a string sans anything before the last directory delimiter '/'. */
+static gchar *
+munchpath (gchar * path_) {
+	gchar * path = g_strdup(path_);
+	path = g_strreverse (path);
+	gchar * p = path;
+
+	while (p && (*p != '\0')) { if (*p == '/') break; p++; }
+
+	gchar * str = g_strdup (p);
+	str = g_strreverse (str);
+	FREE (path);
+	return str;
+}
+
+static guint
+signal_gtknotebook_removed (GtkNotebook * notebook,
+									 GtkNotebookPage * page,
+									 gint page_num,
+									 Workbook * wb) {
+	ASSERT (wb != NULL);
+	return TRUE;
+}
+
+static guint
+signal_gtknotebook_reordered (GtkNotebook * notebook,
+										GtkNotebookPage * page,
+										gint page_num,
+										Workbook * wb) {
+	ASSERT (wb != NULL);
+	return TRUE;
+}
+
+/* @description: This is the callback for the GtkNotebook 'switch-page' 
+   signal. It is called every single time a user *clicks* on different
+   tab. This method is called *before* the drawing takes place.
+
+   This method iterates through the Sheets and updates where neccesary.
+
+   @notebook: This is a pointer to the notebook object. The object is
+   equal to the Workbook->gtk_notebook pointer.
+   @page:
+   @page_num: The number of the *new* page.
+   @book: The Workbook object associated with the GtkNotebook.*/
+static guint
+signal_gtknotebook_switchpage (GtkNotebook * notebook,
+										 GtkNotebookPage * page,
+										 gint page_num,
+										 Workbook * book) {
+	ASSERT (book != NULL);
+
+	/* Perform the "unfocus" on the old notebook tab. */
+	if (!IS_NULL (book->focus_sheet)) {
+      book->focus_sheet->has_focus = FALSE;
+      book->focus_sheet->notices = 0;
+	}
+
+	GtkWidget * widget = gtk_notebook_get_nth_page (notebook, page_num);
+
+	ITERATE_BEGIN (Sheet, book->sheet_first);
+	{
+		/* Once we find the right Sheet object we can perform what we need
+			to in order to change the "focus." Finally, set book pointer. */
+		if (it->gtk_box == widget)
+      {
+			it->page = page_num;
+			it->has_focus = TRUE;
+			it->notices = 0;
+	
+			/* Reset the label on the notebook tab to the object's name. */
+			gtk_notebook_set_tab_label_text (notebook,
+														it->gtk_box,
+														it->name);
+			book->focus_sheet = it;
+			break;
+      }
+	}
+	ITERATE_END ();
+	return TRUE;
+}
+
+static guint
+signal_gtksheet_changed (GtkWidget * gtksheet,
+								 gint row, gint column,
+								 Sheet * sheet) {
+	ASSERT (sheet != NULL);
+	ASSERT (sheet->workbook != NULL);
+
+	Workbook * wb = sheet->workbook;
+
+	if (sheet->notices > 0) {
+      gchar * label 
+			= g_strdup_printf ("%s (%d)", sheet->name, sheet->notices);
+      gtk_notebook_set_tab_label_text (GTK_NOTEBOOK (wb->gtk_notebook),
+													sheet->gtk_box,
+													label);
+      FREE (label);
+	}
+	return FALSE;
+}
+
+/* @description: This is the callback to GtkMain's "delete" event. This is
+   called when we attempt to close the application safely. 
+   @window: A pointer to the GtkWindow object.
+   @event: A pointer to the associated GdkEvent information.
+   @p: NULL */
+static guint
+signal_delete_event (GtkWindow * window, 
+											GdkEvent * event,
+											gpointer p) {
+	GtkWidget * dialog 
+		= gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
+										  GTK_MESSAGE_QUESTION,
+										  GTK_BUTTONS_YES_NO,
+										  "Are you sure that you want to quit?");
+	gtk_window_set_title (GTK_WINDOW (dialog), "Close Application");
+
+	gint result = gtk_dialog_run (GTK_DIALOG (dialog));
+  
+	gtk_widget_destroy (dialog);
+
+	return (result == GTK_RESPONSE_YES) ? FALSE : TRUE;
+}
+
+/* @description: This is the callback to the "destroy" signal that is
+   emitted from GtkMain. Any cleanup should be done here.
+   @window: A pointer to the GtkWindow object.
+   @data: NULL */
+static guint
+signal_destroy_event (GtkWidget *window, gpointer data)
+{
+	Application * app = (Application *)data;
+	app->shutdown();
+	return FALSE;
+}
+
+Application::Application (int argc, char *** argv) {
+	this->init (argc, argv);
+	this->cfg = NULL;
+	this->gtk_window = NULL;
+	this->gtk_menu = NULL;
+	this->gtk_window_vbox = NULL;
+	
+	/* Set up the signals. */
+	this->signals[NOTEBOOK_SWITCHED]
+		= (GSourceFunc)signal_gtknotebook_switchpage;
+	this->signals[NOTEBOOK_REORDERED]
+		= (GSourceFunc)signal_gtknotebook_reordered;
+	this->signals[NOTEBOOK_REMOVED]
+		= (GSourceFunc)signal_gtknotebook_removed;
+	this->signals[DESTROY_EVENT]
+		= (GSourceFunc)signal_destroy_event;
+	this->signals[DELETE_EVENT]
+		= (GSourceFunc)signal_delete_event;
+	this->signals[SHEET_CHANGED]
+		= (GSourceFunc)signal_gtksheet_changed;
+}
+
+Application::~Application (void) {
+	WorkbookList::iterator it = this->workbooks.begin();
+	while (it != this->workbooks.end()) {
+		(*it)->destroy ( (*it) ); (*it) = NULL;
+		it++;
+	}
+	
+	FREE (this->absolute_path);
+
+	this->shutdown();
+}
+
+Plugin *
+Application::load_plugin (const std::string filename) {
+	Plugin * plugin = Plugin::open_plugin (this, filename);
+
+	if (plugin) {
+		this->plugins.push_back (plugin);
+	}
+	return plugin;
+}
+
+void
+Application::shutdown(void) {
+	// STUB: shutdown the proactor threads here.
+	gtk_main_quit ();
+}
+
+void
+Application::open_extension (const gchar * filename, gboolean absolute_path) {
+	gchar * fname = NULL;
+
+	if (absolute_path) {
+		fname = g_strconcat (this->absolute_path, filename, NULL);
+	}
+	else {
+		fname = g_strdup (filename);
+	}
+
+	Plugin * plugin = NULL;
+	if ((plugin = this->load_plugin (fname)) != NULL) {
+		if (plugin->workbook() == NULL) {
+			g_critical ("Plugin returned a NULL pointer instead of allocated"
+							" workbook.");
+			exit (1);
+		} else {
+			/* Attach all of the signals for the Workbook object. */
+			gtk_signal_connect (GTK_OBJECT (plugin->workbook()->gtk_notebook),
+									  "switch-page",
+									  (GtkSignalFunc)this->signals[NOTEBOOK_SWITCHED], 
+									  (gpointer)plugin->workbook());
+	  
+			this->workbooks.push_back (plugin->workbook());
+		}
+	}
+
+	FREE (fname);
+}
+
+void
+Application::init (int argc, char *** argv) {
+	int c;
+	
+	if (!g_thread_supported ()) {
+      g_thread_init (NULL);
+      gdk_threads_init ();
+	}
+
+	this->absolute_path = ::munchpath (*argv[0]);
+	
+	/* This block parses the commandline for options. A better example on how
+		this code works can be found on the GNU website at the following URI:
+		http://gnu.org/software/libtool/manual/libc/Using-Getopt.html */
+	while ((c = getopt (argc, *argv, "c:")) != -1) {
+      switch (c) {
+			case 'c': {
+				Config * cfg = config_new (optarg);
+				if (!cfg)
+				{
+					g_critical ("Failed loading configuration file '%s';" 
+									" which was specified with -c argument\n", optarg);
+					exit (0);
+					break;
+				}
+				this->cfg = cfg;
+			}
+			break;
+
+			case '?': {
+				if (optopt == 'c') {
+					g_warning ("Option -c requires an argument in order to load"
+								  " a configuration file\n");
+				}
+			}
+			break;
+		}
+	}
+
+	gdk_threads_enter ();
+	gtk_init (&argc, argv);
+
+	/* Create the window and connect two callback to the signals. */
+	this->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
+							  "destroy",
+							  G_CALLBACK (this->signals[DESTROY_EVENT]),
+							  (gpointer *)this);
+	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
+							  "delete_event",
+							  G_CALLBACK (this->signals[DELETE_EVENT]),
+							  NULL);
+  
+	/* Set the initial size of the application; we could load this
+		from a configuration file eventually. */
+	gtk_widget_set_usize (this->gtk_window, 1024, 768);
+  
+	/* Attach the window box to the window and present to the screen. */
+	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
+	gtk_container_add (GTK_CONTAINER (this->gtk_window), window_box);
+	this->gtk_window_vbox = window_box;
+  
+	gtk_widget_show_all (this->gtk_window);
+ 
+	gdk_threads_leave ();
+	
+	if (this->cfg) {
+		Config * cfg = this->cfg;
+      cfg->open (cfg);
+     
+      /* Load extensions */
+      ConfigRow * load = cfg->get_row (cfg, "application", "load");
+
+      /* Did a little bit of fixing here. We needed something to specify that
+			certain extensions will start automatically when the application is
+			started. */
+      if (!IS_NULL (load)) {
+			ConfigVector * ext = load->get_vector (load, "extensions");
+			gchar * block = NULL;
+			gint ii = 0;
+
+			if (IS_NULL (ext)) {
+				g_critical ("Config 'extensions' vector is NULL");
+				return;
+			}
+      
+			while ((block = ext->get(ext, ii)) != NULL) {
+				ConfigPair * run = cfg->get_pair (cfg, block, "onLoad", "run");
+	      
+				if (run && (strcmp (run->value, "1") == 0)) {
+					ConfigPair * filename 
+						= cfg->get_pair (cfg, block, "linux", "filename");
+
+					if (!IS_NULL (filename) && !IS_NULLSTR (filename->value)) {
+						gboolean RelativePath 
+							= (filename->value[0] == '/') ? FALSE : TRUE;
+
+						this->open_extension (filename->value, RelativePath);
+					}
+				}
+				ii++;
+			}
+		}
+	}
+}
+
+int
+Application::run (void) {
+	if (proactor()->start() == false) {
+		g_critical ("Failed to start the proactor thread; exiting application.");
+		return -1;
+	}
+	
+	/* Start the GTK+ main loop; make sure it is surrounded in the 
+		thread calls. GTK+ "releases" the current lock after every loop
+		interation. This allows us to call gdk_threads_enter/leave inside
+		of another thread. */
+	gdk_threads_enter ();
+	gtk_main();
+	gdk_threads_leave ();
+	return 0;
+}
diff --git a/src/Makefile b/src/Makefile
index cabb1d7..09d720f 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,8 +1,8 @@
 include ../Makefile.base
 
 INCS += -I${PROJDIR}/shared
-SRCS=$(wildcard *.cc) $(wildcard concurrent/*.cc) $(wildcard network/*.cc) $(wildcard proactor/*.cc) 
-OBJS=$(patsubst %.cc,${OBJDIR}/%.o,${SRCS})
+SRCS=$(wildcard *.cpp)
+OBJS=$(patsubst %.cpp,${OBJDIR}/%.o,${SRCS})
 
 LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0 -lgtkworkbookshared
 
@@ -11,7 +11,7 @@ all: 	gtkworkbook
 	make -C largefile/ all
 
 gtkworkbook: ${OBJS}
-	${CX} -rdynamic -fPIC -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
+	${CX} -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
 
 clean:		
 	${MD} ${OBJDIR}	
@@ -25,8 +25,8 @@ install: all
 #	make -C realtime/ install
 	make -C largefile/ install
 
-${OBJDIR}/%.o: %.cc
-	${CX} -rdynamic -fPIC ${INCS} -c ${CXFLAGS} $< -o $@
+${OBJDIR}/%.o: %.cpp
+	${CX} ${INCS} -c ${CXFLAGS} $< -o $@
 
-.cc.o:
-	${CX} -rdynamic -fPIC ${INCS} -c ${CXFLAGS} $<
+.cpp.o:
+	${CX} ${INCS} -c ${CXFLAGS} $<
diff --git a/src/Plugin.cc b/src/Plugin.cc
deleted file mode 100644
index da021ac..0000000
--- a/src/Plugin.cc
+++ /dev/null
@@ -1,48 +0,0 @@
-#include "Plugin.hpp"
-
-Plugin::Plugin (Application * appstate, Handle * platform)
-	: appstate(appstate), platform(platform) {
-	this->wb = NULL;
-}
-
-Plugin::~Plugin (void) {
-	// If this comment is still here then this potentially really, really, bad idea turned
-	// out to actually work. There is probably a much better and safer way to do this.
-	LIBRARY_CLOSE (platform->handle);
-	delete platform;
-}
-
-Plugin *
-Plugin::open_plugin (Application * appstate, const std::string filename) {
-	typedef Plugin * (*Plugin_Main) (Application *, Handle *);
-      				
-	if (filename.length() == 0)
-		return NULL;
-
-	// Get a handle to the shared library we're attempting to open.
-	Handle * platform = new Handle;
-	if ((platform->handle = LIBRARY_OPEN (filename.c_str())) == NULL) {
-		fprintf (stderr, "%s\n", LIBRARY_ERROR());
-		exit(1);
-	}
-
-	// Grab the main method from the plugin so we can execute to get an object back.
-	Plugin_Main plugin_main;
-	if ((plugin_main = (Plugin_Main)LIBRARY_SYM(platform->handle, "plugin_main")) == NULL) {
-		fprintf (stderr, "%s\n", LIBRARY_ERROR());
-		exit(1);
-	}
-
-	// Execute the method, return an object, and basically go on our merry way.
-	return plugin_main (appstate, platform);
-}
-
-Workbook *
-Plugin::workbook(void) {
-	return this->wb;
-}
-
-Application *
-Plugin::app(void) {
-	return this->appstate;
-}
diff --git a/src/Plugin.cpp b/src/Plugin.cpp
new file mode 100755
index 0000000..da021ac
--- /dev/null
+++ b/src/Plugin.cpp
@@ -0,0 +1,48 @@
+#include "Plugin.hpp"
+
+Plugin::Plugin (Application * appstate, Handle * platform)
+	: appstate(appstate), platform(platform) {
+	this->wb = NULL;
+}
+
+Plugin::~Plugin (void) {
+	// If this comment is still here then this potentially really, really, bad idea turned
+	// out to actually work. There is probably a much better and safer way to do this.
+	LIBRARY_CLOSE (platform->handle);
+	delete platform;
+}
+
+Plugin *
+Plugin::open_plugin (Application * appstate, const std::string filename) {
+	typedef Plugin * (*Plugin_Main) (Application *, Handle *);
+      				
+	if (filename.length() == 0)
+		return NULL;
+
+	// Get a handle to the shared library we're attempting to open.
+	Handle * platform = new Handle;
+	if ((platform->handle = LIBRARY_OPEN (filename.c_str())) == NULL) {
+		fprintf (stderr, "%s\n", LIBRARY_ERROR());
+		exit(1);
+	}
+
+	// Grab the main method from the plugin so we can execute to get an object back.
+	Plugin_Main plugin_main;
+	if ((plugin_main = (Plugin_Main)LIBRARY_SYM(platform->handle, "plugin_main")) == NULL) {
+		fprintf (stderr, "%s\n", LIBRARY_ERROR());
+		exit(1);
+	}
+
+	// Execute the method, return an object, and basically go on our merry way.
+	return plugin_main (appstate, platform);
+}
+
+Workbook *
+Plugin::workbook(void) {
+	return this->wb;
+}
+
+Application *
+Plugin::app(void) {
+	return this->appstate;
+}
diff --git a/src/Plugin.hpp b/src/Plugin.hpp
old mode 100644
new mode 100755
diff --git a/src/config.cc b/src/config.cc
deleted file mode 100755
index 882ed2a..0000000
--- a/src/config.cc
+++ /dev/null
@@ -1,759 +0,0 @@
-/*
-  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <cstdlib>
-#include <cstring>
-#include "config.h"
-#include "parse.h"
-
-/* config.c (static) */
-
-static Config *config_object_init (const gchar *);
-static ConfigPair *configpair_object_init (ConfigRow *, 
-					   const gchar *,
-					   const gchar *);
-static ConfigRow *configrow_object_init (ConfigBlock *, const gchar *);
-static ConfigBlock *configblock_object_init (Config *, const gchar *);
-static ConfigVector *configvector_object_init (ConfigRow *,const gchar *);
-static void configrow_object_free (ConfigRow *);
-static void configblock_object_free (ConfigBlock *);
-static void configpair_object_free (ConfigPair *);
-static void config_object_free (Config *);
-static void configvector_object_free (ConfigVector *);
-static ConfigVector *config_method_get_vector (Config *,
-					       const gchar *,
-					       const gchar *,
-					       const gchar *);
-static ConfigPair *config_method_get_pair (Config *,
-					   const gchar *,
-					   const gchar *,
-					   const gchar *);
-static ConfigBlock *config_method_get_block (Config *, const gchar *);
-static ConfigPair *configblock_method_get_pair (ConfigBlock *, 
-						const gchar *,
-						const gchar *);
-static ConfigRow *config_method_get_row (Config *,
-					 const gchar *, 
-					 const gchar *);
-static ConfigRow *configblock_method_get_row (ConfigBlock *, const gchar *);
-static gchar *configrow_method_parse (ConfigRow *, gchar *);
-static void configrow_method_destroy (ConfigRow *);
-static ConfigPair *configrow_method_get_pair (ConfigRow *, const gchar *);
-static ConfigVector *configrow_method_get_vector (ConfigRow *, const gchar *);
-static void configpair_method_destroy (ConfigPair *);
-static void configblock_method_destroy (ConfigBlock *);
-static void configvector_method_destroy (ConfigVector *);
-static gint configvector_method_get_int (ConfigVector *, gint);
-static gchar *configvector_method_get (ConfigVector *, gint);
-static void configvector_method_add (ConfigVector *, const gchar *);
-static gchar *configblock_method_parse (ConfigBlock *, gchar *, FILE *);
-static void config_method_destroy (Config *);
-static gint config_method_open (Config *);
-static gint config_method_save (Config *, const gchar *);
-static gint config_method_load (Config *, FILE *);
-
-ConfigBlock *
-configblock_new (Config * c, const gchar * tag)
-{
-  /* No NULL tags. */
-  if (IS_NULLSTR (tag)) return NULL;
-  return configblock_object_init (c, tag);
-}
-
-static gchar *
-configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
-{
-  ASSERT (block != NULL);
-  ASSERT (p != NULL);
-
-  if (!fp || feof (fp)) return FALSE;
-
-  gchar buf[1024], word[1024];
-  gchar * q = NULL;
-  g_stpcpy (word, p);
-
-  /* This block of code makes sure that we indeed have an opening brace
-    to continue with parsing of the configuration file. */
-  do
-    {
-      p = word;
-      
-      if (EXPECT (p, q, '{'))
-	{
-	  g_stpcpy (buf, q + 1);
-	  break;
-	} 
-
-      if (*q == '\0')
-	continue;
-      return NULL;
-    } while (fgets (word, 1024, fp) != NULL);
-
-  /* Start actually parsing rows now. */
-  do 
-    {
-      p = buf;
-      do
-	{
-	  if (*p == '}')
-	    return p;
-	  else if (*p == '\n')
-	    {
-	      p++;
-	      continue;
-	    }
-	  else 
-	    {
-	      if ((q = parse (p, &word[0], 1024, ':')) != NULL)
-		{
-		  if (*(q+1) == ':')
-		    {
-		      ConfigRow * row 
-			= block->get_row (block, trim (&word[0]));
-		      
-		      if (row)
-			{
-			  fprintf (stderr, "**CONFIG**: row '%s' already"
-				   " defined in block '%s'; replacing\n",
-				   row->tag, block->tag);
-			  fflush (stderr);
-
-			  row->destroy (row);
-			}
-
-		      row = configrow_new (block, trim (&word[0]));
-		    
-		      if ((p = row->parse (row, q+2)) == NULL)
-			{
-			  fprintf (stderr, "Error parsing line: %s", buf);
-			  fflush (stderr);
-			  return NULL;
-			}
-		      break;
-		    }
-		}
-	    }
-	  fprintf (stderr, "Error in formatting on line: %s\n", buf);
-	  fflush (stderr);
-	  return NULL;
-	} while (*p != '\0');
-     } while (fgets (buf, 1024, fp) != NULL);
-  return NULL;
-}
-
-static void
-configblock_method_destroy (ConfigBlock * block)
-{
-  ASSERT (block != NULL);
-
-  DESTROY (ConfigRow, block->row_head);
-  SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
-		 block->cfg->block_tail, block);
-  
-  configblock_object_free (block);
-}
-
-static ConfigRow *
-configblock_method_get_row (ConfigBlock * block, const gchar * row)
-{
-  ASSERT (block != NULL);
-
-  if (!IS_NULLSTR (row))
-    {
-      ITERATE_BEGIN (ConfigRow, block->row_head);
-      {
-	if (!strcmp (it->tag, row))
-	  return it;
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static ConfigPair *
-configblock_method_get_pair (ConfigBlock * block, 
-			     const gchar * row,
-			     const gchar * key)
-{
-  ASSERT (block != NULL);
-
-  if (!IS_NULLSTR (row))
-    {
-      ITERATE_BEGIN (ConfigRow, block->row_head);
-      {
-	if (!strcmp (it->tag, row))
-	  return it->get_pair (it, key);
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static void
-configblock_object_free (ConfigBlock * block)
-{
-  ASSERT (block != NULL);
-
-  FREE (block->tag);
-  
-  FREE (block);
-  block = NULL;
-}
-
-static ConfigBlock *
-configblock_object_init (Config * c, const gchar * tag)
-{
-  ASSERT (c != NULL);
-
-  ConfigBlock * b = NEW (ConfigBlock);
-
-  /* Members */
-  b->cfg = c;
-  b->tag = g_strdup (tag);
-  b->next = NULL; 
-  b->row_head = b->row_tail = NULL;
-  
-  /* Methods */
-  b->parse = configblock_method_parse;
-  b->destroy = configblock_method_destroy;
-  b->get_row = configblock_method_get_row;
-  b->get_pair = configblock_method_get_pair;
-
-  SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
-  return b;
-}
-
-Config *
-config_new (const gchar * filename)
-{
-  return config_object_init (filename);
-}
-
-static void
-config_method_destroy (Config * c)
-{
-  ASSERT (c != NULL);
-
-  DESTROY (ConfigBlock, c->block_head);
-  
-  config_object_free (c);
-}
-
-static ConfigRow *
-config_method_get_row (Config * cfg, const gchar * block, const gchar * row)
-{
-  ASSERT (cfg != NULL);
- 
-  ConfigBlock * b = cfg->get_block (cfg, block);
-  if (b == NULL)
-    return NULL;
-  return b->get_row (b, row);
-}
-
-static ConfigBlock *
-config_method_get_block (Config * cfg, const gchar * block)
-{
-  ASSERT (cfg != NULL);
-
-  if (!IS_NULLSTR (block))
-    {
-      ITERATE_BEGIN (ConfigBlock, cfg->block_head);
-      {
-	if (!strcmp (it->tag, block))
-	  return it;
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static ConfigPair *
-config_method_get_pair (Config * cfg, 
-			const gchar * block, 
-			const gchar * row,
-			const gchar * pair)
-{
-  ASSERT (cfg != NULL);
-
-  ConfigRow * r = cfg->get_row (cfg, block, row);
-  if (r == NULL)
-    return NULL;
-  return r->get_pair (r, pair);
-}
-
-static ConfigVector *
-config_method_get_vector (Config * cfg,
-			  const gchar * block,
-			  const gchar * row,
-			  const gchar * vector)
-{
-  ASSERT (cfg != NULL);
-  
-  ConfigRow * r = cfg->get_row (cfg, block, row);
-  if (r == NULL)
-    return NULL;
-  return r->get_vector (r, vector);
-}
-
-static void
-config_object_free (Config * c)
-{
-  ASSERT (c != NULL);
-
-  FREE (c->filename);
-
-  FREE (c);
-  c = NULL;
-}
-
-static Config *
-config_object_init (const gchar * filename)
-{
-  Config * c = NEW (Config);
-
-  /* Members */
-  c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
-  c->block_head = c->block_tail = NULL;
-
-  /* Methods */
-  c->open = config_method_open;
-  c->save = config_method_save;
-  c->load = config_method_load;
-  c->close = config_method_destroy;
-  c->get_vector = config_method_get_vector;
-  c->get_row = config_method_get_row;
-  c->get_block = config_method_get_block;
-  c->get_pair = config_method_get_pair;
-
-  return c;
-}
-
-static gint
-config_method_load (Config * c, FILE * fp)
-{
-  ASSERT (c != NULL);
-  
-  if (!fp || feof(fp))
-    {
-      /* STUB: log me? */
-      return FALSE;
-    }
-
-  gchar * buf = (gchar *)g_malloc (sizeof (char) * 1024);
-  gchar word[1024];
-  gchar * p = NULL, * q = NULL, * r = NULL;
-
-  while ((p = fgets (buf, 1024, fp)) != NULL) {
-      r = buf + (strlen (buf) - 1);
- 
-      while (p && (p < r) && (*p != '\n'))
-	{
-	  if (*p == '%')
-	    {
-	      if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
-		/* STUB: exit parsing with a failure. */
-		g_free (buf);	
-		return FALSE;
-	      }
-
-	      if (strcmp (word, "block") == 0)
-		{
-		  if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
-		    g_free(buf);
-		    return FALSE;
-		  }
-		  
-		  /* Replace the block if it already exists. Throw error. */
-		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
-		  if (b)
-		    {
-		      fprintf (stderr, "**CONFIG**: block '%s' already"
-			       "exists. Destroying and replacing.\n", b->tag);
-		      fflush (stderr);
-		      b->destroy (b);
-		    }
-
-		  b = configblock_new (c, trim (&word[0]));
-
-		  if ((p = b->parse (b, q, fp)) == NULL) {
-		    g_free (buf);
-		    return FALSE;
-		  }
-		}
-	      else if (strcmp (word, "include") == 0)
-		{
-		  if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
-		    g_free (buf);
-		    return FALSE;
-		  }
-
-		  /* Include the file; we're going to load up this file
-		     first and then proceed with parsing. */
-		  FILE * ifp = NULL;
-		 
-		  if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
-		    {
-		      fprintf (stderr, "**CONFIG**: include '%s' does not"
-			       " seem to exist or unable to read.\n",
-			       word);
-		      fflush (stderr);
-		      continue;
-		    }
-
-		  c->load (c, ifp);
-		}
-	      else {
-		g_free (buf);
-		return FALSE;
-	      }
-	    }
-	  /* BUGFIX: Need to check for tabs. */
-	  else if ((*p != ' ') && (*p != '\t'))
-	    {
-	      /* STUB: error out */
-	      g_free (buf);
-	      return FALSE;
-	    }
-
-	  p++;
-	}
-    }
-  g_free (buf);
-  return TRUE;
-}
-
-static gint
-config_method_save (Config * c, const gchar * filename)
-{
-  ASSERT (c != NULL);
-
-  if (IS_NULLSTR (filename)) return FALSE;
-
-  FILE * fp = NULL;
-  if ((fp = fopen (filename, "w")) == NULL)
-    {
-      /* STUB: log me? */
-      return FALSE;
-    }
-  
-  FCLOSE (fp);
-  return TRUE;
-}
-
-static gint
-config_method_open (Config * c)
-{
-  ASSERT (c != NULL);
-
-  if (IS_NULLSTR (c->filename))
-    return FALSE;
-
-  FILE * fp = NULL;
-  if ((fp = fopen (c->filename, "r")) == NULL)
-    {
-      /* STUB: log this? */
-      return FALSE;
-    }
-
-  gint result = c->load (c, fp);
-  if (result == FALSE)
-    {
-      /* STUB: log me? */
-    }
-
-  FCLOSE (fp);
-  return result;
-}
-
-ConfigPair *
-configpair_new (ConfigRow * row, const gchar * key, const gchar * value)
-{
-  return configpair_object_init (row, key, value);
-}
-
-static ConfigPair *
-configpair_object_init (ConfigRow * row, 
-			const gchar * key,
-			const gchar * value)
-{
-  ASSERT (row != NULL);
-  ASSERT (!IS_NULLSTR (key));
-  
-  ConfigPair * pair = NEW (ConfigPair);
-
-  /* Members */
-  pair->row = row;
-  pair->key = g_strdup (key);
-  pair->next = NULL;
-  pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
- 
-  /* Methods */
-  pair->destroy = configpair_method_destroy;
-  
-  DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
-  return pair;
-}
-
-static void
-configpair_method_destroy (ConfigPair * pair)
-{
-  ASSERT (pair != NULL);
-
-  DOUBLE_UNLINK (pair);
-
-  configpair_object_free (pair);
-}
-
-static void
-configpair_object_free (ConfigPair * pair)
-{
-  ASSERT (pair != NULL);
-
-  FREE (pair->key);
-  FREE (pair->value);
-  FREE (pair);
-}
-
-ConfigRow *
-configrow_new (ConfigBlock * block, const gchar * tag)
-{
-  return configrow_object_init (block, tag);
-}
-
-static ConfigRow *
-configrow_object_init (ConfigBlock * block, const gchar * tag)
-{
-  if (IS_NULLSTR (tag)) return NULL;
-
-  ConfigRow * row = NEW (ConfigRow);
-  
-  /* Members */
-  row->block = block;
-  row->tag = g_strdup (tag);
-  row->next = NULL;
-  row->vector_head = row->vector_tail = NULL;
-  row->pair_head = row->pair_tail = NULL;
-
-  /* Methods */
-  row->parse = configrow_method_parse;
-  row->destroy = configrow_method_destroy;
-  row->get_pair = configrow_method_get_pair;
-  row->get_vector = configrow_method_get_vector;
-
-  SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
-  return row;
-}
-
-static void
-configrow_object_free (ConfigRow *row)
-{
-  ASSERT (row != NULL);
-  
-  FREE (row->tag);
-
-  DESTROY (ConfigPair, row->pair_head);
-  DESTROY (ConfigVector, row->vector_head);
-
-  FREE (row);
-}
-
-static ConfigPair *
-configrow_method_get_pair (ConfigRow * row, const gchar * key)
-{
-  ASSERT (row != NULL);
-
-  if (!IS_NULLSTR (key))
-    {
-      ITERATE_BEGIN (ConfigPair, row->pair_head);
-      {
-	if (!strcmp (it->key, key))
-	  return it;
-      }
-      ITERATE_END();
-    }
-  return NULL;
-}
-
-static ConfigVector *
-configrow_method_get_vector (ConfigRow * row, const gchar * key)
-{
-  ASSERT (row != NULL);
-
-  if (!IS_NULLSTR (key))
-    {
-      ConfigPair * pair = row->get_pair (row, key);
-      if (IS_NULL (pair))
-	return NULL;
-
-      /* If we have already parsed it there is no reason to do it 
-	 a second time. Check existing linked list and return the
-	 pointer if we have already allocated it. */
-      ITERATE_BEGIN (ConfigVector, row->vector_head);
-      {
-	if (!strcmp (it->tag, key))
-	  return it;
-      }
-      ITERATE_END();
-
-      ConfigVector * vec = configvector_new (row, pair->key);
-      gchar buf[1024];
-      gchar * p = parse (pair->value, &buf[0], 1024, ','); 
-      gchar * q = pair->value + strlen (pair->value);
-    
-      do
-	{
-	  vec->add (vec, trim (&buf[0]));
-	} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
-
-      return vec;
-    }
-  return NULL;
-}
-
-static gchar *
-configrow_method_parse (ConfigRow * row, gchar * p)
-{
-  ASSERT (row != NULL);
-  ASSERT (p != NULL);
-
-  gchar key[1024], value[1024];
-  gchar * q = NULL, * s = NULL;
-
-  do
-    {
-      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
-	{
-	  break;
-	}      
-
-      if ((s = parse (q+1, &value[0], 1024, ';')) != NULL)
-	{
-	  ConfigPair * pair = row->get_pair (row, trim (&key[0]));
-	  if (pair)
-	    {
-	      fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
-		       " row '%s' block '%s'; replacing\n",
-		       pair->key, pair->value, row->tag, row->block->tag);
-	      fflush (stderr);
-	      pair->destroy (pair);
-	    }
-
-	  pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
-	}
-      p = s + 1;
-    } while (*p != '\n' && *p != '}' && *p != '\0');
-  return p;
-}
-
-static void 
-configrow_method_destroy (ConfigRow * row)
-{
-   ASSERT (row != NULL);
-
-   SINGLE_UNLINK (ConfigRow, row->block->row_head, row->block->row_tail, row);
-
-  configrow_object_free (row);
-}
-
-ConfigVector *
-configvector_new (ConfigRow * row, const gchar * tag)
-{
-  ASSERT (row != NULL);
-
-  /* No NULL Tags. */
-  if (IS_NULLSTR (tag)) return NULL;
-  return configvector_object_init (row, tag);
-}
-
-static ConfigVector *
-configvector_object_init (ConfigRow * row, const gchar * tag)
-{
-  ASSERT (row != NULL);
-
-  ConfigVector * vec = NEW (ConfigVector);
-
-  /* Members */
-  vec->row = row;
-  vec->tag = g_strdup (tag);
-  vec->next = vec->prev = NULL;
-  vec->array = g_ptr_array_sized_new (7);
-
-  /* Methods */
-  vec->destroy = configvector_method_destroy;
-  vec->get_int = configvector_method_get_int;
-  vec->get = configvector_method_get;
-  vec->add = configvector_method_add;
-
-  DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
-  return vec;
-}
-
-static void 
-configvector_object_free (ConfigVector * vec)
-{
-  ASSERT (vec != NULL);
-
-  FREE (vec->tag);
-
-  if (vec->array != NULL)
-    g_ptr_array_free (vec->array, TRUE);
-
-  FREE (vec);
-}
-
-static void
-configvector_method_destroy (ConfigVector * vec)
-{
-  ASSERT (vec != NULL);
-
-  DOUBLE_UNLINK (vec);
-
-  configvector_object_free (vec);
-}
-
-static gchar *
-configvector_method_get (ConfigVector * vec, gint index)
-{
-  ASSERT (vec != NULL);
-
-  if (index >= vec->array->len) return NULL;
-
-  gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
-  return rvalue;
-}
-
-static gint
-configvector_method_get_int (ConfigVector * vec, gint index)
-{
-  ASSERT (vec != NULL);
-
-  if (index >= vec->array->len) return -1;
-
-  gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
-  return atoi (rvalue);
-}
-
-static void
-configvector_method_add (ConfigVector * vec, const gchar * value)
-{
-  ASSERT (vec != NULL);
-  ASSERT (value != NULL);
-
-  gchar * ptr = g_strdup (value);
-  g_ptr_array_add (vec->array, ptr);
-}
diff --git a/src/config.cpp b/src/config.cpp
new file mode 100755
index 0000000..882ed2a
--- /dev/null
+++ b/src/config.cpp
@@ -0,0 +1,759 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <cstdlib>
+#include <cstring>
+#include "config.h"
+#include "parse.h"
+
+/* config.c (static) */
+
+static Config *config_object_init (const gchar *);
+static ConfigPair *configpair_object_init (ConfigRow *, 
+					   const gchar *,
+					   const gchar *);
+static ConfigRow *configrow_object_init (ConfigBlock *, const gchar *);
+static ConfigBlock *configblock_object_init (Config *, const gchar *);
+static ConfigVector *configvector_object_init (ConfigRow *,const gchar *);
+static void configrow_object_free (ConfigRow *);
+static void configblock_object_free (ConfigBlock *);
+static void configpair_object_free (ConfigPair *);
+static void config_object_free (Config *);
+static void configvector_object_free (ConfigVector *);
+static ConfigVector *config_method_get_vector (Config *,
+					       const gchar *,
+					       const gchar *,
+					       const gchar *);
+static ConfigPair *config_method_get_pair (Config *,
+					   const gchar *,
+					   const gchar *,
+					   const gchar *);
+static ConfigBlock *config_method_get_block (Config *, const gchar *);
+static ConfigPair *configblock_method_get_pair (ConfigBlock *, 
+						const gchar *,
+						const gchar *);
+static ConfigRow *config_method_get_row (Config *,
+					 const gchar *, 
+					 const gchar *);
+static ConfigRow *configblock_method_get_row (ConfigBlock *, const gchar *);
+static gchar *configrow_method_parse (ConfigRow *, gchar *);
+static void configrow_method_destroy (ConfigRow *);
+static ConfigPair *configrow_method_get_pair (ConfigRow *, const gchar *);
+static ConfigVector *configrow_method_get_vector (ConfigRow *, const gchar *);
+static void configpair_method_destroy (ConfigPair *);
+static void configblock_method_destroy (ConfigBlock *);
+static void configvector_method_destroy (ConfigVector *);
+static gint configvector_method_get_int (ConfigVector *, gint);
+static gchar *configvector_method_get (ConfigVector *, gint);
+static void configvector_method_add (ConfigVector *, const gchar *);
+static gchar *configblock_method_parse (ConfigBlock *, gchar *, FILE *);
+static void config_method_destroy (Config *);
+static gint config_method_open (Config *);
+static gint config_method_save (Config *, const gchar *);
+static gint config_method_load (Config *, FILE *);
+
+ConfigBlock *
+configblock_new (Config * c, const gchar * tag)
+{
+  /* No NULL tags. */
+  if (IS_NULLSTR (tag)) return NULL;
+  return configblock_object_init (c, tag);
+}
+
+static gchar *
+configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
+{
+  ASSERT (block != NULL);
+  ASSERT (p != NULL);
+
+  if (!fp || feof (fp)) return FALSE;
+
+  gchar buf[1024], word[1024];
+  gchar * q = NULL;
+  g_stpcpy (word, p);
+
+  /* This block of code makes sure that we indeed have an opening brace
+    to continue with parsing of the configuration file. */
+  do
+    {
+      p = word;
+      
+      if (EXPECT (p, q, '{'))
+	{
+	  g_stpcpy (buf, q + 1);
+	  break;
+	} 
+
+      if (*q == '\0')
+	continue;
+      return NULL;
+    } while (fgets (word, 1024, fp) != NULL);
+
+  /* Start actually parsing rows now. */
+  do 
+    {
+      p = buf;
+      do
+	{
+	  if (*p == '}')
+	    return p;
+	  else if (*p == '\n')
+	    {
+	      p++;
+	      continue;
+	    }
+	  else 
+	    {
+	      if ((q = parse (p, &word[0], 1024, ':')) != NULL)
+		{
+		  if (*(q+1) == ':')
+		    {
+		      ConfigRow * row 
+			= block->get_row (block, trim (&word[0]));
+		      
+		      if (row)
+			{
+			  fprintf (stderr, "**CONFIG**: row '%s' already"
+				   " defined in block '%s'; replacing\n",
+				   row->tag, block->tag);
+			  fflush (stderr);
+
+			  row->destroy (row);
+			}
+
+		      row = configrow_new (block, trim (&word[0]));
+		    
+		      if ((p = row->parse (row, q+2)) == NULL)
+			{
+			  fprintf (stderr, "Error parsing line: %s", buf);
+			  fflush (stderr);
+			  return NULL;
+			}
+		      break;
+		    }
+		}
+	    }
+	  fprintf (stderr, "Error in formatting on line: %s\n", buf);
+	  fflush (stderr);
+	  return NULL;
+	} while (*p != '\0');
+     } while (fgets (buf, 1024, fp) != NULL);
+  return NULL;
+}
+
+static void
+configblock_method_destroy (ConfigBlock * block)
+{
+  ASSERT (block != NULL);
+
+  DESTROY (ConfigRow, block->row_head);
+  SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
+		 block->cfg->block_tail, block);
+  
+  configblock_object_free (block);
+}
+
+static ConfigRow *
+configblock_method_get_row (ConfigBlock * block, const gchar * row)
+{
+  ASSERT (block != NULL);
+
+  if (!IS_NULLSTR (row))
+    {
+      ITERATE_BEGIN (ConfigRow, block->row_head);
+      {
+	if (!strcmp (it->tag, row))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static ConfigPair *
+configblock_method_get_pair (ConfigBlock * block, 
+			     const gchar * row,
+			     const gchar * key)
+{
+  ASSERT (block != NULL);
+
+  if (!IS_NULLSTR (row))
+    {
+      ITERATE_BEGIN (ConfigRow, block->row_head);
+      {
+	if (!strcmp (it->tag, row))
+	  return it->get_pair (it, key);
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static void
+configblock_object_free (ConfigBlock * block)
+{
+  ASSERT (block != NULL);
+
+  FREE (block->tag);
+  
+  FREE (block);
+  block = NULL;
+}
+
+static ConfigBlock *
+configblock_object_init (Config * c, const gchar * tag)
+{
+  ASSERT (c != NULL);
+
+  ConfigBlock * b = NEW (ConfigBlock);
+
+  /* Members */
+  b->cfg = c;
+  b->tag = g_strdup (tag);
+  b->next = NULL; 
+  b->row_head = b->row_tail = NULL;
+  
+  /* Methods */
+  b->parse = configblock_method_parse;
+  b->destroy = configblock_method_destroy;
+  b->get_row = configblock_method_get_row;
+  b->get_pair = configblock_method_get_pair;
+
+  SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
+  return b;
+}
+
+Config *
+config_new (const gchar * filename)
+{
+  return config_object_init (filename);
+}
+
+static void
+config_method_destroy (Config * c)
+{
+  ASSERT (c != NULL);
+
+  DESTROY (ConfigBlock, c->block_head);
+  
+  config_object_free (c);
+}
+
+static ConfigRow *
+config_method_get_row (Config * cfg, const gchar * block, const gchar * row)
+{
+  ASSERT (cfg != NULL);
+ 
+  ConfigBlock * b = cfg->get_block (cfg, block);
+  if (b == NULL)
+    return NULL;
+  return b->get_row (b, row);
+}
+
+static ConfigBlock *
+config_method_get_block (Config * cfg, const gchar * block)
+{
+  ASSERT (cfg != NULL);
+
+  if (!IS_NULLSTR (block))
+    {
+      ITERATE_BEGIN (ConfigBlock, cfg->block_head);
+      {
+	if (!strcmp (it->tag, block))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static ConfigPair *
+config_method_get_pair (Config * cfg, 
+			const gchar * block, 
+			const gchar * row,
+			const gchar * pair)
+{
+  ASSERT (cfg != NULL);
+
+  ConfigRow * r = cfg->get_row (cfg, block, row);
+  if (r == NULL)
+    return NULL;
+  return r->get_pair (r, pair);
+}
+
+static ConfigVector *
+config_method_get_vector (Config * cfg,
+			  const gchar * block,
+			  const gchar * row,
+			  const gchar * vector)
+{
+  ASSERT (cfg != NULL);
+  
+  ConfigRow * r = cfg->get_row (cfg, block, row);
+  if (r == NULL)
+    return NULL;
+  return r->get_vector (r, vector);
+}
+
+static void
+config_object_free (Config * c)
+{
+  ASSERT (c != NULL);
+
+  FREE (c->filename);
+
+  FREE (c);
+  c = NULL;
+}
+
+static Config *
+config_object_init (const gchar * filename)
+{
+  Config * c = NEW (Config);
+
+  /* Members */
+  c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
+  c->block_head = c->block_tail = NULL;
+
+  /* Methods */
+  c->open = config_method_open;
+  c->save = config_method_save;
+  c->load = config_method_load;
+  c->close = config_method_destroy;
+  c->get_vector = config_method_get_vector;
+  c->get_row = config_method_get_row;
+  c->get_block = config_method_get_block;
+  c->get_pair = config_method_get_pair;
+
+  return c;
+}
+
+static gint
+config_method_load (Config * c, FILE * fp)
+{
+  ASSERT (c != NULL);
+  
+  if (!fp || feof(fp))
+    {
+      /* STUB: log me? */
+      return FALSE;
+    }
+
+  gchar * buf = (gchar *)g_malloc (sizeof (char) * 1024);
+  gchar word[1024];
+  gchar * p = NULL, * q = NULL, * r = NULL;
+
+  while ((p = fgets (buf, 1024, fp)) != NULL) {
+      r = buf + (strlen (buf) - 1);
+ 
+      while (p && (p < r) && (*p != '\n'))
+	{
+	  if (*p == '%')
+	    {
+	      if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
+		/* STUB: exit parsing with a failure. */
+		g_free (buf);	
+		return FALSE;
+	      }
+
+	      if (strcmp (word, "block") == 0)
+		{
+		  if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+		    g_free(buf);
+		    return FALSE;
+		  }
+		  
+		  /* Replace the block if it already exists. Throw error. */
+		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
+		  if (b)
+		    {
+		      fprintf (stderr, "**CONFIG**: block '%s' already"
+			       "exists. Destroying and replacing.\n", b->tag);
+		      fflush (stderr);
+		      b->destroy (b);
+		    }
+
+		  b = configblock_new (c, trim (&word[0]));
+
+		  if ((p = b->parse (b, q, fp)) == NULL) {
+		    g_free (buf);
+		    return FALSE;
+		  }
+		}
+	      else if (strcmp (word, "include") == 0)
+		{
+		  if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+		    g_free (buf);
+		    return FALSE;
+		  }
+
+		  /* Include the file; we're going to load up this file
+		     first and then proceed with parsing. */
+		  FILE * ifp = NULL;
+		 
+		  if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
+		    {
+		      fprintf (stderr, "**CONFIG**: include '%s' does not"
+			       " seem to exist or unable to read.\n",
+			       word);
+		      fflush (stderr);
+		      continue;
+		    }
+
+		  c->load (c, ifp);
+		}
+	      else {
+		g_free (buf);
+		return FALSE;
+	      }
+	    }
+	  /* BUGFIX: Need to check for tabs. */
+	  else if ((*p != ' ') && (*p != '\t'))
+	    {
+	      /* STUB: error out */
+	      g_free (buf);
+	      return FALSE;
+	    }
+
+	  p++;
+	}
+    }
+  g_free (buf);
+  return TRUE;
+}
+
+static gint
+config_method_save (Config * c, const gchar * filename)
+{
+  ASSERT (c != NULL);
+
+  if (IS_NULLSTR (filename)) return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (filename, "w")) == NULL)
+    {
+      /* STUB: log me? */
+      return FALSE;
+    }
+  
+  FCLOSE (fp);
+  return TRUE;
+}
+
+static gint
+config_method_open (Config * c)
+{
+  ASSERT (c != NULL);
+
+  if (IS_NULLSTR (c->filename))
+    return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (c->filename, "r")) == NULL)
+    {
+      /* STUB: log this? */
+      return FALSE;
+    }
+
+  gint result = c->load (c, fp);
+  if (result == FALSE)
+    {
+      /* STUB: log me? */
+    }
+
+  FCLOSE (fp);
+  return result;
+}
+
+ConfigPair *
+configpair_new (ConfigRow * row, const gchar * key, const gchar * value)
+{
+  return configpair_object_init (row, key, value);
+}
+
+static ConfigPair *
+configpair_object_init (ConfigRow * row, 
+			const gchar * key,
+			const gchar * value)
+{
+  ASSERT (row != NULL);
+  ASSERT (!IS_NULLSTR (key));
+  
+  ConfigPair * pair = NEW (ConfigPair);
+
+  /* Members */
+  pair->row = row;
+  pair->key = g_strdup (key);
+  pair->next = NULL;
+  pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
+ 
+  /* Methods */
+  pair->destroy = configpair_method_destroy;
+  
+  DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
+  return pair;
+}
+
+static void
+configpair_method_destroy (ConfigPair * pair)
+{
+  ASSERT (pair != NULL);
+
+  DOUBLE_UNLINK (pair);
+
+  configpair_object_free (pair);
+}
+
+static void
+configpair_object_free (ConfigPair * pair)
+{
+  ASSERT (pair != NULL);
+
+  FREE (pair->key);
+  FREE (pair->value);
+  FREE (pair);
+}
+
+ConfigRow *
+configrow_new (ConfigBlock * block, const gchar * tag)
+{
+  return configrow_object_init (block, tag);
+}
+
+static ConfigRow *
+configrow_object_init (ConfigBlock * block, const gchar * tag)
+{
+  if (IS_NULLSTR (tag)) return NULL;
+
+  ConfigRow * row = NEW (ConfigRow);
+  
+  /* Members */
+  row->block = block;
+  row->tag = g_strdup (tag);
+  row->next = NULL;
+  row->vector_head = row->vector_tail = NULL;
+  row->pair_head = row->pair_tail = NULL;
+
+  /* Methods */
+  row->parse = configrow_method_parse;
+  row->destroy = configrow_method_destroy;
+  row->get_pair = configrow_method_get_pair;
+  row->get_vector = configrow_method_get_vector;
+
+  SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
+  return row;
+}
+
+static void
+configrow_object_free (ConfigRow *row)
+{
+  ASSERT (row != NULL);
+  
+  FREE (row->tag);
+
+  DESTROY (ConfigPair, row->pair_head);
+  DESTROY (ConfigVector, row->vector_head);
+
+  FREE (row);
+}
+
+static ConfigPair *
+configrow_method_get_pair (ConfigRow * row, const gchar * key)
+{
+  ASSERT (row != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ITERATE_BEGIN (ConfigPair, row->pair_head);
+      {
+	if (!strcmp (it->key, key))
+	  return it;
+      }
+      ITERATE_END();
+    }
+  return NULL;
+}
+
+static ConfigVector *
+configrow_method_get_vector (ConfigRow * row, const gchar * key)
+{
+  ASSERT (row != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ConfigPair * pair = row->get_pair (row, key);
+      if (IS_NULL (pair))
+	return NULL;
+
+      /* If we have already parsed it there is no reason to do it 
+	 a second time. Check existing linked list and return the
+	 pointer if we have already allocated it. */
+      ITERATE_BEGIN (ConfigVector, row->vector_head);
+      {
+	if (!strcmp (it->tag, key))
+	  return it;
+      }
+      ITERATE_END();
+
+      ConfigVector * vec = configvector_new (row, pair->key);
+      gchar buf[1024];
+      gchar * p = parse (pair->value, &buf[0], 1024, ','); 
+      gchar * q = pair->value + strlen (pair->value);
+    
+      do
+	{
+	  vec->add (vec, trim (&buf[0]));
+	} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
+
+      return vec;
+    }
+  return NULL;
+}
+
+static gchar *
+configrow_method_parse (ConfigRow * row, gchar * p)
+{
+  ASSERT (row != NULL);
+  ASSERT (p != NULL);
+
+  gchar key[1024], value[1024];
+  gchar * q = NULL, * s = NULL;
+
+  do
+    {
+      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
+	{
+	  break;
+	}      
+
+      if ((s = parse (q+1, &value[0], 1024, ';')) != NULL)
+	{
+	  ConfigPair * pair = row->get_pair (row, trim (&key[0]));
+	  if (pair)
+	    {
+	      fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
+		       " row '%s' block '%s'; replacing\n",
+		       pair->key, pair->value, row->tag, row->block->tag);
+	      fflush (stderr);
+	      pair->destroy (pair);
+	    }
+
+	  pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
+	}
+      p = s + 1;
+    } while (*p != '\n' && *p != '}' && *p != '\0');
+  return p;
+}
+
+static void 
+configrow_method_destroy (ConfigRow * row)
+{
+   ASSERT (row != NULL);
+
+   SINGLE_UNLINK (ConfigRow, row->block->row_head, row->block->row_tail, row);
+
+  configrow_object_free (row);
+}
+
+ConfigVector *
+configvector_new (ConfigRow * row, const gchar * tag)
+{
+  ASSERT (row != NULL);
+
+  /* No NULL Tags. */
+  if (IS_NULLSTR (tag)) return NULL;
+  return configvector_object_init (row, tag);
+}
+
+static ConfigVector *
+configvector_object_init (ConfigRow * row, const gchar * tag)
+{
+  ASSERT (row != NULL);
+
+  ConfigVector * vec = NEW (ConfigVector);
+
+  /* Members */
+  vec->row = row;
+  vec->tag = g_strdup (tag);
+  vec->next = vec->prev = NULL;
+  vec->array = g_ptr_array_sized_new (7);
+
+  /* Methods */
+  vec->destroy = configvector_method_destroy;
+  vec->get_int = configvector_method_get_int;
+  vec->get = configvector_method_get;
+  vec->add = configvector_method_add;
+
+  DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
+  return vec;
+}
+
+static void 
+configvector_object_free (ConfigVector * vec)
+{
+  ASSERT (vec != NULL);
+
+  FREE (vec->tag);
+
+  if (vec->array != NULL)
+    g_ptr_array_free (vec->array, TRUE);
+
+  FREE (vec);
+}
+
+static void
+configvector_method_destroy (ConfigVector * vec)
+{
+  ASSERT (vec != NULL);
+
+  DOUBLE_UNLINK (vec);
+
+  configvector_object_free (vec);
+}
+
+static gchar *
+configvector_method_get (ConfigVector * vec, gint index)
+{
+  ASSERT (vec != NULL);
+
+  if (index >= vec->array->len) return NULL;
+
+  gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
+  return rvalue;
+}
+
+static gint
+configvector_method_get_int (ConfigVector * vec, gint index)
+{
+  ASSERT (vec != NULL);
+
+  if (index >= vec->array->len) return -1;
+
+  gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
+  return atoi (rvalue);
+}
+
+static void
+configvector_method_add (ConfigVector * vec, const gchar * value)
+{
+  ASSERT (vec != NULL);
+  ASSERT (value != NULL);
+
+  gchar * ptr = g_strdup (value);
+  g_ptr_array_add (vec->array, ptr);
+}
diff --git a/src/main.cc b/src/main.cc
deleted file mode 100644
index 3dfd78d..0000000
--- a/src/main.cc
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "Application.hpp"
-
-int
-main (int argc, char ** argv) {
-	Application app (argc, &argv);
-	return app.run();
-}
diff --git a/src/main.cpp b/src/main.cpp
new file mode 100755
index 0000000..3dfd78d
--- /dev/null
+++ b/src/main.cpp
@@ -0,0 +1,7 @@
+#include "Application.hpp"
+
+int
+main (int argc, char ** argv) {
+	Application app (argc, &argv);
+	return app.run();
+}
diff --git a/src/parse.cc b/src/parse.cc
deleted file mode 100755
index b769a63..0000000
--- a/src/parse.cc
+++ /dev/null
@@ -1,76 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "parse.h"
-#include <cstring>
-#include <cstdlib>
-
-gchar *
-munch (gchar *p)
-{
-  ASSERT (p != NULL);
-  
-  /* Munch whitespace and ignore newlines, tabs. */
-  while (p && (*p == ' ' || *p == '\n' || *p == '\t')) { p++; } 
-  return p;
-}
-
-gchar *
-parse (gchar *p, gchar *word, gint n, const gchar delim)
-{
-  const gchar *q = p;
-  gint length = 0, ii = 0;
-
-  do 
-    {
-      if (*p == delim)
-	break;
-      p++;
-    } while (p && (*p != '\0') && (*p != '\n'));
-
-  length = (gint)(p - q);
-
-  if (n < length)    return NULL;
-
-  for (ii = 0; ii < length; ii++)
-    word[ii] = q[ii];
-  word[ii] = '\0';
-
-  return p;
-}
-
-gchar *
-trim (gchar *p)
-{
-  ASSERT (p != NULL);
-
-  gchar *q = NULL;
-
-  /* Eliminate tabs and spaces from beginning. */
-  while (p && (*p == ' ' || *p == '\t')) p++;
-
-  q = p;
-
-  /* Eliminate newlines, returns and whitespaces from end. */
-  while (*q != '\0') { q++; }
-  q--;
-  while (*q == ' ' || *q == '\n' || *q == '\r') { q--; }
-  *(q+1) = '\0';
-
-  return p;
-}
diff --git a/src/parse.cpp b/src/parse.cpp
new file mode 100755
index 0000000..b769a63
--- /dev/null
+++ b/src/parse.cpp
@@ -0,0 +1,76 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "parse.h"
+#include <cstring>
+#include <cstdlib>
+
+gchar *
+munch (gchar *p)
+{
+  ASSERT (p != NULL);
+  
+  /* Munch whitespace and ignore newlines, tabs. */
+  while (p && (*p == ' ' || *p == '\n' || *p == '\t')) { p++; } 
+  return p;
+}
+
+gchar *
+parse (gchar *p, gchar *word, gint n, const gchar delim)
+{
+  const gchar *q = p;
+  gint length = 0, ii = 0;
+
+  do 
+    {
+      if (*p == delim)
+	break;
+      p++;
+    } while (p && (*p != '\0') && (*p != '\n'));
+
+  length = (gint)(p - q);
+
+  if (n < length)    return NULL;
+
+  for (ii = 0; ii < length; ii++)
+    word[ii] = q[ii];
+  word[ii] = '\0';
+
+  return p;
+}
+
+gchar *
+trim (gchar *p)
+{
+  ASSERT (p != NULL);
+
+  gchar *q = NULL;
+
+  /* Eliminate tabs and spaces from beginning. */
+  while (p && (*p == ' ' || *p == '\t')) p++;
+
+  q = p;
+
+  /* Eliminate newlines, returns and whitespaces from end. */
+  while (*q != '\0') { q++; }
+  q--;
+  while (*q == ' ' || *q == '\n' || *q == '\r') { q--; }
+  *(q+1) = '\0';
+
+  return p;
+}

commit e26ae114f60e6f53580c089c92a749911a7d848f
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 23:18:54 2009 -0400

    Added shared library libgtkworkbookshared again.

diff --git a/Makefile b/Makefile
index d9ac1d1..7d0a457 100755
--- a/Makefile
+++ b/Makefile
@@ -2,20 +2,26 @@ MD=mkdir -p
 MAKE=-make -C
 PWD=`pwd`
 
-all:	libgtkworkbook gtkworkbook
+all:	libgtkworkbookshared libgtkworkbook gtkworkbook
 
 libgtkworkbook:
 	${MD} OBJS/libgtkworkbook
 	${MAKE} gtkworkbook/ all
 
+libgtkworkbook:
+	${MD} OBJS/libgtkworkbookshared
+	${MAKE} shared/ all
+
 gtkworkbook:
 	${MD} OBJS/realtime
 	$(MAKE) src/ all
 
 clean:
+	${MAKE} shared/ clean
 	${MAKE} gtkworkbook/ clean
 	$(MAKE) src/ clean
 
 install: all
+	${MAKE} shared/ install
 	${MAKE} gtkworkbook/ install
 	${MAKE} src/ install
diff --git a/shared/Makefile b/shared/Makefile
new file mode 100755
index 0000000..ac02869
--- /dev/null
+++ b/shared/Makefile
@@ -0,0 +1,26 @@
+include ../Makefile.base
+
+SRCS=$(wildcard *.cc) $(wildcard concurrent/*.cc) \
+$(wildcard network/*.cc) $(wildcard proactor/*.cc)
+OBJS=$(patsubst %.cc,${OBJDIR}/libgtkworkbookshared/%.o,${SRCS})
+
+all: 	gtkworkbookshared
+
+gtkworkbookshared: ${OBJS}
+	${CX} -shared -Wl -o ${PROJDIR}/lib/libgtkworkbookshared.so ${OBJS} ${LIBS} \
+	-lpthread
+	${CP} ${PROJDIR}/lib/libgtkworkbookshared.so ${PROJDIR}/lib/libgtkworkbookshared.so.1
+
+clean:		
+	${MD} ${OBJDIR}/libgtkworkbookshared/concurrent ${OBJDIR}/libgtkworkbookshared/network \
+	${OBJDIR}/libgtkworkbookshared/proactor
+	${RM} ${OBJS} ${PROJDIR}/lib/libgtkworkbookshared.so ${PROJDIR}/lib/libgtkworkbookshared.so.1
+
+install: all
+	${MD} ${INSEXTDIR}
+
+${OBJDIR}/libgtkworkbookshared/%.o: %.cc
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
+
+.cc.o:
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<
\ No newline at end of file
diff --git a/shared/concurrent/List.hpp b/shared/concurrent/List.hpp
new file mode 100755
index 0000000..130cb5d
--- /dev/null
+++ b/shared/concurrent/List.hpp
@@ -0,0 +1,33 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_LIST
+#define HPP_CONCURRENT_LIST
+
+#include <list>
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  template <typename T>
+  class List : public RecursiveMutex, public std::list<T> {
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/concurrent/Lockable.hpp b/shared/concurrent/Lockable.hpp
new file mode 100755
index 0000000..31fdc75
--- /dev/null
+++ b/shared/concurrent/Lockable.hpp
@@ -0,0 +1,31 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_LOCKABLE
+#define HPP_THREAD_LOCKABLE
+
+class ILockable {
+public:
+  virtual ~ILockable (void) { }
+
+  virtual void lock (void) = 0;
+  virtual void unlock (void) = 0;
+  virtual bool trylock (void) = 0;
+};
+
+#endif
diff --git a/shared/concurrent/Map.hpp b/shared/concurrent/Map.hpp
new file mode 100755
index 0000000..9f4b9ce
--- /dev/null
+++ b/shared/concurrent/Map.hpp
@@ -0,0 +1,42 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MAP
+#define HPP_THREAD_MAP
+
+#include <iterator>
+#include <map>
+#include "Mutex.hpp"
+
+namespace concurrent {
+ 
+  /* @description: This object uses the standard std::map and wraps all of
+     the calls that are exposed with a Mutex object. This object uses a
+     single lock and may cause performance issues if several threads are
+     attempting to use it. 
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template<typename K, typename V>
+  class Map : public RecursiveMutex, public std::map<K,V> {
+  private:
+  public:
+    Map (void) : RecursiveMutex() { }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/concurrent/Mutex.cc b/shared/concurrent/Mutex.cc
new file mode 100755
index 0000000..43ec628
--- /dev/null
+++ b/shared/concurrent/Mutex.cc
@@ -0,0 +1,89 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  IMutex::IMutex (void) {
+    this->mutex = NULL;
+    this->attrib = NULL;
+  }
+
+  IMutex::IMutex (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+  }
+
+  IMutex::~IMutex (void) {
+  }
+
+  IMutex & 
+  IMutex::operator= (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+    return *this;
+  }
+
+  void
+  IMutex::lock (void) {
+    pthread_mutex_lock (this->mutex);
+  }
+
+  void 
+  IMutex::unlock (void) {
+    pthread_mutex_unlock (this->mutex);
+  }
+
+  bool
+  IMutex::trylock (void) {
+    return (pthread_mutex_trylock (this->mutex) == 0) ?
+      true : false;
+  }
+  
+  RecursiveMutex::RecursiveMutex (void) {
+    this->mutex = new pthread_mutex_t;
+    this->attrib = new pthread_mutexattr_t;
+
+    pthread_mutexattr_init (this->attrib);
+    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+    
+    pthread_mutex_init (this->mutex, attrib);
+  }
+
+  RecursiveMutex::~RecursiveMutex (void) {
+    pthread_mutex_destroy (this->mutex);
+    pthread_mutexattr_destroy (this->attrib);
+
+    delete this->mutex;
+    delete this->attrib;
+  }
+
+  Mutex::Mutex (void) {
+    this->mutex = new pthread_mutex_t;
+
+    pthread_mutex_init (this->mutex, NULL);
+  }
+
+  Mutex::~Mutex (void) {
+    pthread_mutex_destroy (this->mutex);
+
+    delete this->mutex;
+  }
+
+} // end of namespace
diff --git a/shared/concurrent/Mutex.hpp b/shared/concurrent/Mutex.hpp
new file mode 100755
index 0000000..f4be8a9
--- /dev/null
+++ b/shared/concurrent/Mutex.hpp
@@ -0,0 +1,56 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MUTEX
+#define HPP_THREAD_MUTEX
+
+#include <pthread.h>
+#include "Lockable.hpp"
+
+namespace concurrent {
+
+  class IMutex : public ILockable {
+  protected:
+    pthread_mutex_t * mutex;
+    pthread_mutexattr_t * attrib;
+  public:
+    IMutex (void);
+    IMutex (const IMutex & m);
+    virtual ~IMutex (void);
+
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+
+    IMutex & operator= (const IMutex & m);
+  };
+
+  class Mutex : public IMutex {
+  public:
+    Mutex (void);
+    virtual ~Mutex (void);
+  };
+
+  class RecursiveMutex : public IMutex {
+  public:
+    RecursiveMutex (void);
+    virtual ~RecursiveMutex (void);
+  };
+}
+
+#endif
diff --git a/shared/concurrent/Queue.hpp b/shared/concurrent/Queue.hpp
new file mode 100755
index 0000000..092953b
--- /dev/null
+++ b/shared/concurrent/Queue.hpp
@@ -0,0 +1,97 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_QUEUE
+#define HPP_THREAD_QUEUE
+
+#include "Mutex.hpp"
+#include <queue>
+#include <algorithm>
+
+namespace concurrent {
+  
+  /* @description: This object wraps the existing std::queue container with
+     the custom Mutex object from the concurrent namespace. The single lock
+     may be placed in the future with a read/write lock in order to gain a
+     speed advantage.
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template <typename T>
+  class Queue : public RecursiveMutex {
+  private:
+    std::queue<T> the_queue;
+  public:
+    Queue (void) { }
+    virtual ~Queue (void) { }
+
+    inline void clear (void) {
+      this->lock();
+      while (this->the_queue.size() > 0)
+	this->the_queue.pop();
+      this->unlock();
+    }
+
+    inline void copy (std::queue<T> & Q) {
+      this->lock();
+      Q = this->the_queue;
+      this->unlock();
+    }
+
+    inline const T & back (void) {
+      this->lock();
+      T & elem = this->the_queue.back();
+      this->unlock();
+      return elem;
+    }
+
+    inline const T & front (void) {
+      this->lock();
+      T & elem = this->the_queue.front();
+      this->unlock();
+      return elem;
+    }
+
+    inline void push (const T & x) {
+      this->lock();
+      this->the_queue.push (x);
+      this->unlock();
+    }
+
+    inline T pop (void) {
+      this->lock();
+      T elem = this->the_queue.front();
+      this->the_queue.pop();
+      this->unlock();
+      return elem;
+    }
+    
+    inline size_t size (void) {
+      this->lock();
+      size_t size = this->the_queue.size();
+      this->unlock();
+      return size;
+    }
+
+    inline bool empty (void) {
+      this->lock();
+      bool result = this->the_queue.empty();
+      this->unlock();
+      return result;
+    }
+  };
+}
+#endif
diff --git a/shared/concurrent/Runnable.hpp b/shared/concurrent/Runnable.hpp
new file mode 100755
index 0000000..f2241b5
--- /dev/null
+++ b/shared/concurrent/Runnable.hpp
@@ -0,0 +1,34 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_RUNNABLE
+#define HPP_CONCURRENT_RUNNABLE
+
+class IRunnable {
+protected:
+  volatile bool running;
+public:
+  IRunnable (void) { this->running = false; }
+  virtual ~IRunnable (void) { }
+
+  virtual void * run (void *) = 0;
+  
+  inline bool isRunning (void) const { return this->running; }
+};
+
+#endif
diff --git a/shared/concurrent/ScopedMemoryLock.cc b/shared/concurrent/ScopedMemoryLock.cc
new file mode 100755
index 0000000..eb9b901
--- /dev/null
+++ b/shared/concurrent/ScopedMemoryLock.cc
@@ -0,0 +1,118 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ScopedMemoryLock.hpp"
+
+namespace concurrent {
+  ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
+
+  ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
+    this->hasLock = false;
+    this->address = address;
+    this->mutex = NULL;
+
+    ScopedMemoryLock::addressMutexMap.lock();
+    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+    ScopedMemoryLock::addressMutexMap.unlock();
+
+    /* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
+       if someone is passing an address that has not been formally added via the static method
+       call then that means it is very unlikely that they are not removing it either. We do
+       not want a memory leak therefore this seems like the best method. */
+    if (it != ScopedMemoryLock::addressMutexMap.end()) 
+      this->mutex = it->second;
+
+    if (engage == true)
+      this->lock();
+  }
+
+  ScopedMemoryLock::~ScopedMemoryLock (void) {
+    if (this->hasLock == true)
+      unlock();
+  }
+
+  void
+  ScopedMemoryLock::lock (void) {
+    this->mutex->lock();
+    this->hasLock = true;
+  }
+
+  void 
+  ScopedMemoryLock::unlock (void) {
+    this->mutex->unlock();
+    this->hasLock = false;
+  }
+
+  bool
+  ScopedMemoryLock::trylock (void) {
+    this->hasLock = this->mutex->trylock();
+    return this->hasLock;
+  }
+
+  bool
+  ScopedMemoryLock::remove (void) {
+    if (this->hasLock == false) {
+      return false;
+    }
+
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+    if (it != addressMutexMap.end()) {
+      delete it->second;
+      addressMutexMap.end();
+      result = true;
+    }
+    
+    addressMutexMap.unlock();
+    return result;
+  }
+
+  bool 
+  ScopedMemoryLock::addMemoryLock (unsigned long address) {
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
+    if (it == addressMutexMap.end()) {
+      addressMutexMap.insert (std::make_pair (address, new Mutex));
+      result = true;
+    }
+
+    addressMutexMap.unlock();
+    return result;
+  }
+
+  bool 
+  ScopedMemoryLock::removeMemoryLock (unsigned long address) {
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
+    if (it != addressMutexMap.end()) {
+      delete it->second;
+      addressMutexMap.erase(it);
+      result = true;
+    }
+
+    addressMutexMap.unlock();
+    return result;
+  }
+
+} // end of namespace
diff --git a/shared/concurrent/ScopedMemoryLock.hpp b/shared/concurrent/ScopedMemoryLock.hpp
new file mode 100755
index 0000000..eadab0b
--- /dev/null
+++ b/shared/concurrent/ScopedMemoryLock.hpp
@@ -0,0 +1,50 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_SCOPEDMEMORYLOCK
+#define HPP_CONCURRENT_SCOPEDMEMORYLOCK
+
+#include "Map.hpp"
+#include "Mutex.hpp"
+#include <string>
+
+namespace concurrent {
+
+  class ScopedMemoryLock : public ILockable {
+  private:
+    typedef Map<long int,Mutex *> AddressToMutexMap;
+    static AddressToMutexMap addressMutexMap;
+
+    bool hasLock;
+    unsigned long address;
+    Mutex * mutex;
+  public:
+    ScopedMemoryLock (unsigned long address, bool engage = false);
+    virtual ~ScopedMemoryLock (void);
+ 
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+    bool remove (void);
+
+    static bool addMemoryLock (unsigned long address);
+    static bool removeMemoryLock (unsigned long address);
+  };
+} // end of namespace
+
+#endif 
diff --git a/shared/concurrent/Semaphore.cc b/shared/concurrent/Semaphore.cc
new file mode 100755
index 0000000..4e5a58d
--- /dev/null
+++ b/shared/concurrent/Semaphore.cc
@@ -0,0 +1,42 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Semaphore.hpp"
+
+namespace concurrent {
+
+  Semaphore::Semaphore (void) {
+    sem_init (&this->semaphore, 0, 0);
+  }
+
+  Semaphore::~Semaphore (void) {
+    sem_destroy (&this->semaphore);
+  }
+
+  void
+  Semaphore::acquire (void) {
+    sem_wait (&this->semaphore);
+  }
+
+  void
+  Semaphore::release (void) {
+    sem_post (&this->semaphore);
+  }
+
+} // end of namespace
+
diff --git a/shared/concurrent/Semaphore.hpp b/shared/concurrent/Semaphore.hpp
new file mode 100755
index 0000000..3b9e0f4
--- /dev/null
+++ b/shared/concurrent/Semaphore.hpp
@@ -0,0 +1,39 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_SEMAPHORE
+#define HPP_THREAD_SEMAPHORE
+
+#include <semaphore.h>
+
+namespace concurrent {
+
+class Semaphore {
+private:
+  sem_t semaphore;
+public:
+  Semaphore (void);
+  virtual ~Semaphore (void);
+
+  void acquire (void);
+  void release (void);
+};
+
+}
+
+#endif
diff --git a/shared/concurrent/Thread.cc b/shared/concurrent/Thread.cc
new file mode 100755
index 0000000..5b7f143
--- /dev/null
+++ b/shared/concurrent/Thread.cc
@@ -0,0 +1,129 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Thread.hpp"
+#include "ThreadGroup.hpp"
+#include <iostream>
+#include <ctime>
+
+namespace concurrent {
+
+	static void *
+	thread_run (void * runner) {
+		void * rvalue = ((IRunnable *)runner)->run (NULL);
+		return rvalue;
+	}
+
+	Thread::Thread (ThreadGroup * group,
+						 IRunnable * runner, 
+						 const std::string & name) : thread(0) {
+		this->group = group;
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (IRunnable * runner,
+						 const std::string & name) 
+		: group(NULL), thread(0) {
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (const std::string & name) 
+		: group(NULL), runner(NULL), thread(0) {
+		this->name = name;
+	}
+
+	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
+	}
+
+	Thread::~Thread (void) {
+		if (this->running == true) {
+			this->running = false;
+			this->join();
+		}
+	}
+
+	void 
+	Thread::interrupt (void) {
+		this->running = false;
+		pthread_cancel (this->thread);
+		pthread_detach (this->thread);
+	}
+
+	void 
+	Thread::yield (void) {
+		pthread_yield();
+	}
+
+	void * 
+	Thread::stop (void) {
+		this->running = false;
+		return this->join();
+	}
+
+	int 
+	Thread::sleep (unsigned long ms) {
+		struct timespec req = {0};
+		time_t sec = (int)(ms/1000);
+		ms = ms - (sec*1000);
+		req.tv_sec = sec;
+		req.tv_nsec = ms*1000000L;
+		while (nanosleep (&req, &req) == -1)
+			continue;
+		return 1;
+	}
+
+	bool 
+	Thread::start (void) {
+		if (this->running == true)
+			return false;
+
+		if (this->runner != NULL) {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this->runner))
+				return false;
+		}
+		else {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this))
+				return false;
+		}
+
+		this->running = true;
+		return true;
+	}
+
+	void *
+	Thread::join (void) {
+		void * rvalue = NULL;
+		if (this->thread > 0)
+			pthread_join (this->thread, &rvalue);
+		return rvalue;
+	}
+
+	void *
+	Thread::run (void *null) {
+		pthread_exit (null);
+	}
+
+} // end of namespace
diff --git a/shared/concurrent/Thread.hpp b/shared/concurrent/Thread.hpp
new file mode 100755
index 0000000..79f2cf0
--- /dev/null
+++ b/shared/concurrent/Thread.hpp
@@ -0,0 +1,72 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREAD
+#define HPP_CONCURRENT_THREAD
+
+#include <shared.h>
+#include <string>
+#include <pthread.h>
+#include <map>
+#include "Runnable.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup;
+
+  class Thread : public IRunnable {
+  private:
+    friend class ThreadGroup;
+
+    ThreadGroup * group;
+    std::string name;
+    IRunnable * runner;
+    pthread_t thread;
+    bool joinable;
+    int priority;
+  public:
+    Thread (ThreadGroup * group, 
+	    IRunnable * runner, 
+	    const std::string & name);
+    Thread (IRunnable * runner,
+	    const std::string & name);
+    Thread (const std::string & name);
+    Thread (void);
+    virtual ~Thread (void);
+
+    bool start (void);
+    void * stop (void);
+    void * join (void);
+    void interrupt (void);
+    void yield (void);
+  
+    virtual void * run (void *);
+
+    inline const std::string & getName (void) const { return this->name; }
+    inline int getPriority (void) const { return this->priority; }
+    inline void setPriority (int priority) { this->priority = priority; }
+    inline const ThreadGroup * getThreadGroup (void) const { 
+      return this->group; 
+    }
+
+    static int sleep (unsigned long ms);
+  };  
+
+}
+
+#endif
diff --git a/shared/concurrent/ThreadArgs.hpp b/shared/concurrent/ThreadArgs.hpp
new file mode 100755
index 0000000..f44742c
--- /dev/null
+++ b/shared/concurrent/ThreadArgs.hpp
@@ -0,0 +1,8 @@
+#ifndef H_THREAD_THREADARGS
+#define H_THREAD_THREADARGS
+
+#include <vector>
+
+typedef std::vector<void *> ThreadArgs;
+
+#endif
diff --git a/shared/concurrent/ThreadGroup.cc b/shared/concurrent/ThreadGroup.cc
new file mode 100755
index 0000000..f50b487
--- /dev/null
+++ b/shared/concurrent/ThreadGroup.cc
@@ -0,0 +1,105 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadGroup.hpp"
+#include <algorithm>
+
+namespace concurrent {
+
+  ThreadGroup::ThreadGroup (void) 
+    : parent(NULL), daemon(false) {
+  }
+
+  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
+    : daemon(false) {
+    this->parent = parent;
+    this->name = name;
+  }
+
+  ThreadGroup::ThreadGroup (const std::string & name) 
+    : parent(NULL), daemon(false) {
+    this->name = name;
+  }
+
+  ThreadGroup::~ThreadGroup (void) {
+    if (this->daemon == true) {
+      this->stop();
+    }
+  }
+
+  bool 
+  ThreadGroup::parentOf (ThreadGroup * parent) {
+    if ((this->parent == NULL) || (parent == NULL))
+      return false;
+    // Needs to be better than this. 
+    return (this->parent == parent) ? true : false;
+  } 
+    
+  bool
+  ThreadGroup::addThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+    if (it == this->threads.end()) {
+      thread->group = this;
+      this->threads.push_back (thread);
+      return true;
+    }
+    return false;
+  }
+
+  bool 
+  ThreadGroup::removeThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+
+    if (it == this->threads.end())
+      return false;
+    this->threads.erase(it);
+    return true;
+  }
+
+  void
+  ThreadGroup::interrupt (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->interrupt();
+    }
+  }
+
+  bool
+  ThreadGroup::start (void) {
+    bool rvalue = false;
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      rvalue = (*it++)->start();
+    }
+
+    return rvalue;
+  }
+
+  void 
+  ThreadGroup::stop (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->stop();
+    }
+  }
+} // end of namesapce
diff --git a/shared/concurrent/ThreadGroup.hpp b/shared/concurrent/ThreadGroup.hpp
new file mode 100755
index 0000000..f907fd4
--- /dev/null
+++ b/shared/concurrent/ThreadGroup.hpp
@@ -0,0 +1,57 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREADGROUP
+#define HPP_CONCURRENT_THREADGROUP
+
+#include <string>
+#include "List.hpp"
+#include "Thread.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup {
+  private:
+    typedef concurrent::List<Thread *> ThreadList;
+    
+    ThreadGroup * parent;
+    std::string name;
+    ThreadList threads;
+    bool daemon; 
+  public:
+    ThreadGroup (void);
+    ThreadGroup (ThreadGroup * parent, const std::string & name);
+    ThreadGroup (const std::string & name);
+    virtual ~ThreadGroup (void);
+
+    bool parentOf (ThreadGroup * parent);
+    bool addThread (Thread * thread);
+    bool removeThread (Thread * thread);
+    void interrupt (void);
+    bool start (void);
+    void stop (void);
+    
+    inline bool isDaemon (void) const { return this->daemon; }
+    inline void setDaemon (bool daemon) { this->daemon = daemon; }
+    inline const std::string & getName (void) const { return this->name; }
+    inline ThreadGroup * getParent (void) const { return this->parent; }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/concurrent/ThreadPool.cc b/shared/concurrent/ThreadPool.cc
new file mode 100755
index 0000000..cd6890e
--- /dev/null
+++ b/shared/concurrent/ThreadPool.cc
@@ -0,0 +1,123 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadPool.hpp"
+
+namespace concurrent {
+  int ThreadPool::defaultTaskMax = 5;
+
+  ThreadPool::Task::Task (ThreadPool * pool) {
+    this->pool = pool;
+  }
+
+  void *
+  ThreadPool::Task::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+		 if (this->pool->isRunning() == false)
+			 break;
+      
+		 if (this->pool->getQueueSize() > 0) {
+			 IRunnable * runner = this->pool->removeFromQueue();
+			 runner->run (NULL);
+			 delete runner;
+		 }
+		 Thread::sleep (1);
+    }
+
+    return NULL;
+  }
+
+  ThreadPool::ThreadPool (void) {
+    this->running = false;
+
+    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::ThreadPool (int N) {
+    this->running = false;
+
+    for (int ii = 0; ii < N; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::~ThreadPool (void) {
+    if (this->running == true)
+      this->stop(true);
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      Thread * t = (*it); it++;
+      delete t;
+    }
+
+    while (this->runQueue.size() > 0) {
+      IRunnable * r = this->runQueue.pop();
+      delete r;
+    }
+  }
+
+  void 
+  ThreadPool::start (void) {
+    this->running = true;
+    
+	 ThreadList::iterator it = this->threads.begin();
+	 while (it != this->threads.end())
+    {
+		 (*it)->start();
+		 it++;
+    }
+  }
+
+  void 
+  ThreadPool::stop (bool join) {
+    this->running = false;
+
+    /* Waiting to join all of the threads will mean that the thread that the
+       pool is calling the stop() method from will block until all of the 
+       threads inside of the pool have stopped.
+
+       There is a PROBLEM here. If you call this, for some reason, from inside
+       of one of the Task threads then you are going to hit a deadlock. Never
+       pass the join parameter if this is being called from inside the Tasks.*/
+    if (join == true) {
+		 ThreadList::iterator it = this->threads.begin();
+		 while (it != this->threads.end()) {
+			 (*it)->stop();
+			 it++;
+		 }
+    }
+  }
+
+  void 
+  ThreadPool::execute (IRunnable * runner) {
+    this->runQueue.push (runner);
+  }
+
+} // end of namespace
+
diff --git a/shared/concurrent/ThreadPool.hpp b/shared/concurrent/ThreadPool.hpp
new file mode 100755
index 0000000..1999f0e
--- /dev/null
+++ b/shared/concurrent/ThreadPool.hpp
@@ -0,0 +1,72 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_THREADPOOL
+#define HPP_THREAD_THREADPOOL
+
+#include "Mutex.hpp"
+#include "Thread.hpp"
+#include "Queue.hpp"
+#include <queue>
+#include <list>
+
+namespace concurrent {
+
+  /* @description: This is a ThreadPool object that will keep N concurrent
+     threads running. Runnable objects can be attached to this object and they
+     will be executed immediately as a thread becomes available to run them. 
+     @author: John `jb Bellone (jvb4@njit.edu)
+     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
+  class ThreadPool {
+  private:
+    typedef std::list<Thread *> ThreadList;
+    
+    class Task : public IRunnable {
+    private:
+      ThreadPool * pool;
+    public:
+      Task (ThreadPool * pool);
+      
+      void * run (void * null);
+    };
+    
+    concurrent::Queue<IRunnable *> runQueue;
+    ThreadList threads;
+    bool running;
+  public:
+    static int defaultTaskMax;
+
+    ThreadPool (void);
+    ThreadPool (int N);
+    ~ThreadPool (void);
+
+    /* Thread un-Safe Methods */
+    void start (void);
+    void stop (bool join = false);
+
+    /* Thread-Safe Methods */
+    void execute (IRunnable *);
+    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
+    inline bool isRunning (void) const { return this->running; }
+    inline int getMaxThreads (void) const { return this->threads.size(); }
+    inline size_t getQueueSize (void) { return this->runQueue.size(); }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/network/Socket.hpp b/shared/network/Socket.hpp
new file mode 100755
index 0000000..5a87a3d
--- /dev/null
+++ b/shared/network/Socket.hpp
@@ -0,0 +1,39 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK_SOCKET
+#define HPP_NETWORK_SOCKET
+
+#include <cstring>
+
+namespace network {
+
+  class ISocket {
+  protected:
+    int sockfd;
+  public:
+    virtual ~ISocket (void) { }
+
+    virtual void close (void) = 0;
+    virtual int send (const char * bytes, size_t length) = 0;
+    virtual int receive (char * btyes, size_t size) = 0;
+  };
+
+} // end of namesapce
+
+#endif
diff --git a/shared/network/Tcp.cc b/shared/network/Tcp.cc
new file mode 100755
index 0000000..b9a0572
--- /dev/null
+++ b/shared/network/Tcp.cc
@@ -0,0 +1,153 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Tcp.hpp"
+#include <iostream>
+
+namespace network {
+
+	TcpSocket::TcpSocket (void) {
+		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	}
+
+	TcpSocket::~TcpSocket (void) {
+		this->close();
+	}
+
+	void
+	TcpSocket::close (void) {
+		if (this->sockfd > 0)
+			::close (this->sockfd);
+	}
+	
+	int
+	TcpSocket::send (const char * bytes, size_t length) {
+		return ::write (this->sockfd, bytes, length);
+	}
+
+	int
+	TcpSocket::receive (char * bytes, size_t size) {
+		return ::read (this->sockfd, bytes, size);
+	}
+
+	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
+		this->port = port;
+
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+		this->sockaddr.sin_port = htons (this->port);
+	}
+
+	TcpServerSocket::~TcpServerSocket (void) {
+		this->close();
+	}
+
+	bool
+	TcpServerSocket::start (int backlog = 5) {
+		int opt = 1;
+
+		// This is to prevent conflicts with major services' ports.
+		if (this->port < 1024)
+			return false;
+
+		if (::setsockopt (this->sockfd, 
+								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
+			return false;
+
+		if (::bind (this->sockfd,
+						(struct sockaddr *)&(this->sockaddr),
+						sizeof (this->sockaddr)) < 0)
+			return false;
+
+		if (::listen (this->sockfd, backlog) < 0)
+			return false;
+
+		return true;
+	}
+
+	void
+	TcpServerSocket::close (void) {
+		TcpSocket::close();
+	}
+
+	TcpServerSocket::Acceptor *
+	TcpServerSocket::newAcceptor (void) {
+		return new TcpServerSocket::Acceptor (this, this->sockfd);
+	}
+
+	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
+		this->socket = server;
+		this->sockfd = sockfd;
+	}
+
+	int
+	TcpServerSocket::Acceptor::acceptIncoming (void) {
+		int newfd = -1;
+		static struct sockaddr_in clientaddr;
+		unsigned int x = sizeof (clientaddr);
+
+		if ((newfd = ::accept (this->sockfd, 
+									  (struct sockaddr *)&clientaddr,
+									  &x)) < 0)
+			return -1;
+		return newfd;
+	}
+
+	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+	}
+
+	TcpClientSocket::TcpClientSocket (int newfd) {
+		this->sockfd = newfd;
+	}
+				
+	TcpClientSocket::~TcpClientSocket (void) {
+	}
+
+	bool
+	TcpClientSocket::connect (const char * host, int port) {
+		if (!host || (*host == '\0'))
+			return false;
+
+		if ((this->hp = ::gethostbyname (host)) == NULL)
+			return false;
+ 
+		// Copy over the hostname address.
+		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr 
+			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
+		this->sockaddr.sin_port = htons (port);
+
+		if (::connect (this->sockfd,
+							(struct sockaddr *)&(this->sockaddr),
+							sizeof (struct sockaddr)) < 0)
+			return false;
+    
+		return true;
+	}
+
+	void
+	TcpClientSocket::close (void) {
+		TcpSocket::close();
+	}
+
+} // end of namespace
diff --git a/shared/network/Tcp.hpp b/shared/network/Tcp.hpp
new file mode 100755
index 0000000..02ddc8a
--- /dev/null
+++ b/shared/network/Tcp.hpp
@@ -0,0 +1,80 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK_TCP
+#define HPP_NETWORK_TCP
+
+#include "Socket.hpp"
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <netdb.h>
+
+namespace network {
+
+  class TcpSocket : public ISocket {
+  protected:
+    struct sockaddr_in sockaddr;
+  public:
+    TcpSocket (void);
+    virtual ~TcpSocket (void);
+
+    void close (void);
+    int send (const char * bytes, size_t length);
+    int receive (char * bytes, size_t size);
+  };
+
+  class TcpServerSocket : public TcpSocket {
+  private:
+    int port;
+  public:
+    class Acceptor {
+    private:
+      TcpServerSocket * socket;
+      int sockfd;
+    public:
+      Acceptor (TcpServerSocket * server, int sockfd);
+
+      int acceptIncoming (void);
+    };
+
+    TcpServerSocket (int port);
+    virtual ~TcpServerSocket (void);
+    
+    bool start (int backlog);
+    void close (void);
+    Acceptor * newAcceptor (void);
+  };
+  
+  class TcpClientSocket : public TcpSocket {
+  private:
+    struct hostent * hp;
+  public:
+    TcpClientSocket (void);
+    TcpClientSocket (int newfd);
+    virtual ~TcpClientSocket (void);
+
+    bool connect (const char * host, int port);
+    void close (void);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/proactor/Dispatcher.cc b/shared/proactor/Dispatcher.cc
new file mode 100755
index 0000000..c7a9ded
--- /dev/null
+++ b/shared/proactor/Dispatcher.cc
@@ -0,0 +1,54 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Dispatcher.hpp"
+#include "Worker.hpp"
+#include <algorithm>
+
+namespace proactor {
+
+  Dispatcher::~Dispatcher (void) {
+      
+  }
+   
+	bool
+	Dispatcher::addWorker (Worker * w) {
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+		if (it == this->workers.end()) {
+			this->workers.push_back (w);
+			return w->start();
+      }
+		return false;
+	}
+  
+	bool
+	Dispatcher::removeWorker (Worker * w) {
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+
+		if (it == this->workers.end())
+			return false;
+  
+		this->workers.erase (it);
+		return true;
+	}
+
+} // end of namesapce
diff --git a/shared/proactor/Dispatcher.hpp b/shared/proactor/Dispatcher.hpp
new file mode 100755
index 0000000..124f03d
--- /dev/null
+++ b/shared/proactor/Dispatcher.hpp
@@ -0,0 +1,43 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_DISPATCHER
+#define HPP_PROACTOR_DISPATCHER
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/List.hpp"
+
+namespace proactor {
+
+  class Worker;
+
+  class Dispatcher : public concurrent::Thread {
+  protected:
+    typedef concurrent::List<Worker *> WorkerListType;
+
+    WorkerListType workers;
+  public:
+    virtual ~Dispatcher (void);
+
+    bool addWorker (Worker * w);
+    bool removeWorker (Worker * w);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/proactor/Event.cc b/shared/proactor/Event.cc
new file mode 100755
index 0000000..a1c5c2b
--- /dev/null
+++ b/shared/proactor/Event.cc
@@ -0,0 +1,38 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Event.hpp"
+
+namespace proactor {
+
+  int Event::numEvents = 0;
+
+  Event::Event (int e, const std::string & buf) {
+    this->id = e;
+    this->buf = buf;
+  }
+
+  int
+  Event::uniqueEventId (void) {
+    return Event::numEvents++;
+  }
+
+  EventDispatcher::~EventDispatcher (void) {
+  }
+ 
+} // end of namespace
diff --git a/shared/proactor/Event.hpp b/shared/proactor/Event.hpp
new file mode 100755
index 0000000..f5c9f7e
--- /dev/null
+++ b/shared/proactor/Event.hpp
@@ -0,0 +1,56 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_EVENT
+#define HPP_PROACTOR_EVENT
+
+#include "Dispatcher.hpp"
+#include <string>
+
+namespace proactor {
+
+  class Event {
+  private:
+    static int numEvents;
+  public:
+    int id;
+    std::string buf;
+
+    Event (int id, const std::string & buf);
+
+    static int uniqueEventId (void);
+  };
+
+  class EventDispatcher : public Dispatcher {
+  private:
+    int eventId;
+  public:
+    virtual ~EventDispatcher (void);
+
+    inline void setEventId (int e) { 
+      this->eventId = e;
+    }
+
+    inline int getEventId (void) { 
+      return this->eventId;
+    }
+  };
+
+}
+
+#endif
diff --git a/shared/proactor/InputDispatcher.cc b/shared/proactor/InputDispatcher.cc
new file mode 100755
index 0000000..a46febc
--- /dev/null
+++ b/shared/proactor/InputDispatcher.cc
@@ -0,0 +1,66 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "InputDispatcher.hpp"
+#include "Proactor.hpp"
+
+namespace proactor {
+
+  InputDispatcher::~InputDispatcher (void) {
+	  this->inputQueue.lock();
+	  while (this->inputQueue.size() > 0)
+		  this->inputQueue.pop();
+	  this->inputQueue.unlock();
+  }
+
+  void *
+  InputDispatcher::stop (void) {
+    WorkerListType::iterator it = this->workers.begin();
+    while (it != this->workers.end()) {
+      (*it)->stop();
+      it = this->workers.erase(it);
+    }
+    return Thread::stop();
+  }
+
+  void *
+  InputDispatcher::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+      // Dispatch all of the input items on the queue.
+      this->inputQueue.lock();
+
+      while (this->inputQueue.size() > 0) {
+
+	if (this->running == false)
+	  break;
+
+	// For right now all we're doing is pushing up the chain.
+	this->pro->onReadComplete ( this->inputQueue.pop() );
+      }
+
+      this->inputQueue.unlock();
+
+      Thread::sleep(100);
+    }
+  
+    return NULL; 
+  }
+
+} // end of namespace
diff --git a/shared/proactor/InputDispatcher.hpp b/shared/proactor/InputDispatcher.hpp
new file mode 100755
index 0000000..ee49202
--- /dev/null
+++ b/shared/proactor/InputDispatcher.hpp
@@ -0,0 +1,53 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_INPUTDISPATCHER
+#define HPP_PROACTOR_INPUTDISPATCHER
+
+#include "../concurrent/Queue.hpp"
+#include "Event.hpp"
+
+namespace proactor {
+
+  class Proactor;
+
+  class InputDispatcher : public EventDispatcher {
+  protected:
+    typedef concurrent::Queue<Event> InputQueueType;
+
+    Proactor * pro;
+    InputQueueType inputQueue;
+  public:
+    virtual ~InputDispatcher (void);
+
+    void * stop (void);
+    
+    inline void onReadComplete (const char * buf) {
+      this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
+    }
+
+    inline void onReadComplete (std::string buf) {
+      this->inputQueue.push ( Event (getEventId(), buf) );
+    }
+
+    void * run (void * null);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/proactor/Proactor.cc b/shared/proactor/Proactor.cc
new file mode 100755
index 0000000..2085c63
--- /dev/null
+++ b/shared/proactor/Proactor.cc
@@ -0,0 +1,159 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Proactor.hpp"
+#include <iostream>
+#include <algorithm>
+
+namespace proactor {
+
+  Proactor::Proactor (void) {
+  }
+
+  Proactor::~Proactor (void) {
+    // Remove all of the lists of event handlers.
+    {
+      EventMapType::iterator it = this->eventsToHandlers.begin();
+      while (it != this->eventsToHandlers.end()) {
+	  WorkerListType * q = (it->second);
+	  delete q;
+	  it++;
+	}
+    }
+ 
+    // Handle the dispatchers that have not been manually removed.
+    {
+      DispatcherList::iterator it = this->dispatchers.begin();
+      while (it != this->dispatchers.end())
+	{
+	  Dispatcher * d = (*it);
+	  delete d;
+	  it++;
+	}
+    }
+  
+  }
+
+  bool
+  Proactor::addWorker (int e, Worker * job) {
+    this->eventsToHandlers.lock();
+    {
+      EventMapType::iterator it = this->eventsToHandlers.find (e);
+  
+      if (it == this->eventsToHandlers.end())
+	this->eventsToHandlers[e] = new WorkerListType;  
+      this->eventsToHandlers[e]->push_back (job);
+    }
+    this->eventsToHandlers.unlock();
+
+    return job->start();
+  }
+
+  void
+  Proactor::onReadComplete (Event e) {
+    this->events.push (e);
+  }
+
+  void 
+  Proactor::onReadComplete (int e, const char * buf) {
+    this->events.push ( Event (e, std::string (buf)) );   
+  }
+
+  bool
+  Proactor::removeWorker (int e, Worker * job) {
+    bool result = false;
+
+    this->eventsToHandlers.lock();
+    {
+      WorkerListType::iterator it = 
+	std::find (this->eventsToHandlers[e]->begin(),
+		   this->eventsToHandlers[e]->end(),
+		   job);
+    
+      if (it != this->eventsToHandlers[e]->end())
+	{
+	  this->eventsToHandlers[e]->erase (it);
+	  result = true;
+	}
+    }
+    this->eventsToHandlers.unlock();
+   
+    return result;
+  }
+
+  void
+  Proactor::addDispatcher (Dispatcher * d) {
+    this->dispatchers.push_back (d);
+  }
+
+  bool
+  Proactor::removeDispatcher (Dispatcher * d) {
+    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
+					     this->dispatchers.end(),
+					     d);
+
+    if (it == this->dispatchers.end())
+      return false;
+  
+    this->dispatchers.erase (it);
+    return true;
+  }
+
+  void *
+  Proactor::run (void * null) {
+    this->running = true;
+  
+    WorkerListType::iterator it;
+
+    while (this->running == true) {
+	this->events.lock();
+
+	while (this->events.size() > 0) {
+
+	  if (this->running == false)
+	    break;
+
+	    Event e = this->events.pop();
+
+	    // We are throwing events with no handlers to catch them.
+	    if (this->eventsToHandlers.find (e.id) == 
+		this->eventsToHandlers.end())
+	      continue;
+ 
+	    it = this->eventsToHandlers[e.id]->begin();
+	  
+	    while (it != this->eventsToHandlers[e.id]->end()) {
+
+	      if (this->running == false)
+		break;
+
+		Worker * j = (*it);
+	      
+		j->pushInputQueue (e.buf);
+		      
+		it++;
+	      }
+	  }
+	this->events.unlock();
+      
+	Thread::sleep(100);
+      }
+    return NULL;
+  }
+
+} // end of namespace
diff --git a/shared/proactor/Proactor.hpp b/shared/proactor/Proactor.hpp
new file mode 100755
index 0000000..793647c
--- /dev/null
+++ b/shared/proactor/Proactor.hpp
@@ -0,0 +1,63 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_PROACTOR
+#define HPP_PROACTOR_PROACTOR
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/Map.hpp"
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/List.hpp"
+#include "Worker.hpp"
+#include "Event.hpp"
+#include "Dispatcher.hpp"
+#include "InputDispatcher.hpp"
+
+namespace proactor {
+
+  class Proactor : public Dispatcher {
+  private:
+    typedef concurrent::List<Dispatcher *> DispatcherList;
+    typedef concurrent::Map<int, WorkerListType *> EventMapType;
+    typedef concurrent::Queue<Event> EventQueueType;
+
+    EventMapType eventsToHandlers;
+    DispatcherList dispatchers;
+    EventQueueType events;
+  public:
+    Proactor (void);
+    virtual ~Proactor (void);
+
+    bool addWorker (int e, Worker * w);
+    bool removeWorker (int e, Worker * w);
+    void addDispatcher (Dispatcher * d);
+    bool removeDispatcher (Dispatcher * d);
+    
+    void * run (void * null);
+ 
+    void onReadComplete (Event e);
+    void onReadComplete (int e, const char * buf);
+
+    inline const std::string & peekInputQueue (void) {
+      return (this->events.front()).buf;
+    }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/proactor/Worker.cc b/shared/proactor/Worker.cc
new file mode 100755
index 0000000..be5863f
--- /dev/null
+++ b/shared/proactor/Worker.cc
@@ -0,0 +1,26 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Worker.hpp"
+
+namespace proactor {
+
+  Worker::~Worker (void) {
+  }
+
+} // end of namesapce
diff --git a/shared/proactor/Worker.hpp b/shared/proactor/Worker.hpp
new file mode 100755
index 0000000..481cae1
--- /dev/null
+++ b/shared/proactor/Worker.hpp
@@ -0,0 +1,46 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_WORKER
+#define HPP_PROACTOR_WORKER
+
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/Thread.hpp"
+#include <string>
+
+namespace proactor {
+
+  class InputDispatcher;
+
+  class Worker : public concurrent::Thread {
+  protected:
+    typedef concurrent::Queue<std::string> InputQueueType;
+
+    InputDispatcher * dispatcher;
+    InputQueueType inputQueue;
+  public:
+    virtual ~Worker (void);
+
+    inline void pushInputQueue (std::string buf) {
+      this->inputQueue.push (buf);
+    }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/Makefile b/src/Makefile
index d8b5449..cabb1d7 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,16 +1,17 @@
 include ../Makefile.base
 
+INCS += -I${PROJDIR}/shared
 SRCS=$(wildcard *.cc) $(wildcard concurrent/*.cc) $(wildcard network/*.cc) $(wildcard proactor/*.cc) 
 OBJS=$(patsubst %.cc,${OBJDIR}/%.o,${SRCS})
 
-LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0
+LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0 -lgtkworkbookshared
 
 all: 	gtkworkbook
 #	make -C realtime/ all
 	make -C largefile/ all
 
 gtkworkbook: ${OBJS}
-	${CX} -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
+	${CX} -rdynamic -fPIC -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
 
 clean:		
 	${MD} ${OBJDIR}	
@@ -25,7 +26,7 @@ install: all
 	make -C largefile/ install
 
 ${OBJDIR}/%.o: %.cc
-	${CX} ${INCS} -c ${CXFLAGS} $< -o $@
+	${CX} -rdynamic -fPIC ${INCS} -c ${CXFLAGS} $< -o $@
 
 .cc.o:
-	${CX} ${INCS} -c ${CXFLAGS} $<
+	${CX} -rdynamic -fPIC ${INCS} -c ${CXFLAGS} $<
diff --git a/src/concurrent/List.hpp b/src/concurrent/List.hpp
deleted file mode 100755
index 130cb5d..0000000
--- a/src/concurrent/List.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_LIST
-#define HPP_CONCURRENT_LIST
-
-#include <list>
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  template <typename T>
-  class List : public RecursiveMutex, public std::list<T> {
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/concurrent/Lockable.hpp b/src/concurrent/Lockable.hpp
deleted file mode 100755
index 31fdc75..0000000
--- a/src/concurrent/Lockable.hpp
+++ /dev/null
@@ -1,31 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_LOCKABLE
-#define HPP_THREAD_LOCKABLE
-
-class ILockable {
-public:
-  virtual ~ILockable (void) { }
-
-  virtual void lock (void) = 0;
-  virtual void unlock (void) = 0;
-  virtual bool trylock (void) = 0;
-};
-
-#endif
diff --git a/src/concurrent/Map.hpp b/src/concurrent/Map.hpp
deleted file mode 100755
index 9f4b9ce..0000000
--- a/src/concurrent/Map.hpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MAP
-#define HPP_THREAD_MAP
-
-#include <iterator>
-#include <map>
-#include "Mutex.hpp"
-
-namespace concurrent {
- 
-  /* @description: This object uses the standard std::map and wraps all of
-     the calls that are exposed with a Mutex object. This object uses a
-     single lock and may cause performance issues if several threads are
-     attempting to use it. 
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template<typename K, typename V>
-  class Map : public RecursiveMutex, public std::map<K,V> {
-  private:
-  public:
-    Map (void) : RecursiveMutex() { }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/concurrent/Mutex.cc b/src/concurrent/Mutex.cc
deleted file mode 100755
index 43ec628..0000000
--- a/src/concurrent/Mutex.cc
+++ /dev/null
@@ -1,89 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  IMutex::IMutex (void) {
-    this->mutex = NULL;
-    this->attrib = NULL;
-  }
-
-  IMutex::IMutex (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-  }
-
-  IMutex::~IMutex (void) {
-  }
-
-  IMutex & 
-  IMutex::operator= (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-    return *this;
-  }
-
-  void
-  IMutex::lock (void) {
-    pthread_mutex_lock (this->mutex);
-  }
-
-  void 
-  IMutex::unlock (void) {
-    pthread_mutex_unlock (this->mutex);
-  }
-
-  bool
-  IMutex::trylock (void) {
-    return (pthread_mutex_trylock (this->mutex) == 0) ?
-      true : false;
-  }
-  
-  RecursiveMutex::RecursiveMutex (void) {
-    this->mutex = new pthread_mutex_t;
-    this->attrib = new pthread_mutexattr_t;
-
-    pthread_mutexattr_init (this->attrib);
-    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
-    
-    pthread_mutex_init (this->mutex, attrib);
-  }
-
-  RecursiveMutex::~RecursiveMutex (void) {
-    pthread_mutex_destroy (this->mutex);
-    pthread_mutexattr_destroy (this->attrib);
-
-    delete this->mutex;
-    delete this->attrib;
-  }
-
-  Mutex::Mutex (void) {
-    this->mutex = new pthread_mutex_t;
-
-    pthread_mutex_init (this->mutex, NULL);
-  }
-
-  Mutex::~Mutex (void) {
-    pthread_mutex_destroy (this->mutex);
-
-    delete this->mutex;
-  }
-
-} // end of namespace
diff --git a/src/concurrent/Mutex.hpp b/src/concurrent/Mutex.hpp
deleted file mode 100755
index f4be8a9..0000000
--- a/src/concurrent/Mutex.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MUTEX
-#define HPP_THREAD_MUTEX
-
-#include <pthread.h>
-#include "Lockable.hpp"
-
-namespace concurrent {
-
-  class IMutex : public ILockable {
-  protected:
-    pthread_mutex_t * mutex;
-    pthread_mutexattr_t * attrib;
-  public:
-    IMutex (void);
-    IMutex (const IMutex & m);
-    virtual ~IMutex (void);
-
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-
-    IMutex & operator= (const IMutex & m);
-  };
-
-  class Mutex : public IMutex {
-  public:
-    Mutex (void);
-    virtual ~Mutex (void);
-  };
-
-  class RecursiveMutex : public IMutex {
-  public:
-    RecursiveMutex (void);
-    virtual ~RecursiveMutex (void);
-  };
-}
-
-#endif
diff --git a/src/concurrent/Queue.hpp b/src/concurrent/Queue.hpp
deleted file mode 100755
index 092953b..0000000
--- a/src/concurrent/Queue.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_QUEUE
-#define HPP_THREAD_QUEUE
-
-#include "Mutex.hpp"
-#include <queue>
-#include <algorithm>
-
-namespace concurrent {
-  
-  /* @description: This object wraps the existing std::queue container with
-     the custom Mutex object from the concurrent namespace. The single lock
-     may be placed in the future with a read/write lock in order to gain a
-     speed advantage.
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template <typename T>
-  class Queue : public RecursiveMutex {
-  private:
-    std::queue<T> the_queue;
-  public:
-    Queue (void) { }
-    virtual ~Queue (void) { }
-
-    inline void clear (void) {
-      this->lock();
-      while (this->the_queue.size() > 0)
-	this->the_queue.pop();
-      this->unlock();
-    }
-
-    inline void copy (std::queue<T> & Q) {
-      this->lock();
-      Q = this->the_queue;
-      this->unlock();
-    }
-
-    inline const T & back (void) {
-      this->lock();
-      T & elem = this->the_queue.back();
-      this->unlock();
-      return elem;
-    }
-
-    inline const T & front (void) {
-      this->lock();
-      T & elem = this->the_queue.front();
-      this->unlock();
-      return elem;
-    }
-
-    inline void push (const T & x) {
-      this->lock();
-      this->the_queue.push (x);
-      this->unlock();
-    }
-
-    inline T pop (void) {
-      this->lock();
-      T elem = this->the_queue.front();
-      this->the_queue.pop();
-      this->unlock();
-      return elem;
-    }
-    
-    inline size_t size (void) {
-      this->lock();
-      size_t size = this->the_queue.size();
-      this->unlock();
-      return size;
-    }
-
-    inline bool empty (void) {
-      this->lock();
-      bool result = this->the_queue.empty();
-      this->unlock();
-      return result;
-    }
-  };
-}
-#endif
diff --git a/src/concurrent/Runnable.hpp b/src/concurrent/Runnable.hpp
deleted file mode 100755
index f2241b5..0000000
--- a/src/concurrent/Runnable.hpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_RUNNABLE
-#define HPP_CONCURRENT_RUNNABLE
-
-class IRunnable {
-protected:
-  volatile bool running;
-public:
-  IRunnable (void) { this->running = false; }
-  virtual ~IRunnable (void) { }
-
-  virtual void * run (void *) = 0;
-  
-  inline bool isRunning (void) const { return this->running; }
-};
-
-#endif
diff --git a/src/concurrent/ScopedMemoryLock.cc b/src/concurrent/ScopedMemoryLock.cc
deleted file mode 100755
index eb9b901..0000000
--- a/src/concurrent/ScopedMemoryLock.cc
+++ /dev/null
@@ -1,118 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ScopedMemoryLock.hpp"
-
-namespace concurrent {
-  ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
-
-  ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
-    this->hasLock = false;
-    this->address = address;
-    this->mutex = NULL;
-
-    ScopedMemoryLock::addressMutexMap.lock();
-    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-    ScopedMemoryLock::addressMutexMap.unlock();
-
-    /* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
-       if someone is passing an address that has not been formally added via the static method
-       call then that means it is very unlikely that they are not removing it either. We do
-       not want a memory leak therefore this seems like the best method. */
-    if (it != ScopedMemoryLock::addressMutexMap.end()) 
-      this->mutex = it->second;
-
-    if (engage == true)
-      this->lock();
-  }
-
-  ScopedMemoryLock::~ScopedMemoryLock (void) {
-    if (this->hasLock == true)
-      unlock();
-  }
-
-  void
-  ScopedMemoryLock::lock (void) {
-    this->mutex->lock();
-    this->hasLock = true;
-  }
-
-  void 
-  ScopedMemoryLock::unlock (void) {
-    this->mutex->unlock();
-    this->hasLock = false;
-  }
-
-  bool
-  ScopedMemoryLock::trylock (void) {
-    this->hasLock = this->mutex->trylock();
-    return this->hasLock;
-  }
-
-  bool
-  ScopedMemoryLock::remove (void) {
-    if (this->hasLock == false) {
-      return false;
-    }
-
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-    if (it != addressMutexMap.end()) {
-      delete it->second;
-      addressMutexMap.end();
-      result = true;
-    }
-    
-    addressMutexMap.unlock();
-    return result;
-  }
-
-  bool 
-  ScopedMemoryLock::addMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it == addressMutexMap.end()) {
-      addressMutexMap.insert (std::make_pair (address, new Mutex));
-      result = true;
-    }
-
-    addressMutexMap.unlock();
-    return result;
-  }
-
-  bool 
-  ScopedMemoryLock::removeMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it != addressMutexMap.end()) {
-      delete it->second;
-      addressMutexMap.erase(it);
-      result = true;
-    }
-
-    addressMutexMap.unlock();
-    return result;
-  }
-
-} // end of namespace
diff --git a/src/concurrent/ScopedMemoryLock.hpp b/src/concurrent/ScopedMemoryLock.hpp
deleted file mode 100755
index eadab0b..0000000
--- a/src/concurrent/ScopedMemoryLock.hpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_SCOPEDMEMORYLOCK
-#define HPP_CONCURRENT_SCOPEDMEMORYLOCK
-
-#include "Map.hpp"
-#include "Mutex.hpp"
-#include <string>
-
-namespace concurrent {
-
-  class ScopedMemoryLock : public ILockable {
-  private:
-    typedef Map<long int,Mutex *> AddressToMutexMap;
-    static AddressToMutexMap addressMutexMap;
-
-    bool hasLock;
-    unsigned long address;
-    Mutex * mutex;
-  public:
-    ScopedMemoryLock (unsigned long address, bool engage = false);
-    virtual ~ScopedMemoryLock (void);
- 
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-    bool remove (void);
-
-    static bool addMemoryLock (unsigned long address);
-    static bool removeMemoryLock (unsigned long address);
-  };
-} // end of namespace
-
-#endif 
diff --git a/src/concurrent/Semaphore.cc b/src/concurrent/Semaphore.cc
deleted file mode 100755
index 4e5a58d..0000000
--- a/src/concurrent/Semaphore.cc
+++ /dev/null
@@ -1,42 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Semaphore.hpp"
-
-namespace concurrent {
-
-  Semaphore::Semaphore (void) {
-    sem_init (&this->semaphore, 0, 0);
-  }
-
-  Semaphore::~Semaphore (void) {
-    sem_destroy (&this->semaphore);
-  }
-
-  void
-  Semaphore::acquire (void) {
-    sem_wait (&this->semaphore);
-  }
-
-  void
-  Semaphore::release (void) {
-    sem_post (&this->semaphore);
-  }
-
-} // end of namespace
-
diff --git a/src/concurrent/Semaphore.hpp b/src/concurrent/Semaphore.hpp
deleted file mode 100755
index 3b9e0f4..0000000
--- a/src/concurrent/Semaphore.hpp
+++ /dev/null
@@ -1,39 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_SEMAPHORE
-#define HPP_THREAD_SEMAPHORE
-
-#include <semaphore.h>
-
-namespace concurrent {
-
-class Semaphore {
-private:
-  sem_t semaphore;
-public:
-  Semaphore (void);
-  virtual ~Semaphore (void);
-
-  void acquire (void);
-  void release (void);
-};
-
-}
-
-#endif
diff --git a/src/concurrent/Thread.cc b/src/concurrent/Thread.cc
deleted file mode 100755
index 5b7f143..0000000
--- a/src/concurrent/Thread.cc
+++ /dev/null
@@ -1,129 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Thread.hpp"
-#include "ThreadGroup.hpp"
-#include <iostream>
-#include <ctime>
-
-namespace concurrent {
-
-	static void *
-	thread_run (void * runner) {
-		void * rvalue = ((IRunnable *)runner)->run (NULL);
-		return rvalue;
-	}
-
-	Thread::Thread (ThreadGroup * group,
-						 IRunnable * runner, 
-						 const std::string & name) : thread(0) {
-		this->group = group;
-		this->runner = runner;
-		this->name = name;
-	}
-
-	Thread::Thread (IRunnable * runner,
-						 const std::string & name) 
-		: group(NULL), thread(0) {
-		this->runner = runner;
-		this->name = name;
-	}
-
-	Thread::Thread (const std::string & name) 
-		: group(NULL), runner(NULL), thread(0) {
-		this->name = name;
-	}
-
-	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
-	}
-
-	Thread::~Thread (void) {
-		if (this->running == true) {
-			this->running = false;
-			this->join();
-		}
-	}
-
-	void 
-	Thread::interrupt (void) {
-		this->running = false;
-		pthread_cancel (this->thread);
-		pthread_detach (this->thread);
-	}
-
-	void 
-	Thread::yield (void) {
-		pthread_yield();
-	}
-
-	void * 
-	Thread::stop (void) {
-		this->running = false;
-		return this->join();
-	}
-
-	int 
-	Thread::sleep (unsigned long ms) {
-		struct timespec req = {0};
-		time_t sec = (int)(ms/1000);
-		ms = ms - (sec*1000);
-		req.tv_sec = sec;
-		req.tv_nsec = ms*1000000L;
-		while (nanosleep (&req, &req) == -1)
-			continue;
-		return 1;
-	}
-
-	bool 
-	Thread::start (void) {
-		if (this->running == true)
-			return false;
-
-		if (this->runner != NULL) {
-			if (pthread_create (&this->thread,
-									  NULL,
-									  thread_run,
-									  this->runner))
-				return false;
-		}
-		else {
-			if (pthread_create (&this->thread,
-									  NULL,
-									  thread_run,
-									  this))
-				return false;
-		}
-
-		this->running = true;
-		return true;
-	}
-
-	void *
-	Thread::join (void) {
-		void * rvalue = NULL;
-		if (this->thread > 0)
-			pthread_join (this->thread, &rvalue);
-		return rvalue;
-	}
-
-	void *
-	Thread::run (void *null) {
-		pthread_exit (null);
-	}
-
-} // end of namespace
diff --git a/src/concurrent/Thread.hpp b/src/concurrent/Thread.hpp
deleted file mode 100755
index 79f2cf0..0000000
--- a/src/concurrent/Thread.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREAD
-#define HPP_CONCURRENT_THREAD
-
-#include <shared.h>
-#include <string>
-#include <pthread.h>
-#include <map>
-#include "Runnable.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup;
-
-  class Thread : public IRunnable {
-  private:
-    friend class ThreadGroup;
-
-    ThreadGroup * group;
-    std::string name;
-    IRunnable * runner;
-    pthread_t thread;
-    bool joinable;
-    int priority;
-  public:
-    Thread (ThreadGroup * group, 
-	    IRunnable * runner, 
-	    const std::string & name);
-    Thread (IRunnable * runner,
-	    const std::string & name);
-    Thread (const std::string & name);
-    Thread (void);
-    virtual ~Thread (void);
-
-    bool start (void);
-    void * stop (void);
-    void * join (void);
-    void interrupt (void);
-    void yield (void);
-  
-    virtual void * run (void *);
-
-    inline const std::string & getName (void) const { return this->name; }
-    inline int getPriority (void) const { return this->priority; }
-    inline void setPriority (int priority) { this->priority = priority; }
-    inline const ThreadGroup * getThreadGroup (void) const { 
-      return this->group; 
-    }
-
-    static int sleep (unsigned long ms);
-  };  
-
-}
-
-#endif
diff --git a/src/concurrent/ThreadArgs.hpp b/src/concurrent/ThreadArgs.hpp
deleted file mode 100755
index f44742c..0000000
--- a/src/concurrent/ThreadArgs.hpp
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef H_THREAD_THREADARGS
-#define H_THREAD_THREADARGS
-
-#include <vector>
-
-typedef std::vector<void *> ThreadArgs;
-
-#endif
diff --git a/src/concurrent/ThreadGroup.cc b/src/concurrent/ThreadGroup.cc
deleted file mode 100755
index f50b487..0000000
--- a/src/concurrent/ThreadGroup.cc
+++ /dev/null
@@ -1,105 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadGroup.hpp"
-#include <algorithm>
-
-namespace concurrent {
-
-  ThreadGroup::ThreadGroup (void) 
-    : parent(NULL), daemon(false) {
-  }
-
-  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
-    : daemon(false) {
-    this->parent = parent;
-    this->name = name;
-  }
-
-  ThreadGroup::ThreadGroup (const std::string & name) 
-    : parent(NULL), daemon(false) {
-    this->name = name;
-  }
-
-  ThreadGroup::~ThreadGroup (void) {
-    if (this->daemon == true) {
-      this->stop();
-    }
-  }
-
-  bool 
-  ThreadGroup::parentOf (ThreadGroup * parent) {
-    if ((this->parent == NULL) || (parent == NULL))
-      return false;
-    // Needs to be better than this. 
-    return (this->parent == parent) ? true : false;
-  } 
-    
-  bool
-  ThreadGroup::addThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-    if (it == this->threads.end()) {
-      thread->group = this;
-      this->threads.push_back (thread);
-      return true;
-    }
-    return false;
-  }
-
-  bool 
-  ThreadGroup::removeThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-
-    if (it == this->threads.end())
-      return false;
-    this->threads.erase(it);
-    return true;
-  }
-
-  void
-  ThreadGroup::interrupt (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->interrupt();
-    }
-  }
-
-  bool
-  ThreadGroup::start (void) {
-    bool rvalue = false;
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      rvalue = (*it++)->start();
-    }
-
-    return rvalue;
-  }
-
-  void 
-  ThreadGroup::stop (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->stop();
-    }
-  }
-} // end of namesapce
diff --git a/src/concurrent/ThreadGroup.hpp b/src/concurrent/ThreadGroup.hpp
deleted file mode 100755
index f907fd4..0000000
--- a/src/concurrent/ThreadGroup.hpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREADGROUP
-#define HPP_CONCURRENT_THREADGROUP
-
-#include <string>
-#include "List.hpp"
-#include "Thread.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup {
-  private:
-    typedef concurrent::List<Thread *> ThreadList;
-    
-    ThreadGroup * parent;
-    std::string name;
-    ThreadList threads;
-    bool daemon; 
-  public:
-    ThreadGroup (void);
-    ThreadGroup (ThreadGroup * parent, const std::string & name);
-    ThreadGroup (const std::string & name);
-    virtual ~ThreadGroup (void);
-
-    bool parentOf (ThreadGroup * parent);
-    bool addThread (Thread * thread);
-    bool removeThread (Thread * thread);
-    void interrupt (void);
-    bool start (void);
-    void stop (void);
-    
-    inline bool isDaemon (void) const { return this->daemon; }
-    inline void setDaemon (bool daemon) { this->daemon = daemon; }
-    inline const std::string & getName (void) const { return this->name; }
-    inline ThreadGroup * getParent (void) const { return this->parent; }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/concurrent/ThreadPool.cc b/src/concurrent/ThreadPool.cc
deleted file mode 100755
index cd6890e..0000000
--- a/src/concurrent/ThreadPool.cc
+++ /dev/null
@@ -1,123 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadPool.hpp"
-
-namespace concurrent {
-  int ThreadPool::defaultTaskMax = 5;
-
-  ThreadPool::Task::Task (ThreadPool * pool) {
-    this->pool = pool;
-  }
-
-  void *
-  ThreadPool::Task::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
-		 if (this->pool->isRunning() == false)
-			 break;
-      
-		 if (this->pool->getQueueSize() > 0) {
-			 IRunnable * runner = this->pool->removeFromQueue();
-			 runner->run (NULL);
-			 delete runner;
-		 }
-		 Thread::sleep (1);
-    }
-
-    return NULL;
-  }
-
-  ThreadPool::ThreadPool (void) {
-    this->running = false;
-
-    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::ThreadPool (int N) {
-    this->running = false;
-
-    for (int ii = 0; ii < N; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::~ThreadPool (void) {
-    if (this->running == true)
-      this->stop(true);
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      Thread * t = (*it); it++;
-      delete t;
-    }
-
-    while (this->runQueue.size() > 0) {
-      IRunnable * r = this->runQueue.pop();
-      delete r;
-    }
-  }
-
-  void 
-  ThreadPool::start (void) {
-    this->running = true;
-    
-	 ThreadList::iterator it = this->threads.begin();
-	 while (it != this->threads.end())
-    {
-		 (*it)->start();
-		 it++;
-    }
-  }
-
-  void 
-  ThreadPool::stop (bool join) {
-    this->running = false;
-
-    /* Waiting to join all of the threads will mean that the thread that the
-       pool is calling the stop() method from will block until all of the 
-       threads inside of the pool have stopped.
-
-       There is a PROBLEM here. If you call this, for some reason, from inside
-       of one of the Task threads then you are going to hit a deadlock. Never
-       pass the join parameter if this is being called from inside the Tasks.*/
-    if (join == true) {
-		 ThreadList::iterator it = this->threads.begin();
-		 while (it != this->threads.end()) {
-			 (*it)->stop();
-			 it++;
-		 }
-    }
-  }
-
-  void 
-  ThreadPool::execute (IRunnable * runner) {
-    this->runQueue.push (runner);
-  }
-
-} // end of namespace
-
diff --git a/src/concurrent/ThreadPool.hpp b/src/concurrent/ThreadPool.hpp
deleted file mode 100755
index 1999f0e..0000000
--- a/src/concurrent/ThreadPool.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_THREADPOOL
-#define HPP_THREAD_THREADPOOL
-
-#include "Mutex.hpp"
-#include "Thread.hpp"
-#include "Queue.hpp"
-#include <queue>
-#include <list>
-
-namespace concurrent {
-
-  /* @description: This is a ThreadPool object that will keep N concurrent
-     threads running. Runnable objects can be attached to this object and they
-     will be executed immediately as a thread becomes available to run them. 
-     @author: John `jb Bellone (jvb4@njit.edu)
-     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
-  class ThreadPool {
-  private:
-    typedef std::list<Thread *> ThreadList;
-    
-    class Task : public IRunnable {
-    private:
-      ThreadPool * pool;
-    public:
-      Task (ThreadPool * pool);
-      
-      void * run (void * null);
-    };
-    
-    concurrent::Queue<IRunnable *> runQueue;
-    ThreadList threads;
-    bool running;
-  public:
-    static int defaultTaskMax;
-
-    ThreadPool (void);
-    ThreadPool (int N);
-    ~ThreadPool (void);
-
-    /* Thread un-Safe Methods */
-    void start (void);
-    void stop (bool join = false);
-
-    /* Thread-Safe Methods */
-    void execute (IRunnable *);
-    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
-    inline bool isRunning (void) const { return this->running; }
-    inline int getMaxThreads (void) const { return this->threads.size(); }
-    inline size_t getQueueSize (void) { return this->runQueue.size(); }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
old mode 100644
new mode 100755
index ed0a84d..ce177e3
--- a/src/largefile/Largefile.cpp
+++ b/src/largefile/Largefile.cpp
@@ -19,7 +19,6 @@
 #include <gdk/gdkkeysyms.h>
 #include <gtkworkbook/workbook.h>
 #include <proactor/Proactor.hpp>
-#include <proactor/Worker.hpp>
 #include <proactor/Event.hpp>
 #include <vector>
 #include <fstream>
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
old mode 100644
new mode 100755
index 03060b6..fd056e2
--- a/src/largefile/Largefile.hpp
+++ b/src/largefile/Largefile.hpp
@@ -7,6 +7,8 @@
 #include "../Application.hpp"
 #include "../config.h"
 
+extern "C++" {
+
 class Largefile : public Plugin {
 private:
 	typedef std::map<std::string,int> FilenameMap;
@@ -21,4 +23,6 @@ public:
 	bool exit_file (const std::string & filename);
 };
 
+}
+	
 #endif
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index ad03e23..deeb782 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.base
 
-INCS += -I../
+INCS += -I${PROJDIR}/shared -I../
 SRCS=$(wildcard *.cpp) 
 OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
 
@@ -9,8 +9,8 @@ _CXFLAGS= -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
 all: 	largefile
 
 largefile: ${OBJS}
-	${CX} ${_CXFLAGS} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread -lcsv
+	${CX} ${_CXFLAGS} -rdynamic -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
+	-lgthread-2.0 -lpthread -lcsv -lgtkworkbookshared -lgtkworkbook
 
 clean:		
 	${MD} ${OBJDIR}/largefile
@@ -21,7 +21,7 @@ install: all
 	${CP} ${PROJDIR}/bin/largefile.so ${INSEXTDIR}/largefile.so
 
 ${OBJDIR}/largefile/%.o: %.cpp
-	${CX} ${_CXFLAGS} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
+	${CX} ${_CXFLAGS} ${INCS} -c -rdynamic -fPIC ${CXFLAGS} $< -o $@
 
 .cpp.o:
-	${CX} ${_CXFLAGS} ${INCS} -c -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
+	${CX} ${_CXFLAGS} ${INCS} -c -rdynamic -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
diff --git a/src/network/Socket.hpp b/src/network/Socket.hpp
deleted file mode 100755
index 5a87a3d..0000000
--- a/src/network/Socket.hpp
+++ /dev/null
@@ -1,39 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_NETWORK_SOCKET
-#define HPP_NETWORK_SOCKET
-
-#include <cstring>
-
-namespace network {
-
-  class ISocket {
-  protected:
-    int sockfd;
-  public:
-    virtual ~ISocket (void) { }
-
-    virtual void close (void) = 0;
-    virtual int send (const char * bytes, size_t length) = 0;
-    virtual int receive (char * btyes, size_t size) = 0;
-  };
-
-} // end of namesapce
-
-#endif
diff --git a/src/network/Tcp.cc b/src/network/Tcp.cc
deleted file mode 100755
index b9a0572..0000000
--- a/src/network/Tcp.cc
+++ /dev/null
@@ -1,153 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Tcp.hpp"
-#include <iostream>
-
-namespace network {
-
-	TcpSocket::TcpSocket (void) {
-		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
-	}
-
-	TcpSocket::~TcpSocket (void) {
-		this->close();
-	}
-
-	void
-	TcpSocket::close (void) {
-		if (this->sockfd > 0)
-			::close (this->sockfd);
-	}
-	
-	int
-	TcpSocket::send (const char * bytes, size_t length) {
-		return ::write (this->sockfd, bytes, length);
-	}
-
-	int
-	TcpSocket::receive (char * bytes, size_t size) {
-		return ::read (this->sockfd, bytes, size);
-	}
-
-	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
-		this->port = port;
-
-		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-		this->sockaddr.sin_port = htons (this->port);
-	}
-
-	TcpServerSocket::~TcpServerSocket (void) {
-		this->close();
-	}
-
-	bool
-	TcpServerSocket::start (int backlog = 5) {
-		int opt = 1;
-
-		// This is to prevent conflicts with major services' ports.
-		if (this->port < 1024)
-			return false;
-
-		if (::setsockopt (this->sockfd, 
-								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
-			return false;
-
-		if (::bind (this->sockfd,
-						(struct sockaddr *)&(this->sockaddr),
-						sizeof (this->sockaddr)) < 0)
-			return false;
-
-		if (::listen (this->sockfd, backlog) < 0)
-			return false;
-
-		return true;
-	}
-
-	void
-	TcpServerSocket::close (void) {
-		TcpSocket::close();
-	}
-
-	TcpServerSocket::Acceptor *
-	TcpServerSocket::newAcceptor (void) {
-		return new TcpServerSocket::Acceptor (this, this->sockfd);
-	}
-
-	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
-		this->socket = server;
-		this->sockfd = sockfd;
-	}
-
-	int
-	TcpServerSocket::Acceptor::acceptIncoming (void) {
-		int newfd = -1;
-		static struct sockaddr_in clientaddr;
-		unsigned int x = sizeof (clientaddr);
-
-		if ((newfd = ::accept (this->sockfd, 
-									  (struct sockaddr *)&clientaddr,
-									  &x)) < 0)
-			return -1;
-		return newfd;
-	}
-
-	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
-		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-	}
-
-	TcpClientSocket::TcpClientSocket (int newfd) {
-		this->sockfd = newfd;
-	}
-				
-	TcpClientSocket::~TcpClientSocket (void) {
-	}
-
-	bool
-	TcpClientSocket::connect (const char * host, int port) {
-		if (!host || (*host == '\0'))
-			return false;
-
-		if ((this->hp = ::gethostbyname (host)) == NULL)
-			return false;
- 
-		// Copy over the hostname address.
-		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr 
-			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
-		this->sockaddr.sin_port = htons (port);
-
-		if (::connect (this->sockfd,
-							(struct sockaddr *)&(this->sockaddr),
-							sizeof (struct sockaddr)) < 0)
-			return false;
-    
-		return true;
-	}
-
-	void
-	TcpClientSocket::close (void) {
-		TcpSocket::close();
-	}
-
-} // end of namespace
diff --git a/src/network/Tcp.hpp b/src/network/Tcp.hpp
deleted file mode 100755
index 02ddc8a..0000000
--- a/src/network/Tcp.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_NETWORK_TCP
-#define HPP_NETWORK_TCP
-
-#include "Socket.hpp"
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <netdb.h>
-
-namespace network {
-
-  class TcpSocket : public ISocket {
-  protected:
-    struct sockaddr_in sockaddr;
-  public:
-    TcpSocket (void);
-    virtual ~TcpSocket (void);
-
-    void close (void);
-    int send (const char * bytes, size_t length);
-    int receive (char * bytes, size_t size);
-  };
-
-  class TcpServerSocket : public TcpSocket {
-  private:
-    int port;
-  public:
-    class Acceptor {
-    private:
-      TcpServerSocket * socket;
-      int sockfd;
-    public:
-      Acceptor (TcpServerSocket * server, int sockfd);
-
-      int acceptIncoming (void);
-    };
-
-    TcpServerSocket (int port);
-    virtual ~TcpServerSocket (void);
-    
-    bool start (int backlog);
-    void close (void);
-    Acceptor * newAcceptor (void);
-  };
-  
-  class TcpClientSocket : public TcpSocket {
-  private:
-    struct hostent * hp;
-  public:
-    TcpClientSocket (void);
-    TcpClientSocket (int newfd);
-    virtual ~TcpClientSocket (void);
-
-    bool connect (const char * host, int port);
-    void close (void);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/proactor/Dispatcher.cc b/src/proactor/Dispatcher.cc
deleted file mode 100755
index c7a9ded..0000000
--- a/src/proactor/Dispatcher.cc
+++ /dev/null
@@ -1,54 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Dispatcher.hpp"
-#include "Worker.hpp"
-#include <algorithm>
-
-namespace proactor {
-
-  Dispatcher::~Dispatcher (void) {
-      
-  }
-   
-	bool
-	Dispatcher::addWorker (Worker * w) {
-		WorkerListType::iterator it = std::find (this->workers.begin(),
-															  this->workers.end(),
-															  w);
-		if (it == this->workers.end()) {
-			this->workers.push_back (w);
-			return w->start();
-      }
-		return false;
-	}
-  
-	bool
-	Dispatcher::removeWorker (Worker * w) {
-		WorkerListType::iterator it = std::find (this->workers.begin(),
-															  this->workers.end(),
-															  w);
-
-		if (it == this->workers.end())
-			return false;
-  
-		this->workers.erase (it);
-		return true;
-	}
-
-} // end of namesapce
diff --git a/src/proactor/Dispatcher.hpp b/src/proactor/Dispatcher.hpp
deleted file mode 100755
index 124f03d..0000000
--- a/src/proactor/Dispatcher.hpp
+++ /dev/null
@@ -1,43 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_DISPATCHER
-#define HPP_PROACTOR_DISPATCHER
-
-#include "../concurrent/Thread.hpp"
-#include "../concurrent/List.hpp"
-
-namespace proactor {
-
-  class Worker;
-
-  class Dispatcher : public concurrent::Thread {
-  protected:
-    typedef concurrent::List<Worker *> WorkerListType;
-
-    WorkerListType workers;
-  public:
-    virtual ~Dispatcher (void);
-
-    bool addWorker (Worker * w);
-    bool removeWorker (Worker * w);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/proactor/Event.cc b/src/proactor/Event.cc
deleted file mode 100755
index a1c5c2b..0000000
--- a/src/proactor/Event.cc
+++ /dev/null
@@ -1,38 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Event.hpp"
-
-namespace proactor {
-
-  int Event::numEvents = 0;
-
-  Event::Event (int e, const std::string & buf) {
-    this->id = e;
-    this->buf = buf;
-  }
-
-  int
-  Event::uniqueEventId (void) {
-    return Event::numEvents++;
-  }
-
-  EventDispatcher::~EventDispatcher (void) {
-  }
- 
-} // end of namespace
diff --git a/src/proactor/Event.hpp b/src/proactor/Event.hpp
deleted file mode 100755
index f5c9f7e..0000000
--- a/src/proactor/Event.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_EVENT
-#define HPP_PROACTOR_EVENT
-
-#include "Dispatcher.hpp"
-#include <string>
-
-namespace proactor {
-
-  class Event {
-  private:
-    static int numEvents;
-  public:
-    int id;
-    std::string buf;
-
-    Event (int id, const std::string & buf);
-
-    static int uniqueEventId (void);
-  };
-
-  class EventDispatcher : public Dispatcher {
-  private:
-    int eventId;
-  public:
-    virtual ~EventDispatcher (void);
-
-    inline void setEventId (int e) { 
-      this->eventId = e;
-    }
-
-    inline int getEventId (void) { 
-      return this->eventId;
-    }
-  };
-
-}
-
-#endif
diff --git a/src/proactor/InputDispatcher.cc b/src/proactor/InputDispatcher.cc
deleted file mode 100755
index a46febc..0000000
--- a/src/proactor/InputDispatcher.cc
+++ /dev/null
@@ -1,66 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "InputDispatcher.hpp"
-#include "Proactor.hpp"
-
-namespace proactor {
-
-  InputDispatcher::~InputDispatcher (void) {
-	  this->inputQueue.lock();
-	  while (this->inputQueue.size() > 0)
-		  this->inputQueue.pop();
-	  this->inputQueue.unlock();
-  }
-
-  void *
-  InputDispatcher::stop (void) {
-    WorkerListType::iterator it = this->workers.begin();
-    while (it != this->workers.end()) {
-      (*it)->stop();
-      it = this->workers.erase(it);
-    }
-    return Thread::stop();
-  }
-
-  void *
-  InputDispatcher::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
-      // Dispatch all of the input items on the queue.
-      this->inputQueue.lock();
-
-      while (this->inputQueue.size() > 0) {
-
-	if (this->running == false)
-	  break;
-
-	// For right now all we're doing is pushing up the chain.
-	this->pro->onReadComplete ( this->inputQueue.pop() );
-      }
-
-      this->inputQueue.unlock();
-
-      Thread::sleep(100);
-    }
-  
-    return NULL; 
-  }
-
-} // end of namespace
diff --git a/src/proactor/InputDispatcher.hpp b/src/proactor/InputDispatcher.hpp
deleted file mode 100755
index ee49202..0000000
--- a/src/proactor/InputDispatcher.hpp
+++ /dev/null
@@ -1,53 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_INPUTDISPATCHER
-#define HPP_PROACTOR_INPUTDISPATCHER
-
-#include "../concurrent/Queue.hpp"
-#include "Event.hpp"
-
-namespace proactor {
-
-  class Proactor;
-
-  class InputDispatcher : public EventDispatcher {
-  protected:
-    typedef concurrent::Queue<Event> InputQueueType;
-
-    Proactor * pro;
-    InputQueueType inputQueue;
-  public:
-    virtual ~InputDispatcher (void);
-
-    void * stop (void);
-    
-    inline void onReadComplete (const char * buf) {
-      this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
-    }
-
-    inline void onReadComplete (std::string buf) {
-      this->inputQueue.push ( Event (getEventId(), buf) );
-    }
-
-    void * run (void * null);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/proactor/Proactor.cc b/src/proactor/Proactor.cc
deleted file mode 100755
index 2085c63..0000000
--- a/src/proactor/Proactor.cc
+++ /dev/null
@@ -1,159 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Proactor.hpp"
-#include <iostream>
-#include <algorithm>
-
-namespace proactor {
-
-  Proactor::Proactor (void) {
-  }
-
-  Proactor::~Proactor (void) {
-    // Remove all of the lists of event handlers.
-    {
-      EventMapType::iterator it = this->eventsToHandlers.begin();
-      while (it != this->eventsToHandlers.end()) {
-	  WorkerListType * q = (it->second);
-	  delete q;
-	  it++;
-	}
-    }
- 
-    // Handle the dispatchers that have not been manually removed.
-    {
-      DispatcherList::iterator it = this->dispatchers.begin();
-      while (it != this->dispatchers.end())
-	{
-	  Dispatcher * d = (*it);
-	  delete d;
-	  it++;
-	}
-    }
-  
-  }
-
-  bool
-  Proactor::addWorker (int e, Worker * job) {
-    this->eventsToHandlers.lock();
-    {
-      EventMapType::iterator it = this->eventsToHandlers.find (e);
-  
-      if (it == this->eventsToHandlers.end())
-	this->eventsToHandlers[e] = new WorkerListType;  
-      this->eventsToHandlers[e]->push_back (job);
-    }
-    this->eventsToHandlers.unlock();
-
-    return job->start();
-  }
-
-  void
-  Proactor::onReadComplete (Event e) {
-    this->events.push (e);
-  }
-
-  void 
-  Proactor::onReadComplete (int e, const char * buf) {
-    this->events.push ( Event (e, std::string (buf)) );   
-  }
-
-  bool
-  Proactor::removeWorker (int e, Worker * job) {
-    bool result = false;
-
-    this->eventsToHandlers.lock();
-    {
-      WorkerListType::iterator it = 
-	std::find (this->eventsToHandlers[e]->begin(),
-		   this->eventsToHandlers[e]->end(),
-		   job);
-    
-      if (it != this->eventsToHandlers[e]->end())
-	{
-	  this->eventsToHandlers[e]->erase (it);
-	  result = true;
-	}
-    }
-    this->eventsToHandlers.unlock();
-   
-    return result;
-  }
-
-  void
-  Proactor::addDispatcher (Dispatcher * d) {
-    this->dispatchers.push_back (d);
-  }
-
-  bool
-  Proactor::removeDispatcher (Dispatcher * d) {
-    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
-					     this->dispatchers.end(),
-					     d);
-
-    if (it == this->dispatchers.end())
-      return false;
-  
-    this->dispatchers.erase (it);
-    return true;
-  }
-
-  void *
-  Proactor::run (void * null) {
-    this->running = true;
-  
-    WorkerListType::iterator it;
-
-    while (this->running == true) {
-	this->events.lock();
-
-	while (this->events.size() > 0) {
-
-	  if (this->running == false)
-	    break;
-
-	    Event e = this->events.pop();
-
-	    // We are throwing events with no handlers to catch them.
-	    if (this->eventsToHandlers.find (e.id) == 
-		this->eventsToHandlers.end())
-	      continue;
- 
-	    it = this->eventsToHandlers[e.id]->begin();
-	  
-	    while (it != this->eventsToHandlers[e.id]->end()) {
-
-	      if (this->running == false)
-		break;
-
-		Worker * j = (*it);
-	      
-		j->pushInputQueue (e.buf);
-		      
-		it++;
-	      }
-	  }
-	this->events.unlock();
-      
-	Thread::sleep(100);
-      }
-    return NULL;
-  }
-
-} // end of namespace
diff --git a/src/proactor/Proactor.hpp b/src/proactor/Proactor.hpp
deleted file mode 100755
index 793647c..0000000
--- a/src/proactor/Proactor.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_PROACTOR
-#define HPP_PROACTOR_PROACTOR
-
-#include "../concurrent/Thread.hpp"
-#include "../concurrent/Map.hpp"
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/List.hpp"
-#include "Worker.hpp"
-#include "Event.hpp"
-#include "Dispatcher.hpp"
-#include "InputDispatcher.hpp"
-
-namespace proactor {
-
-  class Proactor : public Dispatcher {
-  private:
-    typedef concurrent::List<Dispatcher *> DispatcherList;
-    typedef concurrent::Map<int, WorkerListType *> EventMapType;
-    typedef concurrent::Queue<Event> EventQueueType;
-
-    EventMapType eventsToHandlers;
-    DispatcherList dispatchers;
-    EventQueueType events;
-  public:
-    Proactor (void);
-    virtual ~Proactor (void);
-
-    bool addWorker (int e, Worker * w);
-    bool removeWorker (int e, Worker * w);
-    void addDispatcher (Dispatcher * d);
-    bool removeDispatcher (Dispatcher * d);
-    
-    void * run (void * null);
- 
-    void onReadComplete (Event e);
-    void onReadComplete (int e, const char * buf);
-
-    inline const std::string & peekInputQueue (void) {
-      return (this->events.front()).buf;
-    }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/proactor/Worker.cc b/src/proactor/Worker.cc
deleted file mode 100755
index be5863f..0000000
--- a/src/proactor/Worker.cc
+++ /dev/null
@@ -1,26 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Worker.hpp"
-
-namespace proactor {
-
-  Worker::~Worker (void) {
-  }
-
-} // end of namesapce
diff --git a/src/proactor/Worker.hpp b/src/proactor/Worker.hpp
deleted file mode 100755
index 481cae1..0000000
--- a/src/proactor/Worker.hpp
+++ /dev/null
@@ -1,46 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_WORKER
-#define HPP_PROACTOR_WORKER
-
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/Thread.hpp"
-#include <string>
-
-namespace proactor {
-
-  class InputDispatcher;
-
-  class Worker : public concurrent::Thread {
-  protected:
-    typedef concurrent::Queue<std::string> InputQueueType;
-
-    InputDispatcher * dispatcher;
-    InputQueueType inputQueue;
-  public:
-    virtual ~Worker (void);
-
-    inline void pushInputQueue (std::string buf) {
-      this->inputQueue.push (buf);
-    }
-  };
-
-} // end of namespace
-
-#endif

commit bdd41402b37e58525e980ee025c6add41751312b
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 20:41:29 2009 -0400

    Many changes: new plugin architectuer, Largefile plugin added, removed old plugin methods.

diff --git a/src/Application.cc b/src/Application.cc
index ed51aaa..2f1251a 100755
--- a/src/Application.cc
+++ b/src/Application.cc
@@ -1,4 +1,5 @@
 #include "Application.hpp"
+#include "Plugin.hpp"
 #include <cstring>
 
 /* @description: This method takes the argument and clears the string of
@@ -162,19 +163,6 @@ Application::Application (int argc, char *** argv) {
 }
 
 Application::~Application (void) {
-	/* Because of a change to the Plugin architecture it will now yield until
-		all threads that were instatiated are closed properly. We use the 
-		appstate->workbook_first variable in order to test for NULL. */
-	gdk_threads_leave();
-	{
-		PluginList::iterator it = this->plugins.begin();
-		while (it != this->plugins.end()) {
-			(*it)->destroy ( (*it) ); (*it) = NULL;
-			it++;
-		}
-	}
-	gdk_threads_enter();
-
 	WorkbookList::iterator it = this->workbooks.begin();
 	while (it != this->workbooks.end()) {
 		(*it)->destroy ( (*it) ); (*it) = NULL;
@@ -187,8 +175,8 @@ Application::~Application (void) {
 }
 
 Plugin *
-Application::load_plugin (const gchar * filename) {
-	Plugin * plugin = plugin_open (filename);
+Application::load_plugin (const std::string filename) {
+	Plugin * plugin = Plugin::open_plugin (this, filename);
 
 	if (plugin) {
 		this->plugins.push_back (plugin);
@@ -215,27 +203,18 @@ Application::open_extension (const gchar * filename, gboolean absolute_path) {
 
 	Plugin * plugin = NULL;
 	if ((plugin = this->load_plugin (fname)) != NULL) {
-		typedef Workbook * (*Plugin_Main) (Application *, Plugin *);
-      Plugin_Main plugin_main;
-	  
-      if ((plugin_main = (Plugin_Main)plugin->method_register (plugin, "plugin_main")) == NULL) {
-			g_critical ("Unable to register method with symbol 'plugin_main'");
-			exit (1);
-		}
-
-      Workbook * wb = plugin_main (this, plugin);
-      if (wb == NULL) {
+		if (plugin->workbook() == NULL) {
 			g_critical ("Plugin returned a NULL pointer instead of allocated"
 							" workbook.");
 			exit (1);
 		} else {
 			/* Attach all of the signals for the Workbook object. */
-			gtk_signal_connect (GTK_OBJECT (wb->gtk_notebook),
+			gtk_signal_connect (GTK_OBJECT (plugin->workbook()->gtk_notebook),
 									  "switch-page",
 									  (GtkSignalFunc)this->signals[NOTEBOOK_SWITCHED], 
-									  (gpointer)wb);
+									  (gpointer)plugin->workbook());
 	  
-			this->workbooks.push_back (wb);
+			this->workbooks.push_back (plugin->workbook());
 		}
 	}
 
@@ -364,4 +343,3 @@ Application::run (void) {
 	gdk_threads_leave ();
 	return 0;
 }
-
diff --git a/src/Application.hpp b/src/Application.hpp
index a265685..87c8377 100755
--- a/src/Application.hpp
+++ b/src/Application.hpp
@@ -7,9 +7,9 @@
 #include <cstdlib>
 #include <gtkworkbook/workbook.h>
 #include "config.h"
-#include "plugin.h"
 #include "proactor/Proactor.hpp"
 
+class Plugin;
 class Application {
 public:
 	enum sigs {
@@ -45,7 +45,7 @@ public:
 
 	int run (void);
 	void shutdown (void);
-	Plugin * load_plugin (const gchar * filename);
+	Plugin * load_plugin (const std::string filename);
 	void open_extension (const gchar * filename, gboolean absolute_path);
 
 	inline GtkWidget * gtkwindow() { return this->gtk_window; }
diff --git a/src/Makefile b/src/Makefile
index 418d71d..d8b5449 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -6,7 +6,7 @@ OBJS=$(patsubst %.cc,${OBJDIR}/%.o,${SRCS})
 LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0
 
 all: 	gtkworkbook
-	make -C realtime/ all
+#	make -C realtime/ all
 	make -C largefile/ all
 
 gtkworkbook: ${OBJS}
@@ -15,13 +15,13 @@ gtkworkbook: ${OBJS}
 clean:		
 	${MD} ${OBJDIR}	
 	${RM} ${OBJS} ${INSBINDIR}/gtkworkbook
-	make -C realtime/ clean
+#	make -C realtime/ clean
 	make -C largefile/ clean
 
 install: all
 	${MD} ${INSBINDIR}
 	${CP} ${PROJDIR}/bin/gtkworkbook ${INSBINDIR}/gtkworkbook
-	make -C realtime/ install
+#	make -C realtime/ install
 	make -C largefile/ install
 
 ${OBJDIR}/%.o: %.cc
diff --git a/src/Plugin.cc b/src/Plugin.cc
new file mode 100644
index 0000000..da021ac
--- /dev/null
+++ b/src/Plugin.cc
@@ -0,0 +1,48 @@
+#include "Plugin.hpp"
+
+Plugin::Plugin (Application * appstate, Handle * platform)
+	: appstate(appstate), platform(platform) {
+	this->wb = NULL;
+}
+
+Plugin::~Plugin (void) {
+	// If this comment is still here then this potentially really, really, bad idea turned
+	// out to actually work. There is probably a much better and safer way to do this.
+	LIBRARY_CLOSE (platform->handle);
+	delete platform;
+}
+
+Plugin *
+Plugin::open_plugin (Application * appstate, const std::string filename) {
+	typedef Plugin * (*Plugin_Main) (Application *, Handle *);
+      				
+	if (filename.length() == 0)
+		return NULL;
+
+	// Get a handle to the shared library we're attempting to open.
+	Handle * platform = new Handle;
+	if ((platform->handle = LIBRARY_OPEN (filename.c_str())) == NULL) {
+		fprintf (stderr, "%s\n", LIBRARY_ERROR());
+		exit(1);
+	}
+
+	// Grab the main method from the plugin so we can execute to get an object back.
+	Plugin_Main plugin_main;
+	if ((plugin_main = (Plugin_Main)LIBRARY_SYM(platform->handle, "plugin_main")) == NULL) {
+		fprintf (stderr, "%s\n", LIBRARY_ERROR());
+		exit(1);
+	}
+
+	// Execute the method, return an object, and basically go on our merry way.
+	return plugin_main (appstate, platform);
+}
+
+Workbook *
+Plugin::workbook(void) {
+	return this->wb;
+}
+
+Application *
+Plugin::app(void) {
+	return this->appstate;
+}
diff --git a/src/Plugin.hpp b/src/Plugin.hpp
new file mode 100644
index 0000000..74cc4b1
--- /dev/null
+++ b/src/Plugin.hpp
@@ -0,0 +1,63 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PLUGIN
+#define HPP_PLUGIN
+
+#include "Application.hpp"
+#include <dlfcn.h>
+#include <gtkworkbook/workbook.h>
+#include <string>
+
+#ifdef WIN32
+#include <windows.h>
+typedef HINSTANCE PlatformHandle;
+#define LIBRARY_CLOSE(handle) FreeLibrary(handle)
+#define LIBRARY_OPEN(filename) LoadLibrary(filename)
+#define LIBRARY_SYM(handle, symbol) GetProcAddress(handle, symbol)
+#define LIBRARY_ERROR() GetLastError()
+#else
+typedef void * PlatformHandle;
+#define LIBRARY_CLOSE(handle) dlclose(handle)
+#define LIBRARY_OPEN(filename) dlopen(filename, RTLD_LAZY)
+#define LIBRARY_SYM(handle, symbol) dlsym(handle, symbol)
+#define LIBRARY_ERROR() dlerror()
+#endif
+
+struct Handle {
+	Handle() :handle(NULL) { }
+	PlatformHandle handle;
+};
+
+class Plugin {
+protected:
+	Workbook * wb;
+	Application * appstate;
+private:
+	Handle * platform;
+public:
+	static Plugin * open_plugin (Application * appstate, const std::string filename);
+	
+	Plugin (Application * appstate, Handle * platform);
+	virtual ~Plugin (void);
+
+	Workbook * workbook (void);
+	Application * app (void);
+};
+
+#endif
diff --git a/src/largefile/Largefile.cpp b/src/largefile/Largefile.cpp
new file mode 100644
index 0000000..ed0a84d
--- /dev/null
+++ b/src/largefile/Largefile.cpp
@@ -0,0 +1,138 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <gdk/gdkkeysyms.h>
+#include <gtkworkbook/workbook.h>
+#include <proactor/Proactor.hpp>
+#include <proactor/Worker.hpp>
+#include <proactor/Event.hpp>
+#include <vector>
+#include <fstream>
+#include <iostream>
+#include <string>
+#include <sstream>
+#include "Largefile.hpp"
+#include "File.hpp"
+#include "CsvParser.hpp"
+
+using namespace largefile;
+
+/* @description: This method creates a filename with the prefix supplied and
+   uses the pid of the process as its suffix. 
+   @pre: The prefix (should be a file path, obviously). */
+static std::string
+append_pidname (const gchar * pre) {
+  std::stringstream s;
+  s << pre << getppid();
+  return s.str();
+}
+
+static gint
+key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
+	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
+	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
+	Workbook * wb = (Workbook *)arguments->at(1);
+	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
+
+	//	int vposition = std::abs((int)gtksheet->vadjustment->value);
+	static off64_t cursor = 0;
+	//	float N = vposition, K = 24388, V = (N/K);
+	
+	switch (event->keyval) {
+		case GDK_F1: {
+			fd->read(1012121,1000);
+		}
+		break;
+		
+		case GDK_Page_Up: {
+			fd->read(cursor, 100);
+			cursor += 100;
+		}
+		return TRUE;
+
+		case GDK_Page_Down: {
+			if (cursor <= 100)
+				cursor = 0;
+			else
+				cursor -= 100;
+			
+			fd->read(cursor, 100);
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+Largefile::Largefile (Application * appstate, Handle * platform)
+	: Plugin (appstate, platform) {
+
+	ConfigPair * logpath =
+		appstate->config()->get_pair (appstate->config(), "largefile", "log", "path");
+
+	if (IS_NULL (logpath)) {
+		g_critical ("Failed loading log->path from configuration file. Exiting application.");
+		exit(1);
+	}
+	
+	std::string logname = std::string (logpath->value).append("/");
+	logname.append (append_pidname("largefile.").append(".log"));
+	
+	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
+		g_critical ("Failed opening file '%s' for packet logging; exiting"
+					" thread", logname.c_str());
+		return;
+    }
+}
+
+bool
+Largefile::open_file (const std::string & filename) {
+	int fdEventId = proactor::Event::uniqueEventId();
+	FileDispatcher * fd = new FileDispatcher (fdEventId, appstate->proactor());
+	CsvParser * csv = new CsvParser (this->wb, this->pktlog, 0, 20);
+
+	if (appstate->proactor()->addWorker (fdEventId, csv) == false) {
+		g_critical ("Failed starting CsvParser for file %s", filename.c_str());
+		return false;
+	}
+
+	if (fd->open (filename.c_str()) == false) {
+		g_critical ("Failed opening %s", filename.c_str());
+		return false;
+	}
+
+	if (fd->start() == false) {
+		g_critical ("Failed starting file dispatcher for file %s", filename.c_str());
+		return false;
+	}
+
+	this->mapping.insert (std::make_pair (filename, fdEventId));
+	return true;
+}
+
+bool
+Largefile::exit_file (const std::string & filename) {
+	FilenameMap::iterator it = this->mapping.find(filename);
+	if (it == this->mapping.end()) {
+		// STUB: something meaningful here to mention that the file does not exist inside
+		// of the map. They're trying to exit from a file that seemingly has not been opened.
+		return false;
+	}
+	// STUB: procedure for shutting down a file dispatcher and CsvParser.
+	this->mapping.erase (it);
+	return true;
+}
diff --git a/src/largefile/Largefile.hpp b/src/largefile/Largefile.hpp
new file mode 100644
index 0000000..03060b6
--- /dev/null
+++ b/src/largefile/Largefile.hpp
@@ -0,0 +1,24 @@
+#ifndef HPP_LARGEFILE
+#define HPP_LARGEFILE
+
+#include <map>
+#include <string>
+#include "../Plugin.hpp"
+#include "../Application.hpp"
+#include "../config.h"
+
+class Largefile : public Plugin {
+private:
+	typedef std::map<std::string,int> FilenameMap;
+	
+	FILE * pktlog;
+	FilenameMap mapping;
+public:
+	Largefile (Application * appstate, Handle * platform);
+	virtual ~Largefile (void);
+
+	bool open_file (const std::string & filename);
+	bool exit_file (const std::string & filename);
+};
+
+#endif
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index 205bd8c..ad03e23 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.base
 
-INCS += -I${PROJDIR}/shared -I../
+INCS += -I../
 SRCS=$(wildcard *.cpp) 
 OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
 
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index fb3f04b..cce51fe 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -20,30 +20,36 @@
 #include <gtkworkbook/workbook.h>
 #include <concurrent/ThreadArgs.hpp>
 #include <gtk/gtk.h>
+#include "Largefile.hpp"
 #include "../config.h"
 #include "../Application.hpp"
-#include "../plugin.h"
 
 /* Prototypes */
 extern void thread_main (ThreadArgs *);
 
 static void
 open_csv_file (GtkWidget * w, gpointer data) {
-  Application * app = (Application *)data;
-  Config * cfg = app->config();
+  Largefile * lf = (Largefile *)data;
   
   GtkWidget * dialog = gtk_file_chooser_dialog_new ("Open File",
-																	 GTK_WINDOW (app->gtkwindow()),
+																	 GTK_WINDOW (lf->app()->gtkwindow()),
 																	 GTK_FILE_CHOOSER_ACTION_OPEN,
 																	 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
 																	 GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
 																	 NULL);  
   
   gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (dialog), TRUE);
-
+  
   if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
     gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
 
+	 if (lf->open_file (filename) == true) {
+		 std::cout << filename << "\n";
+	 }
+	 else {
+		 // STUB: The opening of the file failed. Do something meaningful here.
+	 }
+	 
     g_free (filename);
   }
 
@@ -52,70 +58,49 @@ open_csv_file (GtkWidget * w, gpointer data) {
 
 static GtkWidget *
 largefile_mainmenu_new (Application * appstate, GtkWidget * window) {
-  GtkItemFactoryEntry menu_items[] = {
-    {"/_File",         NULL,		NULL, 		0, 	"<Branch>"},
-    {"/File/_Open",    "<CTRL>O",	(GtkItemFactoryCallback)open_csv_file,	0,	"<StockItem>", GTK_STOCK_OPEN},
-    {"/File/_Close",   "<CTRL>C",	NULL,		0,	"<Item>"},
-    {"/File/sep1",     NULL,		NULL,		0,	"<Separator>"},
-    {"/File/_Quit",    "<CTRL>Q", 	gtk_main_quit,	0,	"<StockItem>", GTK_STOCK_QUIT},
-  };
-  
-  gint nmenu_items = sizeof (menu_items) / sizeof (menu_items[0]);
-  GtkAccelGroup * accel 
-    = gtk_accel_group_new ();
+	GtkWidget * lfmenu = gtk_menu_new();
+	GtkWidget * lfmenu_item = gtk_menu_item_new_with_label ("Largefile");
+	GtkWidget * lfmenu_open = gtk_image_menu_item_new_from_stock (GTK_STOCK_OPEN, NULL);
+	gtk_menu_shell_append (GTK_MENU_SHELL (lfmenu), lfmenu_open);
+
+	gtk_menu_item_set_submenu (GTK_MENU_ITEM (lfmenu_item), lfmenu);
+
+	gtk_widget_show_all (lfmenu);
+	return lfmenu;
+}
+
+static GtkWidget *
+build_layout (Application * app, Largefile * lf, Workbook * wb) {
+	GtkWidget * gtk_menu = app->gtkmenu();
+	GtkWidget * box = gtk_vbox_new (FALSE, 0);
 	
-  GtkItemFactory * item_factory 
-    = gtk_item_factory_new (GTK_TYPE_MENU_BAR, "<main>", accel);
-  
-  gtk_item_factory_create_items (item_factory, nmenu_items, menu_items, appstate);
+	GtkWidget * largefile_menu = largefile_mainmenu_new (app, app->gtkwindow());
+	gtk_menu_shell_append (GTK_MENU_SHELL (gtk_menu), largefile_menu);
 
-  gtk_window_add_accel_group (GTK_WINDOW (window), accel);
+	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
 
-  GtkWidget * menu = gtk_item_factory_get_widget (item_factory, "<main>");
-  gtk_widget_show (menu);
+	wb->signals[SIG_WORKBOOK_CHANGED] = app->signals[Application::SHEET_CHANGED];
+	wb->gtk_box = box;
 
-  return menu;
+	gtk_box_pack_start (GTK_BOX (app->gtkvbox()), box, FALSE, FALSE, 0);
+	return box;
 }
 
 extern "C" {
-
-  Workbook *
-  plugin_main (Application * appstate, Plugin * plugin) {
+  Plugin *
+  plugin_main (Application * appstate, Handle * platform) {
     ASSERT (appstate != NULL);
-    ASSERT (plugin != NULL);
-	
-    GtkWidget * box = gtk_vbox_new (FALSE, 0);
-    GtkWidget * mainmenu = largefile_mainmenu_new (appstate, appstate->gtkwindow());
-    gtk_box_pack_start (GTK_BOX (box), mainmenu, FALSE, FALSE, 0);
-
-    Workbook * wb = NULL;
+    ASSERT (platform != NULL);
+	 Largefile * lf = new Largefile (appstate, platform);
+	 Workbook * wb = lf->workbook();
+	 
     if ((wb = workbook_open (appstate->gtkwindow(), "largefile")) == NULL) {
       g_critical ("Failed opening workbook; exiting largefile plugin");
       return NULL;
     }
-
-    gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
-
-    wb->signals[SIG_WORKBOOK_CHANGED] = appstate->signals[Application::SHEET_CHANGED];
-        
-    wb->gtk_box = box;
-    
-    wb->add_new_sheet (wb, "sheet0", 1000, 20);
-
-    ThreadArgs args;
-    args.push_back ( (void *)wb );
-    args.push_back ( (void *)appstate->config() );
-
-    if (plugin->create_thread (plugin,
-			       (GThreadFunc)thread_main,
-			       (gpointer)new ThreadArgs (args)) == NULL) {
-      g_critical ("Failed creating thread; exiting 'largefile' plugin");
-      return NULL;
-    }
-
-    gtk_box_pack_start (GTK_BOX (appstate->gtkvbox()), box, FALSE, FALSE, 0);
-    gtk_widget_show (box);	
-    return wb;
+	 
+	 GtkWidget * box = build_layout (appstate, lf, wb);
+	 gtk_widget_show (box);	 
+    return lf;
   }
-
 } 
diff --git a/src/plugin.cc b/src/plugin.cc
deleted file mode 100755
index ca9b295..0000000
--- a/src/plugin.cc
+++ /dev/null
@@ -1,198 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "plugin.h"
-#include <cstdio>
-#include <cstdlib>
-
-/* plugin.c (static) */
-static Plugin *plugin_object_init (void);
-static void plugin_method_destroy (Plugin *);
-static void *plugin_method_symbol_register (Plugin *, gchar *);
-static void plugin_method_symbol_deregister (Plugin *, PluginMethod *);
-static Plugin *plugin_object_free (Plugin *);
-static PluginMethod *pluginmethod_object_init (Plugin *);
-static PluginMethod *pluginmethod_object_free (PluginMethod *);
-static void pluginmethod_method_deregister (PluginMethod *, Plugin *);
-static GThread *plugin_method_create_thread (Plugin *,
-															GThreadFunc,
-															gpointer);
-
-Plugin *
-plugin_open (const gchar * filename)
-{
-	if (!filename || (*filename == '\0'))
-		return NULL;
-
-	Plugin * plug = plugin_object_init ();
-
-	if ((plug->pfnhandle = LIBRARY_OPEN(filename)) == NULL)
-	{
-      fprintf (stderr, "%s\n", LIBRARY_ERROR());
-      exit (1);
-	}
-	return plug;
-}
-
-static Plugin *
-plugin_object_init (void)
-{
-	Plugin * plug = NEW (Plugin);
-  
-	/* Members */
-	plug->pfnhandle = NULL;
-	plug->next = NULL;
-	plug->prev = NULL;
-	plug->first = NULL;
-	plug->last = NULL;
-	plug->threads = g_ptr_array_new ();
-
-	/* Methods */
-	plug->destroy = plugin_method_destroy;
-	plug->method_register = plugin_method_symbol_register;
-	plug->method_deregister = plugin_method_symbol_deregister;
-	plug->create_thread = plugin_method_create_thread;
-
-	return plug;
-}
-
-static GThread *
-plugin_method_create_thread (Plugin * plugin,
-									  GThreadFunc thread_function,
-									  gpointer data)
-{
-	ASSERT (plugin != NULL);
-
-	GThread * runnable = NULL;
-	GError * err = NULL;
-
-	if ((runnable = g_thread_create (thread_function, data,
-												TRUE, &err)) == NULL)
-	{
-      g_warning ("Failed creating thread; ERROR %s", err->message);
-      g_error_free (err);
-      return NULL;
-	}
-	g_ptr_array_add (plugin->threads, (gpointer)runnable);
-	return runnable;
-} 
-
-static Plugin *
-plugin_object_free (Plugin * plugin)
-{
-	if (!plugin)
-		return NULL;
-
-	plugin->first = plugin->last = NULL;
-
-	g_ptr_array_free (plugin->threads, TRUE);
-
-	FREE (plugin);
-	return plugin;
-}
-
-static void
-plugin_method_destroy (Plugin * plugin)
-{
-	if (!plugin)
-		return;
-
-	PluginMethod * current = plugin->first, * next = NULL;
-	while (current)
-	{
-      next = current->next;
-      current->deregister (current, plugin);
-      current = next;
-	}
-
-	for (guint ii = 0; ii < plugin->threads->len; ii++)
-	{
-      GThread * thread 
-			= (GThread *)g_ptr_array_remove_index_fast (plugin->threads, ii);
-      g_thread_join (thread);
-	}
-
-	UNLINK_OBJECT (plugin);
-	LIBRARY_CLOSE (plugin->pfnhandle);
-	plugin_object_free (plugin);
-}
-
-static void
-plugin_method_symbol_deregister (Plugin * plugin, PluginMethod * method)
-{
-	if (!plugin || !method)
-		return;
-
-	method->deregister (method, plugin);
-}
-
-static void *
-plugin_method_symbol_register (Plugin * plugin, gchar * symbol)
-{
-	if (IS_NULLSTR (symbol))
-		return NULL;
-
-	PluginMethod * plugm = pluginmethod_object_init (plugin);
-
-	if ((plugm->pfnmethod 
-		  = LIBRARY_SYM(plugin->pfnhandle, symbol)) == NULL)
-	{
-      fprintf (stderr, "%s\n", LIBRARY_ERROR());
-      exit (1);
-	}
-
-	LINK_OBJECT (plugin->first, plugin->last, plugm); 
-	return plugm->pfnmethod;
-}
-
-static PluginMethod *
-pluginmethod_object_init (Plugin * plugin)
-{
-	PluginMethod * plugm = NEW (PluginMethod);
-
-	/* Members */
-	plugm->pfnmethod = NULL;
-	plugm->plugin = plugin;
-
-	/* Methods */
-	plugm->deregister = pluginmethod_method_deregister;
-
-	plugm->next = NULL;
-	plugm->prev = NULL;
-	return plugm;
-}
-
-static PluginMethod *
-pluginmethod_object_free (PluginMethod * method)
-{
-	if (!method)
-		return NULL;
-
-	FREE (method);
-	return method;
-}
-
-static void
-pluginmethod_method_deregister (PluginMethod * method, Plugin * plugin)
-{
-	if (!method)
-		return;
-
-	UNLINK_OBJECT (method);
-	pluginmethod_object_free (method);
-}
diff --git a/src/plugin.h b/src/plugin.h
deleted file mode 100755
index 6b4a68f..0000000
--- a/src/plugin.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef H_PLUGIN
-#define H_PLUGIN
-
-typedef struct _PluginMethod PluginMethod;
-typedef struct _Plugin Plugin;
-
-#ifdef WIN32
-#include <windows.h>
-typedef HINSTANCE LibraryHandle;
-#define LIBRARY_CLOSE(handle) FreeLibrary(handle)
-#define LIBRARY_OPEN(filename) LoadLibrary(filename)
-#define LIBRARY_SYM(handle, symbol) GetProcAddress(handle, symbol)
-#define LIBRARY_ERROR() GetLastError()
-#else
-typedef void * LibraryHandle;
-#define LIBRARY_CLOSE(handle) dlclose(handle)
-#define LIBRARY_OPEN(filename) dlopen(filename, RTLD_LAZY)
-#define LIBRARY_SYM(handle, symbol) dlsym(handle, symbol)
-#define LIBRARY_ERROR() dlerror()
-#endif
-
-#include <shared.h>
-#include <dlfcn.h>
-#include <glib/gthread.h>
-
-struct _Plugin
-{
-	/* Members */
-	LibraryHandle pfnhandle;
-	PluginMethod * first, * last;
-	Plugin * next, * prev;
-	GPtrArray * threads;
-
-	/* Methods */
-	void *(*method_register) (Plugin *, gchar *);
-	void (*method_deregister) (Plugin *, PluginMethod *);
-	void (*destroy) (Plugin *);
-	GThread *(*create_thread) (Plugin *, GThreadFunc, gpointer);
-};
-
-struct _PluginMethod
-{
-	/* Members */
-	void * pfnmethod;
-	PluginMethod * next, * prev;
-	Plugin * plugin;
-
-	/* Methods */
-	void (*deregister) (PluginMethod *method, Plugin *plugin);
-};
-
-/* plugin.c */
-Plugin * plugin_open (const gchar * filename);
-
-#endif
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
index 469fa28..956fa38 100755
--- a/src/realtime/plugin_main.cpp
+++ b/src/realtime/plugin_main.cpp
@@ -22,7 +22,7 @@
 #include <concurrent/ThreadArgs.hpp>
 #include "../config.h"
 #include "../Application.hpp"
-#include "../plugin.h"
+#include "../Plugin.hpp"
 
 /* Prototypes */
 extern void thread_main (ThreadArgs *);
@@ -30,7 +30,7 @@ extern void thread_main (ThreadArgs *);
 extern "C"
 {
   Workbook *
-  plugin_main (Application * app, Plugin * plugin) {
+  plugin_main (Application * app) {
     ASSERT (app != NULL);
     ASSERT (plugin != NULL);
 

commit 96f67a73dfd6a14c5d03f96c61d4d5d28c8c2fc9
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 17:17:54 2009 -0400

    First compiled version of C++ branch.

diff --git a/src/Application.cc b/src/Application.cc
index 032d831..ed51aaa 100755
--- a/src/Application.cc
+++ b/src/Application.cc
@@ -1,4 +1,22 @@
 #include "Application.hpp"
+#include <cstring>
+
+/* @description: This method takes the argument and clears the string of
+   everything except for the directories. Therefore the return value would
+   be a string sans anything before the last directory delimiter '/'. */
+static gchar *
+munchpath (gchar * path_) {
+	gchar * path = g_strdup(path_);
+	path = g_strreverse (path);
+	gchar * p = path;
+
+	while (p && (*p != '\0')) { if (*p == '/') break; p++; }
+
+	gchar * str = g_strdup (p);
+	str = g_strreverse (str);
+	FREE (path);
+	return str;
+}
 
 static guint
 signal_gtknotebook_removed (GtkNotebook * notebook,
@@ -121,7 +139,7 @@ signal_destroy_event (GtkWidget *window, gpointer data)
 	return FALSE;
 }
 
-Application::Application (int argc, char ** argv) {
+Application::Application (int argc, char *** argv) {
 	this->init (argc, argv);
 	this->cfg = NULL;
 	this->gtk_window = NULL;
@@ -197,10 +215,10 @@ Application::open_extension (const gchar * filename, gboolean absolute_path) {
 
 	Plugin * plugin = NULL;
 	if ((plugin = this->load_plugin (fname)) != NULL) {
-		typedef Workbook * (*Plugin_Main) (ApplicationState *, Plugin *);
+		typedef Workbook * (*Plugin_Main) (Application *, Plugin *);
       Plugin_Main plugin_main;
 	  
-      if ((plugin_main = plugin->method_register (plugin, "plugin_main")) == NULL) {
+      if ((plugin_main = (Plugin_Main)plugin->method_register (plugin, "plugin_main")) == NULL) {
 			g_critical ("Unable to register method with symbol 'plugin_main'");
 			exit (1);
 		}
@@ -214,7 +232,7 @@ Application::open_extension (const gchar * filename, gboolean absolute_path) {
 			/* Attach all of the signals for the Workbook object. */
 			gtk_signal_connect (GTK_OBJECT (wb->gtk_notebook),
 									  "switch-page",
-									  (GtkSignalFunc)this->signals[SIG_NOTEBOOK_SWITCHED], 
+									  (GtkSignalFunc)this->signals[NOTEBOOK_SWITCHED], 
 									  (gpointer)wb);
 	  
 			this->workbooks.push_back (wb);
@@ -225,7 +243,7 @@ Application::open_extension (const gchar * filename, gboolean absolute_path) {
 }
 
 void
-Application::init (int argc, char ** argv) {
+Application::init (int argc, char *** argv) {
 	int c;
 	
 	if (!g_thread_supported ()) {
@@ -233,12 +251,12 @@ Application::init (int argc, char ** argv) {
       gdk_threads_init ();
 	}
 
-	this->absolute_path = munchpath (*argv[0]);
+	this->absolute_path = ::munchpath (*argv[0]);
 	
 	/* This block parses the commandline for options. A better example on how
 		this code works can be found on the GNU website at the following URI:
 		http://gnu.org/software/libtool/manual/libc/Using-Getopt.html */
-	while ((c = getopt (*argc, *argv, "c:")) != -1) {
+	while ((c = getopt (argc, *argv, "c:")) != -1) {
       switch (c) {
 			case 'c': {
 				Config * cfg = config_new (optarg);
@@ -264,7 +282,7 @@ Application::init (int argc, char ** argv) {
 	}
 
 	gdk_threads_enter ();
-	gtk_init (argc, argv);
+	gtk_init (&argc, argv);
 
 	/* Create the window and connect two callback to the signals. */
 	this->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
@@ -307,7 +325,7 @@ Application::init (int argc, char ** argv) {
 
 			if (IS_NULL (ext)) {
 				g_critical ("Config 'extensions' vector is NULL");
-				return -1;
+				return;
 			}
       
 			while ((block = ext->get(ext, ii)) != NULL) {
@@ -332,7 +350,7 @@ Application::init (int argc, char ** argv) {
 
 int
 Application::run (void) {
-	if (proactor.start() == false) {
+	if (proactor()->start() == false) {
 		g_critical ("Failed to start the proactor thread; exiting application.");
 		return -1;
 	}
diff --git a/src/Application.hpp b/src/Application.hpp
index 71564ea..a265685 100755
--- a/src/Application.hpp
+++ b/src/Application.hpp
@@ -22,30 +22,38 @@ public:
 		/**/
 		MAX_SIGNALS
 	};
+
+	GSourceFunc signals[MAX_SIGNALS];
 private:
 	typedef std::list<Workbook *> WorkbookList;
 	typedef std::list<Plugin *> PluginList;
-
-	GSourceFunc signals[MAX_SIGNALS];
+	
 	Workbook * active_workbook;
 	GtkWidget * gtk_window;
 	GtkWidget * gtk_window_vbox;
 	GtkWidget * gtk_menu;
 	Config * cfg;
-	proactor::Proactor proactor;
+	proactor::Proactor pro;
 	WorkbookList workbooks;
 	PluginList plugins;
 	gchar * absolute_path;
 	
-	void init (int argc, char ** argv);
+	void init (int argc, char *** argv);
 public:
-	Application (int argc, char ** argv);
+	Application (int argc, char *** argv);
 	~Application (void);
 
 	int run (void);
 	void shutdown (void);
 	Plugin * load_plugin (const gchar * filename);
 	void open_extension (const gchar * filename, gboolean absolute_path);
+
+	inline GtkWidget * gtkwindow() { return this->gtk_window; }
+	inline GtkWidget * gtkvbox() { return this->gtk_window_vbox; }
+	inline GtkWidget * gtkmenu() { return this->gtk_menu; }
+	inline Config * config() { return this->cfg; }
+	inline proactor::Proactor * proactor() { return &this->pro; }
+	inline Workbook * wb() { return this->active_workbook; }
 };
 
 #endif
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 442a591..fb3f04b 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -21,7 +21,7 @@
 #include <concurrent/ThreadArgs.hpp>
 #include <gtk/gtk.h>
 #include "../config.h"
-#include "../application.h"
+#include "../Application.hpp"
 #include "../plugin.h"
 
 /* Prototypes */
@@ -29,15 +29,15 @@ extern void thread_main (ThreadArgs *);
 
 static void
 open_csv_file (GtkWidget * w, gpointer data) {
-  ApplicationState * app = (ApplicationState *)data;
-  //Config * cfg = app->cfg;
+  Application * app = (Application *)data;
+  Config * cfg = app->config();
   
   GtkWidget * dialog = gtk_file_chooser_dialog_new ("Open File",
-						    GTK_WINDOW (app->gtk_window),
-						    GTK_FILE_CHOOSER_ACTION_OPEN,
-						    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-						    GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-						    NULL);  
+																	 GTK_WINDOW (app->gtkwindow()),
+																	 GTK_FILE_CHOOSER_ACTION_OPEN,
+																	 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+																	 GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+																	 NULL);  
   
   gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (dialog), TRUE);
 
@@ -51,7 +51,7 @@ open_csv_file (GtkWidget * w, gpointer data) {
 }
 
 static GtkWidget *
-largefile_mainmenu_new (ApplicationState * appstate, GtkWidget * window) {
+largefile_mainmenu_new (Application * appstate, GtkWidget * window) {
   GtkItemFactoryEntry menu_items[] = {
     {"/_File",         NULL,		NULL, 		0, 	"<Branch>"},
     {"/File/_Open",    "<CTRL>O",	(GtkItemFactoryCallback)open_csv_file,	0,	"<StockItem>", GTK_STOCK_OPEN},
@@ -80,23 +80,23 @@ largefile_mainmenu_new (ApplicationState * appstate, GtkWidget * window) {
 extern "C" {
 
   Workbook *
-  plugin_main (ApplicationState * appstate, Plugin * plugin) {
+  plugin_main (Application * appstate, Plugin * plugin) {
     ASSERT (appstate != NULL);
     ASSERT (plugin != NULL);
 	
     GtkWidget * box = gtk_vbox_new (FALSE, 0);
-    GtkWidget * mainmenu = largefile_mainmenu_new (appstate, appstate->gtk_window);
+    GtkWidget * mainmenu = largefile_mainmenu_new (appstate, appstate->gtkwindow());
     gtk_box_pack_start (GTK_BOX (box), mainmenu, FALSE, FALSE, 0);
 
     Workbook * wb = NULL;
-    if ((wb = workbook_open (appstate->gtk_window, "largefile")) == NULL) {
+    if ((wb = workbook_open (appstate->gtkwindow(), "largefile")) == NULL) {
       g_critical ("Failed opening workbook; exiting largefile plugin");
       return NULL;
     }
 
     gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
 
-    wb->signals[SIG_WORKBOOK_CHANGED] = appstate->signals[SIG_SHEET_CHANGED];
+    wb->signals[SIG_WORKBOOK_CHANGED] = appstate->signals[Application::SHEET_CHANGED];
         
     wb->gtk_box = box;
     
@@ -104,8 +104,7 @@ extern "C" {
 
     ThreadArgs args;
     args.push_back ( (void *)wb );
-    args.push_back ( (void *)appstate->cfg );
-    args.push_back ( (void *)appstate->shutdown );
+    args.push_back ( (void *)appstate->config() );
 
     if (plugin->create_thread (plugin,
 			       (GThreadFunc)thread_main,
@@ -114,7 +113,7 @@ extern "C" {
       return NULL;
     }
 
-    gtk_box_pack_start (GTK_BOX (appstate->gtk_window_vbox), box, FALSE, FALSE, 0);
+    gtk_box_pack_start (GTK_BOX (appstate->gtkvbox()), box, FALSE, FALSE, 0);
     gtk_widget_show (box);	
     return wb;
   }
diff --git a/src/main.cc b/src/main.cc
new file mode 100644
index 0000000..3dfd78d
--- /dev/null
+++ b/src/main.cc
@@ -0,0 +1,7 @@
+#include "Application.hpp"
+
+int
+main (int argc, char ** argv) {
+	Application app (argc, &argv);
+	return app.run();
+}
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
index 8781f72..469fa28 100755
--- a/src/realtime/plugin_main.cpp
+++ b/src/realtime/plugin_main.cpp
@@ -21,7 +21,7 @@
 #include <gtkworkbook/workbook.h>
 #include <concurrent/ThreadArgs.hpp>
 #include "../config.h"
-#include "../application.h"
+#include "../Application.hpp"
 #include "../plugin.h"
 
 /* Prototypes */
@@ -30,21 +30,19 @@ extern void thread_main (ThreadArgs *);
 extern "C"
 {
   Workbook *
-  plugin_main (ApplicationState * app, Plugin * plugin)
-  {
+  plugin_main (Application * app, Plugin * plugin) {
     ASSERT (app != NULL);
     ASSERT (plugin != NULL);
 
     Workbook * wb = NULL;
     GtkWidget * hbox = gtk_handle_box_new ();
     
-    if ((wb = workbook_open (app->gtk_window, "realtime")) == NULL)
-      {
-	g_critical ("Failed opening workbook; exiting plugin");
-	return NULL;
-      }
+    if ((wb = workbook_open (app->gtkwindow(), "realtime")) == NULL) {
+		 g_critical ("Failed opening workbook; exiting plugin");
+		 return NULL;
+	 }
 
-    wb->signals[SIG_WORKBOOK_CHANGED] = app->signals[SIG_SHEET_CHANGED];
+    wb->signals[SIG_WORKBOOK_CHANGED] = app->signals[Application::SHEET_CHANGED];
 
     gtk_container_add (GTK_CONTAINER (hbox), wb->gtk_notebook);
  
@@ -54,9 +52,8 @@ extern "C"
 
     ThreadArgs args;
     args.push_back( (void *)wb );
-    args.push_back( (void *)app->cfg );
-    args.push_back( (void *)app->shutdown );
-
+    args.push_back( (void *)app );
+  
     if (plugin->create_thread (plugin, 
 			       (GThreadFunc)thread_main,
 			       (gpointer)new ThreadArgs (args)
@@ -66,7 +63,7 @@ extern "C"
 	return NULL;
       }
 
-    gtk_box_pack_start (GTK_BOX (app->gtk_window_vbox), hbox, FALSE,FALSE, 0);
+    gtk_box_pack_start (GTK_BOX (app->gtkvbox()), hbox, FALSE,FALSE, 0);
     gtk_widget_show (hbox);
     return wb;
   }

commit ad5258e7c938ff3582eaf2772ff214c4218d2a48
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 17:00:44 2009 -0400

    Made changes to fix compliation errors.

diff --git a/src/Application.cc b/src/Application.cc
index 070b100..032d831 100755
--- a/src/Application.cc
+++ b/src/Application.cc
@@ -92,10 +92,9 @@ signal_gtksheet_changed (GtkWidget * gtksheet,
    @event: A pointer to the associated GdkEvent information.
    @p: NULL */
 static guint
-application_signal_delete_event (GtkWindow * window, 
+signal_delete_event (GtkWindow * window, 
 											GdkEvent * event,
-											gpointer p)
-{
+											gpointer p) {
 	GtkWidget * dialog 
 		= gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
 										  GTK_MESSAGE_QUESTION,
@@ -115,7 +114,7 @@ application_signal_delete_event (GtkWindow * window,
    @window: A pointer to the GtkWindow object.
    @data: NULL */
 static guint
-application_signal_destroy_event (GtkWidget *window, gpointer data)
+signal_destroy_event (GtkWidget *window, gpointer data)
 {
 	Application * app = (Application *)data;
 	app->shutdown();
@@ -171,9 +170,9 @@ Application::~Application (void) {
 
 Plugin *
 Application::load_plugin (const gchar * filename) {
-	Plugin * plugin = NULL;
+	Plugin * plugin = plugin_open (filename);
 
-	if ((plugin == plugin_open(filename)) != NULL) {
+	if (plugin) {
 		this->plugins.push_back (plugin);
 	}
 	return plugin;
@@ -182,7 +181,6 @@ Application::load_plugin (const gchar * filename) {
 void
 Application::shutdown(void) {
 	// STUB: shutdown the proactor threads here.
-	
 	gtk_main_quit ();
 }
 
diff --git a/src/Application.hpp b/src/Application.hpp
index 917e37f..71564ea 100755
--- a/src/Application.hpp
+++ b/src/Application.hpp
@@ -32,7 +32,7 @@ private:
 	GtkWidget * gtk_window_vbox;
 	GtkWidget * gtk_menu;
 	Config * cfg;
-	Proactor proactor;
+	proactor::Proactor proactor;
 	WorkbookList workbooks;
 	PluginList plugins;
 	gchar * absolute_path;
@@ -43,7 +43,9 @@ public:
 	~Application (void);
 
 	int run (void);
-	
+	void shutdown (void);
+	Plugin * load_plugin (const gchar * filename);
+	void open_extension (const gchar * filename, gboolean absolute_path);
 };
 
 #endif

commit 930d125f14e894e381144a82f94cc9dd9cef1c1f
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 16:56:01 2009 -0400

    Changed names of files to reflect change to C++ compiler.

diff --git a/include/shared.h b/include/shared.h
index 659306f..1e561a7 100755
--- a/include/shared.h
+++ b/include/shared.h
@@ -1,6 +1,4 @@
 /* 
-   shared.h - Shared Macro Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -26,7 +24,7 @@
 
 #define ASSERT(c) g_assert(c)
 #define FREE(p) { if (p) { g_free (p); p = NULL; } }
-#define NEW(T) g_malloc (sizeof (T))
+#define NEW(T) (T*)g_malloc (sizeof (T))
 #define NEW_ARRAY(T,n) g_malloc (sizeof(T)*n))
 
 #define IS_NULLSTR(s) (!s || (*s == '\0'))
diff --git a/src/Makefile b/src/Makefile
index 9534d4c..418d71d 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,7 +1,7 @@
 include ../Makefile.base
 
-SRCS=$(wildcard *.c)
-OBJS=$(patsubst %.c,${OBJDIR}/%.o,${SRCS})
+SRCS=$(wildcard *.cc) $(wildcard concurrent/*.cc) $(wildcard network/*.cc) $(wildcard proactor/*.cc) 
+OBJS=$(patsubst %.cc,${OBJDIR}/%.o,${SRCS})
 
 LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0
 
@@ -10,7 +10,7 @@ all: 	gtkworkbook
 	make -C largefile/ all
 
 gtkworkbook: ${OBJS}
-	${CC} -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
+	${CX} -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
 
 clean:		
 	${MD} ${OBJDIR}	
@@ -24,8 +24,8 @@ install: all
 	make -C realtime/ install
 	make -C largefile/ install
 
-${OBJDIR}/%.o: %.c
-	${CC} ${INCS} -c ${CCFLAGS} $< -o $@
+${OBJDIR}/%.o: %.cc
+	${CX} ${INCS} -c ${CXFLAGS} $< -o $@
 
-.c.o:
-	${CC} ${INCS} -c ${CCFLAGS} $<
+.cc.o:
+	${CX} ${INCS} -c ${CXFLAGS} $<
diff --git a/src/concurrent/Mutex.cc b/src/concurrent/Mutex.cc
new file mode 100755
index 0000000..43ec628
--- /dev/null
+++ b/src/concurrent/Mutex.cc
@@ -0,0 +1,89 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  IMutex::IMutex (void) {
+    this->mutex = NULL;
+    this->attrib = NULL;
+  }
+
+  IMutex::IMutex (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+  }
+
+  IMutex::~IMutex (void) {
+  }
+
+  IMutex & 
+  IMutex::operator= (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+    return *this;
+  }
+
+  void
+  IMutex::lock (void) {
+    pthread_mutex_lock (this->mutex);
+  }
+
+  void 
+  IMutex::unlock (void) {
+    pthread_mutex_unlock (this->mutex);
+  }
+
+  bool
+  IMutex::trylock (void) {
+    return (pthread_mutex_trylock (this->mutex) == 0) ?
+      true : false;
+  }
+  
+  RecursiveMutex::RecursiveMutex (void) {
+    this->mutex = new pthread_mutex_t;
+    this->attrib = new pthread_mutexattr_t;
+
+    pthread_mutexattr_init (this->attrib);
+    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+    
+    pthread_mutex_init (this->mutex, attrib);
+  }
+
+  RecursiveMutex::~RecursiveMutex (void) {
+    pthread_mutex_destroy (this->mutex);
+    pthread_mutexattr_destroy (this->attrib);
+
+    delete this->mutex;
+    delete this->attrib;
+  }
+
+  Mutex::Mutex (void) {
+    this->mutex = new pthread_mutex_t;
+
+    pthread_mutex_init (this->mutex, NULL);
+  }
+
+  Mutex::~Mutex (void) {
+    pthread_mutex_destroy (this->mutex);
+
+    delete this->mutex;
+  }
+
+} // end of namespace
diff --git a/src/concurrent/Mutex.cpp b/src/concurrent/Mutex.cpp
deleted file mode 100755
index 43ec628..0000000
--- a/src/concurrent/Mutex.cpp
+++ /dev/null
@@ -1,89 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  IMutex::IMutex (void) {
-    this->mutex = NULL;
-    this->attrib = NULL;
-  }
-
-  IMutex::IMutex (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-  }
-
-  IMutex::~IMutex (void) {
-  }
-
-  IMutex & 
-  IMutex::operator= (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-    return *this;
-  }
-
-  void
-  IMutex::lock (void) {
-    pthread_mutex_lock (this->mutex);
-  }
-
-  void 
-  IMutex::unlock (void) {
-    pthread_mutex_unlock (this->mutex);
-  }
-
-  bool
-  IMutex::trylock (void) {
-    return (pthread_mutex_trylock (this->mutex) == 0) ?
-      true : false;
-  }
-  
-  RecursiveMutex::RecursiveMutex (void) {
-    this->mutex = new pthread_mutex_t;
-    this->attrib = new pthread_mutexattr_t;
-
-    pthread_mutexattr_init (this->attrib);
-    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
-    
-    pthread_mutex_init (this->mutex, attrib);
-  }
-
-  RecursiveMutex::~RecursiveMutex (void) {
-    pthread_mutex_destroy (this->mutex);
-    pthread_mutexattr_destroy (this->attrib);
-
-    delete this->mutex;
-    delete this->attrib;
-  }
-
-  Mutex::Mutex (void) {
-    this->mutex = new pthread_mutex_t;
-
-    pthread_mutex_init (this->mutex, NULL);
-  }
-
-  Mutex::~Mutex (void) {
-    pthread_mutex_destroy (this->mutex);
-
-    delete this->mutex;
-  }
-
-} // end of namespace
diff --git a/src/concurrent/ScopedMemoryLock.cc b/src/concurrent/ScopedMemoryLock.cc
new file mode 100755
index 0000000..eb9b901
--- /dev/null
+++ b/src/concurrent/ScopedMemoryLock.cc
@@ -0,0 +1,118 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ScopedMemoryLock.hpp"
+
+namespace concurrent {
+  ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
+
+  ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
+    this->hasLock = false;
+    this->address = address;
+    this->mutex = NULL;
+
+    ScopedMemoryLock::addressMutexMap.lock();
+    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+    ScopedMemoryLock::addressMutexMap.unlock();
+
+    /* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
+       if someone is passing an address that has not been formally added via the static method
+       call then that means it is very unlikely that they are not removing it either. We do
+       not want a memory leak therefore this seems like the best method. */
+    if (it != ScopedMemoryLock::addressMutexMap.end()) 
+      this->mutex = it->second;
+
+    if (engage == true)
+      this->lock();
+  }
+
+  ScopedMemoryLock::~ScopedMemoryLock (void) {
+    if (this->hasLock == true)
+      unlock();
+  }
+
+  void
+  ScopedMemoryLock::lock (void) {
+    this->mutex->lock();
+    this->hasLock = true;
+  }
+
+  void 
+  ScopedMemoryLock::unlock (void) {
+    this->mutex->unlock();
+    this->hasLock = false;
+  }
+
+  bool
+  ScopedMemoryLock::trylock (void) {
+    this->hasLock = this->mutex->trylock();
+    return this->hasLock;
+  }
+
+  bool
+  ScopedMemoryLock::remove (void) {
+    if (this->hasLock == false) {
+      return false;
+    }
+
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+    if (it != addressMutexMap.end()) {
+      delete it->second;
+      addressMutexMap.end();
+      result = true;
+    }
+    
+    addressMutexMap.unlock();
+    return result;
+  }
+
+  bool 
+  ScopedMemoryLock::addMemoryLock (unsigned long address) {
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
+    if (it == addressMutexMap.end()) {
+      addressMutexMap.insert (std::make_pair (address, new Mutex));
+      result = true;
+    }
+
+    addressMutexMap.unlock();
+    return result;
+  }
+
+  bool 
+  ScopedMemoryLock::removeMemoryLock (unsigned long address) {
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
+    if (it != addressMutexMap.end()) {
+      delete it->second;
+      addressMutexMap.erase(it);
+      result = true;
+    }
+
+    addressMutexMap.unlock();
+    return result;
+  }
+
+} // end of namespace
diff --git a/src/concurrent/ScopedMemoryLock.cpp b/src/concurrent/ScopedMemoryLock.cpp
deleted file mode 100755
index eb9b901..0000000
--- a/src/concurrent/ScopedMemoryLock.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ScopedMemoryLock.hpp"
-
-namespace concurrent {
-  ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
-
-  ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
-    this->hasLock = false;
-    this->address = address;
-    this->mutex = NULL;
-
-    ScopedMemoryLock::addressMutexMap.lock();
-    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-    ScopedMemoryLock::addressMutexMap.unlock();
-
-    /* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
-       if someone is passing an address that has not been formally added via the static method
-       call then that means it is very unlikely that they are not removing it either. We do
-       not want a memory leak therefore this seems like the best method. */
-    if (it != ScopedMemoryLock::addressMutexMap.end()) 
-      this->mutex = it->second;
-
-    if (engage == true)
-      this->lock();
-  }
-
-  ScopedMemoryLock::~ScopedMemoryLock (void) {
-    if (this->hasLock == true)
-      unlock();
-  }
-
-  void
-  ScopedMemoryLock::lock (void) {
-    this->mutex->lock();
-    this->hasLock = true;
-  }
-
-  void 
-  ScopedMemoryLock::unlock (void) {
-    this->mutex->unlock();
-    this->hasLock = false;
-  }
-
-  bool
-  ScopedMemoryLock::trylock (void) {
-    this->hasLock = this->mutex->trylock();
-    return this->hasLock;
-  }
-
-  bool
-  ScopedMemoryLock::remove (void) {
-    if (this->hasLock == false) {
-      return false;
-    }
-
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-    if (it != addressMutexMap.end()) {
-      delete it->second;
-      addressMutexMap.end();
-      result = true;
-    }
-    
-    addressMutexMap.unlock();
-    return result;
-  }
-
-  bool 
-  ScopedMemoryLock::addMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it == addressMutexMap.end()) {
-      addressMutexMap.insert (std::make_pair (address, new Mutex));
-      result = true;
-    }
-
-    addressMutexMap.unlock();
-    return result;
-  }
-
-  bool 
-  ScopedMemoryLock::removeMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it != addressMutexMap.end()) {
-      delete it->second;
-      addressMutexMap.erase(it);
-      result = true;
-    }
-
-    addressMutexMap.unlock();
-    return result;
-  }
-
-} // end of namespace
diff --git a/src/concurrent/Semaphore.cc b/src/concurrent/Semaphore.cc
new file mode 100755
index 0000000..4e5a58d
--- /dev/null
+++ b/src/concurrent/Semaphore.cc
@@ -0,0 +1,42 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Semaphore.hpp"
+
+namespace concurrent {
+
+  Semaphore::Semaphore (void) {
+    sem_init (&this->semaphore, 0, 0);
+  }
+
+  Semaphore::~Semaphore (void) {
+    sem_destroy (&this->semaphore);
+  }
+
+  void
+  Semaphore::acquire (void) {
+    sem_wait (&this->semaphore);
+  }
+
+  void
+  Semaphore::release (void) {
+    sem_post (&this->semaphore);
+  }
+
+} // end of namespace
+
diff --git a/src/concurrent/Semaphore.cpp b/src/concurrent/Semaphore.cpp
deleted file mode 100755
index 4e5a58d..0000000
--- a/src/concurrent/Semaphore.cpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Semaphore.hpp"
-
-namespace concurrent {
-
-  Semaphore::Semaphore (void) {
-    sem_init (&this->semaphore, 0, 0);
-  }
-
-  Semaphore::~Semaphore (void) {
-    sem_destroy (&this->semaphore);
-  }
-
-  void
-  Semaphore::acquire (void) {
-    sem_wait (&this->semaphore);
-  }
-
-  void
-  Semaphore::release (void) {
-    sem_post (&this->semaphore);
-  }
-
-} // end of namespace
-
diff --git a/src/concurrent/Thread.cc b/src/concurrent/Thread.cc
new file mode 100755
index 0000000..5b7f143
--- /dev/null
+++ b/src/concurrent/Thread.cc
@@ -0,0 +1,129 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Thread.hpp"
+#include "ThreadGroup.hpp"
+#include <iostream>
+#include <ctime>
+
+namespace concurrent {
+
+	static void *
+	thread_run (void * runner) {
+		void * rvalue = ((IRunnable *)runner)->run (NULL);
+		return rvalue;
+	}
+
+	Thread::Thread (ThreadGroup * group,
+						 IRunnable * runner, 
+						 const std::string & name) : thread(0) {
+		this->group = group;
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (IRunnable * runner,
+						 const std::string & name) 
+		: group(NULL), thread(0) {
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (const std::string & name) 
+		: group(NULL), runner(NULL), thread(0) {
+		this->name = name;
+	}
+
+	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
+	}
+
+	Thread::~Thread (void) {
+		if (this->running == true) {
+			this->running = false;
+			this->join();
+		}
+	}
+
+	void 
+	Thread::interrupt (void) {
+		this->running = false;
+		pthread_cancel (this->thread);
+		pthread_detach (this->thread);
+	}
+
+	void 
+	Thread::yield (void) {
+		pthread_yield();
+	}
+
+	void * 
+	Thread::stop (void) {
+		this->running = false;
+		return this->join();
+	}
+
+	int 
+	Thread::sleep (unsigned long ms) {
+		struct timespec req = {0};
+		time_t sec = (int)(ms/1000);
+		ms = ms - (sec*1000);
+		req.tv_sec = sec;
+		req.tv_nsec = ms*1000000L;
+		while (nanosleep (&req, &req) == -1)
+			continue;
+		return 1;
+	}
+
+	bool 
+	Thread::start (void) {
+		if (this->running == true)
+			return false;
+
+		if (this->runner != NULL) {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this->runner))
+				return false;
+		}
+		else {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this))
+				return false;
+		}
+
+		this->running = true;
+		return true;
+	}
+
+	void *
+	Thread::join (void) {
+		void * rvalue = NULL;
+		if (this->thread > 0)
+			pthread_join (this->thread, &rvalue);
+		return rvalue;
+	}
+
+	void *
+	Thread::run (void *null) {
+		pthread_exit (null);
+	}
+
+} // end of namespace
diff --git a/src/concurrent/Thread.cpp b/src/concurrent/Thread.cpp
deleted file mode 100755
index 5b7f143..0000000
--- a/src/concurrent/Thread.cpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Thread.hpp"
-#include "ThreadGroup.hpp"
-#include <iostream>
-#include <ctime>
-
-namespace concurrent {
-
-	static void *
-	thread_run (void * runner) {
-		void * rvalue = ((IRunnable *)runner)->run (NULL);
-		return rvalue;
-	}
-
-	Thread::Thread (ThreadGroup * group,
-						 IRunnable * runner, 
-						 const std::string & name) : thread(0) {
-		this->group = group;
-		this->runner = runner;
-		this->name = name;
-	}
-
-	Thread::Thread (IRunnable * runner,
-						 const std::string & name) 
-		: group(NULL), thread(0) {
-		this->runner = runner;
-		this->name = name;
-	}
-
-	Thread::Thread (const std::string & name) 
-		: group(NULL), runner(NULL), thread(0) {
-		this->name = name;
-	}
-
-	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
-	}
-
-	Thread::~Thread (void) {
-		if (this->running == true) {
-			this->running = false;
-			this->join();
-		}
-	}
-
-	void 
-	Thread::interrupt (void) {
-		this->running = false;
-		pthread_cancel (this->thread);
-		pthread_detach (this->thread);
-	}
-
-	void 
-	Thread::yield (void) {
-		pthread_yield();
-	}
-
-	void * 
-	Thread::stop (void) {
-		this->running = false;
-		return this->join();
-	}
-
-	int 
-	Thread::sleep (unsigned long ms) {
-		struct timespec req = {0};
-		time_t sec = (int)(ms/1000);
-		ms = ms - (sec*1000);
-		req.tv_sec = sec;
-		req.tv_nsec = ms*1000000L;
-		while (nanosleep (&req, &req) == -1)
-			continue;
-		return 1;
-	}
-
-	bool 
-	Thread::start (void) {
-		if (this->running == true)
-			return false;
-
-		if (this->runner != NULL) {
-			if (pthread_create (&this->thread,
-									  NULL,
-									  thread_run,
-									  this->runner))
-				return false;
-		}
-		else {
-			if (pthread_create (&this->thread,
-									  NULL,
-									  thread_run,
-									  this))
-				return false;
-		}
-
-		this->running = true;
-		return true;
-	}
-
-	void *
-	Thread::join (void) {
-		void * rvalue = NULL;
-		if (this->thread > 0)
-			pthread_join (this->thread, &rvalue);
-		return rvalue;
-	}
-
-	void *
-	Thread::run (void *null) {
-		pthread_exit (null);
-	}
-
-} // end of namespace
diff --git a/src/concurrent/ThreadGroup.cc b/src/concurrent/ThreadGroup.cc
new file mode 100755
index 0000000..f50b487
--- /dev/null
+++ b/src/concurrent/ThreadGroup.cc
@@ -0,0 +1,105 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadGroup.hpp"
+#include <algorithm>
+
+namespace concurrent {
+
+  ThreadGroup::ThreadGroup (void) 
+    : parent(NULL), daemon(false) {
+  }
+
+  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
+    : daemon(false) {
+    this->parent = parent;
+    this->name = name;
+  }
+
+  ThreadGroup::ThreadGroup (const std::string & name) 
+    : parent(NULL), daemon(false) {
+    this->name = name;
+  }
+
+  ThreadGroup::~ThreadGroup (void) {
+    if (this->daemon == true) {
+      this->stop();
+    }
+  }
+
+  bool 
+  ThreadGroup::parentOf (ThreadGroup * parent) {
+    if ((this->parent == NULL) || (parent == NULL))
+      return false;
+    // Needs to be better than this. 
+    return (this->parent == parent) ? true : false;
+  } 
+    
+  bool
+  ThreadGroup::addThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+    if (it == this->threads.end()) {
+      thread->group = this;
+      this->threads.push_back (thread);
+      return true;
+    }
+    return false;
+  }
+
+  bool 
+  ThreadGroup::removeThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+
+    if (it == this->threads.end())
+      return false;
+    this->threads.erase(it);
+    return true;
+  }
+
+  void
+  ThreadGroup::interrupt (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->interrupt();
+    }
+  }
+
+  bool
+  ThreadGroup::start (void) {
+    bool rvalue = false;
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      rvalue = (*it++)->start();
+    }
+
+    return rvalue;
+  }
+
+  void 
+  ThreadGroup::stop (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->stop();
+    }
+  }
+} // end of namesapce
diff --git a/src/concurrent/ThreadGroup.cpp b/src/concurrent/ThreadGroup.cpp
deleted file mode 100755
index f50b487..0000000
--- a/src/concurrent/ThreadGroup.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadGroup.hpp"
-#include <algorithm>
-
-namespace concurrent {
-
-  ThreadGroup::ThreadGroup (void) 
-    : parent(NULL), daemon(false) {
-  }
-
-  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
-    : daemon(false) {
-    this->parent = parent;
-    this->name = name;
-  }
-
-  ThreadGroup::ThreadGroup (const std::string & name) 
-    : parent(NULL), daemon(false) {
-    this->name = name;
-  }
-
-  ThreadGroup::~ThreadGroup (void) {
-    if (this->daemon == true) {
-      this->stop();
-    }
-  }
-
-  bool 
-  ThreadGroup::parentOf (ThreadGroup * parent) {
-    if ((this->parent == NULL) || (parent == NULL))
-      return false;
-    // Needs to be better than this. 
-    return (this->parent == parent) ? true : false;
-  } 
-    
-  bool
-  ThreadGroup::addThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-    if (it == this->threads.end()) {
-      thread->group = this;
-      this->threads.push_back (thread);
-      return true;
-    }
-    return false;
-  }
-
-  bool 
-  ThreadGroup::removeThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-
-    if (it == this->threads.end())
-      return false;
-    this->threads.erase(it);
-    return true;
-  }
-
-  void
-  ThreadGroup::interrupt (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->interrupt();
-    }
-  }
-
-  bool
-  ThreadGroup::start (void) {
-    bool rvalue = false;
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      rvalue = (*it++)->start();
-    }
-
-    return rvalue;
-  }
-
-  void 
-  ThreadGroup::stop (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->stop();
-    }
-  }
-} // end of namesapce
diff --git a/src/concurrent/ThreadPool.cc b/src/concurrent/ThreadPool.cc
new file mode 100755
index 0000000..cd6890e
--- /dev/null
+++ b/src/concurrent/ThreadPool.cc
@@ -0,0 +1,123 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadPool.hpp"
+
+namespace concurrent {
+  int ThreadPool::defaultTaskMax = 5;
+
+  ThreadPool::Task::Task (ThreadPool * pool) {
+    this->pool = pool;
+  }
+
+  void *
+  ThreadPool::Task::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+		 if (this->pool->isRunning() == false)
+			 break;
+      
+		 if (this->pool->getQueueSize() > 0) {
+			 IRunnable * runner = this->pool->removeFromQueue();
+			 runner->run (NULL);
+			 delete runner;
+		 }
+		 Thread::sleep (1);
+    }
+
+    return NULL;
+  }
+
+  ThreadPool::ThreadPool (void) {
+    this->running = false;
+
+    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::ThreadPool (int N) {
+    this->running = false;
+
+    for (int ii = 0; ii < N; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::~ThreadPool (void) {
+    if (this->running == true)
+      this->stop(true);
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      Thread * t = (*it); it++;
+      delete t;
+    }
+
+    while (this->runQueue.size() > 0) {
+      IRunnable * r = this->runQueue.pop();
+      delete r;
+    }
+  }
+
+  void 
+  ThreadPool::start (void) {
+    this->running = true;
+    
+	 ThreadList::iterator it = this->threads.begin();
+	 while (it != this->threads.end())
+    {
+		 (*it)->start();
+		 it++;
+    }
+  }
+
+  void 
+  ThreadPool::stop (bool join) {
+    this->running = false;
+
+    /* Waiting to join all of the threads will mean that the thread that the
+       pool is calling the stop() method from will block until all of the 
+       threads inside of the pool have stopped.
+
+       There is a PROBLEM here. If you call this, for some reason, from inside
+       of one of the Task threads then you are going to hit a deadlock. Never
+       pass the join parameter if this is being called from inside the Tasks.*/
+    if (join == true) {
+		 ThreadList::iterator it = this->threads.begin();
+		 while (it != this->threads.end()) {
+			 (*it)->stop();
+			 it++;
+		 }
+    }
+  }
+
+  void 
+  ThreadPool::execute (IRunnable * runner) {
+    this->runQueue.push (runner);
+  }
+
+} // end of namespace
+
diff --git a/src/concurrent/ThreadPool.cpp b/src/concurrent/ThreadPool.cpp
deleted file mode 100755
index cd6890e..0000000
--- a/src/concurrent/ThreadPool.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadPool.hpp"
-
-namespace concurrent {
-  int ThreadPool::defaultTaskMax = 5;
-
-  ThreadPool::Task::Task (ThreadPool * pool) {
-    this->pool = pool;
-  }
-
-  void *
-  ThreadPool::Task::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
-		 if (this->pool->isRunning() == false)
-			 break;
-      
-		 if (this->pool->getQueueSize() > 0) {
-			 IRunnable * runner = this->pool->removeFromQueue();
-			 runner->run (NULL);
-			 delete runner;
-		 }
-		 Thread::sleep (1);
-    }
-
-    return NULL;
-  }
-
-  ThreadPool::ThreadPool (void) {
-    this->running = false;
-
-    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::ThreadPool (int N) {
-    this->running = false;
-
-    for (int ii = 0; ii < N; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::~ThreadPool (void) {
-    if (this->running == true)
-      this->stop(true);
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      Thread * t = (*it); it++;
-      delete t;
-    }
-
-    while (this->runQueue.size() > 0) {
-      IRunnable * r = this->runQueue.pop();
-      delete r;
-    }
-  }
-
-  void 
-  ThreadPool::start (void) {
-    this->running = true;
-    
-	 ThreadList::iterator it = this->threads.begin();
-	 while (it != this->threads.end())
-    {
-		 (*it)->start();
-		 it++;
-    }
-  }
-
-  void 
-  ThreadPool::stop (bool join) {
-    this->running = false;
-
-    /* Waiting to join all of the threads will mean that the thread that the
-       pool is calling the stop() method from will block until all of the 
-       threads inside of the pool have stopped.
-
-       There is a PROBLEM here. If you call this, for some reason, from inside
-       of one of the Task threads then you are going to hit a deadlock. Never
-       pass the join parameter if this is being called from inside the Tasks.*/
-    if (join == true) {
-		 ThreadList::iterator it = this->threads.begin();
-		 while (it != this->threads.end()) {
-			 (*it)->stop();
-			 it++;
-		 }
-    }
-  }
-
-  void 
-  ThreadPool::execute (IRunnable * runner) {
-    this->runQueue.push (runner);
-  }
-
-} // end of namespace
-
diff --git a/src/config.c b/src/config.c
deleted file mode 100755
index 0fced05..0000000
--- a/src/config.c
+++ /dev/null
@@ -1,761 +0,0 @@
-/*
-  config.c - Configuration File Object/Parser
-
-  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <config/config.h>
-#include <stdlib.h>
-#include <string.h>
-#include "parse.h"
-
-/* config.c (static) */
-
-static Config *config_object_init (const gchar *);
-static ConfigPair *configpair_object_init (ConfigRow *, 
-					   const gchar *,
-					   const gchar *);
-static ConfigRow *configrow_object_init (ConfigBlock *, const gchar *);
-static ConfigBlock *configblock_object_init (Config *, const gchar *);
-static ConfigVector *configvector_object_init (ConfigRow *,const gchar *);
-static void configrow_object_free (ConfigRow *);
-static void configblock_object_free (ConfigBlock *);
-static void configpair_object_free (ConfigPair *);
-static void config_object_free (Config *);
-static void configvector_object_free (ConfigVector *);
-static ConfigVector *config_method_get_vector (Config *,
-					       const gchar *,
-					       const gchar *,
-					       const gchar *);
-static ConfigPair *config_method_get_pair (Config *,
-					   const gchar *,
-					   const gchar *,
-					   const gchar *);
-static ConfigBlock *config_method_get_block (Config *, const gchar *);
-static ConfigPair *configblock_method_get_pair (ConfigBlock *, 
-						const gchar *,
-						const gchar *);
-static ConfigRow *config_method_get_row (Config *,
-					 const gchar *, 
-					 const gchar *);
-static ConfigRow *configblock_method_get_row (ConfigBlock *, const gchar *);
-static gchar *configrow_method_parse (ConfigRow *, gchar *);
-static void configrow_method_destroy (ConfigRow *);
-static ConfigPair *configrow_method_get_pair (ConfigRow *, const gchar *);
-static ConfigVector *configrow_method_get_vector (ConfigRow *, const gchar *);
-static void configpair_method_destroy (ConfigPair *);
-static void configblock_method_destroy (ConfigBlock *);
-static void configvector_method_destroy (ConfigVector *);
-static gint configvector_method_get_int (ConfigVector *, gint);
-static gchar *configvector_method_get (ConfigVector *, gint);
-static void configvector_method_add (ConfigVector *, const gchar *);
-static gchar *configblock_method_parse (ConfigBlock *, gchar *, FILE *);
-static void config_method_destroy (Config *);
-static gint config_method_open (Config *);
-static gint config_method_save (Config *, const gchar *);
-static gint config_method_load (Config *, FILE *);
-
-ConfigBlock *
-configblock_new (Config * c, const gchar * tag)
-{
-  /* No NULL tags. */
-  if (IS_NULLSTR (tag)) return NULL;
-  return configblock_object_init (c, tag);
-}
-
-static gchar *
-configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
-{
-  ASSERT (block != NULL);
-  ASSERT (p != NULL);
-
-  if (!fp || feof (fp)) return FALSE;
-
-  gchar buf[1024], word[1024];
-  gchar * q = NULL;
-  g_stpcpy (word, p);
-
-  /* This block of code makes sure that we indeed have an opening brace
-    to continue with parsing of the configuration file. */
-  do
-    {
-      p = word;
-      
-      if (EXPECT (p, q, '{'))
-	{
-	  g_stpcpy (buf, q + 1);
-	  break;
-	} 
-
-      if (*q == '\0')
-	continue;
-      return NULL;
-    } while (fgets (word, 1024, fp) != NULL);
-
-  /* Start actually parsing rows now. */
-  do 
-    {
-      p = buf;
-      do
-	{
-	  if (*p == '}')
-	    return p;
-	  else if (*p == '\n')
-	    {
-	      p++;
-	      continue;
-	    }
-	  else 
-	    {
-	      if ((q = parse (p, &word[0], 1024, ':')) != NULL)
-		{
-		  if (*(q+1) == ':')
-		    {
-		      ConfigRow * row 
-			= block->get_row (block, trim (&word[0]));
-		      
-		      if (row)
-			{
-			  fprintf (stderr, "**CONFIG**: row '%s' already"
-				   " defined in block '%s'; replacing\n",
-				   row->tag, block->tag);
-			  fflush (stderr);
-
-			  row->destroy (row);
-			}
-
-		      row = configrow_new (block, trim (&word[0]));
-		    
-		      if ((p = row->parse (row, q+2)) == NULL)
-			{
-			  fprintf (stderr, "Error parsing line: %s", buf);
-			  fflush (stderr);
-			  return NULL;
-			}
-		      break;
-		    }
-		}
-	    }
-	  fprintf (stderr, "Error in formatting on line: %s\n", buf);
-	  fflush (stderr);
-	  return NULL;
-	} while (*p != '\0');
-     } while (fgets (buf, 1024, fp) != NULL);
-  return NULL;
-}
-
-static void
-configblock_method_destroy (ConfigBlock * block)
-{
-  ASSERT (block != NULL);
-
-  DESTROY (ConfigRow, block->row_head);
-  SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
-		 block->cfg->block_tail, block);
-  
-  configblock_object_free (block);
-}
-
-static ConfigRow *
-configblock_method_get_row (ConfigBlock * block, const gchar * row)
-{
-  ASSERT (block != NULL);
-
-  if (!IS_NULLSTR (row))
-    {
-      ITERATE_BEGIN (ConfigRow, block->row_head);
-      {
-	if (!strcmp (it->tag, row))
-	  return it;
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static ConfigPair *
-configblock_method_get_pair (ConfigBlock * block, 
-			     const gchar * row,
-			     const gchar * key)
-{
-  ASSERT (block != NULL);
-
-  if (!IS_NULLSTR (row))
-    {
-      ITERATE_BEGIN (ConfigRow, block->row_head);
-      {
-	if (!strcmp (it->tag, row))
-	  return it->get_pair (it, key);
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static void
-configblock_object_free (ConfigBlock * block)
-{
-  ASSERT (block != NULL);
-
-  FREE (block->tag);
-  
-  FREE (block);
-  block = NULL;
-}
-
-static ConfigBlock *
-configblock_object_init (Config * c, const gchar * tag)
-{
-  ASSERT (c != NULL);
-
-  ConfigBlock * b = NEW (ConfigBlock);
-
-  /* Members */
-  b->cfg = c;
-  b->tag = g_strdup (tag);
-  b->next = NULL; 
-  b->row_head = b->row_tail = NULL;
-  
-  /* Methods */
-  b->parse = configblock_method_parse;
-  b->destroy = configblock_method_destroy;
-  b->get_row = configblock_method_get_row;
-  b->get_pair = configblock_method_get_pair;
-
-  SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
-  return b;
-}
-
-Config *
-config_new (const gchar * filename)
-{
-  return config_object_init (filename);
-}
-
-static void
-config_method_destroy (Config * c)
-{
-  ASSERT (c != NULL);
-
-  DESTROY (ConfigBlock, c->block_head);
-  
-  config_object_free (c);
-}
-
-static ConfigRow *
-config_method_get_row (Config * cfg, const gchar * block, const gchar * row)
-{
-  ASSERT (cfg != NULL);
- 
-  ConfigBlock * b = cfg->get_block (cfg, block);
-  if (b == NULL)
-    return NULL;
-  return b->get_row (b, row);
-}
-
-static ConfigBlock *
-config_method_get_block (Config * cfg, const gchar * block)
-{
-  ASSERT (cfg != NULL);
-
-  if (!IS_NULLSTR (block))
-    {
-      ITERATE_BEGIN (ConfigBlock, cfg->block_head);
-      {
-	if (!strcmp (it->tag, block))
-	  return it;
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static ConfigPair *
-config_method_get_pair (Config * cfg, 
-			const gchar * block, 
-			const gchar * row,
-			const gchar * pair)
-{
-  ASSERT (cfg != NULL);
-
-  ConfigRow * r = cfg->get_row (cfg, block, row);
-  if (r == NULL)
-    return NULL;
-  return r->get_pair (r, pair);
-}
-
-static ConfigVector *
-config_method_get_vector (Config * cfg,
-			  const gchar * block,
-			  const gchar * row,
-			  const gchar * vector)
-{
-  ASSERT (cfg != NULL);
-  
-  ConfigRow * r = cfg->get_row (cfg, block, row);
-  if (r == NULL)
-    return NULL;
-  return r->get_vector (r, vector);
-}
-
-static void
-config_object_free (Config * c)
-{
-  ASSERT (c != NULL);
-
-  FREE (c->filename);
-
-  FREE (c);
-  c = NULL;
-}
-
-static Config *
-config_object_init (const gchar * filename)
-{
-  Config * c = NEW (Config);
-
-  /* Members */
-  c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
-  c->block_head = c->block_tail = NULL;
-
-  /* Methods */
-  c->open = config_method_open;
-  c->save = config_method_save;
-  c->load = config_method_load;
-  c->close = config_method_destroy;
-  c->get_vector = config_method_get_vector;
-  c->get_row = config_method_get_row;
-  c->get_block = config_method_get_block;
-  c->get_pair = config_method_get_pair;
-
-  return c;
-}
-
-static gint
-config_method_load (Config * c, FILE * fp)
-{
-  ASSERT (c != NULL);
-  
-  if (!fp || feof(fp))
-    {
-      /* STUB: log me? */
-      return FALSE;
-    }
-
-  gchar * buf = g_malloc (sizeof (char) * 1024);
-  gchar word[1024];
-  gchar * p = NULL, * q = NULL, * r = NULL;
-
-  while ((p = fgets (buf, 1024, fp)) != NULL) {
-      r = buf + (strlen (buf) - 1);
- 
-      while (p && (p < r) && (*p != '\n'))
-	{
-	  if (*p == '%')
-	    {
-	      if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
-		/* STUB: exit parsing with a failure. */
-		g_free (buf);	
-		return FALSE;
-	      }
-
-	      if (strcmp (word, "block") == 0)
-		{
-		  if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
-		    g_free(buf);
-		    return FALSE;
-		  }
-		  
-		  /* Replace the block if it already exists. Throw error. */
-		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
-		  if (b)
-		    {
-		      fprintf (stderr, "**CONFIG**: block '%s' already"
-			       "exists. Destroying and replacing.\n", b->tag);
-		      fflush (stderr);
-		      b->destroy (b);
-		    }
-
-		  b = configblock_new (c, trim (&word[0]));
-
-		  if ((p = b->parse (b, q, fp)) == NULL) {
-		    g_free (buf);
-		    return FALSE;
-		  }
-		}
-	      else if (strcmp (word, "include") == 0)
-		{
-		  if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
-		    g_free (buf);
-		    return FALSE;
-		  }
-
-		  /* Include the file; we're going to load up this file
-		     first and then proceed with parsing. */
-		  FILE * ifp = NULL;
-		 
-		  if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
-		    {
-		      fprintf (stderr, "**CONFIG**: include '%s' does not"
-			       " seem to exist or unable to read.\n",
-			       word);
-		      fflush (stderr);
-		      continue;
-		    }
-
-		  c->load (c, ifp);
-		}
-	      else {
-		g_free (buf);
-		return FALSE;
-	      }
-	    }
-	  /* BUGFIX: Need to check for tabs. */
-	  else if ((*p != ' ') && (*p != '\t'))
-	    {
-	      /* STUB: error out */
-	      g_free (buf);
-	      return FALSE;
-	    }
-
-	  p++;
-	}
-    }
-  g_free (buf);
-  return TRUE;
-}
-
-static gint
-config_method_save (Config * c, const gchar * filename)
-{
-  ASSERT (c != NULL);
-
-  if (IS_NULLSTR (filename)) return FALSE;
-
-  FILE * fp = NULL;
-  if ((fp = fopen (filename, "w")) == NULL)
-    {
-      /* STUB: log me? */
-      return FALSE;
-    }
-  
-  FCLOSE (fp);
-  return TRUE;
-}
-
-static gint
-config_method_open (Config * c)
-{
-  ASSERT (c != NULL);
-
-  if (IS_NULLSTR (c->filename))
-    return FALSE;
-
-  FILE * fp = NULL;
-  if ((fp = fopen (c->filename, "r")) == NULL)
-    {
-      /* STUB: log this? */
-      return FALSE;
-    }
-
-  gint result = c->load (c, fp);
-  if (result == FALSE)
-    {
-      /* STUB: log me? */
-    }
-
-  FCLOSE (fp);
-  return result;
-}
-
-ConfigPair *
-configpair_new (ConfigRow * row, const gchar * key, const gchar * value)
-{
-  return configpair_object_init (row, key, value);
-}
-
-static ConfigPair *
-configpair_object_init (ConfigRow * row, 
-			const gchar * key,
-			const gchar * value)
-{
-  ASSERT (row != NULL);
-  ASSERT (!IS_NULLSTR (key));
-  
-  ConfigPair * pair = NEW (ConfigPair);
-
-  /* Members */
-  pair->row = row;
-  pair->key = g_strdup (key);
-  pair->next = NULL;
-  pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
- 
-  /* Methods */
-  pair->destroy = configpair_method_destroy;
-  
-  DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
-  return pair;
-}
-
-static void
-configpair_method_destroy (ConfigPair * pair)
-{
-  ASSERT (pair != NULL);
-
-  DOUBLE_UNLINK (pair);
-
-  configpair_object_free (pair);
-}
-
-static void
-configpair_object_free (ConfigPair * pair)
-{
-  ASSERT (pair != NULL);
-
-  FREE (pair->key);
-  FREE (pair->value);
-  FREE (pair);
-}
-
-ConfigRow *
-configrow_new (ConfigBlock * block, const gchar * tag)
-{
-  return configrow_object_init (block, tag);
-}
-
-static ConfigRow *
-configrow_object_init (ConfigBlock * block, const gchar * tag)
-{
-  if (IS_NULLSTR (tag)) return NULL;
-
-  ConfigRow * row = NEW (ConfigRow);
-  
-  /* Members */
-  row->block = block;
-  row->tag = g_strdup (tag);
-  row->next = NULL;
-  row->vector_head = row->vector_tail = NULL;
-  row->pair_head = row->pair_tail = NULL;
-
-  /* Methods */
-  row->parse = configrow_method_parse;
-  row->destroy = configrow_method_destroy;
-  row->get_pair = configrow_method_get_pair;
-  row->get_vector = configrow_method_get_vector;
-
-  SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
-  return row;
-}
-
-static void
-configrow_object_free (ConfigRow *row)
-{
-  ASSERT (row != NULL);
-  
-  FREE (row->tag);
-
-  DESTROY (ConfigPair, row->pair_head);
-  DESTROY (ConfigVector, row->vector_head);
-
-  FREE (row);
-}
-
-static ConfigPair *
-configrow_method_get_pair (ConfigRow * row, const gchar * key)
-{
-  ASSERT (row != NULL);
-
-  if (!IS_NULLSTR (key))
-    {
-      ITERATE_BEGIN (ConfigPair, row->pair_head);
-      {
-	if (!strcmp (it->key, key))
-	  return it;
-      }
-      ITERATE_END();
-    }
-  return NULL;
-}
-
-static ConfigVector *
-configrow_method_get_vector (ConfigRow * row, const gchar * key)
-{
-  ASSERT (row != NULL);
-
-  if (!IS_NULLSTR (key))
-    {
-      ConfigPair * pair = row->get_pair (row, key);
-      if (IS_NULL (pair))
-	return NULL;
-
-      /* If we have already parsed it there is no reason to do it 
-	 a second time. Check existing linked list and return the
-	 pointer if we have already allocated it. */
-      ITERATE_BEGIN (ConfigVector, row->vector_head);
-      {
-	if (!strcmp (it->tag, key))
-	  return it;
-      }
-      ITERATE_END();
-
-      ConfigVector * vec = configvector_new (row, pair->key);
-      gchar buf[1024];
-      gchar * p = parse (pair->value, &buf[0], 1024, ','); 
-      gchar * q = pair->value + strlen (pair->value);
-    
-      do
-	{
-	  vec->add (vec, trim (&buf[0]));
-	} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
-
-      return vec;
-    }
-  return NULL;
-}
-
-static gchar *
-configrow_method_parse (ConfigRow * row, gchar * p)
-{
-  ASSERT (row != NULL);
-  ASSERT (p != NULL);
-
-  gchar key[1024], value[1024];
-  gchar * q = NULL, * s = NULL;
-
-  do
-    {
-      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
-	{
-	  break;
-	}      
-
-      if ((s = parse (q+1, &value[0], 1024, ';')) != NULL)
-	{
-	  ConfigPair * pair = row->get_pair (row, trim (&key[0]));
-	  if (pair)
-	    {
-	      fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
-		       " row '%s' block '%s'; replacing\n",
-		       pair->key, pair->value, row->tag, row->block->tag);
-	      fflush (stderr);
-	      pair->destroy (pair);
-	    }
-
-	  pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
-	}
-      p = s + 1;
-    } while (*p != '\n' && *p != '}' && *p != '\0');
-  return p;
-}
-
-static void 
-configrow_method_destroy (ConfigRow * row)
-{
-   ASSERT (row != NULL);
-
-   SINGLE_UNLINK (ConfigRow, row->block->row_head, row->block->row_tail, row);
-
-  configrow_object_free (row);
-}
-
-ConfigVector *
-configvector_new (ConfigRow * row, const gchar * tag)
-{
-  ASSERT (row != NULL);
-
-  /* No NULL Tags. */
-  if (IS_NULLSTR (tag)) return NULL;
-  return configvector_object_init (row, tag);
-}
-
-static ConfigVector *
-configvector_object_init (ConfigRow * row, const gchar * tag)
-{
-  ASSERT (row != NULL);
-
-  ConfigVector * vec = NEW (ConfigVector);
-
-  /* Members */
-  vec->row = row;
-  vec->tag = g_strdup (tag);
-  vec->next = vec->prev = NULL;
-  vec->array = g_ptr_array_sized_new (7);
-
-  /* Methods */
-  vec->destroy = configvector_method_destroy;
-  vec->get_int = configvector_method_get_int;
-  vec->get = configvector_method_get;
-  vec->add = configvector_method_add;
-
-  DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
-  return vec;
-}
-
-static void 
-configvector_object_free (ConfigVector * vec)
-{
-  ASSERT (vec != NULL);
-
-  FREE (vec->tag);
-
-  if (vec->array != NULL)
-    g_ptr_array_free (vec->array, TRUE);
-
-  FREE (vec);
-}
-
-static void
-configvector_method_destroy (ConfigVector * vec)
-{
-  ASSERT (vec != NULL);
-
-  DOUBLE_UNLINK (vec);
-
-  configvector_object_free (vec);
-}
-
-static gchar *
-configvector_method_get (ConfigVector * vec, gint index)
-{
-  ASSERT (vec != NULL);
-
-  if (index >= vec->array->len) return NULL;
-
-  gchar * rvalue = g_ptr_array_index (vec->array, index);
-  return rvalue;
-}
-
-static gint
-configvector_method_get_int (ConfigVector * vec, gint index)
-{
-  ASSERT (vec != NULL);
-
-  if (index >= vec->array->len) return -1;
-
-  gchar * rvalue = g_ptr_array_index (vec->array, index);
-  return atoi (rvalue);
-}
-
-static void
-configvector_method_add (ConfigVector * vec, const gchar * value)
-{
-  ASSERT (vec != NULL);
-  ASSERT (value != NULL);
-
-  gchar * ptr = g_strdup (value);
-  g_ptr_array_add (vec->array, ptr);
-}
diff --git a/src/config.cc b/src/config.cc
new file mode 100755
index 0000000..882ed2a
--- /dev/null
+++ b/src/config.cc
@@ -0,0 +1,759 @@
+/*
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <cstdlib>
+#include <cstring>
+#include "config.h"
+#include "parse.h"
+
+/* config.c (static) */
+
+static Config *config_object_init (const gchar *);
+static ConfigPair *configpair_object_init (ConfigRow *, 
+					   const gchar *,
+					   const gchar *);
+static ConfigRow *configrow_object_init (ConfigBlock *, const gchar *);
+static ConfigBlock *configblock_object_init (Config *, const gchar *);
+static ConfigVector *configvector_object_init (ConfigRow *,const gchar *);
+static void configrow_object_free (ConfigRow *);
+static void configblock_object_free (ConfigBlock *);
+static void configpair_object_free (ConfigPair *);
+static void config_object_free (Config *);
+static void configvector_object_free (ConfigVector *);
+static ConfigVector *config_method_get_vector (Config *,
+					       const gchar *,
+					       const gchar *,
+					       const gchar *);
+static ConfigPair *config_method_get_pair (Config *,
+					   const gchar *,
+					   const gchar *,
+					   const gchar *);
+static ConfigBlock *config_method_get_block (Config *, const gchar *);
+static ConfigPair *configblock_method_get_pair (ConfigBlock *, 
+						const gchar *,
+						const gchar *);
+static ConfigRow *config_method_get_row (Config *,
+					 const gchar *, 
+					 const gchar *);
+static ConfigRow *configblock_method_get_row (ConfigBlock *, const gchar *);
+static gchar *configrow_method_parse (ConfigRow *, gchar *);
+static void configrow_method_destroy (ConfigRow *);
+static ConfigPair *configrow_method_get_pair (ConfigRow *, const gchar *);
+static ConfigVector *configrow_method_get_vector (ConfigRow *, const gchar *);
+static void configpair_method_destroy (ConfigPair *);
+static void configblock_method_destroy (ConfigBlock *);
+static void configvector_method_destroy (ConfigVector *);
+static gint configvector_method_get_int (ConfigVector *, gint);
+static gchar *configvector_method_get (ConfigVector *, gint);
+static void configvector_method_add (ConfigVector *, const gchar *);
+static gchar *configblock_method_parse (ConfigBlock *, gchar *, FILE *);
+static void config_method_destroy (Config *);
+static gint config_method_open (Config *);
+static gint config_method_save (Config *, const gchar *);
+static gint config_method_load (Config *, FILE *);
+
+ConfigBlock *
+configblock_new (Config * c, const gchar * tag)
+{
+  /* No NULL tags. */
+  if (IS_NULLSTR (tag)) return NULL;
+  return configblock_object_init (c, tag);
+}
+
+static gchar *
+configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
+{
+  ASSERT (block != NULL);
+  ASSERT (p != NULL);
+
+  if (!fp || feof (fp)) return FALSE;
+
+  gchar buf[1024], word[1024];
+  gchar * q = NULL;
+  g_stpcpy (word, p);
+
+  /* This block of code makes sure that we indeed have an opening brace
+    to continue with parsing of the configuration file. */
+  do
+    {
+      p = word;
+      
+      if (EXPECT (p, q, '{'))
+	{
+	  g_stpcpy (buf, q + 1);
+	  break;
+	} 
+
+      if (*q == '\0')
+	continue;
+      return NULL;
+    } while (fgets (word, 1024, fp) != NULL);
+
+  /* Start actually parsing rows now. */
+  do 
+    {
+      p = buf;
+      do
+	{
+	  if (*p == '}')
+	    return p;
+	  else if (*p == '\n')
+	    {
+	      p++;
+	      continue;
+	    }
+	  else 
+	    {
+	      if ((q = parse (p, &word[0], 1024, ':')) != NULL)
+		{
+		  if (*(q+1) == ':')
+		    {
+		      ConfigRow * row 
+			= block->get_row (block, trim (&word[0]));
+		      
+		      if (row)
+			{
+			  fprintf (stderr, "**CONFIG**: row '%s' already"
+				   " defined in block '%s'; replacing\n",
+				   row->tag, block->tag);
+			  fflush (stderr);
+
+			  row->destroy (row);
+			}
+
+		      row = configrow_new (block, trim (&word[0]));
+		    
+		      if ((p = row->parse (row, q+2)) == NULL)
+			{
+			  fprintf (stderr, "Error parsing line: %s", buf);
+			  fflush (stderr);
+			  return NULL;
+			}
+		      break;
+		    }
+		}
+	    }
+	  fprintf (stderr, "Error in formatting on line: %s\n", buf);
+	  fflush (stderr);
+	  return NULL;
+	} while (*p != '\0');
+     } while (fgets (buf, 1024, fp) != NULL);
+  return NULL;
+}
+
+static void
+configblock_method_destroy (ConfigBlock * block)
+{
+  ASSERT (block != NULL);
+
+  DESTROY (ConfigRow, block->row_head);
+  SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
+		 block->cfg->block_tail, block);
+  
+  configblock_object_free (block);
+}
+
+static ConfigRow *
+configblock_method_get_row (ConfigBlock * block, const gchar * row)
+{
+  ASSERT (block != NULL);
+
+  if (!IS_NULLSTR (row))
+    {
+      ITERATE_BEGIN (ConfigRow, block->row_head);
+      {
+	if (!strcmp (it->tag, row))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static ConfigPair *
+configblock_method_get_pair (ConfigBlock * block, 
+			     const gchar * row,
+			     const gchar * key)
+{
+  ASSERT (block != NULL);
+
+  if (!IS_NULLSTR (row))
+    {
+      ITERATE_BEGIN (ConfigRow, block->row_head);
+      {
+	if (!strcmp (it->tag, row))
+	  return it->get_pair (it, key);
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static void
+configblock_object_free (ConfigBlock * block)
+{
+  ASSERT (block != NULL);
+
+  FREE (block->tag);
+  
+  FREE (block);
+  block = NULL;
+}
+
+static ConfigBlock *
+configblock_object_init (Config * c, const gchar * tag)
+{
+  ASSERT (c != NULL);
+
+  ConfigBlock * b = NEW (ConfigBlock);
+
+  /* Members */
+  b->cfg = c;
+  b->tag = g_strdup (tag);
+  b->next = NULL; 
+  b->row_head = b->row_tail = NULL;
+  
+  /* Methods */
+  b->parse = configblock_method_parse;
+  b->destroy = configblock_method_destroy;
+  b->get_row = configblock_method_get_row;
+  b->get_pair = configblock_method_get_pair;
+
+  SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
+  return b;
+}
+
+Config *
+config_new (const gchar * filename)
+{
+  return config_object_init (filename);
+}
+
+static void
+config_method_destroy (Config * c)
+{
+  ASSERT (c != NULL);
+
+  DESTROY (ConfigBlock, c->block_head);
+  
+  config_object_free (c);
+}
+
+static ConfigRow *
+config_method_get_row (Config * cfg, const gchar * block, const gchar * row)
+{
+  ASSERT (cfg != NULL);
+ 
+  ConfigBlock * b = cfg->get_block (cfg, block);
+  if (b == NULL)
+    return NULL;
+  return b->get_row (b, row);
+}
+
+static ConfigBlock *
+config_method_get_block (Config * cfg, const gchar * block)
+{
+  ASSERT (cfg != NULL);
+
+  if (!IS_NULLSTR (block))
+    {
+      ITERATE_BEGIN (ConfigBlock, cfg->block_head);
+      {
+	if (!strcmp (it->tag, block))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static ConfigPair *
+config_method_get_pair (Config * cfg, 
+			const gchar * block, 
+			const gchar * row,
+			const gchar * pair)
+{
+  ASSERT (cfg != NULL);
+
+  ConfigRow * r = cfg->get_row (cfg, block, row);
+  if (r == NULL)
+    return NULL;
+  return r->get_pair (r, pair);
+}
+
+static ConfigVector *
+config_method_get_vector (Config * cfg,
+			  const gchar * block,
+			  const gchar * row,
+			  const gchar * vector)
+{
+  ASSERT (cfg != NULL);
+  
+  ConfigRow * r = cfg->get_row (cfg, block, row);
+  if (r == NULL)
+    return NULL;
+  return r->get_vector (r, vector);
+}
+
+static void
+config_object_free (Config * c)
+{
+  ASSERT (c != NULL);
+
+  FREE (c->filename);
+
+  FREE (c);
+  c = NULL;
+}
+
+static Config *
+config_object_init (const gchar * filename)
+{
+  Config * c = NEW (Config);
+
+  /* Members */
+  c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
+  c->block_head = c->block_tail = NULL;
+
+  /* Methods */
+  c->open = config_method_open;
+  c->save = config_method_save;
+  c->load = config_method_load;
+  c->close = config_method_destroy;
+  c->get_vector = config_method_get_vector;
+  c->get_row = config_method_get_row;
+  c->get_block = config_method_get_block;
+  c->get_pair = config_method_get_pair;
+
+  return c;
+}
+
+static gint
+config_method_load (Config * c, FILE * fp)
+{
+  ASSERT (c != NULL);
+  
+  if (!fp || feof(fp))
+    {
+      /* STUB: log me? */
+      return FALSE;
+    }
+
+  gchar * buf = (gchar *)g_malloc (sizeof (char) * 1024);
+  gchar word[1024];
+  gchar * p = NULL, * q = NULL, * r = NULL;
+
+  while ((p = fgets (buf, 1024, fp)) != NULL) {
+      r = buf + (strlen (buf) - 1);
+ 
+      while (p && (p < r) && (*p != '\n'))
+	{
+	  if (*p == '%')
+	    {
+	      if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
+		/* STUB: exit parsing with a failure. */
+		g_free (buf);	
+		return FALSE;
+	      }
+
+	      if (strcmp (word, "block") == 0)
+		{
+		  if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+		    g_free(buf);
+		    return FALSE;
+		  }
+		  
+		  /* Replace the block if it already exists. Throw error. */
+		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
+		  if (b)
+		    {
+		      fprintf (stderr, "**CONFIG**: block '%s' already"
+			       "exists. Destroying and replacing.\n", b->tag);
+		      fflush (stderr);
+		      b->destroy (b);
+		    }
+
+		  b = configblock_new (c, trim (&word[0]));
+
+		  if ((p = b->parse (b, q, fp)) == NULL) {
+		    g_free (buf);
+		    return FALSE;
+		  }
+		}
+	      else if (strcmp (word, "include") == 0)
+		{
+		  if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+		    g_free (buf);
+		    return FALSE;
+		  }
+
+		  /* Include the file; we're going to load up this file
+		     first and then proceed with parsing. */
+		  FILE * ifp = NULL;
+		 
+		  if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
+		    {
+		      fprintf (stderr, "**CONFIG**: include '%s' does not"
+			       " seem to exist or unable to read.\n",
+			       word);
+		      fflush (stderr);
+		      continue;
+		    }
+
+		  c->load (c, ifp);
+		}
+	      else {
+		g_free (buf);
+		return FALSE;
+	      }
+	    }
+	  /* BUGFIX: Need to check for tabs. */
+	  else if ((*p != ' ') && (*p != '\t'))
+	    {
+	      /* STUB: error out */
+	      g_free (buf);
+	      return FALSE;
+	    }
+
+	  p++;
+	}
+    }
+  g_free (buf);
+  return TRUE;
+}
+
+static gint
+config_method_save (Config * c, const gchar * filename)
+{
+  ASSERT (c != NULL);
+
+  if (IS_NULLSTR (filename)) return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (filename, "w")) == NULL)
+    {
+      /* STUB: log me? */
+      return FALSE;
+    }
+  
+  FCLOSE (fp);
+  return TRUE;
+}
+
+static gint
+config_method_open (Config * c)
+{
+  ASSERT (c != NULL);
+
+  if (IS_NULLSTR (c->filename))
+    return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (c->filename, "r")) == NULL)
+    {
+      /* STUB: log this? */
+      return FALSE;
+    }
+
+  gint result = c->load (c, fp);
+  if (result == FALSE)
+    {
+      /* STUB: log me? */
+    }
+
+  FCLOSE (fp);
+  return result;
+}
+
+ConfigPair *
+configpair_new (ConfigRow * row, const gchar * key, const gchar * value)
+{
+  return configpair_object_init (row, key, value);
+}
+
+static ConfigPair *
+configpair_object_init (ConfigRow * row, 
+			const gchar * key,
+			const gchar * value)
+{
+  ASSERT (row != NULL);
+  ASSERT (!IS_NULLSTR (key));
+  
+  ConfigPair * pair = NEW (ConfigPair);
+
+  /* Members */
+  pair->row = row;
+  pair->key = g_strdup (key);
+  pair->next = NULL;
+  pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
+ 
+  /* Methods */
+  pair->destroy = configpair_method_destroy;
+  
+  DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
+  return pair;
+}
+
+static void
+configpair_method_destroy (ConfigPair * pair)
+{
+  ASSERT (pair != NULL);
+
+  DOUBLE_UNLINK (pair);
+
+  configpair_object_free (pair);
+}
+
+static void
+configpair_object_free (ConfigPair * pair)
+{
+  ASSERT (pair != NULL);
+
+  FREE (pair->key);
+  FREE (pair->value);
+  FREE (pair);
+}
+
+ConfigRow *
+configrow_new (ConfigBlock * block, const gchar * tag)
+{
+  return configrow_object_init (block, tag);
+}
+
+static ConfigRow *
+configrow_object_init (ConfigBlock * block, const gchar * tag)
+{
+  if (IS_NULLSTR (tag)) return NULL;
+
+  ConfigRow * row = NEW (ConfigRow);
+  
+  /* Members */
+  row->block = block;
+  row->tag = g_strdup (tag);
+  row->next = NULL;
+  row->vector_head = row->vector_tail = NULL;
+  row->pair_head = row->pair_tail = NULL;
+
+  /* Methods */
+  row->parse = configrow_method_parse;
+  row->destroy = configrow_method_destroy;
+  row->get_pair = configrow_method_get_pair;
+  row->get_vector = configrow_method_get_vector;
+
+  SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
+  return row;
+}
+
+static void
+configrow_object_free (ConfigRow *row)
+{
+  ASSERT (row != NULL);
+  
+  FREE (row->tag);
+
+  DESTROY (ConfigPair, row->pair_head);
+  DESTROY (ConfigVector, row->vector_head);
+
+  FREE (row);
+}
+
+static ConfigPair *
+configrow_method_get_pair (ConfigRow * row, const gchar * key)
+{
+  ASSERT (row != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ITERATE_BEGIN (ConfigPair, row->pair_head);
+      {
+	if (!strcmp (it->key, key))
+	  return it;
+      }
+      ITERATE_END();
+    }
+  return NULL;
+}
+
+static ConfigVector *
+configrow_method_get_vector (ConfigRow * row, const gchar * key)
+{
+  ASSERT (row != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ConfigPair * pair = row->get_pair (row, key);
+      if (IS_NULL (pair))
+	return NULL;
+
+      /* If we have already parsed it there is no reason to do it 
+	 a second time. Check existing linked list and return the
+	 pointer if we have already allocated it. */
+      ITERATE_BEGIN (ConfigVector, row->vector_head);
+      {
+	if (!strcmp (it->tag, key))
+	  return it;
+      }
+      ITERATE_END();
+
+      ConfigVector * vec = configvector_new (row, pair->key);
+      gchar buf[1024];
+      gchar * p = parse (pair->value, &buf[0], 1024, ','); 
+      gchar * q = pair->value + strlen (pair->value);
+    
+      do
+	{
+	  vec->add (vec, trim (&buf[0]));
+	} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
+
+      return vec;
+    }
+  return NULL;
+}
+
+static gchar *
+configrow_method_parse (ConfigRow * row, gchar * p)
+{
+  ASSERT (row != NULL);
+  ASSERT (p != NULL);
+
+  gchar key[1024], value[1024];
+  gchar * q = NULL, * s = NULL;
+
+  do
+    {
+      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
+	{
+	  break;
+	}      
+
+      if ((s = parse (q+1, &value[0], 1024, ';')) != NULL)
+	{
+	  ConfigPair * pair = row->get_pair (row, trim (&key[0]));
+	  if (pair)
+	    {
+	      fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
+		       " row '%s' block '%s'; replacing\n",
+		       pair->key, pair->value, row->tag, row->block->tag);
+	      fflush (stderr);
+	      pair->destroy (pair);
+	    }
+
+	  pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
+	}
+      p = s + 1;
+    } while (*p != '\n' && *p != '}' && *p != '\0');
+  return p;
+}
+
+static void 
+configrow_method_destroy (ConfigRow * row)
+{
+   ASSERT (row != NULL);
+
+   SINGLE_UNLINK (ConfigRow, row->block->row_head, row->block->row_tail, row);
+
+  configrow_object_free (row);
+}
+
+ConfigVector *
+configvector_new (ConfigRow * row, const gchar * tag)
+{
+  ASSERT (row != NULL);
+
+  /* No NULL Tags. */
+  if (IS_NULLSTR (tag)) return NULL;
+  return configvector_object_init (row, tag);
+}
+
+static ConfigVector *
+configvector_object_init (ConfigRow * row, const gchar * tag)
+{
+  ASSERT (row != NULL);
+
+  ConfigVector * vec = NEW (ConfigVector);
+
+  /* Members */
+  vec->row = row;
+  vec->tag = g_strdup (tag);
+  vec->next = vec->prev = NULL;
+  vec->array = g_ptr_array_sized_new (7);
+
+  /* Methods */
+  vec->destroy = configvector_method_destroy;
+  vec->get_int = configvector_method_get_int;
+  vec->get = configvector_method_get;
+  vec->add = configvector_method_add;
+
+  DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
+  return vec;
+}
+
+static void 
+configvector_object_free (ConfigVector * vec)
+{
+  ASSERT (vec != NULL);
+
+  FREE (vec->tag);
+
+  if (vec->array != NULL)
+    g_ptr_array_free (vec->array, TRUE);
+
+  FREE (vec);
+}
+
+static void
+configvector_method_destroy (ConfigVector * vec)
+{
+  ASSERT (vec != NULL);
+
+  DOUBLE_UNLINK (vec);
+
+  configvector_object_free (vec);
+}
+
+static gchar *
+configvector_method_get (ConfigVector * vec, gint index)
+{
+  ASSERT (vec != NULL);
+
+  if (index >= vec->array->len) return NULL;
+
+  gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
+  return rvalue;
+}
+
+static gint
+configvector_method_get_int (ConfigVector * vec, gint index)
+{
+  ASSERT (vec != NULL);
+
+  if (index >= vec->array->len) return -1;
+
+  gchar * rvalue = (gchar *)g_ptr_array_index (vec->array, index);
+  return atoi (rvalue);
+}
+
+static void
+configvector_method_add (ConfigVector * vec, const gchar * value)
+{
+  ASSERT (vec != NULL);
+  ASSERT (value != NULL);
+
+  gchar * ptr = g_strdup (value);
+  g_ptr_array_add (vec->array, ptr);
+}
diff --git a/src/config.h b/src/config.h
index 2113fff..a46192b 100755
--- a/src/config.h
+++ b/src/config.h
@@ -1,6 +1,4 @@
 /* 
-   config.h - Config Object/Parser Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -31,7 +29,7 @@ typedef struct _ConfigPair ConfigPair;
 typedef struct _ConfigVector ConfigVector;
 
 #include <shared.h>
-#include <stdlib.h>
+#include <cstdlib>
 
 struct _ConfigPair
 {
diff --git a/src/main.cc b/src/main.cc
deleted file mode 100755
index 90df412..0000000
--- a/src/main.cc
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "Application.hpp"
-
-int
-main (int argc, char ** argv) {
-	Application app (argc, argv);
-	return app.run();
-}
diff --git a/src/network/Tcp.cc b/src/network/Tcp.cc
new file mode 100755
index 0000000..b9a0572
--- /dev/null
+++ b/src/network/Tcp.cc
@@ -0,0 +1,153 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Tcp.hpp"
+#include <iostream>
+
+namespace network {
+
+	TcpSocket::TcpSocket (void) {
+		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	}
+
+	TcpSocket::~TcpSocket (void) {
+		this->close();
+	}
+
+	void
+	TcpSocket::close (void) {
+		if (this->sockfd > 0)
+			::close (this->sockfd);
+	}
+	
+	int
+	TcpSocket::send (const char * bytes, size_t length) {
+		return ::write (this->sockfd, bytes, length);
+	}
+
+	int
+	TcpSocket::receive (char * bytes, size_t size) {
+		return ::read (this->sockfd, bytes, size);
+	}
+
+	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
+		this->port = port;
+
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+		this->sockaddr.sin_port = htons (this->port);
+	}
+
+	TcpServerSocket::~TcpServerSocket (void) {
+		this->close();
+	}
+
+	bool
+	TcpServerSocket::start (int backlog = 5) {
+		int opt = 1;
+
+		// This is to prevent conflicts with major services' ports.
+		if (this->port < 1024)
+			return false;
+
+		if (::setsockopt (this->sockfd, 
+								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
+			return false;
+
+		if (::bind (this->sockfd,
+						(struct sockaddr *)&(this->sockaddr),
+						sizeof (this->sockaddr)) < 0)
+			return false;
+
+		if (::listen (this->sockfd, backlog) < 0)
+			return false;
+
+		return true;
+	}
+
+	void
+	TcpServerSocket::close (void) {
+		TcpSocket::close();
+	}
+
+	TcpServerSocket::Acceptor *
+	TcpServerSocket::newAcceptor (void) {
+		return new TcpServerSocket::Acceptor (this, this->sockfd);
+	}
+
+	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
+		this->socket = server;
+		this->sockfd = sockfd;
+	}
+
+	int
+	TcpServerSocket::Acceptor::acceptIncoming (void) {
+		int newfd = -1;
+		static struct sockaddr_in clientaddr;
+		unsigned int x = sizeof (clientaddr);
+
+		if ((newfd = ::accept (this->sockfd, 
+									  (struct sockaddr *)&clientaddr,
+									  &x)) < 0)
+			return -1;
+		return newfd;
+	}
+
+	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+	}
+
+	TcpClientSocket::TcpClientSocket (int newfd) {
+		this->sockfd = newfd;
+	}
+				
+	TcpClientSocket::~TcpClientSocket (void) {
+	}
+
+	bool
+	TcpClientSocket::connect (const char * host, int port) {
+		if (!host || (*host == '\0'))
+			return false;
+
+		if ((this->hp = ::gethostbyname (host)) == NULL)
+			return false;
+ 
+		// Copy over the hostname address.
+		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr 
+			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
+		this->sockaddr.sin_port = htons (port);
+
+		if (::connect (this->sockfd,
+							(struct sockaddr *)&(this->sockaddr),
+							sizeof (struct sockaddr)) < 0)
+			return false;
+    
+		return true;
+	}
+
+	void
+	TcpClientSocket::close (void) {
+		TcpSocket::close();
+	}
+
+} // end of namespace
diff --git a/src/network/Tcp.cpp b/src/network/Tcp.cpp
deleted file mode 100755
index b9a0572..0000000
--- a/src/network/Tcp.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Tcp.hpp"
-#include <iostream>
-
-namespace network {
-
-	TcpSocket::TcpSocket (void) {
-		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
-	}
-
-	TcpSocket::~TcpSocket (void) {
-		this->close();
-	}
-
-	void
-	TcpSocket::close (void) {
-		if (this->sockfd > 0)
-			::close (this->sockfd);
-	}
-	
-	int
-	TcpSocket::send (const char * bytes, size_t length) {
-		return ::write (this->sockfd, bytes, length);
-	}
-
-	int
-	TcpSocket::receive (char * bytes, size_t size) {
-		return ::read (this->sockfd, bytes, size);
-	}
-
-	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
-		this->port = port;
-
-		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-		this->sockaddr.sin_port = htons (this->port);
-	}
-
-	TcpServerSocket::~TcpServerSocket (void) {
-		this->close();
-	}
-
-	bool
-	TcpServerSocket::start (int backlog = 5) {
-		int opt = 1;
-
-		// This is to prevent conflicts with major services' ports.
-		if (this->port < 1024)
-			return false;
-
-		if (::setsockopt (this->sockfd, 
-								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
-			return false;
-
-		if (::bind (this->sockfd,
-						(struct sockaddr *)&(this->sockaddr),
-						sizeof (this->sockaddr)) < 0)
-			return false;
-
-		if (::listen (this->sockfd, backlog) < 0)
-			return false;
-
-		return true;
-	}
-
-	void
-	TcpServerSocket::close (void) {
-		TcpSocket::close();
-	}
-
-	TcpServerSocket::Acceptor *
-	TcpServerSocket::newAcceptor (void) {
-		return new TcpServerSocket::Acceptor (this, this->sockfd);
-	}
-
-	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
-		this->socket = server;
-		this->sockfd = sockfd;
-	}
-
-	int
-	TcpServerSocket::Acceptor::acceptIncoming (void) {
-		int newfd = -1;
-		static struct sockaddr_in clientaddr;
-		unsigned int x = sizeof (clientaddr);
-
-		if ((newfd = ::accept (this->sockfd, 
-									  (struct sockaddr *)&clientaddr,
-									  &x)) < 0)
-			return -1;
-		return newfd;
-	}
-
-	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
-		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-	}
-
-	TcpClientSocket::TcpClientSocket (int newfd) {
-		this->sockfd = newfd;
-	}
-				
-	TcpClientSocket::~TcpClientSocket (void) {
-	}
-
-	bool
-	TcpClientSocket::connect (const char * host, int port) {
-		if (!host || (*host == '\0'))
-			return false;
-
-		if ((this->hp = ::gethostbyname (host)) == NULL)
-			return false;
- 
-		// Copy over the hostname address.
-		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr 
-			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
-		this->sockaddr.sin_port = htons (port);
-
-		if (::connect (this->sockfd,
-							(struct sockaddr *)&(this->sockaddr),
-							sizeof (struct sockaddr)) < 0)
-			return false;
-    
-		return true;
-	}
-
-	void
-	TcpClientSocket::close (void) {
-		TcpSocket::close();
-	}
-
-} // end of namespace
diff --git a/src/parse.c b/src/parse.c
deleted file mode 100755
index d575700..0000000
--- a/src/parse.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/* 
-   parse.c - Generic Parsing Code
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "parse.h"
-#include <string.h>
-#include <stdlib.h>
-
-gchar *
-munch (gchar *p)
-{
-  ASSERT (p != NULL);
-  
-  /* Munch whitespace and ignore newlines, tabs. */
-  while (p && (*p == ' ' || *p == '\n' || *p == '\t')) { p++; } 
-  return p;
-}
-
-gchar *
-parse (gchar *p, gchar *word, gint n, const gchar delim)
-{
-  const gchar *q = p;
-  gint length = 0, ii = 0;
-
-  do 
-    {
-      if (*p == delim)
-	break;
-      p++;
-    } while (p && (*p != '\0') && (*p != '\n'));
-
-  length = (gint)(p - q);
-
-  if (n < length)    return NULL;
-
-  for (ii = 0; ii < length; ii++)
-    word[ii] = q[ii];
-  word[ii] = '\0';
-
-  return p;
-}
-
-gchar *
-trim (gchar *p)
-{
-  ASSERT (p != NULL);
-
-  gchar *q = NULL;
-
-  /* Eliminate tabs and spaces from beginning. */
-  while (p && (*p == ' ' || *p == '\t')) p++;
-
-  q = p;
-
-  /* Eliminate newlines, returns and whitespaces from end. */
-  while (*q != '\0') { q++; }
-  q--;
-  while (*q == ' ' || *q == '\n' || *q == '\r') { q--; }
-  *(q+1) = '\0';
-
-  return p;
-}
diff --git a/src/parse.cc b/src/parse.cc
new file mode 100755
index 0000000..b769a63
--- /dev/null
+++ b/src/parse.cc
@@ -0,0 +1,76 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "parse.h"
+#include <cstring>
+#include <cstdlib>
+
+gchar *
+munch (gchar *p)
+{
+  ASSERT (p != NULL);
+  
+  /* Munch whitespace and ignore newlines, tabs. */
+  while (p && (*p == ' ' || *p == '\n' || *p == '\t')) { p++; } 
+  return p;
+}
+
+gchar *
+parse (gchar *p, gchar *word, gint n, const gchar delim)
+{
+  const gchar *q = p;
+  gint length = 0, ii = 0;
+
+  do 
+    {
+      if (*p == delim)
+	break;
+      p++;
+    } while (p && (*p != '\0') && (*p != '\n'));
+
+  length = (gint)(p - q);
+
+  if (n < length)    return NULL;
+
+  for (ii = 0; ii < length; ii++)
+    word[ii] = q[ii];
+  word[ii] = '\0';
+
+  return p;
+}
+
+gchar *
+trim (gchar *p)
+{
+  ASSERT (p != NULL);
+
+  gchar *q = NULL;
+
+  /* Eliminate tabs and spaces from beginning. */
+  while (p && (*p == ' ' || *p == '\t')) p++;
+
+  q = p;
+
+  /* Eliminate newlines, returns and whitespaces from end. */
+  while (*q != '\0') { q++; }
+  q--;
+  while (*q == ' ' || *q == '\n' || *q == '\r') { q--; }
+  *(q+1) = '\0';
+
+  return p;
+}
diff --git a/src/parse.h b/src/parse.h
index 7c4dd3b..9e6c18a 100755
--- a/src/parse.h
+++ b/src/parse.h
@@ -1,6 +1,4 @@
 /* 
-   parse.h - Generic Parse Code Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/plugin.c b/src/plugin.c
deleted file mode 100755
index 62b9375..0000000
--- a/src/plugin.c
+++ /dev/null
@@ -1,198 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "plugin.h"
-#include <stdio.h>
-#include <stdlib.h>
-
-/* plugin.c (static) */
-static Plugin *plugin_object_init (void);
-static void plugin_method_destroy (Plugin *);
-static void *plugin_method_symbol_register (Plugin *, gchar *);
-static void plugin_method_symbol_deregister (Plugin *, PluginMethod *);
-static Plugin *plugin_object_free (Plugin *);
-static PluginMethod *pluginmethod_object_init (Plugin *);
-static PluginMethod *pluginmethod_object_free (PluginMethod *);
-static void pluginmethod_method_deregister (PluginMethod *, Plugin *);
-static GThread *plugin_method_create_thread (Plugin *,
-															GThreadFunc,
-															gpointer);
-
-Plugin *
-plugin_open (const gchar * filename)
-{
-	if (!filename || (*filename == '\0'))
-		return NULL;
-
-	Plugin * plug = plugin_object_init ();
-
-	if ((plug->pfnhandle = LIBRARY_OPEN(filename)) == NULL)
-	{
-      fprintf (stderr, "%s\n", LIBRARY_ERROR());
-      exit (1);
-	}
-	return plug;
-}
-
-static Plugin *
-plugin_object_init (void)
-{
-	Plugin * plug = NEW (Plugin);
-  
-	/* Members */
-	plug->pfnhandle = NULL;
-	plug->next = NULL;
-	plug->prev = NULL;
-	plug->first = NULL;
-	plug->last = NULL;
-	plug->threads = g_ptr_array_new ();
-
-	/* Methods */
-	plug->destroy = plugin_method_destroy;
-	plug->method_register = plugin_method_symbol_register;
-	plug->method_deregister = plugin_method_symbol_deregister;
-	plug->create_thread = plugin_method_create_thread;
-
-	return plug;
-}
-
-static GThread *
-plugin_method_create_thread (Plugin * plugin,
-									  GThreadFunc thread_function,
-									  gpointer data)
-{
-	ASSERT (plugin != NULL);
-
-	GThread * runnable = NULL;
-	GError * err = NULL;
-
-	if ((runnable = g_thread_create (thread_function, data,
-												TRUE, &err)) == NULL)
-	{
-      g_warning ("Failed creating thread; ERROR %s", err->message);
-      g_error_free (err);
-      return NULL;
-	}
-	g_ptr_array_add (plugin->threads, (gpointer)runnable);
-	return runnable;
-} 
-
-static Plugin *
-plugin_object_free (Plugin * plugin)
-{
-	if (!plugin)
-		return NULL;
-
-	plugin->first = plugin->last = NULL;
-
-	g_ptr_array_free (plugin->threads, TRUE);
-
-	FREE (plugin);
-	return plugin;
-}
-
-static void
-plugin_method_destroy (Plugin * plugin)
-{
-	if (!plugin)
-		return;
-
-	PluginMethod * current = plugin->first, * next = NULL;
-	while (current)
-	{
-      next = current->next;
-      current->deregister (current, plugin);
-      current = next;
-	}
-
-	for (guint ii = 0; ii < plugin->threads->len; ii++)
-	{
-      GThread * thread 
-			= (GThread *)g_ptr_array_remove_index_fast (plugin->threads, ii);
-      g_thread_join (thread);
-	}
-
-	UNLINK_OBJECT (plugin);
-	LIBRARY_CLOSE (plugin->pfnhandle);
-	plugin_object_free (plugin);
-}
-
-static void
-plugin_method_symbol_deregister (Plugin * plugin, PluginMethod * method)
-{
-	if (!plugin || !method)
-		return;
-
-	method->deregister (method, plugin);
-}
-
-static void *
-plugin_method_symbol_register (Plugin * plugin, gchar * symbol)
-{
-	if (IS_NULLSTR (symbol))
-		return NULL;
-
-	PluginMethod * plugm = pluginmethod_object_init (plugin);
-
-	if ((plugm->pfnmethod 
-		  = LIBRARY_SYM(plugin->pfnhandle, symbol)) == NULL)
-	{
-      fprintf (stderr, "%s\n", LIBRARY_ERROR());
-      exit (1);
-	}
-
-	LINK_OBJECT (plugin->first, plugin->last, plugm); 
-	return plugm->pfnmethod;
-}
-
-static PluginMethod *
-pluginmethod_object_init (Plugin * plugin)
-{
-	PluginMethod * plugm = NEW (PluginMethod);
-
-	/* Members */
-	plugm->pfnmethod = NULL;
-	plugm->plugin = plugin;
-
-	/* Methods */
-	plugm->deregister = pluginmethod_method_deregister;
-
-	plugm->next = NULL;
-	plugm->prev = NULL;
-	return plugm;
-}
-
-static PluginMethod *
-pluginmethod_object_free (PluginMethod * method)
-{
-	if (!method)
-		return NULL;
-
-	FREE (method);
-	return method;
-}
-
-static void
-pluginmethod_method_deregister (PluginMethod * method, Plugin * plugin)
-{
-	if (!method)
-		return;
-
-	UNLINK_OBJECT (method);
-	pluginmethod_object_free (method);
-}
diff --git a/src/plugin.cc b/src/plugin.cc
new file mode 100755
index 0000000..ca9b295
--- /dev/null
+++ b/src/plugin.cc
@@ -0,0 +1,198 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "plugin.h"
+#include <cstdio>
+#include <cstdlib>
+
+/* plugin.c (static) */
+static Plugin *plugin_object_init (void);
+static void plugin_method_destroy (Plugin *);
+static void *plugin_method_symbol_register (Plugin *, gchar *);
+static void plugin_method_symbol_deregister (Plugin *, PluginMethod *);
+static Plugin *plugin_object_free (Plugin *);
+static PluginMethod *pluginmethod_object_init (Plugin *);
+static PluginMethod *pluginmethod_object_free (PluginMethod *);
+static void pluginmethod_method_deregister (PluginMethod *, Plugin *);
+static GThread *plugin_method_create_thread (Plugin *,
+															GThreadFunc,
+															gpointer);
+
+Plugin *
+plugin_open (const gchar * filename)
+{
+	if (!filename || (*filename == '\0'))
+		return NULL;
+
+	Plugin * plug = plugin_object_init ();
+
+	if ((plug->pfnhandle = LIBRARY_OPEN(filename)) == NULL)
+	{
+      fprintf (stderr, "%s\n", LIBRARY_ERROR());
+      exit (1);
+	}
+	return plug;
+}
+
+static Plugin *
+plugin_object_init (void)
+{
+	Plugin * plug = NEW (Plugin);
+  
+	/* Members */
+	plug->pfnhandle = NULL;
+	plug->next = NULL;
+	plug->prev = NULL;
+	plug->first = NULL;
+	plug->last = NULL;
+	plug->threads = g_ptr_array_new ();
+
+	/* Methods */
+	plug->destroy = plugin_method_destroy;
+	plug->method_register = plugin_method_symbol_register;
+	plug->method_deregister = plugin_method_symbol_deregister;
+	plug->create_thread = plugin_method_create_thread;
+
+	return plug;
+}
+
+static GThread *
+plugin_method_create_thread (Plugin * plugin,
+									  GThreadFunc thread_function,
+									  gpointer data)
+{
+	ASSERT (plugin != NULL);
+
+	GThread * runnable = NULL;
+	GError * err = NULL;
+
+	if ((runnable = g_thread_create (thread_function, data,
+												TRUE, &err)) == NULL)
+	{
+      g_warning ("Failed creating thread; ERROR %s", err->message);
+      g_error_free (err);
+      return NULL;
+	}
+	g_ptr_array_add (plugin->threads, (gpointer)runnable);
+	return runnable;
+} 
+
+static Plugin *
+plugin_object_free (Plugin * plugin)
+{
+	if (!plugin)
+		return NULL;
+
+	plugin->first = plugin->last = NULL;
+
+	g_ptr_array_free (plugin->threads, TRUE);
+
+	FREE (plugin);
+	return plugin;
+}
+
+static void
+plugin_method_destroy (Plugin * plugin)
+{
+	if (!plugin)
+		return;
+
+	PluginMethod * current = plugin->first, * next = NULL;
+	while (current)
+	{
+      next = current->next;
+      current->deregister (current, plugin);
+      current = next;
+	}
+
+	for (guint ii = 0; ii < plugin->threads->len; ii++)
+	{
+      GThread * thread 
+			= (GThread *)g_ptr_array_remove_index_fast (plugin->threads, ii);
+      g_thread_join (thread);
+	}
+
+	UNLINK_OBJECT (plugin);
+	LIBRARY_CLOSE (plugin->pfnhandle);
+	plugin_object_free (plugin);
+}
+
+static void
+plugin_method_symbol_deregister (Plugin * plugin, PluginMethod * method)
+{
+	if (!plugin || !method)
+		return;
+
+	method->deregister (method, plugin);
+}
+
+static void *
+plugin_method_symbol_register (Plugin * plugin, gchar * symbol)
+{
+	if (IS_NULLSTR (symbol))
+		return NULL;
+
+	PluginMethod * plugm = pluginmethod_object_init (plugin);
+
+	if ((plugm->pfnmethod 
+		  = LIBRARY_SYM(plugin->pfnhandle, symbol)) == NULL)
+	{
+      fprintf (stderr, "%s\n", LIBRARY_ERROR());
+      exit (1);
+	}
+
+	LINK_OBJECT (plugin->first, plugin->last, plugm); 
+	return plugm->pfnmethod;
+}
+
+static PluginMethod *
+pluginmethod_object_init (Plugin * plugin)
+{
+	PluginMethod * plugm = NEW (PluginMethod);
+
+	/* Members */
+	plugm->pfnmethod = NULL;
+	plugm->plugin = plugin;
+
+	/* Methods */
+	plugm->deregister = pluginmethod_method_deregister;
+
+	plugm->next = NULL;
+	plugm->prev = NULL;
+	return plugm;
+}
+
+static PluginMethod *
+pluginmethod_object_free (PluginMethod * method)
+{
+	if (!method)
+		return NULL;
+
+	FREE (method);
+	return method;
+}
+
+static void
+pluginmethod_method_deregister (PluginMethod * method, Plugin * plugin)
+{
+	if (!method)
+		return;
+
+	UNLINK_OBJECT (method);
+	pluginmethod_object_free (method);
+}
diff --git a/src/proactor/Dispatcher.cc b/src/proactor/Dispatcher.cc
new file mode 100755
index 0000000..c7a9ded
--- /dev/null
+++ b/src/proactor/Dispatcher.cc
@@ -0,0 +1,54 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Dispatcher.hpp"
+#include "Worker.hpp"
+#include <algorithm>
+
+namespace proactor {
+
+  Dispatcher::~Dispatcher (void) {
+      
+  }
+   
+	bool
+	Dispatcher::addWorker (Worker * w) {
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+		if (it == this->workers.end()) {
+			this->workers.push_back (w);
+			return w->start();
+      }
+		return false;
+	}
+  
+	bool
+	Dispatcher::removeWorker (Worker * w) {
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+
+		if (it == this->workers.end())
+			return false;
+  
+		this->workers.erase (it);
+		return true;
+	}
+
+} // end of namesapce
diff --git a/src/proactor/Dispatcher.cpp b/src/proactor/Dispatcher.cpp
deleted file mode 100755
index c7a9ded..0000000
--- a/src/proactor/Dispatcher.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Dispatcher.hpp"
-#include "Worker.hpp"
-#include <algorithm>
-
-namespace proactor {
-
-  Dispatcher::~Dispatcher (void) {
-      
-  }
-   
-	bool
-	Dispatcher::addWorker (Worker * w) {
-		WorkerListType::iterator it = std::find (this->workers.begin(),
-															  this->workers.end(),
-															  w);
-		if (it == this->workers.end()) {
-			this->workers.push_back (w);
-			return w->start();
-      }
-		return false;
-	}
-  
-	bool
-	Dispatcher::removeWorker (Worker * w) {
-		WorkerListType::iterator it = std::find (this->workers.begin(),
-															  this->workers.end(),
-															  w);
-
-		if (it == this->workers.end())
-			return false;
-  
-		this->workers.erase (it);
-		return true;
-	}
-
-} // end of namesapce
diff --git a/src/proactor/Event.cc b/src/proactor/Event.cc
new file mode 100755
index 0000000..a1c5c2b
--- /dev/null
+++ b/src/proactor/Event.cc
@@ -0,0 +1,38 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Event.hpp"
+
+namespace proactor {
+
+  int Event::numEvents = 0;
+
+  Event::Event (int e, const std::string & buf) {
+    this->id = e;
+    this->buf = buf;
+  }
+
+  int
+  Event::uniqueEventId (void) {
+    return Event::numEvents++;
+  }
+
+  EventDispatcher::~EventDispatcher (void) {
+  }
+ 
+} // end of namespace
diff --git a/src/proactor/Event.cpp b/src/proactor/Event.cpp
deleted file mode 100755
index a1c5c2b..0000000
--- a/src/proactor/Event.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Event.hpp"
-
-namespace proactor {
-
-  int Event::numEvents = 0;
-
-  Event::Event (int e, const std::string & buf) {
-    this->id = e;
-    this->buf = buf;
-  }
-
-  int
-  Event::uniqueEventId (void) {
-    return Event::numEvents++;
-  }
-
-  EventDispatcher::~EventDispatcher (void) {
-  }
- 
-} // end of namespace
diff --git a/src/proactor/InputDispatcher.cc b/src/proactor/InputDispatcher.cc
new file mode 100755
index 0000000..a46febc
--- /dev/null
+++ b/src/proactor/InputDispatcher.cc
@@ -0,0 +1,66 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "InputDispatcher.hpp"
+#include "Proactor.hpp"
+
+namespace proactor {
+
+  InputDispatcher::~InputDispatcher (void) {
+	  this->inputQueue.lock();
+	  while (this->inputQueue.size() > 0)
+		  this->inputQueue.pop();
+	  this->inputQueue.unlock();
+  }
+
+  void *
+  InputDispatcher::stop (void) {
+    WorkerListType::iterator it = this->workers.begin();
+    while (it != this->workers.end()) {
+      (*it)->stop();
+      it = this->workers.erase(it);
+    }
+    return Thread::stop();
+  }
+
+  void *
+  InputDispatcher::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+      // Dispatch all of the input items on the queue.
+      this->inputQueue.lock();
+
+      while (this->inputQueue.size() > 0) {
+
+	if (this->running == false)
+	  break;
+
+	// For right now all we're doing is pushing up the chain.
+	this->pro->onReadComplete ( this->inputQueue.pop() );
+      }
+
+      this->inputQueue.unlock();
+
+      Thread::sleep(100);
+    }
+  
+    return NULL; 
+  }
+
+} // end of namespace
diff --git a/src/proactor/InputDispatcher.cpp b/src/proactor/InputDispatcher.cpp
deleted file mode 100755
index a46febc..0000000
--- a/src/proactor/InputDispatcher.cpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "InputDispatcher.hpp"
-#include "Proactor.hpp"
-
-namespace proactor {
-
-  InputDispatcher::~InputDispatcher (void) {
-	  this->inputQueue.lock();
-	  while (this->inputQueue.size() > 0)
-		  this->inputQueue.pop();
-	  this->inputQueue.unlock();
-  }
-
-  void *
-  InputDispatcher::stop (void) {
-    WorkerListType::iterator it = this->workers.begin();
-    while (it != this->workers.end()) {
-      (*it)->stop();
-      it = this->workers.erase(it);
-    }
-    return Thread::stop();
-  }
-
-  void *
-  InputDispatcher::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
-      // Dispatch all of the input items on the queue.
-      this->inputQueue.lock();
-
-      while (this->inputQueue.size() > 0) {
-
-	if (this->running == false)
-	  break;
-
-	// For right now all we're doing is pushing up the chain.
-	this->pro->onReadComplete ( this->inputQueue.pop() );
-      }
-
-      this->inputQueue.unlock();
-
-      Thread::sleep(100);
-    }
-  
-    return NULL; 
-  }
-
-} // end of namespace
diff --git a/src/proactor/Proactor.cc b/src/proactor/Proactor.cc
new file mode 100755
index 0000000..2085c63
--- /dev/null
+++ b/src/proactor/Proactor.cc
@@ -0,0 +1,159 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Proactor.hpp"
+#include <iostream>
+#include <algorithm>
+
+namespace proactor {
+
+  Proactor::Proactor (void) {
+  }
+
+  Proactor::~Proactor (void) {
+    // Remove all of the lists of event handlers.
+    {
+      EventMapType::iterator it = this->eventsToHandlers.begin();
+      while (it != this->eventsToHandlers.end()) {
+	  WorkerListType * q = (it->second);
+	  delete q;
+	  it++;
+	}
+    }
+ 
+    // Handle the dispatchers that have not been manually removed.
+    {
+      DispatcherList::iterator it = this->dispatchers.begin();
+      while (it != this->dispatchers.end())
+	{
+	  Dispatcher * d = (*it);
+	  delete d;
+	  it++;
+	}
+    }
+  
+  }
+
+  bool
+  Proactor::addWorker (int e, Worker * job) {
+    this->eventsToHandlers.lock();
+    {
+      EventMapType::iterator it = this->eventsToHandlers.find (e);
+  
+      if (it == this->eventsToHandlers.end())
+	this->eventsToHandlers[e] = new WorkerListType;  
+      this->eventsToHandlers[e]->push_back (job);
+    }
+    this->eventsToHandlers.unlock();
+
+    return job->start();
+  }
+
+  void
+  Proactor::onReadComplete (Event e) {
+    this->events.push (e);
+  }
+
+  void 
+  Proactor::onReadComplete (int e, const char * buf) {
+    this->events.push ( Event (e, std::string (buf)) );   
+  }
+
+  bool
+  Proactor::removeWorker (int e, Worker * job) {
+    bool result = false;
+
+    this->eventsToHandlers.lock();
+    {
+      WorkerListType::iterator it = 
+	std::find (this->eventsToHandlers[e]->begin(),
+		   this->eventsToHandlers[e]->end(),
+		   job);
+    
+      if (it != this->eventsToHandlers[e]->end())
+	{
+	  this->eventsToHandlers[e]->erase (it);
+	  result = true;
+	}
+    }
+    this->eventsToHandlers.unlock();
+   
+    return result;
+  }
+
+  void
+  Proactor::addDispatcher (Dispatcher * d) {
+    this->dispatchers.push_back (d);
+  }
+
+  bool
+  Proactor::removeDispatcher (Dispatcher * d) {
+    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
+					     this->dispatchers.end(),
+					     d);
+
+    if (it == this->dispatchers.end())
+      return false;
+  
+    this->dispatchers.erase (it);
+    return true;
+  }
+
+  void *
+  Proactor::run (void * null) {
+    this->running = true;
+  
+    WorkerListType::iterator it;
+
+    while (this->running == true) {
+	this->events.lock();
+
+	while (this->events.size() > 0) {
+
+	  if (this->running == false)
+	    break;
+
+	    Event e = this->events.pop();
+
+	    // We are throwing events with no handlers to catch them.
+	    if (this->eventsToHandlers.find (e.id) == 
+		this->eventsToHandlers.end())
+	      continue;
+ 
+	    it = this->eventsToHandlers[e.id]->begin();
+	  
+	    while (it != this->eventsToHandlers[e.id]->end()) {
+
+	      if (this->running == false)
+		break;
+
+		Worker * j = (*it);
+	      
+		j->pushInputQueue (e.buf);
+		      
+		it++;
+	      }
+	  }
+	this->events.unlock();
+      
+	Thread::sleep(100);
+      }
+    return NULL;
+  }
+
+} // end of namespace
diff --git a/src/proactor/Proactor.cpp b/src/proactor/Proactor.cpp
deleted file mode 100755
index 2085c63..0000000
--- a/src/proactor/Proactor.cpp
+++ /dev/null
@@ -1,159 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Proactor.hpp"
-#include <iostream>
-#include <algorithm>
-
-namespace proactor {
-
-  Proactor::Proactor (void) {
-  }
-
-  Proactor::~Proactor (void) {
-    // Remove all of the lists of event handlers.
-    {
-      EventMapType::iterator it = this->eventsToHandlers.begin();
-      while (it != this->eventsToHandlers.end()) {
-	  WorkerListType * q = (it->second);
-	  delete q;
-	  it++;
-	}
-    }
- 
-    // Handle the dispatchers that have not been manually removed.
-    {
-      DispatcherList::iterator it = this->dispatchers.begin();
-      while (it != this->dispatchers.end())
-	{
-	  Dispatcher * d = (*it);
-	  delete d;
-	  it++;
-	}
-    }
-  
-  }
-
-  bool
-  Proactor::addWorker (int e, Worker * job) {
-    this->eventsToHandlers.lock();
-    {
-      EventMapType::iterator it = this->eventsToHandlers.find (e);
-  
-      if (it == this->eventsToHandlers.end())
-	this->eventsToHandlers[e] = new WorkerListType;  
-      this->eventsToHandlers[e]->push_back (job);
-    }
-    this->eventsToHandlers.unlock();
-
-    return job->start();
-  }
-
-  void
-  Proactor::onReadComplete (Event e) {
-    this->events.push (e);
-  }
-
-  void 
-  Proactor::onReadComplete (int e, const char * buf) {
-    this->events.push ( Event (e, std::string (buf)) );   
-  }
-
-  bool
-  Proactor::removeWorker (int e, Worker * job) {
-    bool result = false;
-
-    this->eventsToHandlers.lock();
-    {
-      WorkerListType::iterator it = 
-	std::find (this->eventsToHandlers[e]->begin(),
-		   this->eventsToHandlers[e]->end(),
-		   job);
-    
-      if (it != this->eventsToHandlers[e]->end())
-	{
-	  this->eventsToHandlers[e]->erase (it);
-	  result = true;
-	}
-    }
-    this->eventsToHandlers.unlock();
-   
-    return result;
-  }
-
-  void
-  Proactor::addDispatcher (Dispatcher * d) {
-    this->dispatchers.push_back (d);
-  }
-
-  bool
-  Proactor::removeDispatcher (Dispatcher * d) {
-    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
-					     this->dispatchers.end(),
-					     d);
-
-    if (it == this->dispatchers.end())
-      return false;
-  
-    this->dispatchers.erase (it);
-    return true;
-  }
-
-  void *
-  Proactor::run (void * null) {
-    this->running = true;
-  
-    WorkerListType::iterator it;
-
-    while (this->running == true) {
-	this->events.lock();
-
-	while (this->events.size() > 0) {
-
-	  if (this->running == false)
-	    break;
-
-	    Event e = this->events.pop();
-
-	    // We are throwing events with no handlers to catch them.
-	    if (this->eventsToHandlers.find (e.id) == 
-		this->eventsToHandlers.end())
-	      continue;
- 
-	    it = this->eventsToHandlers[e.id]->begin();
-	  
-	    while (it != this->eventsToHandlers[e.id]->end()) {
-
-	      if (this->running == false)
-		break;
-
-		Worker * j = (*it);
-	      
-		j->pushInputQueue (e.buf);
-		      
-		it++;
-	      }
-	  }
-	this->events.unlock();
-      
-	Thread::sleep(100);
-      }
-    return NULL;
-  }
-
-} // end of namespace
diff --git a/src/proactor/Worker.cc b/src/proactor/Worker.cc
new file mode 100755
index 0000000..be5863f
--- /dev/null
+++ b/src/proactor/Worker.cc
@@ -0,0 +1,26 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Worker.hpp"
+
+namespace proactor {
+
+  Worker::~Worker (void) {
+  }
+
+} // end of namesapce
diff --git a/src/proactor/Worker.cpp b/src/proactor/Worker.cpp
deleted file mode 100755
index be5863f..0000000
--- a/src/proactor/Worker.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Worker.hpp"
-
-namespace proactor {
-
-  Worker::~Worker (void) {
-  }
-
-} // end of namesapce

commit d7fdc56fe29444b0191baa39ae041602f57c4df9
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 16:38:53 2009 -0400

    Changed permissions to files.

diff --git a/src/Application.cc b/src/Application.cc
old mode 100644
new mode 100755
diff --git a/src/Application.hpp b/src/Application.hpp
old mode 100644
new mode 100755
diff --git a/src/main.cc b/src/main.cc
old mode 100644
new mode 100755

commit e01d63ba445daf4ec504d1afe397155fbd6f6536
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 16:38:23 2009 -0400

    Removed application.c

diff --git a/src/application.c b/src/application.c
deleted file mode 100755
index e8a7458..0000000
--- a/src/application.c
+++ /dev/null
@@ -1,513 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "application.h"
-#include "plugin.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <string.h>
-#include <glib/gthread.h>
-
-/* application.c (static) */
-static int application_method_run (ApplicationState *);
-static guint application_signal_delete_event (GtkWindow *,
-															 GdkEvent *, 
-															 gpointer);
-static guint application_signal_destroy_event (GtkWidget *, gpointer);
-static void application_method_close (ApplicationState *);
-static ApplicationState* application_object_free (ApplicationState *);
-static ApplicationState* application_object_init (void);
-static Plugin* application_method_loadplugin (ApplicationState *, 
-															 const gchar *);
-static void application_method_openextension (ApplicationState *,
-															 const gchar *,
-															 gboolean);
-static guint application_signal_gtknotebook_switchpage (GtkNotebook *,
-																		  GtkNotebookPage *,
-																		  gint,
-																		  Workbook *);
-static guint application_signal_gtknotebook_removed (GtkNotebook *,
-																	  GtkNotebookPage *,
-																	  gint,
-																	  Workbook *);
-static guint application_signal_gtknotebook_reordered (GtkNotebook *,
-																		 GtkNotebookPage *,
-																		 gint,
-																		 Workbook *);
-static guint application_signal_gtksheet_changed (GtkWidget *,
-																  gint, gint,
-																  Sheet *);
-
-/* @description: This method takes the argument and clears the string of
-   everything except for the directories. Therefore the return value would
-   be a string sans anything before the last directory delimiter '/'. */
-static gchar *
-munchpath (gchar * path_)
-{
-	gchar * path = g_strdup(path_);
-	path = g_strreverse (path);
-	gchar * p = path;
-
-	while (p && (*p != '\0')) { if (*p == '/') break; p++; }
-
-	gchar * str = g_strdup (p);
-	str = g_strreverse (str);
-	FREE (path);
-	return str;
-}
-
-/* @description: This method creates and returns a new initialized 
-   ApplicationState object. This should only be performed once.
-   @argc: The argument count (passed in from commandline).
-   @argv: The argument pointer to string array. */
-ApplicationState *
-application_init (int * argc, char *** argv)
-{
-	if (!g_thread_supported ())
-	{
-      g_thread_init (NULL);
-      gdk_threads_init ();
-	}
-
-	ApplicationState * appstate = application_object_init ();
-	int c;
-
-	appstate->absolute_path = munchpath (*argv[0]);
-
-	/* This block parses the commandline for options. A better example on how
-		this code works can be found on the GNU website at the following URI:
-		http://gnu.org/software/libtool/manual/libc/Using-Getopt.html */
-	while ((c = getopt (*argc, *argv, "c:")) != -1)
-	{
-      switch (c)
-		{
-			case 'c':
-			{
-				Config * cfg = config_new (optarg);
-				if (!cfg)
-				{
-					g_critical ("Failed loading configuration file '%s';" 
-									" which was specified with -c argument\n", optarg);
-					exit (0);
-					break;
-				}
-				appstate->cfg = cfg;
-			}
-			break;
-
-			case '?':
-			{
-				if (optopt == 'c')
-				{
-					g_warning ("Option -c requires an argument in order to load"
-								  " a configuration file\n");
-				}
-			}
-			break;
-		}
-	}
-
-	gdk_threads_enter ();
-	gtk_init (argc, argv);
-
-	/* Create the window and connect two callback to the signals. */
-	appstate->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-	gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
-							  "destroy",
-							  G_CALLBACK (appstate->signals[SIG_DESTROY_EVENT]),
-							  (gpointer *)appstate);
-	gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
-							  "delete_event",
-							  G_CALLBACK (appstate->signals[SIG_DELETE_EVENT]),
-							  NULL);
-  
-	/* Set the initial size of the application; we could load this
-		from a configuration file eventually. */
-	gtk_widget_set_usize (appstate->gtk_window, 1024, 768);
-  
-	/* Attach the window box to the window and present to the screen. */
-	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
-	gtk_container_add (GTK_CONTAINER (appstate->gtk_window), window_box);
-	appstate->gtk_window_vbox = window_box;
-  
-	gtk_widget_show_all (appstate->gtk_window);
- 
-	gdk_threads_leave ();
-	return appstate;
-}
-
-/* @description: This method destroys the application state object.
-   @appstate: The pointer to the object to destroy. */
-static void
-application_method_close (ApplicationState *appstate)
-{
-	ASSERT (appstate != NULL);
-
-	*appstate->shutdown = TRUE;
-  
-	DESTROY (Workbook, appstate->workbook_first);
-
-	/* This has to be set so that we have a sentinel variable in separate threads
-		if there is a better way to do this than it should be changed inside of
-		the plugins that use these pointers to check if the object is still
-		allocated. */
-	appstate->workbook_first = appstate->workbook_last = NULL;
-
-	application_object_free (appstate);
-}
-
-static guint
-application_signal_gtknotebook_removed (GtkNotebook * notebook,
-													 GtkNotebookPage * page,
-													 gint page_num,
-													 Workbook * wb)
-{
-	ASSERT (wb != NULL);
-
-	return TRUE;
-}
-
-static guint
-application_signal_gtknotebook_reordered (GtkNotebook * notebook,
-														GtkNotebookPage * page,
-														gint page_num,
-														Workbook * wb)
-{
-	ASSERT (wb != NULL);
-
-	return TRUE;
-}
-
-/* @description: This is the callback for the GtkNotebook 'switch-page' 
-   signal. It is called every single time a user *clicks* on different
-   tab. This method is called *before* the drawing takes place.
-
-   This method iterates through the Sheets and updates where neccesary.
-
-   @notebook: This is a pointer to the notebook object. The object is
-   equal to the Workbook->gtk_notebook pointer.
-   @page:
-   @page_num: The number of the *new* page.
-   @book: The Workbook object associated with the GtkNotebook.*/
-static guint
-application_signal_gtknotebook_switchpage (GtkNotebook * notebook,
-														 GtkNotebookPage * page,
-														 gint page_num,
-														 Workbook * book)
-{
-	ASSERT (book != NULL);
-
-	/* Perform the "unfocus" on the old notebook tab. */
-	if (!IS_NULL (book->focus_sheet))
-	{
-      book->focus_sheet->has_focus = FALSE;
-      book->focus_sheet->notices = 0;
-	}
-
-	GtkWidget * widget = gtk_notebook_get_nth_page (notebook, page_num);
-
-	ITERATE_BEGIN (Sheet, book->sheet_first);
-	{
-		/* Once we find the right Sheet object we can perform what we need
-			to in order to change the "focus." Finally, set book pointer. */
-		if (it->gtk_box == widget)
-      {
-			it->page = page_num;
-			it->has_focus = TRUE;
-			it->notices = 0;
-	
-			/* Reset the label on the notebook tab to the object's name. */
-			gtk_notebook_set_tab_label_text (notebook,
-														it->gtk_box,
-														it->name);
-			book->focus_sheet = it;
-			break;
-      }
-	}
-	ITERATE_END ();
-	return TRUE;
-}
-
-static guint
-application_signal_gtksheet_changed (GtkWidget * gtksheet,
-												 gint row, gint column,
-												 Sheet * sheet)
-{
-	ASSERT (sheet != NULL);
-	ASSERT (sheet->workbook != NULL);
-
-	Workbook * wb = sheet->workbook;
-
-	if (sheet->notices > 0)
-	{
-      gchar * label 
-			= g_strdup_printf ("%s (%d)", sheet->name, sheet->notices);
-      gtk_notebook_set_tab_label_text (GTK_NOTEBOOK (wb->gtk_notebook),
-													sheet->gtk_box,
-													label);
-      FREE (label);
-	}
-	return FALSE;
-}
-
-/* @description: This method frees teh application state object.   
-   @appstate: The application state object to free. */
-static ApplicationState *
-application_object_free (ApplicationState *appstate)
-{
-	ASSERT (appstate != NULL);
-
-	FREE (appstate->shutdown);
-	FREE (appstate->absolute_path);
-	FREE (appstate);
-	return appstate;
-}
-
-/* @description: This initializes a new application state object. This
-   should only be called once. */
-static ApplicationState *
-application_object_init (void)
-{
-	ApplicationState * app = NEW (ApplicationState);
-
-	/* Members */
-	app->cfg = NULL;
-	app->workbook_first = app->workbook_last = NULL;
-	app->plugin_first = app->plugin_last = NULL;
-	app->gtk_window = NULL;
-	app->gtk_menu = NULL;
-	app->gtk_window_vbox = NULL;
-	app->shutdown = NEW (gboolean);
-	*app->shutdown = FALSE;
-
-	/* Set up the signals. */
-	app->signals[SIG_NOTEBOOK_SWITCHED]
-		= (GSourceFunc)application_signal_gtknotebook_switchpage;
-	app->signals[SIG_NOTEBOOK_REORDERED]
-		= (GSourceFunc)application_signal_gtknotebook_reordered;
-	app->signals[SIG_NOTEBOOK_REMOVED]
-		= (GSourceFunc)application_signal_gtknotebook_removed;
-	app->signals[SIG_DESTROY_EVENT]
-		= (GSourceFunc)application_signal_destroy_event;
-	app->signals[SIG_DELETE_EVENT]
-		= (GSourceFunc)application_signal_delete_event;
-	app->signals[SIG_SHEET_CHANGED]
-		= (GSourceFunc)application_signal_gtksheet_changed;
-
-	/* Methods */
-	app->run = application_method_run;
-	app->close = application_method_close;
-	app->load_plugin = application_method_loadplugin;
-	app->open_extension = application_method_openextension;
-
-	return app;
-}
-
-/* @description: This is called from main() when we want to start the
-   application.It loads up the configuration file (if present) and starts
-   gtk_main.
-   @appstate: A pointer to the application state object. */
-static int
-application_method_run (ApplicationState *appstate)
-{
-	if (appstate->cfg)
-	{
-      Config * cfg = appstate->cfg;
-      cfg->open (cfg);
-     
-      /* Load extensions */
-      ConfigRow * load = cfg->get_row (cfg, "application", "load");
-
-      /* Did a little bit of fixing here. We needed something to specify that
-			certain extensions will start automatically when the application is
-			started. */
-      if (!IS_NULL (load))
-		{
-			ConfigVector * ext = load->get_vector (load, "extensions");
-			gchar * block = NULL;
-			gint ii = 0;
-
-			if (IS_NULL (ext))
-			{
-				g_critical ("Config 'extensions' vector is NULL");
-				return -1;
-			}
-      
-			while ((block = ext->get(ext, ii)) != NULL)
-			{
-				ConfigPair * run = cfg->get_pair (cfg, block, "onLoad", "run");
-	      
-				if (run && (strcmp (run->value, "1") == 0))
-				{
-					ConfigPair * filename 
-						= cfg->get_pair (cfg, block, "linux", "filename");
-
-					if (!IS_NULL (filename) && !IS_NULLSTR (filename->value))
-					{
-						gboolean RelativePath 
-							= (filename->value[0] == '/') ? FALSE : TRUE;
-
-						appstate->open_extension (appstate, 
-														  filename->value, 
-														  RelativePath);
-					}
-				}
-				ii++;
-			}
-		}
-	}
-
-	/* Start the GTK+ main loop; make sure it is surrounded in the 
-		thread calls. GTK+ "releases" the current lock after every loop
-		interation. This allows us to call gdk_threads_enter/leave inside
-		of another thread. */
-	gdk_threads_enter ();
-	gtk_main ();
-	gdk_threads_leave ();
-	return 0;
-}
-
-/* @description: This method loads a shared library (plugin) from disk.
-   @appstate: A pointer to the application state object.
-   @filename: The string to the file that we're looking to load.*/
-static Plugin *
-application_method_loadplugin (ApplicationState * appstate, 
-										 const gchar * filename)
-{
-	ASSERT (appstate != NULL);
-  
-	Plugin * plugin = plugin_open (filename);
-  
-	if (plugin == NULL)
-		return NULL;
-
-	LINK_OBJECT (appstate->plugin_first, 
-					 appstate->plugin_last, 
-					 plugin);
-
-	return plugin;
-}
-
-/* @description: This is the callback to GtkMain's "delete" event. This is
-   called when we attempt to close the application safely. 
-   @window: A pointer to the GtkWindow object.
-   @event: A pointer to the associated GdkEvent information.
-   @p: NULL */
-static guint
-application_signal_delete_event (GtkWindow * window, 
-											GdkEvent * event,
-											gpointer p)
-{
-	GtkWidget * dialog 
-		= gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
-										  GTK_MESSAGE_QUESTION,
-										  GTK_BUTTONS_YES_NO,
-										  "Are you sure that you want to quit?");
-	gtk_window_set_title (GTK_WINDOW (dialog), "Close Application");
-
-	gint result = gtk_dialog_run (GTK_DIALOG (dialog));
-  
-	gtk_widget_destroy (dialog);
-
-	return (result == GTK_RESPONSE_YES) ? FALSE : TRUE;
-}
-
-/* @description: This is the callback to the "destroy" signal that is
-   emitted from GtkMain. Any cleanup should be done here.
-   @window: A pointer to the GtkWindow object.
-   @data: NULL */
-static guint
-application_signal_destroy_event (GtkWidget *window, gpointer data)
-{
-	ApplicationState * appstate = (ApplicationState *)data;
-	*appstate->shutdown = TRUE;
-
-	/* Because of a change to the Plugin architecture it will now yield until
-		all threads that were instatiated are closed properly. We use the 
-		appstate->workbook_first variable in order to test for NULL. */
-	gdk_threads_leave();
-	DESTROY (Plugin, appstate->plugin_first);
-	gdk_threads_enter();
-
-	appstate->plugin_first = appstate->plugin_last = NULL;
-
-	gtk_main_quit ();
-	return FALSE;
-}
-
-/* @description: This method loads an extension from the filename
-   provided. It also registers the plugin's method and calls it.
-   @app: A pointer to the application state object.
-   @filename: The string that we should load the library from.
-   @absolute_path: Is the string an absolute or relative path? */
-static void
-application_method_openextension (ApplicationState * app, 
-											 const gchar * filename,
-											 gboolean absolute_path)
-{
-	ASSERT (app != NULL);
-	gchar * fname = NULL;
-  
-	if (absolute_path)
-	{
-      fname = g_strconcat (app->absolute_path, 
-									filename,
-									NULL);
-	}
-	else
-	{
-      fname = g_strdup (filename);
-	}
-
-	Plugin * plugin = NULL;
-	if ((plugin = app->load_plugin (app, fname)) != NULL)
-	{
-      typedef Workbook * (*Plugin_Main) (ApplicationState *, Plugin *);
-      Plugin_Main plugin_main;
-	  
-      if ((plugin_main 
-			  = plugin->method_register (plugin, "plugin_main")) == NULL)
-		{
-			g_critical ("Unable to register method with symbol 'plugin_main'");
-			exit (1);
-		}
-
-      Workbook * wb = plugin_main (app, plugin);
-      if (wb == NULL)
-		{
-			g_critical ("Plugin returned a NULL pointer instead of allocated"
-							" workbook.");
-			exit (1);
-		}
-      else
-		{
-			/* Attach all of the signals for the Workbook object. */
-			gtk_signal_connect (GTK_OBJECT (wb->gtk_notebook),
-									  "switch-page",
-									  (GtkSignalFunc)app->signals[SIG_NOTEBOOK_SWITCHED], 
-									  (gpointer)wb);
-	  
-			LINK_OBJECT (app->workbook_first, app->workbook_last, wb);
-		}
-	}
-
-	if (absolute_path)
-		FREE (fname);
-}
-

commit ed57538d5ac4e42c2e631728b91062b46ad9ff28
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 16:37:36 2009 -0400

    Merged application.c into Application.cc, and added additional exclusion to .gitignore.

diff --git a/.gitignore b/.gitignore
index 6f5f9d5..ab33b31 100755
--- a/.gitignore
+++ b/.gitignore
@@ -6,4 +6,5 @@ lib/
 csv/libcsv.*
 massif*
 *.log
-\#*\#
\ No newline at end of file
+\#*\#
+.\#*
\ No newline at end of file
diff --git a/src/Application.cc b/src/Application.cc
index db1f8e2..070b100 100644
--- a/src/Application.cc
+++ b/src/Application.cc
@@ -1,5 +1,127 @@
 #include "Application.hpp"
 
+static guint
+signal_gtknotebook_removed (GtkNotebook * notebook,
+									 GtkNotebookPage * page,
+									 gint page_num,
+									 Workbook * wb) {
+	ASSERT (wb != NULL);
+	return TRUE;
+}
+
+static guint
+signal_gtknotebook_reordered (GtkNotebook * notebook,
+										GtkNotebookPage * page,
+										gint page_num,
+										Workbook * wb) {
+	ASSERT (wb != NULL);
+	return TRUE;
+}
+
+/* @description: This is the callback for the GtkNotebook 'switch-page' 
+   signal. It is called every single time a user *clicks* on different
+   tab. This method is called *before* the drawing takes place.
+
+   This method iterates through the Sheets and updates where neccesary.
+
+   @notebook: This is a pointer to the notebook object. The object is
+   equal to the Workbook->gtk_notebook pointer.
+   @page:
+   @page_num: The number of the *new* page.
+   @book: The Workbook object associated with the GtkNotebook.*/
+static guint
+signal_gtknotebook_switchpage (GtkNotebook * notebook,
+										 GtkNotebookPage * page,
+										 gint page_num,
+										 Workbook * book) {
+	ASSERT (book != NULL);
+
+	/* Perform the "unfocus" on the old notebook tab. */
+	if (!IS_NULL (book->focus_sheet)) {
+      book->focus_sheet->has_focus = FALSE;
+      book->focus_sheet->notices = 0;
+	}
+
+	GtkWidget * widget = gtk_notebook_get_nth_page (notebook, page_num);
+
+	ITERATE_BEGIN (Sheet, book->sheet_first);
+	{
+		/* Once we find the right Sheet object we can perform what we need
+			to in order to change the "focus." Finally, set book pointer. */
+		if (it->gtk_box == widget)
+      {
+			it->page = page_num;
+			it->has_focus = TRUE;
+			it->notices = 0;
+	
+			/* Reset the label on the notebook tab to the object's name. */
+			gtk_notebook_set_tab_label_text (notebook,
+														it->gtk_box,
+														it->name);
+			book->focus_sheet = it;
+			break;
+      }
+	}
+	ITERATE_END ();
+	return TRUE;
+}
+
+static guint
+signal_gtksheet_changed (GtkWidget * gtksheet,
+								 gint row, gint column,
+								 Sheet * sheet) {
+	ASSERT (sheet != NULL);
+	ASSERT (sheet->workbook != NULL);
+
+	Workbook * wb = sheet->workbook;
+
+	if (sheet->notices > 0) {
+      gchar * label 
+			= g_strdup_printf ("%s (%d)", sheet->name, sheet->notices);
+      gtk_notebook_set_tab_label_text (GTK_NOTEBOOK (wb->gtk_notebook),
+													sheet->gtk_box,
+													label);
+      FREE (label);
+	}
+	return FALSE;
+}
+
+/* @description: This is the callback to GtkMain's "delete" event. This is
+   called when we attempt to close the application safely. 
+   @window: A pointer to the GtkWindow object.
+   @event: A pointer to the associated GdkEvent information.
+   @p: NULL */
+static guint
+application_signal_delete_event (GtkWindow * window, 
+											GdkEvent * event,
+											gpointer p)
+{
+	GtkWidget * dialog 
+		= gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
+										  GTK_MESSAGE_QUESTION,
+										  GTK_BUTTONS_YES_NO,
+										  "Are you sure that you want to quit?");
+	gtk_window_set_title (GTK_WINDOW (dialog), "Close Application");
+
+	gint result = gtk_dialog_run (GTK_DIALOG (dialog));
+  
+	gtk_widget_destroy (dialog);
+
+	return (result == GTK_RESPONSE_YES) ? FALSE : TRUE;
+}
+
+/* @description: This is the callback to the "destroy" signal that is
+   emitted from GtkMain. Any cleanup should be done here.
+   @window: A pointer to the GtkWindow object.
+   @data: NULL */
+static guint
+application_signal_destroy_event (GtkWidget *window, gpointer data)
+{
+	Application * app = (Application *)data;
+	app->shutdown();
+	return FALSE;
+}
+
 Application::Application (int argc, char ** argv) {
 	this->init (argc, argv);
 	this->cfg = NULL;
@@ -8,25 +130,170 @@ Application::Application (int argc, char ** argv) {
 	this->gtk_window_vbox = NULL;
 	
 	/* Set up the signals. */
-	this->signals[SIG_NOTEBOOK_SWITCHED]
+	this->signals[NOTEBOOK_SWITCHED]
 		= (GSourceFunc)signal_gtknotebook_switchpage;
-	this->signals[SIG_NOTEBOOK_REORDERED]
+	this->signals[NOTEBOOK_REORDERED]
 		= (GSourceFunc)signal_gtknotebook_reordered;
-	this->signals[SIG_NOTEBOOK_REMOVED]
+	this->signals[NOTEBOOK_REMOVED]
 		= (GSourceFunc)signal_gtknotebook_removed;
-	this->signals[SIG_DESTROY_EVENT]
+	this->signals[DESTROY_EVENT]
 		= (GSourceFunc)signal_destroy_event;
-	this->signals[SIG_DELETE_EVENT]
+	this->signals[DELETE_EVENT]
 		= (GSourceFunc)signal_delete_event;
-	this->signals[SIG_SHEET_CHANGED]
+	this->signals[SHEET_CHANGED]
 		= (GSourceFunc)signal_gtksheet_changed;
 }
 
+Application::~Application (void) {
+	/* Because of a change to the Plugin architecture it will now yield until
+		all threads that were instatiated are closed properly. We use the 
+		appstate->workbook_first variable in order to test for NULL. */
+	gdk_threads_leave();
+	{
+		PluginList::iterator it = this->plugins.begin();
+		while (it != this->plugins.end()) {
+			(*it)->destroy ( (*it) ); (*it) = NULL;
+			it++;
+		}
+	}
+	gdk_threads_enter();
+
+	WorkbookList::iterator it = this->workbooks.begin();
+	while (it != this->workbooks.end()) {
+		(*it)->destroy ( (*it) ); (*it) = NULL;
+		it++;
+	}
+	
+	FREE (this->absolute_path);
+
+	this->shutdown();
+}
+
+Plugin *
+Application::load_plugin (const gchar * filename) {
+	Plugin * plugin = NULL;
+
+	if ((plugin == plugin_open(filename)) != NULL) {
+		this->plugins.push_back (plugin);
+	}
+	return plugin;
+}
+
+void
+Application::shutdown(void) {
+	// STUB: shutdown the proactor threads here.
+	
+	gtk_main_quit ();
+}
+
+void
+Application::open_extension (const gchar * filename, gboolean absolute_path) {
+	gchar * fname = NULL;
+
+	if (absolute_path) {
+		fname = g_strconcat (this->absolute_path, filename, NULL);
+	}
+	else {
+		fname = g_strdup (filename);
+	}
+
+	Plugin * plugin = NULL;
+	if ((plugin = this->load_plugin (fname)) != NULL) {
+		typedef Workbook * (*Plugin_Main) (ApplicationState *, Plugin *);
+      Plugin_Main plugin_main;
+	  
+      if ((plugin_main = plugin->method_register (plugin, "plugin_main")) == NULL) {
+			g_critical ("Unable to register method with symbol 'plugin_main'");
+			exit (1);
+		}
+
+      Workbook * wb = plugin_main (this, plugin);
+      if (wb == NULL) {
+			g_critical ("Plugin returned a NULL pointer instead of allocated"
+							" workbook.");
+			exit (1);
+		} else {
+			/* Attach all of the signals for the Workbook object. */
+			gtk_signal_connect (GTK_OBJECT (wb->gtk_notebook),
+									  "switch-page",
+									  (GtkSignalFunc)this->signals[SIG_NOTEBOOK_SWITCHED], 
+									  (gpointer)wb);
+	  
+			this->workbooks.push_back (wb);
+		}
+	}
+
+	FREE (fname);
+}
+
 void
 Application::init (int argc, char ** argv) {
+	int c;
+	
+	if (!g_thread_supported ()) {
+      g_thread_init (NULL);
+      gdk_threads_init ();
+	}
 
+	this->absolute_path = munchpath (*argv[0]);
+	
+	/* This block parses the commandline for options. A better example on how
+		this code works can be found on the GNU website at the following URI:
+		http://gnu.org/software/libtool/manual/libc/Using-Getopt.html */
+	while ((c = getopt (*argc, *argv, "c:")) != -1) {
+      switch (c) {
+			case 'c': {
+				Config * cfg = config_new (optarg);
+				if (!cfg)
+				{
+					g_critical ("Failed loading configuration file '%s';" 
+									" which was specified with -c argument\n", optarg);
+					exit (0);
+					break;
+				}
+				this->cfg = cfg;
+			}
+			break;
+
+			case '?': {
+				if (optopt == 'c') {
+					g_warning ("Option -c requires an argument in order to load"
+								  " a configuration file\n");
+				}
+			}
+			break;
+		}
+	}
+
+	gdk_threads_enter ();
+	gtk_init (argc, argv);
+
+	/* Create the window and connect two callback to the signals. */
+	this->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
+							  "destroy",
+							  G_CALLBACK (this->signals[DESTROY_EVENT]),
+							  (gpointer *)this);
+	gtk_signal_connect (GTK_OBJECT (this->gtk_window),
+							  "delete_event",
+							  G_CALLBACK (this->signals[DELETE_EVENT]),
+							  NULL);
+  
+	/* Set the initial size of the application; we could load this
+		from a configuration file eventually. */
+	gtk_widget_set_usize (this->gtk_window, 1024, 768);
+  
+	/* Attach the window box to the window and present to the screen. */
+	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
+	gtk_container_add (GTK_CONTAINER (this->gtk_window), window_box);
+	this->gtk_window_vbox = window_box;
+  
+	gtk_widget_show_all (this->gtk_window);
+ 
+	gdk_threads_leave ();
+	
 	if (this->cfg) {
-		Config * cfg = appstate->cfg;
+		Config * cfg = this->cfg;
       cfg->open (cfg);
      
       /* Load extensions */
@@ -56,17 +323,13 @@ Application::init (int argc, char ** argv) {
 						gboolean RelativePath 
 							= (filename->value[0] == '/') ? FALSE : TRUE;
 
-						appstate->open_extension (appstate, 
-														  filename->value, 
-														  RelativePath);
+						this->open_extension (filename->value, RelativePath);
 					}
 				}
 				ii++;
 			}
 		}
 	}
-
-	
 }
 
 int
@@ -81,7 +344,7 @@ Application::run (void) {
 		interation. This allows us to call gdk_threads_enter/leave inside
 		of another thread. */
 	gdk_threads_enter ();
-	gtk_main ();
+	gtk_main();
 	gdk_threads_leave ();
 	return 0;
 }

commit c1ad5cca78b0feab01697ab3e259aeec19efd928
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 16:01:29 2009 -0400

    Removed main.c and application.h; begun adding Application object in port
    to C++.

diff --git a/src/Application.cc b/src/Application.cc
new file mode 100644
index 0000000..db1f8e2
--- /dev/null
+++ b/src/Application.cc
@@ -0,0 +1,88 @@
+#include "Application.hpp"
+
+Application::Application (int argc, char ** argv) {
+	this->init (argc, argv);
+	this->cfg = NULL;
+	this->gtk_window = NULL;
+	this->gtk_menu = NULL;
+	this->gtk_window_vbox = NULL;
+	
+	/* Set up the signals. */
+	this->signals[SIG_NOTEBOOK_SWITCHED]
+		= (GSourceFunc)signal_gtknotebook_switchpage;
+	this->signals[SIG_NOTEBOOK_REORDERED]
+		= (GSourceFunc)signal_gtknotebook_reordered;
+	this->signals[SIG_NOTEBOOK_REMOVED]
+		= (GSourceFunc)signal_gtknotebook_removed;
+	this->signals[SIG_DESTROY_EVENT]
+		= (GSourceFunc)signal_destroy_event;
+	this->signals[SIG_DELETE_EVENT]
+		= (GSourceFunc)signal_delete_event;
+	this->signals[SIG_SHEET_CHANGED]
+		= (GSourceFunc)signal_gtksheet_changed;
+}
+
+void
+Application::init (int argc, char ** argv) {
+
+	if (this->cfg) {
+		Config * cfg = appstate->cfg;
+      cfg->open (cfg);
+     
+      /* Load extensions */
+      ConfigRow * load = cfg->get_row (cfg, "application", "load");
+
+      /* Did a little bit of fixing here. We needed something to specify that
+			certain extensions will start automatically when the application is
+			started. */
+      if (!IS_NULL (load)) {
+			ConfigVector * ext = load->get_vector (load, "extensions");
+			gchar * block = NULL;
+			gint ii = 0;
+
+			if (IS_NULL (ext)) {
+				g_critical ("Config 'extensions' vector is NULL");
+				return -1;
+			}
+      
+			while ((block = ext->get(ext, ii)) != NULL) {
+				ConfigPair * run = cfg->get_pair (cfg, block, "onLoad", "run");
+	      
+				if (run && (strcmp (run->value, "1") == 0)) {
+					ConfigPair * filename 
+						= cfg->get_pair (cfg, block, "linux", "filename");
+
+					if (!IS_NULL (filename) && !IS_NULLSTR (filename->value)) {
+						gboolean RelativePath 
+							= (filename->value[0] == '/') ? FALSE : TRUE;
+
+						appstate->open_extension (appstate, 
+														  filename->value, 
+														  RelativePath);
+					}
+				}
+				ii++;
+			}
+		}
+	}
+
+	
+}
+
+int
+Application::run (void) {
+	if (proactor.start() == false) {
+		g_critical ("Failed to start the proactor thread; exiting application.");
+		return -1;
+	}
+	
+	/* Start the GTK+ main loop; make sure it is surrounded in the 
+		thread calls. GTK+ "releases" the current lock after every loop
+		interation. This allows us to call gdk_threads_enter/leave inside
+		of another thread. */
+	gdk_threads_enter ();
+	gtk_main ();
+	gdk_threads_leave ();
+	return 0;
+}
+
diff --git a/src/Application.hpp b/src/Application.hpp
new file mode 100644
index 0000000..917e37f
--- /dev/null
+++ b/src/Application.hpp
@@ -0,0 +1,49 @@
+#ifndef HPP_APPLICATION
+#define HPP_APPLICATION
+
+#include <string>
+#include <list>
+#include <cstdio>
+#include <cstdlib>
+#include <gtkworkbook/workbook.h>
+#include "config.h"
+#include "plugin.h"
+#include "proactor/Proactor.hpp"
+
+class Application {
+public:
+	enum sigs {
+		DESTROY_EVENT = 0,
+		DELETE_EVENT,
+		NOTEBOOK_SWITCHED,
+		NOTEBOOK_REMOVED,
+		NOTEBOOK_REORDERED,
+		SHEET_CHANGED,
+		/**/
+		MAX_SIGNALS
+	};
+private:
+	typedef std::list<Workbook *> WorkbookList;
+	typedef std::list<Plugin *> PluginList;
+
+	GSourceFunc signals[MAX_SIGNALS];
+	Workbook * active_workbook;
+	GtkWidget * gtk_window;
+	GtkWidget * gtk_window_vbox;
+	GtkWidget * gtk_menu;
+	Config * cfg;
+	Proactor proactor;
+	WorkbookList workbooks;
+	PluginList plugins;
+	gchar * absolute_path;
+	
+	void init (int argc, char ** argv);
+public:
+	Application (int argc, char ** argv);
+	~Application (void);
+
+	int run (void);
+	
+};
+
+#endif
diff --git a/src/application.h b/src/application.h
deleted file mode 100755
index 5239bb0..0000000
--- a/src/application.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef H_APPLICATION
-#define H_APPLICATION
-
-typedef struct _ApplicationState ApplicationState;
-
-#include <gtk/gtk.h>
-#include <gtkworkbook/workbook.h>
-#include <shared.h>
-#include "plugin.h"
-#include "config.h"
-
-enum
-	{
-		SIG_DESTROY_EVENT = 0,
-		SIG_DELETE_EVENT,
-		SIG_NOTEBOOK_SWITCHED,
-		SIG_NOTEBOOK_REMOVED,
-		SIG_NOTEBOOK_REORDERED,
-		SIG_SHEET_CHANGED,
-		/**/
-		MAX_SIGNALS
-	};
-
-struct _ApplicationState
-{
-	/* Members */
-	GSourceFunc signals[MAX_SIGNALS];
-	Config * cfg;
-	Workbook * workbook_first, * workbook_last;
-	Plugin * plugin_first, * plugin_last;
-	GtkWidget * gtk_window;
-	GtkWidget * gtk_menu;
-	GtkWidget * gtk_window_vbox;
-	gchar * absolute_path;
-	gboolean * shutdown;
-
-	/* Methods */
-	int (*run) (ApplicationState *);
-	void (*close) (ApplicationState *);
-	void (*open_extension) (ApplicationState *, const gchar *, gboolean);
-	Plugin *(*load_plugin) (ApplicationState *, const gchar *);
-};
-
-/* application.c */
-ApplicationState * application_init (int * argc, char *** argv);
-
-#endif
diff --git a/src/main.c b/src/main.c
deleted file mode 100755
index 3e5a2ac..0000000
--- a/src/main.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "application.h"
-
-int 
-main(int argc, char *argv[])
-{
-	ApplicationState *app = application_init (&argc, &argv);
-
-	app->run (app);
-	app->close (app);
-
-	return 0; 
-}
-
-
diff --git a/src/main.cc b/src/main.cc
new file mode 100644
index 0000000..90df412
--- /dev/null
+++ b/src/main.cc
@@ -0,0 +1,7 @@
+#include "Application.hpp"
+
+int
+main (int argc, char ** argv) {
+	Application app (argc, argv);
+	return app.run();
+}

commit d35d539bcca33ad2095091edf407ec83abf19453
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 15:41:50 2009 -0400

    Changed references to csv, workbook, and config header files.

diff --git a/Makefile b/Makefile
index 679764c..d9ac1d1 100755
--- a/Makefile
+++ b/Makefile
@@ -2,38 +2,20 @@ MD=mkdir -p
 MAKE=-make -C
 PWD=`pwd`
 
-all:	libshared libconfig libworkbook libcsv gtkworkbook
+all:	libgtkworkbook gtkworkbook
 
-libshared:
-	${MD} OBJS/libshared
-	${MAKE} shared/ all
-
-libcsv:
-	${MD} OBJS/libcsv
-	${MAKE} csv/ all
-
-libconfig:
-	${MD} OBJS/libconfig
-	${MAKE} config/ all
-
-libworkbook:
-	${MD} OBJS/libworkbook
-	${MAKE} workbook/ all
+libgtkworkbook:
+	${MD} OBJS/libgtkworkbook
+	${MAKE} gtkworkbook/ all
 
 gtkworkbook:
 	${MD} OBJS/realtime
 	$(MAKE) src/ all
 
 clean:
-	${MAKE} shared/ clean
-	$(MAKE) config/ clean
-	${MAKE} workbook/ clean
-	${MAKE} csv/ clean
+	${MAKE} gtkworkbook/ clean
 	$(MAKE) src/ clean
 
 install: all
-	${MAKE} shared/ install
-	$(MAKE) config/ install
-	${MAKE} workbook/ install
-	${MAKE} csv/ install
+	${MAKE} gtkworkbook/ install
 	${MAKE} src/ install
diff --git a/src/Makefile b/src/Makefile
index 16537c7..9534d4c 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -3,7 +3,7 @@ include ../Makefile.base
 SRCS=$(wildcard *.c)
 OBJS=$(patsubst %.c,${OBJDIR}/%.o,${SRCS})
 
-LFLAGS=-lworkbook -lconfig -lgtkextra-x11-2.0 -lgthread-2.0
+LFLAGS=-lgtkworkbook -lgtkextra-x11-2.0 -lgthread-2.0
 
 all: 	gtkworkbook
 	make -C realtime/ all
diff --git a/src/application.h b/src/application.h
index 1df1b15..5239bb0 100755
--- a/src/application.h
+++ b/src/application.h
@@ -22,10 +22,10 @@
 typedef struct _ApplicationState ApplicationState;
 
 #include <gtk/gtk.h>
-#include <workbook/workbook.h>
-#include <config/config.h>
+#include <gtkworkbook/workbook.h>
 #include <shared.h>
 #include "plugin.h"
+#include "config.h"
 
 enum
 	{
diff --git a/src/config.c b/src/config.c
new file mode 100755
index 0000000..0fced05
--- /dev/null
+++ b/src/config.c
@@ -0,0 +1,761 @@
+/*
+  config.c - Configuration File Object/Parser
+
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <config/config.h>
+#include <stdlib.h>
+#include <string.h>
+#include "parse.h"
+
+/* config.c (static) */
+
+static Config *config_object_init (const gchar *);
+static ConfigPair *configpair_object_init (ConfigRow *, 
+					   const gchar *,
+					   const gchar *);
+static ConfigRow *configrow_object_init (ConfigBlock *, const gchar *);
+static ConfigBlock *configblock_object_init (Config *, const gchar *);
+static ConfigVector *configvector_object_init (ConfigRow *,const gchar *);
+static void configrow_object_free (ConfigRow *);
+static void configblock_object_free (ConfigBlock *);
+static void configpair_object_free (ConfigPair *);
+static void config_object_free (Config *);
+static void configvector_object_free (ConfigVector *);
+static ConfigVector *config_method_get_vector (Config *,
+					       const gchar *,
+					       const gchar *,
+					       const gchar *);
+static ConfigPair *config_method_get_pair (Config *,
+					   const gchar *,
+					   const gchar *,
+					   const gchar *);
+static ConfigBlock *config_method_get_block (Config *, const gchar *);
+static ConfigPair *configblock_method_get_pair (ConfigBlock *, 
+						const gchar *,
+						const gchar *);
+static ConfigRow *config_method_get_row (Config *,
+					 const gchar *, 
+					 const gchar *);
+static ConfigRow *configblock_method_get_row (ConfigBlock *, const gchar *);
+static gchar *configrow_method_parse (ConfigRow *, gchar *);
+static void configrow_method_destroy (ConfigRow *);
+static ConfigPair *configrow_method_get_pair (ConfigRow *, const gchar *);
+static ConfigVector *configrow_method_get_vector (ConfigRow *, const gchar *);
+static void configpair_method_destroy (ConfigPair *);
+static void configblock_method_destroy (ConfigBlock *);
+static void configvector_method_destroy (ConfigVector *);
+static gint configvector_method_get_int (ConfigVector *, gint);
+static gchar *configvector_method_get (ConfigVector *, gint);
+static void configvector_method_add (ConfigVector *, const gchar *);
+static gchar *configblock_method_parse (ConfigBlock *, gchar *, FILE *);
+static void config_method_destroy (Config *);
+static gint config_method_open (Config *);
+static gint config_method_save (Config *, const gchar *);
+static gint config_method_load (Config *, FILE *);
+
+ConfigBlock *
+configblock_new (Config * c, const gchar * tag)
+{
+  /* No NULL tags. */
+  if (IS_NULLSTR (tag)) return NULL;
+  return configblock_object_init (c, tag);
+}
+
+static gchar *
+configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
+{
+  ASSERT (block != NULL);
+  ASSERT (p != NULL);
+
+  if (!fp || feof (fp)) return FALSE;
+
+  gchar buf[1024], word[1024];
+  gchar * q = NULL;
+  g_stpcpy (word, p);
+
+  /* This block of code makes sure that we indeed have an opening brace
+    to continue with parsing of the configuration file. */
+  do
+    {
+      p = word;
+      
+      if (EXPECT (p, q, '{'))
+	{
+	  g_stpcpy (buf, q + 1);
+	  break;
+	} 
+
+      if (*q == '\0')
+	continue;
+      return NULL;
+    } while (fgets (word, 1024, fp) != NULL);
+
+  /* Start actually parsing rows now. */
+  do 
+    {
+      p = buf;
+      do
+	{
+	  if (*p == '}')
+	    return p;
+	  else if (*p == '\n')
+	    {
+	      p++;
+	      continue;
+	    }
+	  else 
+	    {
+	      if ((q = parse (p, &word[0], 1024, ':')) != NULL)
+		{
+		  if (*(q+1) == ':')
+		    {
+		      ConfigRow * row 
+			= block->get_row (block, trim (&word[0]));
+		      
+		      if (row)
+			{
+			  fprintf (stderr, "**CONFIG**: row '%s' already"
+				   " defined in block '%s'; replacing\n",
+				   row->tag, block->tag);
+			  fflush (stderr);
+
+			  row->destroy (row);
+			}
+
+		      row = configrow_new (block, trim (&word[0]));
+		    
+		      if ((p = row->parse (row, q+2)) == NULL)
+			{
+			  fprintf (stderr, "Error parsing line: %s", buf);
+			  fflush (stderr);
+			  return NULL;
+			}
+		      break;
+		    }
+		}
+	    }
+	  fprintf (stderr, "Error in formatting on line: %s\n", buf);
+	  fflush (stderr);
+	  return NULL;
+	} while (*p != '\0');
+     } while (fgets (buf, 1024, fp) != NULL);
+  return NULL;
+}
+
+static void
+configblock_method_destroy (ConfigBlock * block)
+{
+  ASSERT (block != NULL);
+
+  DESTROY (ConfigRow, block->row_head);
+  SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
+		 block->cfg->block_tail, block);
+  
+  configblock_object_free (block);
+}
+
+static ConfigRow *
+configblock_method_get_row (ConfigBlock * block, const gchar * row)
+{
+  ASSERT (block != NULL);
+
+  if (!IS_NULLSTR (row))
+    {
+      ITERATE_BEGIN (ConfigRow, block->row_head);
+      {
+	if (!strcmp (it->tag, row))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static ConfigPair *
+configblock_method_get_pair (ConfigBlock * block, 
+			     const gchar * row,
+			     const gchar * key)
+{
+  ASSERT (block != NULL);
+
+  if (!IS_NULLSTR (row))
+    {
+      ITERATE_BEGIN (ConfigRow, block->row_head);
+      {
+	if (!strcmp (it->tag, row))
+	  return it->get_pair (it, key);
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static void
+configblock_object_free (ConfigBlock * block)
+{
+  ASSERT (block != NULL);
+
+  FREE (block->tag);
+  
+  FREE (block);
+  block = NULL;
+}
+
+static ConfigBlock *
+configblock_object_init (Config * c, const gchar * tag)
+{
+  ASSERT (c != NULL);
+
+  ConfigBlock * b = NEW (ConfigBlock);
+
+  /* Members */
+  b->cfg = c;
+  b->tag = g_strdup (tag);
+  b->next = NULL; 
+  b->row_head = b->row_tail = NULL;
+  
+  /* Methods */
+  b->parse = configblock_method_parse;
+  b->destroy = configblock_method_destroy;
+  b->get_row = configblock_method_get_row;
+  b->get_pair = configblock_method_get_pair;
+
+  SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
+  return b;
+}
+
+Config *
+config_new (const gchar * filename)
+{
+  return config_object_init (filename);
+}
+
+static void
+config_method_destroy (Config * c)
+{
+  ASSERT (c != NULL);
+
+  DESTROY (ConfigBlock, c->block_head);
+  
+  config_object_free (c);
+}
+
+static ConfigRow *
+config_method_get_row (Config * cfg, const gchar * block, const gchar * row)
+{
+  ASSERT (cfg != NULL);
+ 
+  ConfigBlock * b = cfg->get_block (cfg, block);
+  if (b == NULL)
+    return NULL;
+  return b->get_row (b, row);
+}
+
+static ConfigBlock *
+config_method_get_block (Config * cfg, const gchar * block)
+{
+  ASSERT (cfg != NULL);
+
+  if (!IS_NULLSTR (block))
+    {
+      ITERATE_BEGIN (ConfigBlock, cfg->block_head);
+      {
+	if (!strcmp (it->tag, block))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static ConfigPair *
+config_method_get_pair (Config * cfg, 
+			const gchar * block, 
+			const gchar * row,
+			const gchar * pair)
+{
+  ASSERT (cfg != NULL);
+
+  ConfigRow * r = cfg->get_row (cfg, block, row);
+  if (r == NULL)
+    return NULL;
+  return r->get_pair (r, pair);
+}
+
+static ConfigVector *
+config_method_get_vector (Config * cfg,
+			  const gchar * block,
+			  const gchar * row,
+			  const gchar * vector)
+{
+  ASSERT (cfg != NULL);
+  
+  ConfigRow * r = cfg->get_row (cfg, block, row);
+  if (r == NULL)
+    return NULL;
+  return r->get_vector (r, vector);
+}
+
+static void
+config_object_free (Config * c)
+{
+  ASSERT (c != NULL);
+
+  FREE (c->filename);
+
+  FREE (c);
+  c = NULL;
+}
+
+static Config *
+config_object_init (const gchar * filename)
+{
+  Config * c = NEW (Config);
+
+  /* Members */
+  c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
+  c->block_head = c->block_tail = NULL;
+
+  /* Methods */
+  c->open = config_method_open;
+  c->save = config_method_save;
+  c->load = config_method_load;
+  c->close = config_method_destroy;
+  c->get_vector = config_method_get_vector;
+  c->get_row = config_method_get_row;
+  c->get_block = config_method_get_block;
+  c->get_pair = config_method_get_pair;
+
+  return c;
+}
+
+static gint
+config_method_load (Config * c, FILE * fp)
+{
+  ASSERT (c != NULL);
+  
+  if (!fp || feof(fp))
+    {
+      /* STUB: log me? */
+      return FALSE;
+    }
+
+  gchar * buf = g_malloc (sizeof (char) * 1024);
+  gchar word[1024];
+  gchar * p = NULL, * q = NULL, * r = NULL;
+
+  while ((p = fgets (buf, 1024, fp)) != NULL) {
+      r = buf + (strlen (buf) - 1);
+ 
+      while (p && (p < r) && (*p != '\n'))
+	{
+	  if (*p == '%')
+	    {
+	      if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
+		/* STUB: exit parsing with a failure. */
+		g_free (buf);	
+		return FALSE;
+	      }
+
+	      if (strcmp (word, "block") == 0)
+		{
+		  if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+		    g_free(buf);
+		    return FALSE;
+		  }
+		  
+		  /* Replace the block if it already exists. Throw error. */
+		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
+		  if (b)
+		    {
+		      fprintf (stderr, "**CONFIG**: block '%s' already"
+			       "exists. Destroying and replacing.\n", b->tag);
+		      fflush (stderr);
+		      b->destroy (b);
+		    }
+
+		  b = configblock_new (c, trim (&word[0]));
+
+		  if ((p = b->parse (b, q, fp)) == NULL) {
+		    g_free (buf);
+		    return FALSE;
+		  }
+		}
+	      else if (strcmp (word, "include") == 0)
+		{
+		  if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+		    g_free (buf);
+		    return FALSE;
+		  }
+
+		  /* Include the file; we're going to load up this file
+		     first and then proceed with parsing. */
+		  FILE * ifp = NULL;
+		 
+		  if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
+		    {
+		      fprintf (stderr, "**CONFIG**: include '%s' does not"
+			       " seem to exist or unable to read.\n",
+			       word);
+		      fflush (stderr);
+		      continue;
+		    }
+
+		  c->load (c, ifp);
+		}
+	      else {
+		g_free (buf);
+		return FALSE;
+	      }
+	    }
+	  /* BUGFIX: Need to check for tabs. */
+	  else if ((*p != ' ') && (*p != '\t'))
+	    {
+	      /* STUB: error out */
+	      g_free (buf);
+	      return FALSE;
+	    }
+
+	  p++;
+	}
+    }
+  g_free (buf);
+  return TRUE;
+}
+
+static gint
+config_method_save (Config * c, const gchar * filename)
+{
+  ASSERT (c != NULL);
+
+  if (IS_NULLSTR (filename)) return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (filename, "w")) == NULL)
+    {
+      /* STUB: log me? */
+      return FALSE;
+    }
+  
+  FCLOSE (fp);
+  return TRUE;
+}
+
+static gint
+config_method_open (Config * c)
+{
+  ASSERT (c != NULL);
+
+  if (IS_NULLSTR (c->filename))
+    return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (c->filename, "r")) == NULL)
+    {
+      /* STUB: log this? */
+      return FALSE;
+    }
+
+  gint result = c->load (c, fp);
+  if (result == FALSE)
+    {
+      /* STUB: log me? */
+    }
+
+  FCLOSE (fp);
+  return result;
+}
+
+ConfigPair *
+configpair_new (ConfigRow * row, const gchar * key, const gchar * value)
+{
+  return configpair_object_init (row, key, value);
+}
+
+static ConfigPair *
+configpair_object_init (ConfigRow * row, 
+			const gchar * key,
+			const gchar * value)
+{
+  ASSERT (row != NULL);
+  ASSERT (!IS_NULLSTR (key));
+  
+  ConfigPair * pair = NEW (ConfigPair);
+
+  /* Members */
+  pair->row = row;
+  pair->key = g_strdup (key);
+  pair->next = NULL;
+  pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
+ 
+  /* Methods */
+  pair->destroy = configpair_method_destroy;
+  
+  DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
+  return pair;
+}
+
+static void
+configpair_method_destroy (ConfigPair * pair)
+{
+  ASSERT (pair != NULL);
+
+  DOUBLE_UNLINK (pair);
+
+  configpair_object_free (pair);
+}
+
+static void
+configpair_object_free (ConfigPair * pair)
+{
+  ASSERT (pair != NULL);
+
+  FREE (pair->key);
+  FREE (pair->value);
+  FREE (pair);
+}
+
+ConfigRow *
+configrow_new (ConfigBlock * block, const gchar * tag)
+{
+  return configrow_object_init (block, tag);
+}
+
+static ConfigRow *
+configrow_object_init (ConfigBlock * block, const gchar * tag)
+{
+  if (IS_NULLSTR (tag)) return NULL;
+
+  ConfigRow * row = NEW (ConfigRow);
+  
+  /* Members */
+  row->block = block;
+  row->tag = g_strdup (tag);
+  row->next = NULL;
+  row->vector_head = row->vector_tail = NULL;
+  row->pair_head = row->pair_tail = NULL;
+
+  /* Methods */
+  row->parse = configrow_method_parse;
+  row->destroy = configrow_method_destroy;
+  row->get_pair = configrow_method_get_pair;
+  row->get_vector = configrow_method_get_vector;
+
+  SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
+  return row;
+}
+
+static void
+configrow_object_free (ConfigRow *row)
+{
+  ASSERT (row != NULL);
+  
+  FREE (row->tag);
+
+  DESTROY (ConfigPair, row->pair_head);
+  DESTROY (ConfigVector, row->vector_head);
+
+  FREE (row);
+}
+
+static ConfigPair *
+configrow_method_get_pair (ConfigRow * row, const gchar * key)
+{
+  ASSERT (row != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ITERATE_BEGIN (ConfigPair, row->pair_head);
+      {
+	if (!strcmp (it->key, key))
+	  return it;
+      }
+      ITERATE_END();
+    }
+  return NULL;
+}
+
+static ConfigVector *
+configrow_method_get_vector (ConfigRow * row, const gchar * key)
+{
+  ASSERT (row != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ConfigPair * pair = row->get_pair (row, key);
+      if (IS_NULL (pair))
+	return NULL;
+
+      /* If we have already parsed it there is no reason to do it 
+	 a second time. Check existing linked list and return the
+	 pointer if we have already allocated it. */
+      ITERATE_BEGIN (ConfigVector, row->vector_head);
+      {
+	if (!strcmp (it->tag, key))
+	  return it;
+      }
+      ITERATE_END();
+
+      ConfigVector * vec = configvector_new (row, pair->key);
+      gchar buf[1024];
+      gchar * p = parse (pair->value, &buf[0], 1024, ','); 
+      gchar * q = pair->value + strlen (pair->value);
+    
+      do
+	{
+	  vec->add (vec, trim (&buf[0]));
+	} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
+
+      return vec;
+    }
+  return NULL;
+}
+
+static gchar *
+configrow_method_parse (ConfigRow * row, gchar * p)
+{
+  ASSERT (row != NULL);
+  ASSERT (p != NULL);
+
+  gchar key[1024], value[1024];
+  gchar * q = NULL, * s = NULL;
+
+  do
+    {
+      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
+	{
+	  break;
+	}      
+
+      if ((s = parse (q+1, &value[0], 1024, ';')) != NULL)
+	{
+	  ConfigPair * pair = row->get_pair (row, trim (&key[0]));
+	  if (pair)
+	    {
+	      fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
+		       " row '%s' block '%s'; replacing\n",
+		       pair->key, pair->value, row->tag, row->block->tag);
+	      fflush (stderr);
+	      pair->destroy (pair);
+	    }
+
+	  pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
+	}
+      p = s + 1;
+    } while (*p != '\n' && *p != '}' && *p != '\0');
+  return p;
+}
+
+static void 
+configrow_method_destroy (ConfigRow * row)
+{
+   ASSERT (row != NULL);
+
+   SINGLE_UNLINK (ConfigRow, row->block->row_head, row->block->row_tail, row);
+
+  configrow_object_free (row);
+}
+
+ConfigVector *
+configvector_new (ConfigRow * row, const gchar * tag)
+{
+  ASSERT (row != NULL);
+
+  /* No NULL Tags. */
+  if (IS_NULLSTR (tag)) return NULL;
+  return configvector_object_init (row, tag);
+}
+
+static ConfigVector *
+configvector_object_init (ConfigRow * row, const gchar * tag)
+{
+  ASSERT (row != NULL);
+
+  ConfigVector * vec = NEW (ConfigVector);
+
+  /* Members */
+  vec->row = row;
+  vec->tag = g_strdup (tag);
+  vec->next = vec->prev = NULL;
+  vec->array = g_ptr_array_sized_new (7);
+
+  /* Methods */
+  vec->destroy = configvector_method_destroy;
+  vec->get_int = configvector_method_get_int;
+  vec->get = configvector_method_get;
+  vec->add = configvector_method_add;
+
+  DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
+  return vec;
+}
+
+static void 
+configvector_object_free (ConfigVector * vec)
+{
+  ASSERT (vec != NULL);
+
+  FREE (vec->tag);
+
+  if (vec->array != NULL)
+    g_ptr_array_free (vec->array, TRUE);
+
+  FREE (vec);
+}
+
+static void
+configvector_method_destroy (ConfigVector * vec)
+{
+  ASSERT (vec != NULL);
+
+  DOUBLE_UNLINK (vec);
+
+  configvector_object_free (vec);
+}
+
+static gchar *
+configvector_method_get (ConfigVector * vec, gint index)
+{
+  ASSERT (vec != NULL);
+
+  if (index >= vec->array->len) return NULL;
+
+  gchar * rvalue = g_ptr_array_index (vec->array, index);
+  return rvalue;
+}
+
+static gint
+configvector_method_get_int (ConfigVector * vec, gint index)
+{
+  ASSERT (vec != NULL);
+
+  if (index >= vec->array->len) return -1;
+
+  gchar * rvalue = g_ptr_array_index (vec->array, index);
+  return atoi (rvalue);
+}
+
+static void
+configvector_method_add (ConfigVector * vec, const gchar * value)
+{
+  ASSERT (vec != NULL);
+  ASSERT (value != NULL);
+
+  gchar * ptr = g_strdup (value);
+  g_ptr_array_add (vec->array, ptr);
+}
diff --git a/src/config.h b/src/config.h
new file mode 100755
index 0000000..2113fff
--- /dev/null
+++ b/src/config.h
@@ -0,0 +1,134 @@
+/* 
+   config.h - Config Object/Parser Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef H_CONFIG
+#define H_CONFIG
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _Config Config;
+typedef struct _ConfigBlock ConfigBlock;
+typedef struct _ConfigRow ConfigRow;
+typedef struct _ConfigPair ConfigPair;
+typedef struct _ConfigVector ConfigVector;
+
+#include <shared.h>
+#include <stdlib.h>
+
+struct _ConfigPair
+{
+  /* Members */
+  ConfigRow * row;
+  ConfigPair * next;
+  ConfigPair * prev;
+  gchar * key;
+  gchar * value;
+
+  /* Methods */
+  void (*destroy) (ConfigPair *);
+};
+
+struct _ConfigVector
+{
+  /* Members */
+  ConfigRow * row;
+  ConfigVector * next;
+  ConfigVector * prev;
+  GPtrArray * array;
+  gchar * tag;
+
+  /* Methods */
+  void (*add) (ConfigVector *, const gchar *);
+  gint (*get_int) (ConfigVector *, gint);
+  gchar *(*get) (ConfigVector *, gint);
+  void (*destroy) (ConfigVector *);
+};
+
+struct _ConfigRow
+{
+  /* Members */
+  ConfigBlock * block;
+  ConfigRow * next;
+  ConfigVector * vector_head;
+  ConfigVector * vector_tail;
+  ConfigPair * pair_head;
+  ConfigPair * pair_tail;
+  gchar * tag;
+
+  /* Methods */
+  ConfigPair *(*get_pair) (ConfigRow *, const gchar *);
+  ConfigVector *(*get_vector) (ConfigRow *, const gchar *);
+  gchar *(*parse) (ConfigRow *, gchar *);
+  void (*destroy) (ConfigRow *);
+};
+
+struct _ConfigBlock
+{
+  /* Members */
+  ConfigBlock * next;
+  Config * cfg;
+  ConfigRow * row_head;
+  ConfigRow * row_tail;
+  gchar * tag;
+
+  /* Methods */
+  gchar *(*parse) (ConfigBlock *, gchar *, FILE *);
+  void (*destroy) (ConfigBlock *);
+  ConfigRow *(*get_row) (ConfigBlock *, const gchar *);
+  ConfigPair *(*get_pair) (ConfigBlock *, const gchar *, const gchar *);
+};
+
+struct _Config
+{
+  /* Members */
+  gchar * filename;
+  ConfigBlock * block_head;
+  ConfigBlock * block_tail;
+
+  /* Methods */
+  gint (*open) (Config *);
+  gint (*save) (Config *, const gchar *);
+  gint (*load) (Config *, FILE *);
+  void (*close) (Config *);
+  ConfigVector *(*get_vector) (Config *,
+			       const gchar *,
+			       const gchar *,
+			       const gchar *);
+  ConfigPair *(*get_pair) (Config *, 
+			   const gchar *, 
+			   const gchar *, 
+			   const gchar *);
+  ConfigBlock *(*get_block) (Config *, 
+			     const gchar *);
+  ConfigRow *(*get_row) (Config *, const gchar *, const gchar *);
+};
+
+/* config.c */
+ConfigBlock *configblock_new (Config *, const gchar *);
+Config *config_new (const gchar *);
+ConfigRow *configrow_new (ConfigBlock *, const gchar *);
+ConfigPair *configpair_new (ConfigRow *, const gchar *, const gchar *);
+ConfigVector *configvector_new (ConfigRow *, const gchar *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_CONFIG*/
diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index fc601d0..9a72de7 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -17,8 +17,7 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "CsvParser.hpp"
-#include <csv/csv.h>
-#include <workbook/sheet.h>
+#include <gtkworkbook/sheet.h>
 #include <queue>
 #include <string>
 #include <iostream>
diff --git a/src/largefile/CsvParser.hpp b/src/largefile/CsvParser.hpp
index b84a9a7..759768e 100755
--- a/src/largefile/CsvParser.hpp
+++ b/src/largefile/CsvParser.hpp
@@ -20,8 +20,9 @@
 #define HPP_LF_CSVPARSER
 
 #include <proactor/Worker.hpp>
-#include <workbook/workbook.h>
+#include <gtkworkbook/workbook.h>
 #include <concurrent/Thread.hpp>
+#include <libcsv/csv.h>
 
 namespace largefile {
 
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index f0444a9..205bd8c 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.base
 
-INCS += -I${PROJDIR}/shared
+INCS += -I${PROJDIR}/shared -I../
 SRCS=$(wildcard *.cpp) 
 OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
 
@@ -10,7 +10,7 @@ all: 	largefile
 
 largefile: ${OBJS}
 	${CX} ${_CXFLAGS} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread -lcsv -lshared
+	-lgthread-2.0 -lpthread -lcsv
 
 clean:		
 	${MD} ${OBJDIR}/largefile
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 34c7266..442a591 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -17,9 +17,10 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include <iostream>
-#include <workbook/workbook.h>
+#include <gtkworkbook/workbook.h>
 #include <concurrent/ThreadArgs.hpp>
 #include <gtk/gtk.h>
+#include "../config.h"
 #include "../application.h"
 #include "../plugin.h"
 
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index eb9e6c6..535eaa4 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -17,8 +17,7 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include <gdk/gdkkeysyms.h>
-#include <workbook/workbook.h>
-#include <config/config.h>
+#include <gtkworkbook/workbook.h>
 #include <concurrent/Thread.hpp>
 #include <concurrent/ThreadArgs.hpp>
 #include <concurrent/ScopedMemoryLock.hpp>
@@ -31,6 +30,7 @@
 #include <sstream>
 #include "File.hpp"
 #include "CsvParser.hpp"
+#include "../config.h"
 
 using namespace largefile;
 
diff --git a/src/parse.c b/src/parse.c
new file mode 100755
index 0000000..d575700
--- /dev/null
+++ b/src/parse.c
@@ -0,0 +1,78 @@
+/* 
+   parse.c - Generic Parsing Code
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "parse.h"
+#include <string.h>
+#include <stdlib.h>
+
+gchar *
+munch (gchar *p)
+{
+  ASSERT (p != NULL);
+  
+  /* Munch whitespace and ignore newlines, tabs. */
+  while (p && (*p == ' ' || *p == '\n' || *p == '\t')) { p++; } 
+  return p;
+}
+
+gchar *
+parse (gchar *p, gchar *word, gint n, const gchar delim)
+{
+  const gchar *q = p;
+  gint length = 0, ii = 0;
+
+  do 
+    {
+      if (*p == delim)
+	break;
+      p++;
+    } while (p && (*p != '\0') && (*p != '\n'));
+
+  length = (gint)(p - q);
+
+  if (n < length)    return NULL;
+
+  for (ii = 0; ii < length; ii++)
+    word[ii] = q[ii];
+  word[ii] = '\0';
+
+  return p;
+}
+
+gchar *
+trim (gchar *p)
+{
+  ASSERT (p != NULL);
+
+  gchar *q = NULL;
+
+  /* Eliminate tabs and spaces from beginning. */
+  while (p && (*p == ' ' || *p == '\t')) p++;
+
+  q = p;
+
+  /* Eliminate newlines, returns and whitespaces from end. */
+  while (*q != '\0') { q++; }
+  q--;
+  while (*q == ' ' || *q == '\n' || *q == '\r') { q--; }
+  *(q+1) = '\0';
+
+  return p;
+}
diff --git a/src/parse.h b/src/parse.h
new file mode 100755
index 0000000..7c4dd3b
--- /dev/null
+++ b/src/parse.h
@@ -0,0 +1,34 @@
+/* 
+   parse.h - Generic Parse Code Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef H_PARSE
+#define H_PARSE
+
+#include <glib.h>
+#include <shared.h>
+
+#define EXPECT(p,q,d) (*(q = munch (p)) == d)
+
+/* parse.c */
+extern gchar *munch (gchar *p);
+extern gchar *parse (gchar *p, gchar *word, gint n, const gchar delim);
+extern gchar *trim (gchar *p);
+
+#endif
diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
index f1f98bf..53a610a 100755
--- a/src/realtime/CsvParser.cpp
+++ b/src/realtime/CsvParser.cpp
@@ -17,8 +17,8 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "CsvParser.hpp"
-#include <workbook/sheet.h>
-#include <workbook/cell.h>
+#include <gtkworkbook/sheet.h>
+#include <gtkworkbook/cell.h>
 #include <iostream>
 
 namespace realtime {
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
index 05230a5..77324ab 100755
--- a/src/realtime/CsvParser.hpp
+++ b/src/realtime/CsvParser.hpp
@@ -20,10 +20,10 @@
 #define HPP_CSVPARSER
 
 #include <proactor/Worker.hpp>
-#include <workbook/workbook.h>
-#include <workbook/sheet.h>
-#include <workbook/cell.h>
-#include <csv/csv.h>
+#include <gtkworkbook/workbook.h>
+#include <gtkworkbook/sheet.h>
+#include <gtkworkbook/cell.h>
+#include <libcsv/csv.h>
 #include <iostream>
 
 namespace realtime {
diff --git a/src/realtime/Makefile b/src/realtime/Makefile
index 8ba5091..29ac64d 100755
--- a/src/realtime/Makefile
+++ b/src/realtime/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.base
 
-INCS += -I${PROJDIR}/shared
+INCS += -I${PROJDIR}/shared -I../
 SRCS = $(wildcard *.cpp) 
 OBJS = $(patsubst %.cpp,${OBJDIR}/realtime/%.o,${SRCS}) 
 
@@ -8,7 +8,7 @@ all: 	realtime
 
 realtime: ${OBJS}
 	${CX} -shared -Wl -o ${PROJDIR}/bin/realtime.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread -lcsv -lshared
+	-lgthread-2.0 -lpthread -lcsv
 
 clean:		
 	${MD} ${OBJDIR}/realtime
diff --git a/src/realtime/Packet.hpp b/src/realtime/Packet.hpp
index 39e580e..5aa7ba0 100755
--- a/src/realtime/Packet.hpp
+++ b/src/realtime/Packet.hpp
@@ -19,7 +19,7 @@
 #ifndef HPP_PACKET
 #define HPP_PACKET
 
-#include <workbook/cell.h>
+#include <gtkworkbook/cell.h>
 #include <glib.h>
 #include <string>
 #include <cstdlib>
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index 74bd7ce..9cf53c0 100755
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -21,9 +21,9 @@
 
 #include <proactor/Worker.hpp>
 #include "Packet.hpp"
-#include <workbook/cell.h>
-#include <workbook/sheet.h>
-#include <workbook/workbook.h>
+#include <gtkworkbook/cell.h>
+#include <gtkworkbook/sheet.h>
+#include <gtkworkbook/workbook.h>
 #include <string>
 #include <queue>
 #include <ctime>
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
index 1e8c0f1..8781f72 100755
--- a/src/realtime/plugin_main.cpp
+++ b/src/realtime/plugin_main.cpp
@@ -18,8 +18,9 @@
 */
 #include <iostream>
 #include <glib/gthread.h>
-#include <workbook/workbook.h>
+#include <gtkworkbook/workbook.h>
 #include <concurrent/ThreadArgs.hpp>
+#include "../config.h"
 #include "../application.h"
 #include "../plugin.h"
 
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index 9949e86..c3c4103 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -16,8 +16,7 @@
    License along with the library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
-#include <workbook/workbook.h>
-#include <config/config.h>
+#include <gtkworkbook/workbook.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -34,6 +33,7 @@
 #include "CsvParser.hpp"
 #include "PacketParser.hpp"
 #include "Packet.hpp"
+#include "../config.h"
 
 using namespace realtime;
 

commit 5047e122b0f22c787dc664cad849f2b46d776a81
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 15:41:11 2009 -0400

    Changed name of workbook directory to gtkworkbook.

diff --git a/gtkworkbook/Makefile b/gtkworkbook/Makefile
new file mode 100755
index 0000000..ee3af15
--- /dev/null
+++ b/gtkworkbook/Makefile
@@ -0,0 +1,31 @@
+include ../Makefile.base
+
+SRCS=$(wildcard *.c)
+OBJS=$(patsubst %.c,${OBJDIR}/libgtkworkbook/%.o,${SRCS})
+
+all: 	libgtkworkbook
+
+install:
+	${RM} ${INSLIBDIR}/libgtkworkbook.a ${INSLIBDIR}/libgtkworkbook.so.1 \
+	${INSLIBDIR}/libgtkworkbook.so.1
+	${CP} ${PROJDIR}/lib/libgtkworkbook.so ${INSLIBDIR}/libgtkworkbook.so.1
+	${LN} ${INSLIBDIR}/libgtkworkbook.so.1 ${INSLIBDIR}/libgtkworkbook.a
+	${LN} ${INSLIBDIR}/libgtkworkbook.a ${INSLIBDIR}/libgtkworkbook.so
+#	chcon -t textrel_shlib_t ${INSLIBDIR}/libgtkworkbook.so.1
+
+libgtkworkbook: ${OBJS}
+	${MD} ${PROJDIR}/lib
+	${RM} ${PROJDIR}/lib/libgtkworkbook.so.1 ${PROJDIR}/lib/libgtkworkbook.so
+	${CC} -shared -Wl,-soname,libgtkworkbook.so.1 \
+	-o ${PROJDIR}/lib/libgtkworkbook.so ${OBJS} ${LIBS} \
+	-lgtkextra-x11-2.0 -ldl -gthread-2.0
+	${LN} ${PROJDIR}/lib/libgtkworkbook.so ${PROJDIR}/lib/libgtkworkbook.so.1
+clean:		
+	${MD} ${OBJDIR}/libgtkworkbook	
+	${RM} ${OBJS} ${PROJDIR}/lib/libgtkworkbook.so.1
+
+${OBJDIR}/libgtkworkbook/%.o: %.c
+	${CC} ${INCS} -c -fPIC ${CCFLAGS} $< -o $@
+
+.c.o:
+	${CC} ${INCS} -c -fPIC ${CCFLAGS} $<
diff --git a/gtkworkbook/cell.c b/gtkworkbook/cell.c
new file mode 100755
index 0000000..514723a
--- /dev/null
+++ b/gtkworkbook/cell.c
@@ -0,0 +1,208 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <gtkworkbook/cell.h>
+
+/* cell.c (static) */
+static Cell *cell_object_init (void);
+static void cell_object_free (Cell *);
+static void cell_method_set_value (Cell *, const gchar *);
+static void cell_method_set_value_length (Cell *, void *, size_t);
+static void cell_method_set_column (Cell *, gint);
+static void cell_method_set_row (Cell *, gint);
+static void cell_method_set_all (Cell *, gint, gint, const gchar *);
+static void cell_method_set_justification (Cell *, GtkJustification);
+static void cell_method_destroy (Cell *);
+static void cell_method_set_bgcolor (Cell *, const gchar *);
+static void cell_method_set_fgcolor (Cell *, const gchar *);
+static void cell_method_set_attributes (Cell *, const CellAttributes *);
+static void cell_method_set_range (Cell *, const GtkSheetRange *);
+
+/* @description: The function returns a pointer to a Cell object. */
+Cell *
+cell_new (void)
+{
+  Cell * cell = cell_object_init ();
+  return cell;
+}
+
+/* @description: This function is the Cell object's constructor. */
+static Cell *
+cell_object_init (void)
+{
+  Cell * cell = NEW (Cell);
+
+  cell->value = g_string_new_len ("", 4096);
+  cell->attributes.bgcolor = g_string_new_len ("", 1024);
+  cell->attributes.fgcolor = g_string_new_len ("", 1024);
+
+  /* Methods */
+  cell->set_fgcolor = cell_method_set_fgcolor;
+  cell->set_bgcolor = cell_method_set_bgcolor;
+  cell->set_attributes = cell_method_set_attributes;
+  cell->set_range = cell_method_set_range;
+  cell->set_value = cell_method_set_value;
+  cell->set_value_length = cell_method_set_value_length;
+  cell->set_column = cell_method_set_column;
+  cell->set_row = cell_method_set_row;
+  cell->set = cell_method_set_all;
+  cell->set_justification = cell_method_set_justification;
+  cell->destroy = cell_method_destroy;
+
+  return cell;
+}
+
+/* @description: This object frees the memory created by the Cell object.
+   @cell: The pointer to the object to free. */
+static void
+cell_object_free (Cell * cell)
+{
+  ASSERT (cell != NULL);
+
+  g_string_free (cell->value, TRUE);
+  g_string_free (cell->attributes.fgcolor, TRUE);
+  g_string_free (cell->attributes.bgcolor, TRUE);
+  FREE (cell);
+}
+
+/* @description: This method sets a cell in the GtkSheet with the attributes
+   of a Cell object.
+   @row: An integer value of the row to set.
+   @column: An integer value fo the column to set.
+   @value: A string value to what should be set in the Cell. */
+static void
+cell_method_set_all (Cell * cell, 
+		     gint row, gint column, 
+		     const gchar * value)
+{
+  ASSERT (cell != NULL);
+
+  g_string_assign (cell->value, value);
+  cell->row = row;
+  cell->column = column;  
+}
+
+/* @description: This method sets the justification of the specified Cell
+   object.
+   @justification: The GtkJustification value for the cell. */
+static void
+cell_method_set_justification (Cell * cell, 
+			       GtkJustification justification)
+{
+  ASSERT (cell != NULL);
+  cell->attributes.justification = justification;
+}
+
+/* @description: The method sets the row of the Cell object.
+   @row: Integer value of the row. */
+static void
+cell_method_set_row (Cell * cell, 
+		     gint row)
+{
+  ASSERT (cell != NULL);
+  cell->row = row;
+  cell->range.row0 = cell->range.rowi = row;
+}
+
+/* @description: The method sets the column of the Cell object.
+   @column: Integer value fo the column. */
+static void
+cell_method_set_column (Cell * cell, 
+			gint column)
+{
+  ASSERT (cell != NULL);
+  cell->column = column;
+  cell->range.col0 = cell->range.coli = column;
+}
+
+/* @description: This method sets the bgcolor of the Cell object.
+   @color: String value of the color, e.g. white, blue, red. */
+static void
+cell_method_set_bgcolor (Cell * cell, 
+			 const gchar * color)
+{
+  ASSERT (cell != NULL);
+
+  g_string_assign (cell->attributes.bgcolor, color);
+}
+
+/* @description: This method sets the fgcolor of the Cell object.
+   @color: String value of the color, e.g. white, blue, red. */
+static void 
+cell_method_set_fgcolor (Cell * cell, 
+			 const gchar *color)
+{
+  ASSERT (cell != NULL);
+  
+  g_string_assign (cell->attributes.fgcolor, color);
+}
+
+/* @description: This method sets the range of the Cell object.
+   @range: A pointer to a GtkSheetRange object. */
+static void
+cell_method_set_range (Cell * cell, 
+		       const GtkSheetRange * range)
+{
+  ASSERT (cell != NULL); ASSERT (range != NULL);
+  
+  cell->range.row0 = range->row0;
+  cell->range.col0 = range->col0;
+  cell->range.rowi = range->rowi;
+  cell->range.coli = range->coli;
+}
+
+/* @description: This method sets the attributes of the Cell object.
+   @attrib: A pointer to the Cell Attributes object. */
+static void
+cell_method_set_attributes (Cell * cell, 
+			    const CellAttributes * attrib)
+{
+  ASSERT (cell != NULL); ASSERT (attrib != NULL);
+
+  cell->attributes.justification = attrib->justification;
+ 
+  g_string_assign (cell->attributes.fgcolor, attrib->fgcolor->str);
+  g_string_assign (cell->attributes.bgcolor, attrib->bgcolor->str);
+}
+
+/* @description: This method sets the text value of the Cell object.
+   @value: This is a string pointer to the value. */
+static void
+cell_method_set_value (Cell * cell, 
+		       const gchar * value)
+{
+  ASSERT (cell != NULL);
+  
+  g_string_assign (cell->value, value);
+}
+
+static void
+cell_method_set_value_length (Cell * cell, void * s, size_t length) {
+  ASSERT (cell != NULL);
+
+  g_string_assign (cell->value, "");
+  g_string_append_len (cell->value, (const char *)s, length);
+}
+
+static void
+cell_method_destroy (Cell * cell)
+{
+  g_return_if_fail (cell != NULL);
+
+  cell_object_free (cell);
+}
diff --git a/gtkworkbook/sheet.c b/gtkworkbook/sheet.c
new file mode 100755
index 0000000..21e3244
--- /dev/null
+++ b/gtkworkbook/sheet.c
@@ -0,0 +1,603 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <gtkworkbook/sheet.h>
+#include <gtkextra/gtksheet.h>
+#include <string.h>
+
+/* sheet.c (static) */
+static Sheet *sheet_object_init (Workbook *, const gchar *, gint, gint);
+static void sheet_object_free (Sheet *);
+static void sheet_method_destroy (Sheet *);
+static void sheet_method_set_cell (Sheet *, gint, gint, const gchar *);
+static void sheet_method_apply_cell (Sheet *, const Cell *);
+static void sheet_method_apply_cellarray (Sheet *, Cell **, gint);
+static void sheet_method_apply_cellrange (Sheet *, 
+					  const GtkSheetRange *,
+					  const CellAttributes *);
+static void sheet_method_range_set_background (Sheet *, 
+					       const GtkSheetRange *,
+					       const gchar *);
+static void sheet_method_range_set_foreground (Sheet *,
+					       const GtkSheetRange *,
+					       const gchar *);
+static void sheet_method_set_attention (Sheet *, gint);
+static gboolean sheet_method_load (Sheet *, const gchar *);
+static gboolean sheet_method_save (Sheet *, const gchar *);
+static void sheet_method_apply_cellrow (Sheet *, Cell **, gint, gint);
+
+struct geometryFileHeader {
+  gint fileVersion;
+  gint maxRow;
+  gint maxColumn;
+};
+
+struct geometryFileEntry {
+  gint cellRow;
+  gint cellCol;
+  gint cellTextLength;
+  gboolean cellIsVisible;
+  gboolean cellIsEditable;
+  GtkJustification cellJustification;
+  GdkColor cellForeground;
+  GdkColor cellBackground;
+};
+
+/*
+static GtkSheetCell *
+gtk_sheet_cell_new (void) {
+  GtkSheetCell * cell = g_new (GtkSheetCell, 1);
+  cell->text = NULL;
+  cell->link = NULL;
+  cell->attributes = NULL;
+  return cell;
+}
+*/
+/*
+static void
+GrowSheet (GtkSheet * tbl, gint newrows, gint newcols) {
+  gint ii, jj, inirow, inicol;
+
+  inirow = tbl->maxallocrow + 1;
+  inicol = tbl->maxalloccol + 1;
+
+  tbl->maxalloccol = tbl->maxalloccol + newcols;
+  tbl->maxallocrow = tbl->maxallocrow + newrows;
+
+  if (newrows > 0) {
+    tbl->data = (GtkSheetCell ***) g_realloc (tbl->data,
+					      (tbl->maxallocrow+1)*sizeof(GtkSheetCell**)+sizeof(double));
+
+    for (ii = inirow; ii <= tbl->maxallocrow; ii++) {
+      tbl->data[ii] = (GtkSheetCell **) g_malloc ((tbl->maxcol+1)*sizeof(GtkSheetCell*)+sizeof(double));
+
+      for (jj = 0; jj < inicol; jj++)
+	tbl->data[ii][jj] = NULL;
+    }
+  }
+
+  if (newcols > 0) {
+    for (ii = 0; ii <= tbl->maxallocrow; ii++) {
+      tbl->data[ii] = (GtkSheetCell **) g_realloc (tbl->data[ii],
+						   (tbl->maxalloccol+1)*sizeof(GtkSheetCell*)+sizeof(double));
+
+      for (jj = inicol; jj <= tbl->maxalloccol; jj++)
+	tbl->data[ii][jj] = NULL;
+    }
+  }
+}
+
+static void
+CheckBounds (GtkSheet * tbl, gint row, gint col) {
+  gint newrows = 0, newcols = 0;
+
+  if (col > tbl->maxalloccol) newcols = col - tbl->maxalloccol;
+  if (row > tbl->maxallocrow) newrows = row - tbl->maxallocrow;
+  if (newrows > 0 || newcols > 0) GrowSheet (tbl, newrows, newcols);
+}
+*/
+/* @description: This method creates a new Sheet object and returns the
+   pointer to that object. It calls the constructor function to do so.
+   @book: A pointer to the Workbook that the object will be a part of.
+   @label: A string to the Sheet's label. 
+   @rows: The number of rows.
+   @columns: The number of columns. */
+Sheet *
+sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
+{
+  ASSERT (book != NULL);
+  
+  Sheet * sheet = sheet_object_init (book, label, rows, columns);
+
+  /* STUB: Perform anything that is based on a style here. */
+
+  return sheet;
+}
+
+/* @description: This function is the Sheet's constructor. 
+   @book: A pointer to the Workbook that the Sheet object will be assigned.
+   @label: A string label - the name of the sheet that we will use to search.
+   @rows: The amount of rows the GtkSheet widget should have.
+   @cols: The amount of columns the GtkSheet widget should have. */
+static Sheet *
+sheet_object_init (Workbook * book,
+		   const gchar * label, 
+		   gint rows, gint columns)
+{
+  gdk_threads_enter ();
+  Sheet * sheet = NEW (Sheet);
+
+  /* Create the sheet containers and GtkSheet object. */
+  sheet->gtk_box = gtk_vbox_new (FALSE, 1);
+  gtk_widget_show (sheet->gtk_box);
+
+  GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
+  gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
+				  GTK_POLICY_AUTOMATIC,
+				  GTK_POLICY_AUTOMATIC);
+  gtk_widget_show (scrolled_window);
+
+  sheet->gtk_label = gtk_label_new (label);
+  
+  sheet->gtk_sheet = gtk_sheet_new (rows, columns, label);
+  gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
+  gtk_container_add (GTK_CONTAINER (scrolled_window),
+		     GTK_WIDGET (sheet->gtk_sheet));
+  gtk_widget_show (sheet->gtk_sheet);
+
+  /* We should be able to use sheet->gtk_box now throughout all of our
+     tests when iterating through a GtkNotebook structure. The page number
+     will change when something is removed (or reordered). The pointer will
+     stay the same. */
+  sheet->page = gtk_notebook_append_page (GTK_NOTEBOOK (book->gtk_notebook),
+					  sheet->gtk_box,
+					  sheet->gtk_label);
+  /* Members */
+  sheet->workbook = book;
+  sheet->name = g_strdup (label);
+  sheet->attention = 0;
+  sheet->notices = 0;
+  sheet->has_focus = FALSE;
+  sheet->next = sheet->prev = NULL;
+  sheet->max_rows = rows;
+  sheet->max_columns = columns;
+
+  /* Methods */
+  sheet->destroy = sheet_method_destroy;
+  sheet->set_cell = sheet_method_set_cell;
+  sheet->apply_range = sheet_method_apply_cellrange;
+  sheet->apply_array = sheet_method_apply_cellarray;
+  sheet->apply_cell = sheet_method_apply_cell;
+  sheet->apply_row = sheet_method_apply_cellrow;
+  sheet->range_set_foreground = sheet_method_range_set_foreground;
+  sheet->range_set_background = sheet_method_range_set_background;
+  sheet->set_attention = sheet_method_set_attention;
+  sheet->save = sheet_method_save;
+  sheet->load = sheet_method_load;
+
+  /* Connect any signals that we need to. */
+  if (!IS_NULL (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]))
+    {
+      gtk_signal_connect (GTK_OBJECT (sheet->gtk_sheet),
+			  "changed",
+		  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]),
+			  (gpointer)sheet);
+    }
+
+  gdk_threads_leave ();
+  return sheet;
+}
+
+static gboolean
+sheet_method_load (Sheet * sheet, const gchar * filepath)
+{
+  ASSERT (sheet != NULL);
+
+  if (IS_NULLSTR (filepath))
+    {
+      g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
+      return FALSE;
+    }
+
+  FILE * fp = NULL;
+  if ((fp = fopen (filepath, "rb")) == NULL)
+    {
+      g_warning ("%s: failed opening file '%s' for reading", 
+		 __FUNCTION__,
+		 filepath);
+      return FALSE;
+    }
+
+  gdk_threads_enter ();
+  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+  struct geometryFileHeader header = {-1,-1,-1};
+  struct geometryFileEntry entry = {-1,-1,-1};
+ 
+  fread ((void *)&header, sizeof (struct geometryFileHeader), 1, fp);
+
+  if (header.fileVersion != GEOMETRY_FILE_VERSION)
+    {
+      g_warning ("Geometry file version %d is not accepted. (%d)",
+		 header.fileVersion, GEOMETRY_FILE_VERSION);
+      FCLOSE (fp);
+      gdk_threads_leave ();
+      return FALSE;
+    }
+
+  while (fread ((void *)&entry, sizeof (struct geometryFileEntry), 1, fp) > 0)
+    {
+      gchar * text = g_strndup ("", entry.cellTextLength);
+      fread ((void *)text, sizeof (gchar), entry.cellTextLength, fp);
+      gtk_sheet_set_cell_text (gtksheet, 
+			       entry.cellRow, 
+			       entry.cellCol, 
+			       text);
+      
+      GtkSheetCell ** cell = &gtksheet->data[entry.cellRow][entry.cellCol];
+      
+      (*cell)->attributes->is_editable = entry.cellIsEditable;
+      (*cell)->attributes->is_visible = entry.cellIsVisible;
+      (*cell)->attributes->justification = entry.cellJustification;
+      (*cell)->attributes->foreground.pixel = entry.cellForeground.pixel;
+      (*cell)->attributes->foreground.red = entry.cellForeground.red;
+      (*cell)->attributes->foreground.green = entry.cellForeground.green;
+      (*cell)->attributes->foreground.blue = entry.cellForeground.blue;
+      (*cell)->attributes->background.pixel = entry.cellBackground.pixel;
+      (*cell)->attributes->background.red = entry.cellBackground.red;
+      (*cell)->attributes->background.green = entry.cellBackground.green;
+      (*cell)->attributes->background.blue = entry.cellBackground.blue;
+
+      FREE (text);
+    }
+
+  FCLOSE (fp);
+  gdk_threads_leave ();
+  return TRUE;
+}
+
+static gboolean
+sheet_method_save (Sheet * sheet, const gchar * filepath)
+{
+  ASSERT (sheet != NULL);
+
+  if (IS_NULLSTR (filepath))
+    {
+      g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
+      return FALSE;
+    }
+
+  FILE * fp = NULL;
+  if ((fp = fopen (filepath, "wb")) == NULL)
+    {
+      g_warning ("%s: failed opening file '%s' for writing", 
+		 __FUNCTION__, 
+		 filepath);
+      return FALSE;
+    }
+  
+  gdk_threads_enter ();
+  GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
+  struct geometryFileHeader header =
+    {
+      GEOMETRY_FILE_VERSION,
+      GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
+      GTK_SHEET (sheet->gtk_sheet)->maxalloccol
+    };
+
+  fwrite ((void *)&header, sizeof(struct geometryFileHeader), 1, fp);
+
+  for (gint ii = 0; ii <= header.maxRow; ii++)
+    {
+      for (gint jj = 0; jj <= header.maxColumn; jj++)
+	{
+	  GtkSheetCell * cell = data[ii][jj];
+
+	  if (!IS_NULL (cell) && !IS_NULLSTR(cell->text))
+	    {
+	      struct geometryFileEntry entry =
+		{
+		  cell->row,
+		  cell->col,
+		  strlen (cell->text),
+		  cell->attributes->is_visible,
+		  cell->attributes->is_editable,
+		  cell->attributes->justification
+		};
+
+	      entry.cellForeground.pixel = cell->attributes->foreground.pixel;
+	      entry.cellForeground.red = cell->attributes->foreground.red;
+	      entry.cellForeground.green = cell->attributes->foreground.green;
+	      entry.cellForeground.blue = cell->attributes->foreground.blue;
+	      entry.cellBackground.pixel = cell->attributes->background.pixel;
+	      entry.cellBackground.red = cell->attributes->background.red;
+	      entry.cellBackground.green = cell->attributes->background.green;
+	      entry.cellBackground.blue = cell->attributes->background.blue;
+
+	      fwrite ((void *)&entry, 
+		      sizeof (struct geometryFileEntry), 1, fp);
+	      fwrite ((void *)cell->text, 
+		      sizeof (gchar), entry.cellTextLength, fp);
+	    }
+	}
+    }
+
+  FCLOSE (fp);
+  gdk_threads_leave ();
+  return TRUE;
+}
+
+/* @description: This method sets the attention level of the Sheet.
+   @sheet: A pointer to the Sheet object.
+   @attention: The attention level. */
+static void 
+sheet_method_set_attention (Sheet * sheet, gint attention)
+{
+  ASSERT (sheet != NULL);
+  gdk_threads_enter ();
+
+  sheet->attention = attention;
+
+  /* Do something funky to show that you should be looking at ME!
+     Oh, GtkNotebook tab, why are thou so vain? */
+  if ((sheet->has_focus == FALSE) && (sheet->notices > 0)) {
+      
+    }
+
+  gdk_threads_leave ();
+}
+
+/* @description: This method destroys the Sheet object.
+   @sheet: A pointer to the object that will be destroyed. */
+static void
+sheet_method_destroy (Sheet * sheet)
+{
+  ASSERT (sheet != NULL);
+  gdk_threads_enter ();
+
+  DOUBLE_UNLINK (sheet);
+
+  sheet_object_free (sheet);
+
+  gdk_threads_leave ();
+}
+
+/* @description: This method frees the memory that was used by the Sheet
+   object. This should only be called from sheet->destroy()
+   @sheet: A pointer to the Sheet object that will be freed. */
+static void
+sheet_object_free (Sheet * sheet)
+{
+  ASSERT (sheet != NULL);
+
+  FREE (sheet->name);
+  FREE (sheet);
+  return;
+}
+
+static void
+sheet_method_apply_cellrange (Sheet * sheet, 
+			      const GtkSheetRange * range,
+			      const CellAttributes * attrib)
+{
+  ASSERT (sheet != NULL);
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (attrib != NULL);
+  gdk_threads_enter ();
+
+  gdk_threads_leave ();
+}
+
+static void
+sheet_method_apply_cellrow (Sheet * sheet,
+			    Cell ** array,
+			    gint row,
+			    gint size) {
+  ASSERT (sheet != NULL);
+  g_return_if_fail (array != NULL);
+
+  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+  GtkSheetCell ** cell;
+  Cell * item;
+
+  if (row > gtksheet->maxrow || row < 0) return;
+  if (size > gtksheet->maxcol || size < 0) return;
+
+  gdk_threads_enter();
+
+  for (int col = 0; col < size; col++) {
+    item = array[col]; 
+    cell = &gtksheet->data[row][col];
+    
+    gtk_sheet_set_cell_text (gtksheet,
+			     row,
+			     col,
+			     item->value->str);
+    /*
+    if (*cell == NULL)
+      (*cell) = gtk_sheet_cell_new();
+      
+    (*cell)->row = row;
+    (*cell)->col = col;
+
+    if ((*cell)->text)
+      g_free ((*cell)->text);
+      
+    (*cell)->text = g_strdup (item->value->str);
+    */
+
+    item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
+  }
+
+  gdk_threads_leave();
+}
+
+static void
+sheet_method_apply_cellarray (Sheet * sheet, 
+			      Cell ** array,
+			      gint size)
+{
+  ASSERT (sheet != NULL);
+  g_return_if_fail (array != NULL);
+
+  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+
+  gdk_threads_enter ();
+
+  /* We'll see how this performs for now. In the future we may want to go
+     directly into the GtkSheet structures to get a little more performance
+     boost (mainly because we should not have to check all the bounds each
+     time we want to update). */
+  for (gint ii = 0; ii < size; ii++) {
+    Cell * cell = array[ii];
+
+    gtk_sheet_set_cell_text (gtksheet,
+			     cell->row,
+			     cell->column,
+			     cell->value->str);
+
+    if (!IS_NULLSTR (cell->attributes.bgcolor->str))
+      sheet->range_set_background (sheet, 
+				   &cell->range, 
+				   cell->attributes.bgcolor->str);
+
+    if (!IS_NULLSTR (cell->attributes.fgcolor->str))
+      sheet->range_set_foreground (sheet, 
+				   &cell->range, 
+				   cell->attributes.fgcolor->str);
+
+    cell->value->str[0] = cell->attributes.bgcolor->str[0] = cell->attributes.fgcolor->str[0] = 0;
+  }
+
+  gdk_threads_leave ();
+}
+
+/* @description: This method applies the settings from a Cell object into the
+   GtkSheet. In order to properly function this should be really the only the
+   GtkSheet object is modified.
+   @sheet: A pointer to the Sheet that holds the GtkSheet object.
+   @cell: A pointer to the Cell that will be applied. */
+static void
+sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
+{
+  ASSERT (sheet != NULL);
+  g_return_if_fail (cell != NULL);
+
+  gdk_threads_enter ();
+
+  if (sheet->has_focus == FALSE)
+    sheet->notices++;
+
+  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet),
+		      cell->row,
+		      cell->column,
+		      cell->attributes.justification,
+		      cell->value->str);
+  gdk_threads_leave ();
+
+  if (!IS_NULLSTR (cell->attributes.bgcolor->str))
+    sheet->range_set_background (sheet, 
+				 &cell->range, 
+				 cell->attributes.bgcolor->str);
+
+  if (!IS_NULLSTR (cell->attributes.fgcolor->str))
+    sheet->range_set_foreground (sheet, 
+				 &cell->range, 
+				 cell->attributes.fgcolor->str);
+
+  /* Clear all of the strings */
+  g_string_assign (cell->value, "");
+  g_string_assign (cell->attributes.bgcolor, "");
+  g_string_assign (cell->attributes.fgcolor, "");
+}
+
+/* @description: This method changes the background of a range of cells. 
+   @sheet: A pointer to the Sheet object that contains GtkSheet.
+   @range: A pointer to the GtkSheetRange object that contains the ranges
+   that we will be applying the background color to.
+   @desc: A string that contains the color's string value (e.g. white, red
+   green, etc). */
+static void
+sheet_method_range_set_background (Sheet * sheet, 
+				   const GtkSheetRange * range,
+				   const gchar * desc)
+{
+  ASSERT (sheet != NULL); ASSERT (range != NULL);
+  GdkColor color;
+
+  /* The color needs to be taken from the colormap; there is an alternative
+     way to do this if we use #rgb or #rrggbb formats. */
+  gdk_threads_enter ();
+  gdk_color_parse (desc, &color);
+  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
+		   &color);
+  
+  gtk_sheet_range_set_background (GTK_SHEET (sheet->gtk_sheet),
+				  range, &color);
+  gdk_threads_leave ();
+}
+
+/* @description: This method changes the foreground color over a range of
+   cells. 
+   @sheet: A pointer to the Sheet object that contains GtkSheet.
+   @range: A pointer to the GtkSheetRange object that contains the ranges
+   that we will be applying the foreground color to.
+   @desc: The string representation of the color (e.g. white, green, blue). */
+static void
+sheet_method_range_set_foreground (Sheet * sheet, 
+				   const GtkSheetRange * range,
+				   const gchar * desc)
+{
+  ASSERT (sheet != NULL); ASSERT (range != NULL);
+  GdkColor color;
+  
+   /* The color needs to be taken from the colormap; there is an alternative
+     way to do this if we use #rgb or #rrggbb formats. */
+  gdk_threads_enter ();
+  gdk_color_parse (desc, &color);
+  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
+		   &color);
+      
+  gtk_sheet_range_set_foreground (GTK_SHEET (sheet->gtk_sheet),
+				  range, &color);
+  gdk_threads_leave ();
+ }
+
+/* @description: This method manually sets a GtkSheet cell's value. It does
+   not require the use of the Cell object.
+   @sheet: A pointer to the Sheet object that contains GtkSheet.
+   @row: An integer value of the row.
+   @col: An integer value of the column.
+   @value: The text string to be applied to the cell. */
+static void 
+sheet_method_set_cell (Sheet * sheet,
+		       gint row, gint col,
+		       const gchar * value)
+{
+  ASSERT (sheet != NULL);
+
+  gdk_threads_enter ();
+  if (sheet->has_focus == FALSE)
+    sheet->notices++;
+  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet), 
+		      row, 
+		      col, 
+		      GTK_JUSTIFY_LEFT, 
+		      value);
+  gdk_threads_leave ();
+}
diff --git a/gtkworkbook/workbook.c b/gtkworkbook/workbook.c
new file mode 100755
index 0000000..6fbe5a0
--- /dev/null
+++ b/gtkworkbook/workbook.c
@@ -0,0 +1,289 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <gtkworkbook/workbook.h>
+#include <glib/gthread.h>
+#include <string.h>
+
+/* workbook.c (static) */
+static void workbook_method_destroy (Workbook *);
+static Workbook *workbook_object_init (GtkWidget *, const gchar *);
+static Workbook *workbook_object_free (Workbook *);
+static Sheet *workbook_method_addnewsheet (Workbook *, 
+					   const gchar *, 
+					   gint, gint);
+static Sheet *workbook_method_get_sheet (Workbook *, const gchar *);
+static void workbook_method_remove_sheet (Workbook *, Sheet *);
+static gboolean workbook_method_move_sheet_index (Workbook *, Sheet *, gint);
+static gboolean workbook_method_move_sheet (Workbook *, 
+					    Sheet *,
+					    const gchar *,
+					    gboolean);
+
+/* @description: This method "opens" a Workbook. In the future it will load
+   a Workbook from a specified filename (which will most likely be a GZIP
+   file) but for now it merely loads one into memory.
+   @window: A pointer to the GtkWindow object. 
+   @filename: A pointer to the filename string. */
+Workbook *
+workbook_open (GtkWidget * window, const gchar * filename)
+{
+  ASSERT (window != NULL);
+
+  /* STUB: A workbook is opened here from some form of an archived file.
+     At this point we would load up the configuration files for the styles,
+     sheets and plugins to be loaded then this would all be executed here. */
+
+  Workbook * book = workbook_object_init (window, filename);
+  return book;
+}
+
+/* @description: This method adds a new Sheet to the Workbook object. The
+   specified parameters are passed on to the Sheet object's constructor.
+   But first we check to make sure that a sheet with the same label does
+   not already exist inside of the Workbook.
+   @book: Pointer to the Workbook object.
+   @label: The Sheet's label string.
+   @rows: Number of rows the GtkSheet object should have.
+   @cols: Number of columns the GtkSheet object should have.*/
+static Sheet *
+workbook_method_addnewsheet (Workbook * book,
+			     const gchar * label, 
+			     gint rows, 
+			     gint cols)
+{
+  ASSERT (book != NULL);
+
+  Sheet * sheet = book->get_sheet (book, label);
+  if (sheet != NULL) 
+    {
+      g_warning ("Cannot create '%s' because it already exists", 
+		 label);
+      return NULL;
+    }
+
+  sheet = sheet_new (book, label, rows, cols);
+
+  LINK_OBJECT (book->sheet_first,
+	       book->sheet_last, 
+	       sheet);
+
+  /* We are the first and only sheet; make sure we are set to have focus. */
+  /* BUGFIX: This was in the wrong place... needs to be below LINK_OBJECT */
+  if ((book->sheet_first == sheet) && IS_NULL (book->sheet_last))
+    {
+      sheet->has_focus = TRUE;
+      book->focus_sheet = sheet;
+    }
+
+  return sheet;
+}
+
+/* @description: This method performs a search of all the Workbooks and
+   returns a pointer to the Sheet object if it matches the provided label.
+   @wb: Pointer to the workbook we're searching.
+   @sheet: String label of the sheet we are searching for. */
+static Sheet *
+workbook_method_get_sheet (Workbook * wb, const gchar * sheet)
+{
+  ASSERT (wb != NULL);
+
+  if (!IS_NULLSTR (sheet))
+    {
+      ITERATE_BEGIN (Sheet, wb->sheet_first);
+      {
+	if (!sheet) return NULL;
+	if (!strcmp (sheet, it->name))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+
+  return NULL;
+}
+
+/* @description: This method removes a Sheet object from the Workbook. It also
+   removes to GtkSheet tab from the GtkNotebook (held in the Workbook).
+   @wb: The Workbook pointer we are removing the object from.
+   @sheet: The Sheet object that we will be removing. */
+static void
+workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
+{
+  ASSERT (wb != NULL);
+
+  if (sheet->workbook != wb)
+    {
+      g_warning ("'%s' does not belong to workbook '%s'",
+		 sheet->name, wb->filename);
+      return;
+    }
+  
+  ITERATE_BEGIN (Sheet, wb->sheet_first);
+  {
+    /* Remove the sheet from the GtkNotebook */
+    if (it == sheet)
+      {
+	gdk_threads_enter ();
+	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
+					   sheet->gtk_box);
+	gtk_notebook_remove_page (GTK_NOTEBOOK (wb->gtk_notebook), page); 
+	gtk_widget_queue_draw (wb->gtk_notebook);
+	gdk_threads_leave ();
+	return;
+      }
+  }
+  ITERATE_END ();
+
+  g_warning ("Sheet '%s' was not found inside of workbook '%s'", 
+	     sheet->name, wb->filename);
+}
+
+/* @description: This method moves the Sheet's GtkSheet tab inside of the
+   Workbook's GtkNotebook.
+   @wb: The Workbook object that contains the GtkNotebook.
+   @sheet: The Sheet object that contains the GtkSheet we're moving.
+   @index: The _new_ page index. */
+static gboolean
+workbook_method_move_sheet_index (Workbook * wb, Sheet * sheet, gint index)
+{
+  gdk_threads_enter ();
+  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
+			      sheet->gtk_box,
+			      index);
+  gdk_threads_leave ();
+  return TRUE;
+}
+
+static gboolean
+workbook_method_move_sheet (Workbook * wb, 
+			    Sheet * sheet, 
+			    const gchar * id,
+			    gboolean after)
+{
+  ASSERT (wb != NULL);
+  ASSERT (sheet != NULL);
+
+  if (IS_NULLSTR (id))
+    return FALSE;
+
+  Sheet * sh = wb->get_sheet (wb, id);
+  if (IS_NULL (sh))
+    {
+      g_warning ("Sheet '%s' does not exist in workbook '%s'", 
+		 sheet->name, wb->filename);
+      return FALSE;
+    }
+  
+  gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
+				     sh->gtk_box);
+  if (page == -1)
+    {
+      g_warning ("Sheet '%s' does not appear to be in workbook '%s' notebook",
+		 sheet->name, wb->filename);
+      return FALSE;
+    }
+
+  if (after == TRUE)  page++;
+  else                page--;
+
+  gdk_threads_enter ();
+  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
+			      sheet->gtk_box,
+			      page);
+  gdk_threads_leave ();
+  return TRUE;
+}
+
+/* @description: This is a Workbook object's constructor. 
+   @window: A pointer to the GtkWindow context.
+   @filename: A pointer to the filename string. */
+static Workbook *
+workbook_object_init (GtkWidget * window, const gchar * filename)
+{
+  Workbook * book = NEW (Workbook);
+
+  /* Set up the signals. */
+  book->signals[SIG_WORKBOOK_CHANGED] = NULL;
+
+  /* Set up the notebook */
+  gdk_threads_enter ();
+  book->gtk_notebook = gtk_notebook_new ();
+  
+  GtkNotebook * notebook = GTK_NOTEBOOK (book->gtk_notebook);
+
+  gtk_notebook_set_tab_pos (notebook, GTK_POS_BOTTOM);
+  gtk_notebook_popup_enable (notebook);
+  gtk_notebook_set_show_tabs (notebook, TRUE);
+  gtk_notebook_set_show_border (notebook, TRUE);
+  gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
+  gtk_widget_show (book->gtk_notebook);
+  gdk_threads_leave ();
+
+  /* Members */
+  book->sheet_first = book->sheet_last = NULL;
+  book->next = book->prev = NULL;
+  book->focus_sheet = NULL;
+  book->gtk_window = window;
+  book->filename = g_strdup (filename);
+    
+  /* Methods */
+  book->destroy = workbook_method_destroy;
+  book->add_new_sheet = workbook_method_addnewsheet;
+  book->get_sheet = workbook_method_get_sheet;
+  book->remove_sheet = workbook_method_remove_sheet;
+  book->move_sheet_index = workbook_method_move_sheet_index;
+  book->move_sheet = workbook_method_move_sheet;
+
+  return book;
+}
+
+/* @description: This method destroys the Workbook object and all of the
+   Sheet objects that it contains. 
+   @book: The Workbook object to destroy. */
+static void
+workbook_method_destroy (Workbook * book)
+{
+  ASSERT (book != NULL);
+
+  /* Wrap anything up here. */
+  Sheet * current = book->sheet_first, * next = NULL;
+  while (current)
+    {
+      next = current->next;
+      current->destroy (current);
+      current = next;
+    }
+
+  UNLINK_OBJECT (book);
+  workbook_object_free (book);
+}
+
+/* @description: This method frees the memory that the Workbook object has 
+   been using. This is only able to be called from book->destroy()
+   @book: The Workbook object we are freeing. */
+static Workbook *
+workbook_object_free (Workbook * book)
+{
+  ASSERT (book != NULL);
+
+  book->sheet_first = book->sheet_last = NULL;
+
+  FREE (book->filename);
+  FREE (book);
+  return book;
+}
diff --git a/include/gtkworkbook/cell.h b/include/gtkworkbook/cell.h
new file mode 100755
index 0000000..fb956cd
--- /dev/null
+++ b/include/gtkworkbook/cell.h
@@ -0,0 +1,93 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef H_CELL
+#define H_CELL
+
+#include <shared.h>
+#include <gtkextra/gtkextra.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  typedef struct _Cell Cell;
+  typedef struct _CellAttributes CellAttributes;
+
+  #include "sheet.h"
+
+  /*
+    @description: These objects will evolve as more uses are found for it. 
+    Right now it provides as an intermediate abstraction for the cell 
+    information of a GtkSheetEntry. It works in conjunction with the Sheet 
+    object (the Sheet object performs all the gtk_sheet_* functions). 
+
+    If you decide to manually set any of the members be sure:
+    a. For single cell changes row and column ranges must equal each other
+       because GtkSheet does not provide interfaces for all operations to
+       be done on single cell.
+    b. Keep in mind that this object was built with the ability to dump a whole
+       array of changes into a Sheet with a single call. This was built for 
+       simple brute forcing of cell additions (and changes).
+    c. If you find yourself adding a lot of code to this object then it may
+       be time to add a new object to libworkbook. It was meant to be simple.
+
+    If you decide to use gtk_sheet_* calls:
+    a. Do not add them to any methods inside of this object. This object does
+       not (and should not) contain any locking procedures. All the locking for
+       threading should be done in the Sheet object (where all gtk+ calls 
+       should be performed). 
+  */
+  struct _CellAttributes
+  {
+    GString * bgcolor;
+    GString * fgcolor;
+    GtkJustification justification;
+  };
+
+  struct _Cell
+  {
+    /* Members */
+    Sheet * sheet;
+    Cell * next;
+    GString * value;
+    CellAttributes attributes;
+    GtkSheetRange range;
+    gint row, column;
+    
+    /* Methods */
+    void (*set) (Cell * cell, gint row, gint column, const gchar * value);
+    void (*set_value) (Cell * cell, const gchar * value);  
+    void (*set_value_length) (Cell * cell, void * s, size_t length);
+    void (*set_column) (Cell * cell, gint column);
+    void (*set_row) (Cell * cell, gint row);
+    void (*set_range) (Cell * cell, const GtkSheetRange * range);
+    void (*set_justification) (Cell * cell, GtkJustification justification);
+    void (*set_fgcolor) (Cell * cell, const gchar * color);
+    void (*set_bgcolor) (Cell * cell, const gchar * color);
+    void (*set_attributes) (Cell * cell, const CellAttributes * attrib);
+    void (*destroy) (Cell * cell);
+  };
+
+  /* cell.c */
+  Cell *cell_new (void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_CELL*/
diff --git a/include/gtkworkbook/sheet.h b/include/gtkworkbook/sheet.h
new file mode 100755
index 0000000..6156459
--- /dev/null
+++ b/include/gtkworkbook/sheet.h
@@ -0,0 +1,93 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef H_SHEET
+#define H_SHEET
+
+#include <shared.h>
+#include <gtk/gtk.h>
+#include <gtkextra/gtksheet.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define GEOMETRY_FILE_VERSION 0x000001
+
+typedef struct _Sheet Sheet;
+
+#include "workbook.h"
+#include "cell.h"
+
+  /*
+    @description: This object abstracts away all of the calls to the native
+    GtkSheet methods. It is meant to be used with the Cell object(s).
+    
+    Please keep the following in mind:
+    a. All calls to gtk_* methods should be performed in here and not inside of
+       a cell object. 
+    b. All calls to gtk_* methods should be performed inside of a lock, e.g. 
+       you should always use gdk_threads_enter and gtk_threads_exit. Any calls
+       outside of the window (main) thread will usually result in problems if
+       you do not get a mutex. 
+  */
+  struct _Sheet
+  {
+    /* Members */
+    Sheet * next;
+    Sheet * prev;
+    gchar * name;
+    Workbook * workbook;
+    GtkWidget * gtk_label;
+    GtkWidget * gtk_sheet;
+    GtkWidget * gtk_box;
+    gint page;
+    gint attention;
+    gint notices;
+    gint max_rows;
+    gint max_columns;
+    gboolean has_focus;
+
+    /* Methods */
+    void (*destroy) (Sheet *);
+    void (*set_attention) (Sheet *, gint);
+    void (*apply_range) (Sheet *, 
+			 const GtkSheetRange *, 
+			 const CellAttributes *);
+    void (*apply_array) (Sheet *, Cell **, gint);
+    void (*apply_cell) (Sheet *, const Cell *);
+    void (*apply_row) (Sheet *, Cell **, gint, gint);
+
+    void (*set_cell) (Sheet *, gint, gint, const gchar *);  
+    void (*range_set_background) (Sheet *, 
+				  const GtkSheetRange *, 
+				  const gchar *);
+    void (*range_set_foreground) (Sheet *, 
+				  const GtkSheetRange *,
+				  const gchar *);
+    gboolean (*save) (Sheet *, const gchar *);
+    gboolean (*load) (Sheet *, const gchar *);
+  };
+
+  /* sheet.c */
+  Sheet *sheet_new (Workbook *, const gchar *, gint, gint);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_SHEET*/
diff --git a/include/gtkworkbook/workbook.h b/include/gtkworkbook/workbook.h
new file mode 100755
index 0000000..0e39324
--- /dev/null
+++ b/include/gtkworkbook/workbook.h
@@ -0,0 +1,69 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef H_WORKBOOK
+#define H_WORKBOOK
+
+#include <shared.h>
+#include <gtk/gtk.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  enum
+    {
+      SIG_WORKBOOK_CHANGED = 0,
+      /**/
+      MAX_WORKBOOK_SIGNALS
+    };
+
+  typedef struct _Workbook Workbook;
+
+#include "sheet.h"
+
+  struct _Workbook
+  {
+    /* Members */
+    GSourceFunc signals[MAX_WORKBOOK_SIGNALS];
+    Sheet * sheet_first;
+    Sheet * sheet_last;
+    Sheet * focus_sheet;
+    Workbook * next;
+    Workbook * prev;  
+    GtkWidget * gtk_notebook;
+    GtkWidget * gtk_window;
+    GtkWidget * gtk_box;
+    gchar * filename;
+
+    /* Methods */
+    void (*destroy) (Workbook *);
+    Sheet *(*add_new_sheet) (Workbook *, const gchar *, gint, gint);
+    Sheet *(*get_sheet) (Workbook *, const gchar *);
+    void (*remove_sheet) (Workbook *, Sheet *);
+    gboolean (*move_sheet_index) (Workbook *, Sheet *, gint);
+    gboolean (*move_sheet) (Workbook *, Sheet *, const gchar *, gboolean); 
+  };
+
+  /* workbook.c */
+  Workbook *workbook_open (GtkWidget *, const gchar *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_WORKBOOK*/
diff --git a/include/workbook/cell.h b/include/workbook/cell.h
deleted file mode 100755
index fb956cd..0000000
--- a/include/workbook/cell.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef H_CELL
-#define H_CELL
-
-#include <shared.h>
-#include <gtkextra/gtkextra.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  typedef struct _Cell Cell;
-  typedef struct _CellAttributes CellAttributes;
-
-  #include "sheet.h"
-
-  /*
-    @description: These objects will evolve as more uses are found for it. 
-    Right now it provides as an intermediate abstraction for the cell 
-    information of a GtkSheetEntry. It works in conjunction with the Sheet 
-    object (the Sheet object performs all the gtk_sheet_* functions). 
-
-    If you decide to manually set any of the members be sure:
-    a. For single cell changes row and column ranges must equal each other
-       because GtkSheet does not provide interfaces for all operations to
-       be done on single cell.
-    b. Keep in mind that this object was built with the ability to dump a whole
-       array of changes into a Sheet with a single call. This was built for 
-       simple brute forcing of cell additions (and changes).
-    c. If you find yourself adding a lot of code to this object then it may
-       be time to add a new object to libworkbook. It was meant to be simple.
-
-    If you decide to use gtk_sheet_* calls:
-    a. Do not add them to any methods inside of this object. This object does
-       not (and should not) contain any locking procedures. All the locking for
-       threading should be done in the Sheet object (where all gtk+ calls 
-       should be performed). 
-  */
-  struct _CellAttributes
-  {
-    GString * bgcolor;
-    GString * fgcolor;
-    GtkJustification justification;
-  };
-
-  struct _Cell
-  {
-    /* Members */
-    Sheet * sheet;
-    Cell * next;
-    GString * value;
-    CellAttributes attributes;
-    GtkSheetRange range;
-    gint row, column;
-    
-    /* Methods */
-    void (*set) (Cell * cell, gint row, gint column, const gchar * value);
-    void (*set_value) (Cell * cell, const gchar * value);  
-    void (*set_value_length) (Cell * cell, void * s, size_t length);
-    void (*set_column) (Cell * cell, gint column);
-    void (*set_row) (Cell * cell, gint row);
-    void (*set_range) (Cell * cell, const GtkSheetRange * range);
-    void (*set_justification) (Cell * cell, GtkJustification justification);
-    void (*set_fgcolor) (Cell * cell, const gchar * color);
-    void (*set_bgcolor) (Cell * cell, const gchar * color);
-    void (*set_attributes) (Cell * cell, const CellAttributes * attrib);
-    void (*destroy) (Cell * cell);
-  };
-
-  /* cell.c */
-  Cell *cell_new (void);
-
-#ifdef __cplusplus
-}
-#endif
-#endif /*H_CELL*/
diff --git a/include/workbook/sheet.h b/include/workbook/sheet.h
deleted file mode 100755
index 6156459..0000000
--- a/include/workbook/sheet.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef H_SHEET
-#define H_SHEET
-
-#include <shared.h>
-#include <gtk/gtk.h>
-#include <gtkextra/gtksheet.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define GEOMETRY_FILE_VERSION 0x000001
-
-typedef struct _Sheet Sheet;
-
-#include "workbook.h"
-#include "cell.h"
-
-  /*
-    @description: This object abstracts away all of the calls to the native
-    GtkSheet methods. It is meant to be used with the Cell object(s).
-    
-    Please keep the following in mind:
-    a. All calls to gtk_* methods should be performed in here and not inside of
-       a cell object. 
-    b. All calls to gtk_* methods should be performed inside of a lock, e.g. 
-       you should always use gdk_threads_enter and gtk_threads_exit. Any calls
-       outside of the window (main) thread will usually result in problems if
-       you do not get a mutex. 
-  */
-  struct _Sheet
-  {
-    /* Members */
-    Sheet * next;
-    Sheet * prev;
-    gchar * name;
-    Workbook * workbook;
-    GtkWidget * gtk_label;
-    GtkWidget * gtk_sheet;
-    GtkWidget * gtk_box;
-    gint page;
-    gint attention;
-    gint notices;
-    gint max_rows;
-    gint max_columns;
-    gboolean has_focus;
-
-    /* Methods */
-    void (*destroy) (Sheet *);
-    void (*set_attention) (Sheet *, gint);
-    void (*apply_range) (Sheet *, 
-			 const GtkSheetRange *, 
-			 const CellAttributes *);
-    void (*apply_array) (Sheet *, Cell **, gint);
-    void (*apply_cell) (Sheet *, const Cell *);
-    void (*apply_row) (Sheet *, Cell **, gint, gint);
-
-    void (*set_cell) (Sheet *, gint, gint, const gchar *);  
-    void (*range_set_background) (Sheet *, 
-				  const GtkSheetRange *, 
-				  const gchar *);
-    void (*range_set_foreground) (Sheet *, 
-				  const GtkSheetRange *,
-				  const gchar *);
-    gboolean (*save) (Sheet *, const gchar *);
-    gboolean (*load) (Sheet *, const gchar *);
-  };
-
-  /* sheet.c */
-  Sheet *sheet_new (Workbook *, const gchar *, gint, gint);
-
-#ifdef __cplusplus
-}
-#endif
-#endif /*H_SHEET*/
diff --git a/include/workbook/workbook.h b/include/workbook/workbook.h
deleted file mode 100755
index 0e39324..0000000
--- a/include/workbook/workbook.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef H_WORKBOOK
-#define H_WORKBOOK
-
-#include <shared.h>
-#include <gtk/gtk.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  enum
-    {
-      SIG_WORKBOOK_CHANGED = 0,
-      /**/
-      MAX_WORKBOOK_SIGNALS
-    };
-
-  typedef struct _Workbook Workbook;
-
-#include "sheet.h"
-
-  struct _Workbook
-  {
-    /* Members */
-    GSourceFunc signals[MAX_WORKBOOK_SIGNALS];
-    Sheet * sheet_first;
-    Sheet * sheet_last;
-    Sheet * focus_sheet;
-    Workbook * next;
-    Workbook * prev;  
-    GtkWidget * gtk_notebook;
-    GtkWidget * gtk_window;
-    GtkWidget * gtk_box;
-    gchar * filename;
-
-    /* Methods */
-    void (*destroy) (Workbook *);
-    Sheet *(*add_new_sheet) (Workbook *, const gchar *, gint, gint);
-    Sheet *(*get_sheet) (Workbook *, const gchar *);
-    void (*remove_sheet) (Workbook *, Sheet *);
-    gboolean (*move_sheet_index) (Workbook *, Sheet *, gint);
-    gboolean (*move_sheet) (Workbook *, Sheet *, const gchar *, gboolean); 
-  };
-
-  /* workbook.c */
-  Workbook *workbook_open (GtkWidget *, const gchar *);
-
-#ifdef __cplusplus
-}
-#endif
-#endif /*H_WORKBOOK*/
diff --git a/workbook/Makefile b/workbook/Makefile
deleted file mode 100755
index db5f84e..0000000
--- a/workbook/Makefile
+++ /dev/null
@@ -1,31 +0,0 @@
-include ../Makefile.base
-
-SRCS=$(wildcard *.c)
-OBJS=$(patsubst %.c,${OBJDIR}/libworkbook/%.o,${SRCS})
-
-all: 	libworkbook
-
-install:
-	${RM} ${INSLIBDIR}/libworkbook.a ${INSLIBDIR}/libworkbook.so.1 \
-	${INSLIBDIR}/libworkbook.so.1
-	${CP} ${PROJDIR}/lib/libworkbook.so ${INSLIBDIR}/libworkbook.so.1
-	${LN} ${INSLIBDIR}/libworkbook.so.1 ${INSLIBDIR}/libworkbook.a
-	${LN} ${INSLIBDIR}/libworkbook.a ${INSLIBDIR}/libworkbook.so
-#	chcon -t textrel_shlib_t ${INSLIBDIR}/libworkbook.so.1
-
-libworkbook: ${OBJS}
-	${MD} ${PROJDIR}/lib
-	${RM} ${PROJDIR}/lib/libworkbook.so.1 ${PROJDIR}/lib/libworkbook.so
-	${CC} -shared -Wl,-soname,libworkbook.so.1 \
-	-o ${PROJDIR}/lib/libworkbook.so ${OBJS} ${LIBS} \
-	-lgtkextra-x11-2.0 -ldl -gthread-2.0
-	${LN} ${PROJDIR}/lib/libworkbook.so ${PROJDIR}/lib/libworkbook.so.1
-clean:		
-	${MD} ${OBJDIR}/libworkbook	
-	${RM} ${OBJS} ${PROJDIR}/lib/libworkbook.so.1
-
-${OBJDIR}/libworkbook/%.o: %.c
-	${CC} ${INCS} -c -fPIC ${CCFLAGS} $< -o $@
-
-.c.o:
-	${CC} ${INCS} -c -fPIC ${CCFLAGS} $<
diff --git a/workbook/cell.c b/workbook/cell.c
deleted file mode 100755
index 3dcd154..0000000
--- a/workbook/cell.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <workbook/cell.h>
-
-/* cell.c (static) */
-static Cell *cell_object_init (void);
-static void cell_object_free (Cell *);
-static void cell_method_set_value (Cell *, const gchar *);
-static void cell_method_set_value_length (Cell *, void *, size_t);
-static void cell_method_set_column (Cell *, gint);
-static void cell_method_set_row (Cell *, gint);
-static void cell_method_set_all (Cell *, gint, gint, const gchar *);
-static void cell_method_set_justification (Cell *, GtkJustification);
-static void cell_method_destroy (Cell *);
-static void cell_method_set_bgcolor (Cell *, const gchar *);
-static void cell_method_set_fgcolor (Cell *, const gchar *);
-static void cell_method_set_attributes (Cell *, const CellAttributes *);
-static void cell_method_set_range (Cell *, const GtkSheetRange *);
-
-/* @description: The function returns a pointer to a Cell object. */
-Cell *
-cell_new (void)
-{
-  Cell * cell = cell_object_init ();
-  return cell;
-}
-
-/* @description: This function is the Cell object's constructor. */
-static Cell *
-cell_object_init (void)
-{
-  Cell * cell = NEW (Cell);
-
-  cell->value = g_string_new_len ("", 4096);
-  cell->attributes.bgcolor = g_string_new_len ("", 1024);
-  cell->attributes.fgcolor = g_string_new_len ("", 1024);
-
-  /* Methods */
-  cell->set_fgcolor = cell_method_set_fgcolor;
-  cell->set_bgcolor = cell_method_set_bgcolor;
-  cell->set_attributes = cell_method_set_attributes;
-  cell->set_range = cell_method_set_range;
-  cell->set_value = cell_method_set_value;
-  cell->set_value_length = cell_method_set_value_length;
-  cell->set_column = cell_method_set_column;
-  cell->set_row = cell_method_set_row;
-  cell->set = cell_method_set_all;
-  cell->set_justification = cell_method_set_justification;
-  cell->destroy = cell_method_destroy;
-
-  return cell;
-}
-
-/* @description: This object frees the memory created by the Cell object.
-   @cell: The pointer to the object to free. */
-static void
-cell_object_free (Cell * cell)
-{
-  ASSERT (cell != NULL);
-
-  g_string_free (cell->value, TRUE);
-  g_string_free (cell->attributes.fgcolor, TRUE);
-  g_string_free (cell->attributes.bgcolor, TRUE);
-  FREE (cell);
-}
-
-/* @description: This method sets a cell in the GtkSheet with the attributes
-   of a Cell object.
-   @row: An integer value of the row to set.
-   @column: An integer value fo the column to set.
-   @value: A string value to what should be set in the Cell. */
-static void
-cell_method_set_all (Cell * cell, 
-		     gint row, gint column, 
-		     const gchar * value)
-{
-  ASSERT (cell != NULL);
-
-  g_string_assign (cell->value, value);
-  cell->row = row;
-  cell->column = column;  
-}
-
-/* @description: This method sets the justification of the specified Cell
-   object.
-   @justification: The GtkJustification value for the cell. */
-static void
-cell_method_set_justification (Cell * cell, 
-			       GtkJustification justification)
-{
-  ASSERT (cell != NULL);
-  cell->attributes.justification = justification;
-}
-
-/* @description: The method sets the row of the Cell object.
-   @row: Integer value of the row. */
-static void
-cell_method_set_row (Cell * cell, 
-		     gint row)
-{
-  ASSERT (cell != NULL);
-  cell->row = row;
-  cell->range.row0 = cell->range.rowi = row;
-}
-
-/* @description: The method sets the column of the Cell object.
-   @column: Integer value fo the column. */
-static void
-cell_method_set_column (Cell * cell, 
-			gint column)
-{
-  ASSERT (cell != NULL);
-  cell->column = column;
-  cell->range.col0 = cell->range.coli = column;
-}
-
-/* @description: This method sets the bgcolor of the Cell object.
-   @color: String value of the color, e.g. white, blue, red. */
-static void
-cell_method_set_bgcolor (Cell * cell, 
-			 const gchar * color)
-{
-  ASSERT (cell != NULL);
-
-  g_string_assign (cell->attributes.bgcolor, color);
-}
-
-/* @description: This method sets the fgcolor of the Cell object.
-   @color: String value of the color, e.g. white, blue, red. */
-static void 
-cell_method_set_fgcolor (Cell * cell, 
-			 const gchar *color)
-{
-  ASSERT (cell != NULL);
-  
-  g_string_assign (cell->attributes.fgcolor, color);
-}
-
-/* @description: This method sets the range of the Cell object.
-   @range: A pointer to a GtkSheetRange object. */
-static void
-cell_method_set_range (Cell * cell, 
-		       const GtkSheetRange * range)
-{
-  ASSERT (cell != NULL); ASSERT (range != NULL);
-  
-  cell->range.row0 = range->row0;
-  cell->range.col0 = range->col0;
-  cell->range.rowi = range->rowi;
-  cell->range.coli = range->coli;
-}
-
-/* @description: This method sets the attributes of the Cell object.
-   @attrib: A pointer to the Cell Attributes object. */
-static void
-cell_method_set_attributes (Cell * cell, 
-			    const CellAttributes * attrib)
-{
-  ASSERT (cell != NULL); ASSERT (attrib != NULL);
-
-  cell->attributes.justification = attrib->justification;
- 
-  g_string_assign (cell->attributes.fgcolor, attrib->fgcolor->str);
-  g_string_assign (cell->attributes.bgcolor, attrib->bgcolor->str);
-}
-
-/* @description: This method sets the text value of the Cell object.
-   @value: This is a string pointer to the value. */
-static void
-cell_method_set_value (Cell * cell, 
-		       const gchar * value)
-{
-  ASSERT (cell != NULL);
-  
-  g_string_assign (cell->value, value);
-}
-
-static void
-cell_method_set_value_length (Cell * cell, void * s, size_t length) {
-  ASSERT (cell != NULL);
-
-  g_string_assign (cell->value, "");
-  g_string_append_len (cell->value, (const char *)s, length);
-}
-
-static void
-cell_method_destroy (Cell * cell)
-{
-  g_return_if_fail (cell != NULL);
-
-  cell_object_free (cell);
-}
diff --git a/workbook/sheet.c b/workbook/sheet.c
deleted file mode 100755
index c379c26..0000000
--- a/workbook/sheet.c
+++ /dev/null
@@ -1,603 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <workbook/sheet.h>
-#include <gtkextra/gtksheet.h>
-#include <string.h>
-
-/* sheet.c (static) */
-static Sheet *sheet_object_init (Workbook *, const gchar *, gint, gint);
-static void sheet_object_free (Sheet *);
-static void sheet_method_destroy (Sheet *);
-static void sheet_method_set_cell (Sheet *, gint, gint, const gchar *);
-static void sheet_method_apply_cell (Sheet *, const Cell *);
-static void sheet_method_apply_cellarray (Sheet *, Cell **, gint);
-static void sheet_method_apply_cellrange (Sheet *, 
-					  const GtkSheetRange *,
-					  const CellAttributes *);
-static void sheet_method_range_set_background (Sheet *, 
-					       const GtkSheetRange *,
-					       const gchar *);
-static void sheet_method_range_set_foreground (Sheet *,
-					       const GtkSheetRange *,
-					       const gchar *);
-static void sheet_method_set_attention (Sheet *, gint);
-static gboolean sheet_method_load (Sheet *, const gchar *);
-static gboolean sheet_method_save (Sheet *, const gchar *);
-static void sheet_method_apply_cellrow (Sheet *, Cell **, gint, gint);
-
-struct geometryFileHeader {
-  gint fileVersion;
-  gint maxRow;
-  gint maxColumn;
-};
-
-struct geometryFileEntry {
-  gint cellRow;
-  gint cellCol;
-  gint cellTextLength;
-  gboolean cellIsVisible;
-  gboolean cellIsEditable;
-  GtkJustification cellJustification;
-  GdkColor cellForeground;
-  GdkColor cellBackground;
-};
-
-/*
-static GtkSheetCell *
-gtk_sheet_cell_new (void) {
-  GtkSheetCell * cell = g_new (GtkSheetCell, 1);
-  cell->text = NULL;
-  cell->link = NULL;
-  cell->attributes = NULL;
-  return cell;
-}
-*/
-/*
-static void
-GrowSheet (GtkSheet * tbl, gint newrows, gint newcols) {
-  gint ii, jj, inirow, inicol;
-
-  inirow = tbl->maxallocrow + 1;
-  inicol = tbl->maxalloccol + 1;
-
-  tbl->maxalloccol = tbl->maxalloccol + newcols;
-  tbl->maxallocrow = tbl->maxallocrow + newrows;
-
-  if (newrows > 0) {
-    tbl->data = (GtkSheetCell ***) g_realloc (tbl->data,
-					      (tbl->maxallocrow+1)*sizeof(GtkSheetCell**)+sizeof(double));
-
-    for (ii = inirow; ii <= tbl->maxallocrow; ii++) {
-      tbl->data[ii] = (GtkSheetCell **) g_malloc ((tbl->maxcol+1)*sizeof(GtkSheetCell*)+sizeof(double));
-
-      for (jj = 0; jj < inicol; jj++)
-	tbl->data[ii][jj] = NULL;
-    }
-  }
-
-  if (newcols > 0) {
-    for (ii = 0; ii <= tbl->maxallocrow; ii++) {
-      tbl->data[ii] = (GtkSheetCell **) g_realloc (tbl->data[ii],
-						   (tbl->maxalloccol+1)*sizeof(GtkSheetCell*)+sizeof(double));
-
-      for (jj = inicol; jj <= tbl->maxalloccol; jj++)
-	tbl->data[ii][jj] = NULL;
-    }
-  }
-}
-
-static void
-CheckBounds (GtkSheet * tbl, gint row, gint col) {
-  gint newrows = 0, newcols = 0;
-
-  if (col > tbl->maxalloccol) newcols = col - tbl->maxalloccol;
-  if (row > tbl->maxallocrow) newrows = row - tbl->maxallocrow;
-  if (newrows > 0 || newcols > 0) GrowSheet (tbl, newrows, newcols);
-}
-*/
-/* @description: This method creates a new Sheet object and returns the
-   pointer to that object. It calls the constructor function to do so.
-   @book: A pointer to the Workbook that the object will be a part of.
-   @label: A string to the Sheet's label. 
-   @rows: The number of rows.
-   @columns: The number of columns. */
-Sheet *
-sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
-{
-  ASSERT (book != NULL);
-  
-  Sheet * sheet = sheet_object_init (book, label, rows, columns);
-
-  /* STUB: Perform anything that is based on a style here. */
-
-  return sheet;
-}
-
-/* @description: This function is the Sheet's constructor. 
-   @book: A pointer to the Workbook that the Sheet object will be assigned.
-   @label: A string label - the name of the sheet that we will use to search.
-   @rows: The amount of rows the GtkSheet widget should have.
-   @cols: The amount of columns the GtkSheet widget should have. */
-static Sheet *
-sheet_object_init (Workbook * book,
-		   const gchar * label, 
-		   gint rows, gint columns)
-{
-  gdk_threads_enter ();
-  Sheet * sheet = NEW (Sheet);
-
-  /* Create the sheet containers and GtkSheet object. */
-  sheet->gtk_box = gtk_vbox_new (FALSE, 1);
-  gtk_widget_show (sheet->gtk_box);
-
-  GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
-  gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
-				  GTK_POLICY_AUTOMATIC,
-				  GTK_POLICY_AUTOMATIC);
-  gtk_widget_show (scrolled_window);
-
-  sheet->gtk_label = gtk_label_new (label);
-  
-  sheet->gtk_sheet = gtk_sheet_new (rows, columns, label);
-  gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
-  gtk_container_add (GTK_CONTAINER (scrolled_window),
-		     GTK_WIDGET (sheet->gtk_sheet));
-  gtk_widget_show (sheet->gtk_sheet);
-
-  /* We should be able to use sheet->gtk_box now throughout all of our
-     tests when iterating through a GtkNotebook structure. The page number
-     will change when something is removed (or reordered). The pointer will
-     stay the same. */
-  sheet->page = gtk_notebook_append_page (GTK_NOTEBOOK (book->gtk_notebook),
-					  sheet->gtk_box,
-					  sheet->gtk_label);
-  /* Members */
-  sheet->workbook = book;
-  sheet->name = g_strdup (label);
-  sheet->attention = 0;
-  sheet->notices = 0;
-  sheet->has_focus = FALSE;
-  sheet->next = sheet->prev = NULL;
-  sheet->max_rows = rows;
-  sheet->max_columns = columns;
-
-  /* Methods */
-  sheet->destroy = sheet_method_destroy;
-  sheet->set_cell = sheet_method_set_cell;
-  sheet->apply_range = sheet_method_apply_cellrange;
-  sheet->apply_array = sheet_method_apply_cellarray;
-  sheet->apply_cell = sheet_method_apply_cell;
-  sheet->apply_row = sheet_method_apply_cellrow;
-  sheet->range_set_foreground = sheet_method_range_set_foreground;
-  sheet->range_set_background = sheet_method_range_set_background;
-  sheet->set_attention = sheet_method_set_attention;
-  sheet->save = sheet_method_save;
-  sheet->load = sheet_method_load;
-
-  /* Connect any signals that we need to. */
-  if (!IS_NULL (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]))
-    {
-      gtk_signal_connect (GTK_OBJECT (sheet->gtk_sheet),
-			  "changed",
-		  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]),
-			  (gpointer)sheet);
-    }
-
-  gdk_threads_leave ();
-  return sheet;
-}
-
-static gboolean
-sheet_method_load (Sheet * sheet, const gchar * filepath)
-{
-  ASSERT (sheet != NULL);
-
-  if (IS_NULLSTR (filepath))
-    {
-      g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
-      return FALSE;
-    }
-
-  FILE * fp = NULL;
-  if ((fp = fopen (filepath, "rb")) == NULL)
-    {
-      g_warning ("%s: failed opening file '%s' for reading", 
-		 __FUNCTION__,
-		 filepath);
-      return FALSE;
-    }
-
-  gdk_threads_enter ();
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
-  struct geometryFileHeader header = {-1,-1,-1};
-  struct geometryFileEntry entry = {-1,-1,-1};
- 
-  fread ((void *)&header, sizeof (struct geometryFileHeader), 1, fp);
-
-  if (header.fileVersion != GEOMETRY_FILE_VERSION)
-    {
-      g_warning ("Geometry file version %d is not accepted. (%d)",
-		 header.fileVersion, GEOMETRY_FILE_VERSION);
-      FCLOSE (fp);
-      gdk_threads_leave ();
-      return FALSE;
-    }
-
-  while (fread ((void *)&entry, sizeof (struct geometryFileEntry), 1, fp) > 0)
-    {
-      gchar * text = g_strndup ("", entry.cellTextLength);
-      fread ((void *)text, sizeof (gchar), entry.cellTextLength, fp);
-      gtk_sheet_set_cell_text (gtksheet, 
-			       entry.cellRow, 
-			       entry.cellCol, 
-			       text);
-      
-      GtkSheetCell ** cell = &gtksheet->data[entry.cellRow][entry.cellCol];
-      
-      (*cell)->attributes->is_editable = entry.cellIsEditable;
-      (*cell)->attributes->is_visible = entry.cellIsVisible;
-      (*cell)->attributes->justification = entry.cellJustification;
-      (*cell)->attributes->foreground.pixel = entry.cellForeground.pixel;
-      (*cell)->attributes->foreground.red = entry.cellForeground.red;
-      (*cell)->attributes->foreground.green = entry.cellForeground.green;
-      (*cell)->attributes->foreground.blue = entry.cellForeground.blue;
-      (*cell)->attributes->background.pixel = entry.cellBackground.pixel;
-      (*cell)->attributes->background.red = entry.cellBackground.red;
-      (*cell)->attributes->background.green = entry.cellBackground.green;
-      (*cell)->attributes->background.blue = entry.cellBackground.blue;
-
-      FREE (text);
-    }
-
-  FCLOSE (fp);
-  gdk_threads_leave ();
-  return TRUE;
-}
-
-static gboolean
-sheet_method_save (Sheet * sheet, const gchar * filepath)
-{
-  ASSERT (sheet != NULL);
-
-  if (IS_NULLSTR (filepath))
-    {
-      g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
-      return FALSE;
-    }
-
-  FILE * fp = NULL;
-  if ((fp = fopen (filepath, "wb")) == NULL)
-    {
-      g_warning ("%s: failed opening file '%s' for writing", 
-		 __FUNCTION__, 
-		 filepath);
-      return FALSE;
-    }
-  
-  gdk_threads_enter ();
-  GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
-  struct geometryFileHeader header =
-    {
-      GEOMETRY_FILE_VERSION,
-      GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
-      GTK_SHEET (sheet->gtk_sheet)->maxalloccol
-    };
-
-  fwrite ((void *)&header, sizeof(struct geometryFileHeader), 1, fp);
-
-  for (gint ii = 0; ii <= header.maxRow; ii++)
-    {
-      for (gint jj = 0; jj <= header.maxColumn; jj++)
-	{
-	  GtkSheetCell * cell = data[ii][jj];
-
-	  if (!IS_NULL (cell) && !IS_NULLSTR(cell->text))
-	    {
-	      struct geometryFileEntry entry =
-		{
-		  cell->row,
-		  cell->col,
-		  strlen (cell->text),
-		  cell->attributes->is_visible,
-		  cell->attributes->is_editable,
-		  cell->attributes->justification
-		};
-
-	      entry.cellForeground.pixel = cell->attributes->foreground.pixel;
-	      entry.cellForeground.red = cell->attributes->foreground.red;
-	      entry.cellForeground.green = cell->attributes->foreground.green;
-	      entry.cellForeground.blue = cell->attributes->foreground.blue;
-	      entry.cellBackground.pixel = cell->attributes->background.pixel;
-	      entry.cellBackground.red = cell->attributes->background.red;
-	      entry.cellBackground.green = cell->attributes->background.green;
-	      entry.cellBackground.blue = cell->attributes->background.blue;
-
-	      fwrite ((void *)&entry, 
-		      sizeof (struct geometryFileEntry), 1, fp);
-	      fwrite ((void *)cell->text, 
-		      sizeof (gchar), entry.cellTextLength, fp);
-	    }
-	}
-    }
-
-  FCLOSE (fp);
-  gdk_threads_leave ();
-  return TRUE;
-}
-
-/* @description: This method sets the attention level of the Sheet.
-   @sheet: A pointer to the Sheet object.
-   @attention: The attention level. */
-static void 
-sheet_method_set_attention (Sheet * sheet, gint attention)
-{
-  ASSERT (sheet != NULL);
-  gdk_threads_enter ();
-
-  sheet->attention = attention;
-
-  /* Do something funky to show that you should be looking at ME!
-     Oh, GtkNotebook tab, why are thou so vain? */
-  if ((sheet->has_focus == FALSE) && (sheet->notices > 0)) {
-      
-    }
-
-  gdk_threads_leave ();
-}
-
-/* @description: This method destroys the Sheet object.
-   @sheet: A pointer to the object that will be destroyed. */
-static void
-sheet_method_destroy (Sheet * sheet)
-{
-  ASSERT (sheet != NULL);
-  gdk_threads_enter ();
-
-  DOUBLE_UNLINK (sheet);
-
-  sheet_object_free (sheet);
-
-  gdk_threads_leave ();
-}
-
-/* @description: This method frees the memory that was used by the Sheet
-   object. This should only be called from sheet->destroy()
-   @sheet: A pointer to the Sheet object that will be freed. */
-static void
-sheet_object_free (Sheet * sheet)
-{
-  ASSERT (sheet != NULL);
-
-  FREE (sheet->name);
-  FREE (sheet);
-  return;
-}
-
-static void
-sheet_method_apply_cellrange (Sheet * sheet, 
-			      const GtkSheetRange * range,
-			      const CellAttributes * attrib)
-{
-  ASSERT (sheet != NULL);
-  g_return_if_fail (range != NULL);
-  g_return_if_fail (attrib != NULL);
-  gdk_threads_enter ();
-
-  gdk_threads_leave ();
-}
-
-static void
-sheet_method_apply_cellrow (Sheet * sheet,
-			    Cell ** array,
-			    gint row,
-			    gint size) {
-  ASSERT (sheet != NULL);
-  g_return_if_fail (array != NULL);
-
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
-  GtkSheetCell ** cell;
-  Cell * item;
-
-  if (row > gtksheet->maxrow || row < 0) return;
-  if (size > gtksheet->maxcol || size < 0) return;
-
-  gdk_threads_enter();
-
-  for (int col = 0; col < size; col++) {
-    item = array[col]; 
-    cell = &gtksheet->data[row][col];
-    
-    gtk_sheet_set_cell_text (gtksheet,
-			     row,
-			     col,
-			     item->value->str);
-    /*
-    if (*cell == NULL)
-      (*cell) = gtk_sheet_cell_new();
-      
-    (*cell)->row = row;
-    (*cell)->col = col;
-
-    if ((*cell)->text)
-      g_free ((*cell)->text);
-      
-    (*cell)->text = g_strdup (item->value->str);
-    */
-
-    item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
-  }
-
-  gdk_threads_leave();
-}
-
-static void
-sheet_method_apply_cellarray (Sheet * sheet, 
-			      Cell ** array,
-			      gint size)
-{
-  ASSERT (sheet != NULL);
-  g_return_if_fail (array != NULL);
-
-  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
-
-  gdk_threads_enter ();
-
-  /* We'll see how this performs for now. In the future we may want to go
-     directly into the GtkSheet structures to get a little more performance
-     boost (mainly because we should not have to check all the bounds each
-     time we want to update). */
-  for (gint ii = 0; ii < size; ii++) {
-    Cell * cell = array[ii];
-
-    gtk_sheet_set_cell_text (gtksheet,
-			     cell->row,
-			     cell->column,
-			     cell->value->str);
-
-    if (!IS_NULLSTR (cell->attributes.bgcolor->str))
-      sheet->range_set_background (sheet, 
-				   &cell->range, 
-				   cell->attributes.bgcolor->str);
-
-    if (!IS_NULLSTR (cell->attributes.fgcolor->str))
-      sheet->range_set_foreground (sheet, 
-				   &cell->range, 
-				   cell->attributes.fgcolor->str);
-
-    cell->value->str[0] = cell->attributes.bgcolor->str[0] = cell->attributes.fgcolor->str[0] = 0;
-  }
-
-  gdk_threads_leave ();
-}
-
-/* @description: This method applies the settings from a Cell object into the
-   GtkSheet. In order to properly function this should be really the only the
-   GtkSheet object is modified.
-   @sheet: A pointer to the Sheet that holds the GtkSheet object.
-   @cell: A pointer to the Cell that will be applied. */
-static void
-sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
-{
-  ASSERT (sheet != NULL);
-  g_return_if_fail (cell != NULL);
-
-  gdk_threads_enter ();
-
-  if (sheet->has_focus == FALSE)
-    sheet->notices++;
-
-  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet),
-		      cell->row,
-		      cell->column,
-		      cell->attributes.justification,
-		      cell->value->str);
-  gdk_threads_leave ();
-
-  if (!IS_NULLSTR (cell->attributes.bgcolor->str))
-    sheet->range_set_background (sheet, 
-				 &cell->range, 
-				 cell->attributes.bgcolor->str);
-
-  if (!IS_NULLSTR (cell->attributes.fgcolor->str))
-    sheet->range_set_foreground (sheet, 
-				 &cell->range, 
-				 cell->attributes.fgcolor->str);
-
-  /* Clear all of the strings */
-  g_string_assign (cell->value, "");
-  g_string_assign (cell->attributes.bgcolor, "");
-  g_string_assign (cell->attributes.fgcolor, "");
-}
-
-/* @description: This method changes the background of a range of cells. 
-   @sheet: A pointer to the Sheet object that contains GtkSheet.
-   @range: A pointer to the GtkSheetRange object that contains the ranges
-   that we will be applying the background color to.
-   @desc: A string that contains the color's string value (e.g. white, red
-   green, etc). */
-static void
-sheet_method_range_set_background (Sheet * sheet, 
-				   const GtkSheetRange * range,
-				   const gchar * desc)
-{
-  ASSERT (sheet != NULL); ASSERT (range != NULL);
-  GdkColor color;
-
-  /* The color needs to be taken from the colormap; there is an alternative
-     way to do this if we use #rgb or #rrggbb formats. */
-  gdk_threads_enter ();
-  gdk_color_parse (desc, &color);
-  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
-		   &color);
-  
-  gtk_sheet_range_set_background (GTK_SHEET (sheet->gtk_sheet),
-				  range, &color);
-  gdk_threads_leave ();
-}
-
-/* @description: This method changes the foreground color over a range of
-   cells. 
-   @sheet: A pointer to the Sheet object that contains GtkSheet.
-   @range: A pointer to the GtkSheetRange object that contains the ranges
-   that we will be applying the foreground color to.
-   @desc: The string representation of the color (e.g. white, green, blue). */
-static void
-sheet_method_range_set_foreground (Sheet * sheet, 
-				   const GtkSheetRange * range,
-				   const gchar * desc)
-{
-  ASSERT (sheet != NULL); ASSERT (range != NULL);
-  GdkColor color;
-  
-   /* The color needs to be taken from the colormap; there is an alternative
-     way to do this if we use #rgb or #rrggbb formats. */
-  gdk_threads_enter ();
-  gdk_color_parse (desc, &color);
-  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
-		   &color);
-      
-  gtk_sheet_range_set_foreground (GTK_SHEET (sheet->gtk_sheet),
-				  range, &color);
-  gdk_threads_leave ();
- }
-
-/* @description: This method manually sets a GtkSheet cell's value. It does
-   not require the use of the Cell object.
-   @sheet: A pointer to the Sheet object that contains GtkSheet.
-   @row: An integer value of the row.
-   @col: An integer value of the column.
-   @value: The text string to be applied to the cell. */
-static void 
-sheet_method_set_cell (Sheet * sheet,
-		       gint row, gint col,
-		       const gchar * value)
-{
-  ASSERT (sheet != NULL);
-
-  gdk_threads_enter ();
-  if (sheet->has_focus == FALSE)
-    sheet->notices++;
-  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet), 
-		      row, 
-		      col, 
-		      GTK_JUSTIFY_LEFT, 
-		      value);
-  gdk_threads_leave ();
-}
diff --git a/workbook/workbook.c b/workbook/workbook.c
deleted file mode 100755
index 15bcc96..0000000
--- a/workbook/workbook.c
+++ /dev/null
@@ -1,289 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <workbook/workbook.h>
-#include <glib/gthread.h>
-#include <string.h>
-
-/* workbook.c (static) */
-static void workbook_method_destroy (Workbook *);
-static Workbook *workbook_object_init (GtkWidget *, const gchar *);
-static Workbook *workbook_object_free (Workbook *);
-static Sheet *workbook_method_addnewsheet (Workbook *, 
-					   const gchar *, 
-					   gint, gint);
-static Sheet *workbook_method_get_sheet (Workbook *, const gchar *);
-static void workbook_method_remove_sheet (Workbook *, Sheet *);
-static gboolean workbook_method_move_sheet_index (Workbook *, Sheet *, gint);
-static gboolean workbook_method_move_sheet (Workbook *, 
-					    Sheet *,
-					    const gchar *,
-					    gboolean);
-
-/* @description: This method "opens" a Workbook. In the future it will load
-   a Workbook from a specified filename (which will most likely be a GZIP
-   file) but for now it merely loads one into memory.
-   @window: A pointer to the GtkWindow object. 
-   @filename: A pointer to the filename string. */
-Workbook *
-workbook_open (GtkWidget * window, const gchar * filename)
-{
-  ASSERT (window != NULL);
-
-  /* STUB: A workbook is opened here from some form of an archived file.
-     At this point we would load up the configuration files for the styles,
-     sheets and plugins to be loaded then this would all be executed here. */
-
-  Workbook * book = workbook_object_init (window, filename);
-  return book;
-}
-
-/* @description: This method adds a new Sheet to the Workbook object. The
-   specified parameters are passed on to the Sheet object's constructor.
-   But first we check to make sure that a sheet with the same label does
-   not already exist inside of the Workbook.
-   @book: Pointer to the Workbook object.
-   @label: The Sheet's label string.
-   @rows: Number of rows the GtkSheet object should have.
-   @cols: Number of columns the GtkSheet object should have.*/
-static Sheet *
-workbook_method_addnewsheet (Workbook * book,
-			     const gchar * label, 
-			     gint rows, 
-			     gint cols)
-{
-  ASSERT (book != NULL);
-
-  Sheet * sheet = book->get_sheet (book, label);
-  if (sheet != NULL) 
-    {
-      g_warning ("Cannot create '%s' because it already exists", 
-		 label);
-      return NULL;
-    }
-
-  sheet = sheet_new (book, label, rows, cols);
-
-  LINK_OBJECT (book->sheet_first,
-	       book->sheet_last, 
-	       sheet);
-
-  /* We are the first and only sheet; make sure we are set to have focus. */
-  /* BUGFIX: This was in the wrong place... needs to be below LINK_OBJECT */
-  if ((book->sheet_first == sheet) && IS_NULL (book->sheet_last))
-    {
-      sheet->has_focus = TRUE;
-      book->focus_sheet = sheet;
-    }
-
-  return sheet;
-}
-
-/* @description: This method performs a search of all the Workbooks and
-   returns a pointer to the Sheet object if it matches the provided label.
-   @wb: Pointer to the workbook we're searching.
-   @sheet: String label of the sheet we are searching for. */
-static Sheet *
-workbook_method_get_sheet (Workbook * wb, const gchar * sheet)
-{
-  ASSERT (wb != NULL);
-
-  if (!IS_NULLSTR (sheet))
-    {
-      ITERATE_BEGIN (Sheet, wb->sheet_first);
-      {
-	if (!sheet) return NULL;
-	if (!strcmp (sheet, it->name))
-	  return it;
-      }
-      ITERATE_END ();
-    }
-
-  return NULL;
-}
-
-/* @description: This method removes a Sheet object from the Workbook. It also
-   removes to GtkSheet tab from the GtkNotebook (held in the Workbook).
-   @wb: The Workbook pointer we are removing the object from.
-   @sheet: The Sheet object that we will be removing. */
-static void
-workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
-{
-  ASSERT (wb != NULL);
-
-  if (sheet->workbook != wb)
-    {
-      g_warning ("'%s' does not belong to workbook '%s'",
-		 sheet->name, wb->filename);
-      return;
-    }
-  
-  ITERATE_BEGIN (Sheet, wb->sheet_first);
-  {
-    /* Remove the sheet from the GtkNotebook */
-    if (it == sheet)
-      {
-	gdk_threads_enter ();
-	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
-					   sheet->gtk_box);
-	gtk_notebook_remove_page (GTK_NOTEBOOK (wb->gtk_notebook), page); 
-	gtk_widget_queue_draw (wb->gtk_notebook);
-	gdk_threads_leave ();
-	return;
-      }
-  }
-  ITERATE_END ();
-
-  g_warning ("Sheet '%s' was not found inside of workbook '%s'", 
-	     sheet->name, wb->filename);
-}
-
-/* @description: This method moves the Sheet's GtkSheet tab inside of the
-   Workbook's GtkNotebook.
-   @wb: The Workbook object that contains the GtkNotebook.
-   @sheet: The Sheet object that contains the GtkSheet we're moving.
-   @index: The _new_ page index. */
-static gboolean
-workbook_method_move_sheet_index (Workbook * wb, Sheet * sheet, gint index)
-{
-  gdk_threads_enter ();
-  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
-			      sheet->gtk_box,
-			      index);
-  gdk_threads_leave ();
-  return TRUE;
-}
-
-static gboolean
-workbook_method_move_sheet (Workbook * wb, 
-			    Sheet * sheet, 
-			    const gchar * id,
-			    gboolean after)
-{
-  ASSERT (wb != NULL);
-  ASSERT (sheet != NULL);
-
-  if (IS_NULLSTR (id))
-    return FALSE;
-
-  Sheet * sh = wb->get_sheet (wb, id);
-  if (IS_NULL (sh))
-    {
-      g_warning ("Sheet '%s' does not exist in workbook '%s'", 
-		 sheet->name, wb->filename);
-      return FALSE;
-    }
-  
-  gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
-				     sh->gtk_box);
-  if (page == -1)
-    {
-      g_warning ("Sheet '%s' does not appear to be in workbook '%s' notebook",
-		 sheet->name, wb->filename);
-      return FALSE;
-    }
-
-  if (after == TRUE)  page++;
-  else                page--;
-
-  gdk_threads_enter ();
-  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
-			      sheet->gtk_box,
-			      page);
-  gdk_threads_leave ();
-  return TRUE;
-}
-
-/* @description: This is a Workbook object's constructor. 
-   @window: A pointer to the GtkWindow context.
-   @filename: A pointer to the filename string. */
-static Workbook *
-workbook_object_init (GtkWidget * window, const gchar * filename)
-{
-  Workbook * book = NEW (Workbook);
-
-  /* Set up the signals. */
-  book->signals[SIG_WORKBOOK_CHANGED] = NULL;
-
-  /* Set up the notebook */
-  gdk_threads_enter ();
-  book->gtk_notebook = gtk_notebook_new ();
-  
-  GtkNotebook * notebook = GTK_NOTEBOOK (book->gtk_notebook);
-
-  gtk_notebook_set_tab_pos (notebook, GTK_POS_BOTTOM);
-  gtk_notebook_popup_enable (notebook);
-  gtk_notebook_set_show_tabs (notebook, TRUE);
-  gtk_notebook_set_show_border (notebook, TRUE);
-  gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
-  gtk_widget_show (book->gtk_notebook);
-  gdk_threads_leave ();
-
-  /* Members */
-  book->sheet_first = book->sheet_last = NULL;
-  book->next = book->prev = NULL;
-  book->focus_sheet = NULL;
-  book->gtk_window = window;
-  book->filename = g_strdup (filename);
-    
-  /* Methods */
-  book->destroy = workbook_method_destroy;
-  book->add_new_sheet = workbook_method_addnewsheet;
-  book->get_sheet = workbook_method_get_sheet;
-  book->remove_sheet = workbook_method_remove_sheet;
-  book->move_sheet_index = workbook_method_move_sheet_index;
-  book->move_sheet = workbook_method_move_sheet;
-
-  return book;
-}
-
-/* @description: This method destroys the Workbook object and all of the
-   Sheet objects that it contains. 
-   @book: The Workbook object to destroy. */
-static void
-workbook_method_destroy (Workbook * book)
-{
-  ASSERT (book != NULL);
-
-  /* Wrap anything up here. */
-  Sheet * current = book->sheet_first, * next = NULL;
-  while (current)
-    {
-      next = current->next;
-      current->destroy (current);
-      current = next;
-    }
-
-  UNLINK_OBJECT (book);
-  workbook_object_free (book);
-}
-
-/* @description: This method frees the memory that the Workbook object has 
-   been using. This is only able to be called from book->destroy()
-   @book: The Workbook object we are freeing. */
-static Workbook *
-workbook_object_free (Workbook * book)
-{
-  ASSERT (book != NULL);
-
-  book->sheet_first = book->sheet_last = NULL;
-
-  FREE (book->filename);
-  FREE (book);
-  return book;
-}

commit a2e307c2f470e7309c94098ac710fa48d33b8240
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 15:31:37 2009 -0400

    Moved concurrent, network, and proactor libraries into src folder.

diff --git a/shared/Makefile b/shared/Makefile
deleted file mode 100755
index 13759d7..0000000
--- a/shared/Makefile
+++ /dev/null
@@ -1,26 +0,0 @@
-include ../Makefile.base
-
-SRCS=$(wildcard *.cpp) $(wildcard concurrent/*.cpp) \
-$(wildcard network/*.cpp) $(wildcard proactor/*.cpp)
-OBJS=$(patsubst %.cpp,${OBJDIR}/libshared/%.o,${SRCS})
-
-all: 	shared
-
-shared: ${OBJS}
-	${CX} -shared -Wl -o ${PROJDIR}/lib/libshared.so ${OBJS} ${LIBS} \
-	-lpthread
-	${CP} ${PROJDIR}/lib/libshared.so ${PROJDIR}/lib/libshared.so.1
-
-clean:		
-	${MD} ${OBJDIR}/libshared/concurrent ${OBJDIR}/libshared/network \
-	${OBJDIR}/libshared/proactor
-	${RM} ${OBJS} ${PROJDIR}/lib/libshared.so ${PROJDIR}/lib/libshared.so.1
-
-install: all
-	${MD} ${INSEXTDIR}
-
-${OBJDIR}/libshared/%.o: %.cpp
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
-
-.cpp.o:
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<
\ No newline at end of file
diff --git a/shared/concurrent/List.hpp b/shared/concurrent/List.hpp
deleted file mode 100755
index 130cb5d..0000000
--- a/shared/concurrent/List.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_LIST
-#define HPP_CONCURRENT_LIST
-
-#include <list>
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  template <typename T>
-  class List : public RecursiveMutex, public std::list<T> {
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/concurrent/Lockable.hpp b/shared/concurrent/Lockable.hpp
deleted file mode 100755
index 31fdc75..0000000
--- a/shared/concurrent/Lockable.hpp
+++ /dev/null
@@ -1,31 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_LOCKABLE
-#define HPP_THREAD_LOCKABLE
-
-class ILockable {
-public:
-  virtual ~ILockable (void) { }
-
-  virtual void lock (void) = 0;
-  virtual void unlock (void) = 0;
-  virtual bool trylock (void) = 0;
-};
-
-#endif
diff --git a/shared/concurrent/Map.hpp b/shared/concurrent/Map.hpp
deleted file mode 100755
index 9f4b9ce..0000000
--- a/shared/concurrent/Map.hpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MAP
-#define HPP_THREAD_MAP
-
-#include <iterator>
-#include <map>
-#include "Mutex.hpp"
-
-namespace concurrent {
- 
-  /* @description: This object uses the standard std::map and wraps all of
-     the calls that are exposed with a Mutex object. This object uses a
-     single lock and may cause performance issues if several threads are
-     attempting to use it. 
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template<typename K, typename V>
-  class Map : public RecursiveMutex, public std::map<K,V> {
-  private:
-  public:
-    Map (void) : RecursiveMutex() { }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/concurrent/Mutex.cpp b/shared/concurrent/Mutex.cpp
deleted file mode 100755
index 43ec628..0000000
--- a/shared/concurrent/Mutex.cpp
+++ /dev/null
@@ -1,89 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  IMutex::IMutex (void) {
-    this->mutex = NULL;
-    this->attrib = NULL;
-  }
-
-  IMutex::IMutex (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-  }
-
-  IMutex::~IMutex (void) {
-  }
-
-  IMutex & 
-  IMutex::operator= (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-    return *this;
-  }
-
-  void
-  IMutex::lock (void) {
-    pthread_mutex_lock (this->mutex);
-  }
-
-  void 
-  IMutex::unlock (void) {
-    pthread_mutex_unlock (this->mutex);
-  }
-
-  bool
-  IMutex::trylock (void) {
-    return (pthread_mutex_trylock (this->mutex) == 0) ?
-      true : false;
-  }
-  
-  RecursiveMutex::RecursiveMutex (void) {
-    this->mutex = new pthread_mutex_t;
-    this->attrib = new pthread_mutexattr_t;
-
-    pthread_mutexattr_init (this->attrib);
-    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
-    
-    pthread_mutex_init (this->mutex, attrib);
-  }
-
-  RecursiveMutex::~RecursiveMutex (void) {
-    pthread_mutex_destroy (this->mutex);
-    pthread_mutexattr_destroy (this->attrib);
-
-    delete this->mutex;
-    delete this->attrib;
-  }
-
-  Mutex::Mutex (void) {
-    this->mutex = new pthread_mutex_t;
-
-    pthread_mutex_init (this->mutex, NULL);
-  }
-
-  Mutex::~Mutex (void) {
-    pthread_mutex_destroy (this->mutex);
-
-    delete this->mutex;
-  }
-
-} // end of namespace
diff --git a/shared/concurrent/Mutex.hpp b/shared/concurrent/Mutex.hpp
deleted file mode 100755
index f4be8a9..0000000
--- a/shared/concurrent/Mutex.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MUTEX
-#define HPP_THREAD_MUTEX
-
-#include <pthread.h>
-#include "Lockable.hpp"
-
-namespace concurrent {
-
-  class IMutex : public ILockable {
-  protected:
-    pthread_mutex_t * mutex;
-    pthread_mutexattr_t * attrib;
-  public:
-    IMutex (void);
-    IMutex (const IMutex & m);
-    virtual ~IMutex (void);
-
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-
-    IMutex & operator= (const IMutex & m);
-  };
-
-  class Mutex : public IMutex {
-  public:
-    Mutex (void);
-    virtual ~Mutex (void);
-  };
-
-  class RecursiveMutex : public IMutex {
-  public:
-    RecursiveMutex (void);
-    virtual ~RecursiveMutex (void);
-  };
-}
-
-#endif
diff --git a/shared/concurrent/Queue.hpp b/shared/concurrent/Queue.hpp
deleted file mode 100755
index 092953b..0000000
--- a/shared/concurrent/Queue.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_QUEUE
-#define HPP_THREAD_QUEUE
-
-#include "Mutex.hpp"
-#include <queue>
-#include <algorithm>
-
-namespace concurrent {
-  
-  /* @description: This object wraps the existing std::queue container with
-     the custom Mutex object from the concurrent namespace. The single lock
-     may be placed in the future with a read/write lock in order to gain a
-     speed advantage.
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template <typename T>
-  class Queue : public RecursiveMutex {
-  private:
-    std::queue<T> the_queue;
-  public:
-    Queue (void) { }
-    virtual ~Queue (void) { }
-
-    inline void clear (void) {
-      this->lock();
-      while (this->the_queue.size() > 0)
-	this->the_queue.pop();
-      this->unlock();
-    }
-
-    inline void copy (std::queue<T> & Q) {
-      this->lock();
-      Q = this->the_queue;
-      this->unlock();
-    }
-
-    inline const T & back (void) {
-      this->lock();
-      T & elem = this->the_queue.back();
-      this->unlock();
-      return elem;
-    }
-
-    inline const T & front (void) {
-      this->lock();
-      T & elem = this->the_queue.front();
-      this->unlock();
-      return elem;
-    }
-
-    inline void push (const T & x) {
-      this->lock();
-      this->the_queue.push (x);
-      this->unlock();
-    }
-
-    inline T pop (void) {
-      this->lock();
-      T elem = this->the_queue.front();
-      this->the_queue.pop();
-      this->unlock();
-      return elem;
-    }
-    
-    inline size_t size (void) {
-      this->lock();
-      size_t size = this->the_queue.size();
-      this->unlock();
-      return size;
-    }
-
-    inline bool empty (void) {
-      this->lock();
-      bool result = this->the_queue.empty();
-      this->unlock();
-      return result;
-    }
-  };
-}
-#endif
diff --git a/shared/concurrent/Runnable.hpp b/shared/concurrent/Runnable.hpp
deleted file mode 100755
index f2241b5..0000000
--- a/shared/concurrent/Runnable.hpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_RUNNABLE
-#define HPP_CONCURRENT_RUNNABLE
-
-class IRunnable {
-protected:
-  volatile bool running;
-public:
-  IRunnable (void) { this->running = false; }
-  virtual ~IRunnable (void) { }
-
-  virtual void * run (void *) = 0;
-  
-  inline bool isRunning (void) const { return this->running; }
-};
-
-#endif
diff --git a/shared/concurrent/ScopedMemoryLock.cpp b/shared/concurrent/ScopedMemoryLock.cpp
deleted file mode 100755
index eb9b901..0000000
--- a/shared/concurrent/ScopedMemoryLock.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ScopedMemoryLock.hpp"
-
-namespace concurrent {
-  ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
-
-  ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
-    this->hasLock = false;
-    this->address = address;
-    this->mutex = NULL;
-
-    ScopedMemoryLock::addressMutexMap.lock();
-    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-    ScopedMemoryLock::addressMutexMap.unlock();
-
-    /* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
-       if someone is passing an address that has not been formally added via the static method
-       call then that means it is very unlikely that they are not removing it either. We do
-       not want a memory leak therefore this seems like the best method. */
-    if (it != ScopedMemoryLock::addressMutexMap.end()) 
-      this->mutex = it->second;
-
-    if (engage == true)
-      this->lock();
-  }
-
-  ScopedMemoryLock::~ScopedMemoryLock (void) {
-    if (this->hasLock == true)
-      unlock();
-  }
-
-  void
-  ScopedMemoryLock::lock (void) {
-    this->mutex->lock();
-    this->hasLock = true;
-  }
-
-  void 
-  ScopedMemoryLock::unlock (void) {
-    this->mutex->unlock();
-    this->hasLock = false;
-  }
-
-  bool
-  ScopedMemoryLock::trylock (void) {
-    this->hasLock = this->mutex->trylock();
-    return this->hasLock;
-  }
-
-  bool
-  ScopedMemoryLock::remove (void) {
-    if (this->hasLock == false) {
-      return false;
-    }
-
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-    if (it != addressMutexMap.end()) {
-      delete it->second;
-      addressMutexMap.end();
-      result = true;
-    }
-    
-    addressMutexMap.unlock();
-    return result;
-  }
-
-  bool 
-  ScopedMemoryLock::addMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it == addressMutexMap.end()) {
-      addressMutexMap.insert (std::make_pair (address, new Mutex));
-      result = true;
-    }
-
-    addressMutexMap.unlock();
-    return result;
-  }
-
-  bool 
-  ScopedMemoryLock::removeMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    bool result = false;
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it != addressMutexMap.end()) {
-      delete it->second;
-      addressMutexMap.erase(it);
-      result = true;
-    }
-
-    addressMutexMap.unlock();
-    return result;
-  }
-
-} // end of namespace
diff --git a/shared/concurrent/ScopedMemoryLock.hpp b/shared/concurrent/ScopedMemoryLock.hpp
deleted file mode 100755
index eadab0b..0000000
--- a/shared/concurrent/ScopedMemoryLock.hpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_SCOPEDMEMORYLOCK
-#define HPP_CONCURRENT_SCOPEDMEMORYLOCK
-
-#include "Map.hpp"
-#include "Mutex.hpp"
-#include <string>
-
-namespace concurrent {
-
-  class ScopedMemoryLock : public ILockable {
-  private:
-    typedef Map<long int,Mutex *> AddressToMutexMap;
-    static AddressToMutexMap addressMutexMap;
-
-    bool hasLock;
-    unsigned long address;
-    Mutex * mutex;
-  public:
-    ScopedMemoryLock (unsigned long address, bool engage = false);
-    virtual ~ScopedMemoryLock (void);
- 
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-    bool remove (void);
-
-    static bool addMemoryLock (unsigned long address);
-    static bool removeMemoryLock (unsigned long address);
-  };
-} // end of namespace
-
-#endif 
diff --git a/shared/concurrent/Semaphore.cpp b/shared/concurrent/Semaphore.cpp
deleted file mode 100755
index 4e5a58d..0000000
--- a/shared/concurrent/Semaphore.cpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Semaphore.hpp"
-
-namespace concurrent {
-
-  Semaphore::Semaphore (void) {
-    sem_init (&this->semaphore, 0, 0);
-  }
-
-  Semaphore::~Semaphore (void) {
-    sem_destroy (&this->semaphore);
-  }
-
-  void
-  Semaphore::acquire (void) {
-    sem_wait (&this->semaphore);
-  }
-
-  void
-  Semaphore::release (void) {
-    sem_post (&this->semaphore);
-  }
-
-} // end of namespace
-
diff --git a/shared/concurrent/Semaphore.hpp b/shared/concurrent/Semaphore.hpp
deleted file mode 100755
index 3b9e0f4..0000000
--- a/shared/concurrent/Semaphore.hpp
+++ /dev/null
@@ -1,39 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_SEMAPHORE
-#define HPP_THREAD_SEMAPHORE
-
-#include <semaphore.h>
-
-namespace concurrent {
-
-class Semaphore {
-private:
-  sem_t semaphore;
-public:
-  Semaphore (void);
-  virtual ~Semaphore (void);
-
-  void acquire (void);
-  void release (void);
-};
-
-}
-
-#endif
diff --git a/shared/concurrent/Thread.cpp b/shared/concurrent/Thread.cpp
deleted file mode 100755
index 5b7f143..0000000
--- a/shared/concurrent/Thread.cpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Thread.hpp"
-#include "ThreadGroup.hpp"
-#include <iostream>
-#include <ctime>
-
-namespace concurrent {
-
-	static void *
-	thread_run (void * runner) {
-		void * rvalue = ((IRunnable *)runner)->run (NULL);
-		return rvalue;
-	}
-
-	Thread::Thread (ThreadGroup * group,
-						 IRunnable * runner, 
-						 const std::string & name) : thread(0) {
-		this->group = group;
-		this->runner = runner;
-		this->name = name;
-	}
-
-	Thread::Thread (IRunnable * runner,
-						 const std::string & name) 
-		: group(NULL), thread(0) {
-		this->runner = runner;
-		this->name = name;
-	}
-
-	Thread::Thread (const std::string & name) 
-		: group(NULL), runner(NULL), thread(0) {
-		this->name = name;
-	}
-
-	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
-	}
-
-	Thread::~Thread (void) {
-		if (this->running == true) {
-			this->running = false;
-			this->join();
-		}
-	}
-
-	void 
-	Thread::interrupt (void) {
-		this->running = false;
-		pthread_cancel (this->thread);
-		pthread_detach (this->thread);
-	}
-
-	void 
-	Thread::yield (void) {
-		pthread_yield();
-	}
-
-	void * 
-	Thread::stop (void) {
-		this->running = false;
-		return this->join();
-	}
-
-	int 
-	Thread::sleep (unsigned long ms) {
-		struct timespec req = {0};
-		time_t sec = (int)(ms/1000);
-		ms = ms - (sec*1000);
-		req.tv_sec = sec;
-		req.tv_nsec = ms*1000000L;
-		while (nanosleep (&req, &req) == -1)
-			continue;
-		return 1;
-	}
-
-	bool 
-	Thread::start (void) {
-		if (this->running == true)
-			return false;
-
-		if (this->runner != NULL) {
-			if (pthread_create (&this->thread,
-									  NULL,
-									  thread_run,
-									  this->runner))
-				return false;
-		}
-		else {
-			if (pthread_create (&this->thread,
-									  NULL,
-									  thread_run,
-									  this))
-				return false;
-		}
-
-		this->running = true;
-		return true;
-	}
-
-	void *
-	Thread::join (void) {
-		void * rvalue = NULL;
-		if (this->thread > 0)
-			pthread_join (this->thread, &rvalue);
-		return rvalue;
-	}
-
-	void *
-	Thread::run (void *null) {
-		pthread_exit (null);
-	}
-
-} // end of namespace
diff --git a/shared/concurrent/Thread.hpp b/shared/concurrent/Thread.hpp
deleted file mode 100755
index 79f2cf0..0000000
--- a/shared/concurrent/Thread.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREAD
-#define HPP_CONCURRENT_THREAD
-
-#include <shared.h>
-#include <string>
-#include <pthread.h>
-#include <map>
-#include "Runnable.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup;
-
-  class Thread : public IRunnable {
-  private:
-    friend class ThreadGroup;
-
-    ThreadGroup * group;
-    std::string name;
-    IRunnable * runner;
-    pthread_t thread;
-    bool joinable;
-    int priority;
-  public:
-    Thread (ThreadGroup * group, 
-	    IRunnable * runner, 
-	    const std::string & name);
-    Thread (IRunnable * runner,
-	    const std::string & name);
-    Thread (const std::string & name);
-    Thread (void);
-    virtual ~Thread (void);
-
-    bool start (void);
-    void * stop (void);
-    void * join (void);
-    void interrupt (void);
-    void yield (void);
-  
-    virtual void * run (void *);
-
-    inline const std::string & getName (void) const { return this->name; }
-    inline int getPriority (void) const { return this->priority; }
-    inline void setPriority (int priority) { this->priority = priority; }
-    inline const ThreadGroup * getThreadGroup (void) const { 
-      return this->group; 
-    }
-
-    static int sleep (unsigned long ms);
-  };  
-
-}
-
-#endif
diff --git a/shared/concurrent/ThreadArgs.hpp b/shared/concurrent/ThreadArgs.hpp
deleted file mode 100755
index f44742c..0000000
--- a/shared/concurrent/ThreadArgs.hpp
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef H_THREAD_THREADARGS
-#define H_THREAD_THREADARGS
-
-#include <vector>
-
-typedef std::vector<void *> ThreadArgs;
-
-#endif
diff --git a/shared/concurrent/ThreadGroup.cpp b/shared/concurrent/ThreadGroup.cpp
deleted file mode 100755
index f50b487..0000000
--- a/shared/concurrent/ThreadGroup.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadGroup.hpp"
-#include <algorithm>
-
-namespace concurrent {
-
-  ThreadGroup::ThreadGroup (void) 
-    : parent(NULL), daemon(false) {
-  }
-
-  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
-    : daemon(false) {
-    this->parent = parent;
-    this->name = name;
-  }
-
-  ThreadGroup::ThreadGroup (const std::string & name) 
-    : parent(NULL), daemon(false) {
-    this->name = name;
-  }
-
-  ThreadGroup::~ThreadGroup (void) {
-    if (this->daemon == true) {
-      this->stop();
-    }
-  }
-
-  bool 
-  ThreadGroup::parentOf (ThreadGroup * parent) {
-    if ((this->parent == NULL) || (parent == NULL))
-      return false;
-    // Needs to be better than this. 
-    return (this->parent == parent) ? true : false;
-  } 
-    
-  bool
-  ThreadGroup::addThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-    if (it == this->threads.end()) {
-      thread->group = this;
-      this->threads.push_back (thread);
-      return true;
-    }
-    return false;
-  }
-
-  bool 
-  ThreadGroup::removeThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-
-    if (it == this->threads.end())
-      return false;
-    this->threads.erase(it);
-    return true;
-  }
-
-  void
-  ThreadGroup::interrupt (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->interrupt();
-    }
-  }
-
-  bool
-  ThreadGroup::start (void) {
-    bool rvalue = false;
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      rvalue = (*it++)->start();
-    }
-
-    return rvalue;
-  }
-
-  void 
-  ThreadGroup::stop (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->stop();
-    }
-  }
-} // end of namesapce
diff --git a/shared/concurrent/ThreadGroup.hpp b/shared/concurrent/ThreadGroup.hpp
deleted file mode 100755
index f907fd4..0000000
--- a/shared/concurrent/ThreadGroup.hpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREADGROUP
-#define HPP_CONCURRENT_THREADGROUP
-
-#include <string>
-#include "List.hpp"
-#include "Thread.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup {
-  private:
-    typedef concurrent::List<Thread *> ThreadList;
-    
-    ThreadGroup * parent;
-    std::string name;
-    ThreadList threads;
-    bool daemon; 
-  public:
-    ThreadGroup (void);
-    ThreadGroup (ThreadGroup * parent, const std::string & name);
-    ThreadGroup (const std::string & name);
-    virtual ~ThreadGroup (void);
-
-    bool parentOf (ThreadGroup * parent);
-    bool addThread (Thread * thread);
-    bool removeThread (Thread * thread);
-    void interrupt (void);
-    bool start (void);
-    void stop (void);
-    
-    inline bool isDaemon (void) const { return this->daemon; }
-    inline void setDaemon (bool daemon) { this->daemon = daemon; }
-    inline const std::string & getName (void) const { return this->name; }
-    inline ThreadGroup * getParent (void) const { return this->parent; }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/concurrent/ThreadPool.cpp b/shared/concurrent/ThreadPool.cpp
deleted file mode 100755
index cd6890e..0000000
--- a/shared/concurrent/ThreadPool.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadPool.hpp"
-
-namespace concurrent {
-  int ThreadPool::defaultTaskMax = 5;
-
-  ThreadPool::Task::Task (ThreadPool * pool) {
-    this->pool = pool;
-  }
-
-  void *
-  ThreadPool::Task::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
-		 if (this->pool->isRunning() == false)
-			 break;
-      
-		 if (this->pool->getQueueSize() > 0) {
-			 IRunnable * runner = this->pool->removeFromQueue();
-			 runner->run (NULL);
-			 delete runner;
-		 }
-		 Thread::sleep (1);
-    }
-
-    return NULL;
-  }
-
-  ThreadPool::ThreadPool (void) {
-    this->running = false;
-
-    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::ThreadPool (int N) {
-    this->running = false;
-
-    for (int ii = 0; ii < N; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::~ThreadPool (void) {
-    if (this->running == true)
-      this->stop(true);
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      Thread * t = (*it); it++;
-      delete t;
-    }
-
-    while (this->runQueue.size() > 0) {
-      IRunnable * r = this->runQueue.pop();
-      delete r;
-    }
-  }
-
-  void 
-  ThreadPool::start (void) {
-    this->running = true;
-    
-	 ThreadList::iterator it = this->threads.begin();
-	 while (it != this->threads.end())
-    {
-		 (*it)->start();
-		 it++;
-    }
-  }
-
-  void 
-  ThreadPool::stop (bool join) {
-    this->running = false;
-
-    /* Waiting to join all of the threads will mean that the thread that the
-       pool is calling the stop() method from will block until all of the 
-       threads inside of the pool have stopped.
-
-       There is a PROBLEM here. If you call this, for some reason, from inside
-       of one of the Task threads then you are going to hit a deadlock. Never
-       pass the join parameter if this is being called from inside the Tasks.*/
-    if (join == true) {
-		 ThreadList::iterator it = this->threads.begin();
-		 while (it != this->threads.end()) {
-			 (*it)->stop();
-			 it++;
-		 }
-    }
-  }
-
-  void 
-  ThreadPool::execute (IRunnable * runner) {
-    this->runQueue.push (runner);
-  }
-
-} // end of namespace
-
diff --git a/shared/concurrent/ThreadPool.hpp b/shared/concurrent/ThreadPool.hpp
deleted file mode 100755
index 1999f0e..0000000
--- a/shared/concurrent/ThreadPool.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_THREADPOOL
-#define HPP_THREAD_THREADPOOL
-
-#include "Mutex.hpp"
-#include "Thread.hpp"
-#include "Queue.hpp"
-#include <queue>
-#include <list>
-
-namespace concurrent {
-
-  /* @description: This is a ThreadPool object that will keep N concurrent
-     threads running. Runnable objects can be attached to this object and they
-     will be executed immediately as a thread becomes available to run them. 
-     @author: John `jb Bellone (jvb4@njit.edu)
-     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
-  class ThreadPool {
-  private:
-    typedef std::list<Thread *> ThreadList;
-    
-    class Task : public IRunnable {
-    private:
-      ThreadPool * pool;
-    public:
-      Task (ThreadPool * pool);
-      
-      void * run (void * null);
-    };
-    
-    concurrent::Queue<IRunnable *> runQueue;
-    ThreadList threads;
-    bool running;
-  public:
-    static int defaultTaskMax;
-
-    ThreadPool (void);
-    ThreadPool (int N);
-    ~ThreadPool (void);
-
-    /* Thread un-Safe Methods */
-    void start (void);
-    void stop (bool join = false);
-
-    /* Thread-Safe Methods */
-    void execute (IRunnable *);
-    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
-    inline bool isRunning (void) const { return this->running; }
-    inline int getMaxThreads (void) const { return this->threads.size(); }
-    inline size_t getQueueSize (void) { return this->runQueue.size(); }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/network/Socket.hpp b/shared/network/Socket.hpp
deleted file mode 100755
index 5a87a3d..0000000
--- a/shared/network/Socket.hpp
+++ /dev/null
@@ -1,39 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_NETWORK_SOCKET
-#define HPP_NETWORK_SOCKET
-
-#include <cstring>
-
-namespace network {
-
-  class ISocket {
-  protected:
-    int sockfd;
-  public:
-    virtual ~ISocket (void) { }
-
-    virtual void close (void) = 0;
-    virtual int send (const char * bytes, size_t length) = 0;
-    virtual int receive (char * btyes, size_t size) = 0;
-  };
-
-} // end of namesapce
-
-#endif
diff --git a/shared/network/Tcp.cpp b/shared/network/Tcp.cpp
deleted file mode 100755
index b9a0572..0000000
--- a/shared/network/Tcp.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Tcp.hpp"
-#include <iostream>
-
-namespace network {
-
-	TcpSocket::TcpSocket (void) {
-		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
-	}
-
-	TcpSocket::~TcpSocket (void) {
-		this->close();
-	}
-
-	void
-	TcpSocket::close (void) {
-		if (this->sockfd > 0)
-			::close (this->sockfd);
-	}
-	
-	int
-	TcpSocket::send (const char * bytes, size_t length) {
-		return ::write (this->sockfd, bytes, length);
-	}
-
-	int
-	TcpSocket::receive (char * bytes, size_t size) {
-		return ::read (this->sockfd, bytes, size);
-	}
-
-	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
-		this->port = port;
-
-		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-		this->sockaddr.sin_port = htons (this->port);
-	}
-
-	TcpServerSocket::~TcpServerSocket (void) {
-		this->close();
-	}
-
-	bool
-	TcpServerSocket::start (int backlog = 5) {
-		int opt = 1;
-
-		// This is to prevent conflicts with major services' ports.
-		if (this->port < 1024)
-			return false;
-
-		if (::setsockopt (this->sockfd, 
-								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
-			return false;
-
-		if (::bind (this->sockfd,
-						(struct sockaddr *)&(this->sockaddr),
-						sizeof (this->sockaddr)) < 0)
-			return false;
-
-		if (::listen (this->sockfd, backlog) < 0)
-			return false;
-
-		return true;
-	}
-
-	void
-	TcpServerSocket::close (void) {
-		TcpSocket::close();
-	}
-
-	TcpServerSocket::Acceptor *
-	TcpServerSocket::newAcceptor (void) {
-		return new TcpServerSocket::Acceptor (this, this->sockfd);
-	}
-
-	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
-		this->socket = server;
-		this->sockfd = sockfd;
-	}
-
-	int
-	TcpServerSocket::Acceptor::acceptIncoming (void) {
-		int newfd = -1;
-		static struct sockaddr_in clientaddr;
-		unsigned int x = sizeof (clientaddr);
-
-		if ((newfd = ::accept (this->sockfd, 
-									  (struct sockaddr *)&clientaddr,
-									  &x)) < 0)
-			return -1;
-		return newfd;
-	}
-
-	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
-		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-	}
-
-	TcpClientSocket::TcpClientSocket (int newfd) {
-		this->sockfd = newfd;
-	}
-				
-	TcpClientSocket::~TcpClientSocket (void) {
-	}
-
-	bool
-	TcpClientSocket::connect (const char * host, int port) {
-		if (!host || (*host == '\0'))
-			return false;
-
-		if ((this->hp = ::gethostbyname (host)) == NULL)
-			return false;
- 
-		// Copy over the hostname address.
-		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
-		this->sockaddr.sin_family = AF_INET;
-		this->sockaddr.sin_addr.s_addr 
-			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
-		this->sockaddr.sin_port = htons (port);
-
-		if (::connect (this->sockfd,
-							(struct sockaddr *)&(this->sockaddr),
-							sizeof (struct sockaddr)) < 0)
-			return false;
-    
-		return true;
-	}
-
-	void
-	TcpClientSocket::close (void) {
-		TcpSocket::close();
-	}
-
-} // end of namespace
diff --git a/shared/network/Tcp.hpp b/shared/network/Tcp.hpp
deleted file mode 100755
index 02ddc8a..0000000
--- a/shared/network/Tcp.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_NETWORK_TCP
-#define HPP_NETWORK_TCP
-
-#include "Socket.hpp"
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <netdb.h>
-
-namespace network {
-
-  class TcpSocket : public ISocket {
-  protected:
-    struct sockaddr_in sockaddr;
-  public:
-    TcpSocket (void);
-    virtual ~TcpSocket (void);
-
-    void close (void);
-    int send (const char * bytes, size_t length);
-    int receive (char * bytes, size_t size);
-  };
-
-  class TcpServerSocket : public TcpSocket {
-  private:
-    int port;
-  public:
-    class Acceptor {
-    private:
-      TcpServerSocket * socket;
-      int sockfd;
-    public:
-      Acceptor (TcpServerSocket * server, int sockfd);
-
-      int acceptIncoming (void);
-    };
-
-    TcpServerSocket (int port);
-    virtual ~TcpServerSocket (void);
-    
-    bool start (int backlog);
-    void close (void);
-    Acceptor * newAcceptor (void);
-  };
-  
-  class TcpClientSocket : public TcpSocket {
-  private:
-    struct hostent * hp;
-  public:
-    TcpClientSocket (void);
-    TcpClientSocket (int newfd);
-    virtual ~TcpClientSocket (void);
-
-    bool connect (const char * host, int port);
-    void close (void);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/proactor/Dispatcher.cpp b/shared/proactor/Dispatcher.cpp
deleted file mode 100755
index c7a9ded..0000000
--- a/shared/proactor/Dispatcher.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Dispatcher.hpp"
-#include "Worker.hpp"
-#include <algorithm>
-
-namespace proactor {
-
-  Dispatcher::~Dispatcher (void) {
-      
-  }
-   
-	bool
-	Dispatcher::addWorker (Worker * w) {
-		WorkerListType::iterator it = std::find (this->workers.begin(),
-															  this->workers.end(),
-															  w);
-		if (it == this->workers.end()) {
-			this->workers.push_back (w);
-			return w->start();
-      }
-		return false;
-	}
-  
-	bool
-	Dispatcher::removeWorker (Worker * w) {
-		WorkerListType::iterator it = std::find (this->workers.begin(),
-															  this->workers.end(),
-															  w);
-
-		if (it == this->workers.end())
-			return false;
-  
-		this->workers.erase (it);
-		return true;
-	}
-
-} // end of namesapce
diff --git a/shared/proactor/Dispatcher.hpp b/shared/proactor/Dispatcher.hpp
deleted file mode 100755
index 124f03d..0000000
--- a/shared/proactor/Dispatcher.hpp
+++ /dev/null
@@ -1,43 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_DISPATCHER
-#define HPP_PROACTOR_DISPATCHER
-
-#include "../concurrent/Thread.hpp"
-#include "../concurrent/List.hpp"
-
-namespace proactor {
-
-  class Worker;
-
-  class Dispatcher : public concurrent::Thread {
-  protected:
-    typedef concurrent::List<Worker *> WorkerListType;
-
-    WorkerListType workers;
-  public:
-    virtual ~Dispatcher (void);
-
-    bool addWorker (Worker * w);
-    bool removeWorker (Worker * w);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/proactor/Event.cpp b/shared/proactor/Event.cpp
deleted file mode 100755
index a1c5c2b..0000000
--- a/shared/proactor/Event.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Event.hpp"
-
-namespace proactor {
-
-  int Event::numEvents = 0;
-
-  Event::Event (int e, const std::string & buf) {
-    this->id = e;
-    this->buf = buf;
-  }
-
-  int
-  Event::uniqueEventId (void) {
-    return Event::numEvents++;
-  }
-
-  EventDispatcher::~EventDispatcher (void) {
-  }
- 
-} // end of namespace
diff --git a/shared/proactor/Event.hpp b/shared/proactor/Event.hpp
deleted file mode 100755
index f5c9f7e..0000000
--- a/shared/proactor/Event.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_EVENT
-#define HPP_PROACTOR_EVENT
-
-#include "Dispatcher.hpp"
-#include <string>
-
-namespace proactor {
-
-  class Event {
-  private:
-    static int numEvents;
-  public:
-    int id;
-    std::string buf;
-
-    Event (int id, const std::string & buf);
-
-    static int uniqueEventId (void);
-  };
-
-  class EventDispatcher : public Dispatcher {
-  private:
-    int eventId;
-  public:
-    virtual ~EventDispatcher (void);
-
-    inline void setEventId (int e) { 
-      this->eventId = e;
-    }
-
-    inline int getEventId (void) { 
-      return this->eventId;
-    }
-  };
-
-}
-
-#endif
diff --git a/shared/proactor/InputDispatcher.cpp b/shared/proactor/InputDispatcher.cpp
deleted file mode 100755
index a46febc..0000000
--- a/shared/proactor/InputDispatcher.cpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "InputDispatcher.hpp"
-#include "Proactor.hpp"
-
-namespace proactor {
-
-  InputDispatcher::~InputDispatcher (void) {
-	  this->inputQueue.lock();
-	  while (this->inputQueue.size() > 0)
-		  this->inputQueue.pop();
-	  this->inputQueue.unlock();
-  }
-
-  void *
-  InputDispatcher::stop (void) {
-    WorkerListType::iterator it = this->workers.begin();
-    while (it != this->workers.end()) {
-      (*it)->stop();
-      it = this->workers.erase(it);
-    }
-    return Thread::stop();
-  }
-
-  void *
-  InputDispatcher::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
-      // Dispatch all of the input items on the queue.
-      this->inputQueue.lock();
-
-      while (this->inputQueue.size() > 0) {
-
-	if (this->running == false)
-	  break;
-
-	// For right now all we're doing is pushing up the chain.
-	this->pro->onReadComplete ( this->inputQueue.pop() );
-      }
-
-      this->inputQueue.unlock();
-
-      Thread::sleep(100);
-    }
-  
-    return NULL; 
-  }
-
-} // end of namespace
diff --git a/shared/proactor/InputDispatcher.hpp b/shared/proactor/InputDispatcher.hpp
deleted file mode 100755
index ee49202..0000000
--- a/shared/proactor/InputDispatcher.hpp
+++ /dev/null
@@ -1,53 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_INPUTDISPATCHER
-#define HPP_PROACTOR_INPUTDISPATCHER
-
-#include "../concurrent/Queue.hpp"
-#include "Event.hpp"
-
-namespace proactor {
-
-  class Proactor;
-
-  class InputDispatcher : public EventDispatcher {
-  protected:
-    typedef concurrent::Queue<Event> InputQueueType;
-
-    Proactor * pro;
-    InputQueueType inputQueue;
-  public:
-    virtual ~InputDispatcher (void);
-
-    void * stop (void);
-    
-    inline void onReadComplete (const char * buf) {
-      this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
-    }
-
-    inline void onReadComplete (std::string buf) {
-      this->inputQueue.push ( Event (getEventId(), buf) );
-    }
-
-    void * run (void * null);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/proactor/Proactor.cpp b/shared/proactor/Proactor.cpp
deleted file mode 100755
index 2085c63..0000000
--- a/shared/proactor/Proactor.cpp
+++ /dev/null
@@ -1,159 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Proactor.hpp"
-#include <iostream>
-#include <algorithm>
-
-namespace proactor {
-
-  Proactor::Proactor (void) {
-  }
-
-  Proactor::~Proactor (void) {
-    // Remove all of the lists of event handlers.
-    {
-      EventMapType::iterator it = this->eventsToHandlers.begin();
-      while (it != this->eventsToHandlers.end()) {
-	  WorkerListType * q = (it->second);
-	  delete q;
-	  it++;
-	}
-    }
- 
-    // Handle the dispatchers that have not been manually removed.
-    {
-      DispatcherList::iterator it = this->dispatchers.begin();
-      while (it != this->dispatchers.end())
-	{
-	  Dispatcher * d = (*it);
-	  delete d;
-	  it++;
-	}
-    }
-  
-  }
-
-  bool
-  Proactor::addWorker (int e, Worker * job) {
-    this->eventsToHandlers.lock();
-    {
-      EventMapType::iterator it = this->eventsToHandlers.find (e);
-  
-      if (it == this->eventsToHandlers.end())
-	this->eventsToHandlers[e] = new WorkerListType;  
-      this->eventsToHandlers[e]->push_back (job);
-    }
-    this->eventsToHandlers.unlock();
-
-    return job->start();
-  }
-
-  void
-  Proactor::onReadComplete (Event e) {
-    this->events.push (e);
-  }
-
-  void 
-  Proactor::onReadComplete (int e, const char * buf) {
-    this->events.push ( Event (e, std::string (buf)) );   
-  }
-
-  bool
-  Proactor::removeWorker (int e, Worker * job) {
-    bool result = false;
-
-    this->eventsToHandlers.lock();
-    {
-      WorkerListType::iterator it = 
-	std::find (this->eventsToHandlers[e]->begin(),
-		   this->eventsToHandlers[e]->end(),
-		   job);
-    
-      if (it != this->eventsToHandlers[e]->end())
-	{
-	  this->eventsToHandlers[e]->erase (it);
-	  result = true;
-	}
-    }
-    this->eventsToHandlers.unlock();
-   
-    return result;
-  }
-
-  void
-  Proactor::addDispatcher (Dispatcher * d) {
-    this->dispatchers.push_back (d);
-  }
-
-  bool
-  Proactor::removeDispatcher (Dispatcher * d) {
-    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
-					     this->dispatchers.end(),
-					     d);
-
-    if (it == this->dispatchers.end())
-      return false;
-  
-    this->dispatchers.erase (it);
-    return true;
-  }
-
-  void *
-  Proactor::run (void * null) {
-    this->running = true;
-  
-    WorkerListType::iterator it;
-
-    while (this->running == true) {
-	this->events.lock();
-
-	while (this->events.size() > 0) {
-
-	  if (this->running == false)
-	    break;
-
-	    Event e = this->events.pop();
-
-	    // We are throwing events with no handlers to catch them.
-	    if (this->eventsToHandlers.find (e.id) == 
-		this->eventsToHandlers.end())
-	      continue;
- 
-	    it = this->eventsToHandlers[e.id]->begin();
-	  
-	    while (it != this->eventsToHandlers[e.id]->end()) {
-
-	      if (this->running == false)
-		break;
-
-		Worker * j = (*it);
-	      
-		j->pushInputQueue (e.buf);
-		      
-		it++;
-	      }
-	  }
-	this->events.unlock();
-      
-	Thread::sleep(100);
-      }
-    return NULL;
-  }
-
-} // end of namespace
diff --git a/shared/proactor/Proactor.hpp b/shared/proactor/Proactor.hpp
deleted file mode 100755
index 793647c..0000000
--- a/shared/proactor/Proactor.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_PROACTOR
-#define HPP_PROACTOR_PROACTOR
-
-#include "../concurrent/Thread.hpp"
-#include "../concurrent/Map.hpp"
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/List.hpp"
-#include "Worker.hpp"
-#include "Event.hpp"
-#include "Dispatcher.hpp"
-#include "InputDispatcher.hpp"
-
-namespace proactor {
-
-  class Proactor : public Dispatcher {
-  private:
-    typedef concurrent::List<Dispatcher *> DispatcherList;
-    typedef concurrent::Map<int, WorkerListType *> EventMapType;
-    typedef concurrent::Queue<Event> EventQueueType;
-
-    EventMapType eventsToHandlers;
-    DispatcherList dispatchers;
-    EventQueueType events;
-  public:
-    Proactor (void);
-    virtual ~Proactor (void);
-
-    bool addWorker (int e, Worker * w);
-    bool removeWorker (int e, Worker * w);
-    void addDispatcher (Dispatcher * d);
-    bool removeDispatcher (Dispatcher * d);
-    
-    void * run (void * null);
- 
-    void onReadComplete (Event e);
-    void onReadComplete (int e, const char * buf);
-
-    inline const std::string & peekInputQueue (void) {
-      return (this->events.front()).buf;
-    }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/shared/proactor/Worker.cpp b/shared/proactor/Worker.cpp
deleted file mode 100755
index be5863f..0000000
--- a/shared/proactor/Worker.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Worker.hpp"
-
-namespace proactor {
-
-  Worker::~Worker (void) {
-  }
-
-} // end of namesapce
diff --git a/shared/proactor/Worker.hpp b/shared/proactor/Worker.hpp
deleted file mode 100755
index 481cae1..0000000
--- a/shared/proactor/Worker.hpp
+++ /dev/null
@@ -1,46 +0,0 @@
-/* 
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_WORKER
-#define HPP_PROACTOR_WORKER
-
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/Thread.hpp"
-#include <string>
-
-namespace proactor {
-
-  class InputDispatcher;
-
-  class Worker : public concurrent::Thread {
-  protected:
-    typedef concurrent::Queue<std::string> InputQueueType;
-
-    InputDispatcher * dispatcher;
-    InputQueueType inputQueue;
-  public:
-    virtual ~Worker (void);
-
-    inline void pushInputQueue (std::string buf) {
-      this->inputQueue.push (buf);
-    }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/concurrent/List.hpp b/src/concurrent/List.hpp
new file mode 100755
index 0000000..130cb5d
--- /dev/null
+++ b/src/concurrent/List.hpp
@@ -0,0 +1,33 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_LIST
+#define HPP_CONCURRENT_LIST
+
+#include <list>
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  template <typename T>
+  class List : public RecursiveMutex, public std::list<T> {
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/concurrent/Lockable.hpp b/src/concurrent/Lockable.hpp
new file mode 100755
index 0000000..31fdc75
--- /dev/null
+++ b/src/concurrent/Lockable.hpp
@@ -0,0 +1,31 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_LOCKABLE
+#define HPP_THREAD_LOCKABLE
+
+class ILockable {
+public:
+  virtual ~ILockable (void) { }
+
+  virtual void lock (void) = 0;
+  virtual void unlock (void) = 0;
+  virtual bool trylock (void) = 0;
+};
+
+#endif
diff --git a/src/concurrent/Map.hpp b/src/concurrent/Map.hpp
new file mode 100755
index 0000000..9f4b9ce
--- /dev/null
+++ b/src/concurrent/Map.hpp
@@ -0,0 +1,42 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MAP
+#define HPP_THREAD_MAP
+
+#include <iterator>
+#include <map>
+#include "Mutex.hpp"
+
+namespace concurrent {
+ 
+  /* @description: This object uses the standard std::map and wraps all of
+     the calls that are exposed with a Mutex object. This object uses a
+     single lock and may cause performance issues if several threads are
+     attempting to use it. 
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template<typename K, typename V>
+  class Map : public RecursiveMutex, public std::map<K,V> {
+  private:
+  public:
+    Map (void) : RecursiveMutex() { }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/concurrent/Mutex.cpp b/src/concurrent/Mutex.cpp
new file mode 100755
index 0000000..43ec628
--- /dev/null
+++ b/src/concurrent/Mutex.cpp
@@ -0,0 +1,89 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  IMutex::IMutex (void) {
+    this->mutex = NULL;
+    this->attrib = NULL;
+  }
+
+  IMutex::IMutex (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+  }
+
+  IMutex::~IMutex (void) {
+  }
+
+  IMutex & 
+  IMutex::operator= (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+    return *this;
+  }
+
+  void
+  IMutex::lock (void) {
+    pthread_mutex_lock (this->mutex);
+  }
+
+  void 
+  IMutex::unlock (void) {
+    pthread_mutex_unlock (this->mutex);
+  }
+
+  bool
+  IMutex::trylock (void) {
+    return (pthread_mutex_trylock (this->mutex) == 0) ?
+      true : false;
+  }
+  
+  RecursiveMutex::RecursiveMutex (void) {
+    this->mutex = new pthread_mutex_t;
+    this->attrib = new pthread_mutexattr_t;
+
+    pthread_mutexattr_init (this->attrib);
+    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+    
+    pthread_mutex_init (this->mutex, attrib);
+  }
+
+  RecursiveMutex::~RecursiveMutex (void) {
+    pthread_mutex_destroy (this->mutex);
+    pthread_mutexattr_destroy (this->attrib);
+
+    delete this->mutex;
+    delete this->attrib;
+  }
+
+  Mutex::Mutex (void) {
+    this->mutex = new pthread_mutex_t;
+
+    pthread_mutex_init (this->mutex, NULL);
+  }
+
+  Mutex::~Mutex (void) {
+    pthread_mutex_destroy (this->mutex);
+
+    delete this->mutex;
+  }
+
+} // end of namespace
diff --git a/src/concurrent/Mutex.hpp b/src/concurrent/Mutex.hpp
new file mode 100755
index 0000000..f4be8a9
--- /dev/null
+++ b/src/concurrent/Mutex.hpp
@@ -0,0 +1,56 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MUTEX
+#define HPP_THREAD_MUTEX
+
+#include <pthread.h>
+#include "Lockable.hpp"
+
+namespace concurrent {
+
+  class IMutex : public ILockable {
+  protected:
+    pthread_mutex_t * mutex;
+    pthread_mutexattr_t * attrib;
+  public:
+    IMutex (void);
+    IMutex (const IMutex & m);
+    virtual ~IMutex (void);
+
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+
+    IMutex & operator= (const IMutex & m);
+  };
+
+  class Mutex : public IMutex {
+  public:
+    Mutex (void);
+    virtual ~Mutex (void);
+  };
+
+  class RecursiveMutex : public IMutex {
+  public:
+    RecursiveMutex (void);
+    virtual ~RecursiveMutex (void);
+  };
+}
+
+#endif
diff --git a/src/concurrent/Queue.hpp b/src/concurrent/Queue.hpp
new file mode 100755
index 0000000..092953b
--- /dev/null
+++ b/src/concurrent/Queue.hpp
@@ -0,0 +1,97 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_QUEUE
+#define HPP_THREAD_QUEUE
+
+#include "Mutex.hpp"
+#include <queue>
+#include <algorithm>
+
+namespace concurrent {
+  
+  /* @description: This object wraps the existing std::queue container with
+     the custom Mutex object from the concurrent namespace. The single lock
+     may be placed in the future with a read/write lock in order to gain a
+     speed advantage.
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template <typename T>
+  class Queue : public RecursiveMutex {
+  private:
+    std::queue<T> the_queue;
+  public:
+    Queue (void) { }
+    virtual ~Queue (void) { }
+
+    inline void clear (void) {
+      this->lock();
+      while (this->the_queue.size() > 0)
+	this->the_queue.pop();
+      this->unlock();
+    }
+
+    inline void copy (std::queue<T> & Q) {
+      this->lock();
+      Q = this->the_queue;
+      this->unlock();
+    }
+
+    inline const T & back (void) {
+      this->lock();
+      T & elem = this->the_queue.back();
+      this->unlock();
+      return elem;
+    }
+
+    inline const T & front (void) {
+      this->lock();
+      T & elem = this->the_queue.front();
+      this->unlock();
+      return elem;
+    }
+
+    inline void push (const T & x) {
+      this->lock();
+      this->the_queue.push (x);
+      this->unlock();
+    }
+
+    inline T pop (void) {
+      this->lock();
+      T elem = this->the_queue.front();
+      this->the_queue.pop();
+      this->unlock();
+      return elem;
+    }
+    
+    inline size_t size (void) {
+      this->lock();
+      size_t size = this->the_queue.size();
+      this->unlock();
+      return size;
+    }
+
+    inline bool empty (void) {
+      this->lock();
+      bool result = this->the_queue.empty();
+      this->unlock();
+      return result;
+    }
+  };
+}
+#endif
diff --git a/src/concurrent/Runnable.hpp b/src/concurrent/Runnable.hpp
new file mode 100755
index 0000000..f2241b5
--- /dev/null
+++ b/src/concurrent/Runnable.hpp
@@ -0,0 +1,34 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_RUNNABLE
+#define HPP_CONCURRENT_RUNNABLE
+
+class IRunnable {
+protected:
+  volatile bool running;
+public:
+  IRunnable (void) { this->running = false; }
+  virtual ~IRunnable (void) { }
+
+  virtual void * run (void *) = 0;
+  
+  inline bool isRunning (void) const { return this->running; }
+};
+
+#endif
diff --git a/src/concurrent/ScopedMemoryLock.cpp b/src/concurrent/ScopedMemoryLock.cpp
new file mode 100755
index 0000000..eb9b901
--- /dev/null
+++ b/src/concurrent/ScopedMemoryLock.cpp
@@ -0,0 +1,118 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ScopedMemoryLock.hpp"
+
+namespace concurrent {
+  ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
+
+  ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
+    this->hasLock = false;
+    this->address = address;
+    this->mutex = NULL;
+
+    ScopedMemoryLock::addressMutexMap.lock();
+    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+    ScopedMemoryLock::addressMutexMap.unlock();
+
+    /* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
+       if someone is passing an address that has not been formally added via the static method
+       call then that means it is very unlikely that they are not removing it either. We do
+       not want a memory leak therefore this seems like the best method. */
+    if (it != ScopedMemoryLock::addressMutexMap.end()) 
+      this->mutex = it->second;
+
+    if (engage == true)
+      this->lock();
+  }
+
+  ScopedMemoryLock::~ScopedMemoryLock (void) {
+    if (this->hasLock == true)
+      unlock();
+  }
+
+  void
+  ScopedMemoryLock::lock (void) {
+    this->mutex->lock();
+    this->hasLock = true;
+  }
+
+  void 
+  ScopedMemoryLock::unlock (void) {
+    this->mutex->unlock();
+    this->hasLock = false;
+  }
+
+  bool
+  ScopedMemoryLock::trylock (void) {
+    this->hasLock = this->mutex->trylock();
+    return this->hasLock;
+  }
+
+  bool
+  ScopedMemoryLock::remove (void) {
+    if (this->hasLock == false) {
+      return false;
+    }
+
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+    if (it != addressMutexMap.end()) {
+      delete it->second;
+      addressMutexMap.end();
+      result = true;
+    }
+    
+    addressMutexMap.unlock();
+    return result;
+  }
+
+  bool 
+  ScopedMemoryLock::addMemoryLock (unsigned long address) {
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
+    if (it == addressMutexMap.end()) {
+      addressMutexMap.insert (std::make_pair (address, new Mutex));
+      result = true;
+    }
+
+    addressMutexMap.unlock();
+    return result;
+  }
+
+  bool 
+  ScopedMemoryLock::removeMemoryLock (unsigned long address) {
+    addressMutexMap.lock();
+
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
+    if (it != addressMutexMap.end()) {
+      delete it->second;
+      addressMutexMap.erase(it);
+      result = true;
+    }
+
+    addressMutexMap.unlock();
+    return result;
+  }
+
+} // end of namespace
diff --git a/src/concurrent/ScopedMemoryLock.hpp b/src/concurrent/ScopedMemoryLock.hpp
new file mode 100755
index 0000000..eadab0b
--- /dev/null
+++ b/src/concurrent/ScopedMemoryLock.hpp
@@ -0,0 +1,50 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_SCOPEDMEMORYLOCK
+#define HPP_CONCURRENT_SCOPEDMEMORYLOCK
+
+#include "Map.hpp"
+#include "Mutex.hpp"
+#include <string>
+
+namespace concurrent {
+
+  class ScopedMemoryLock : public ILockable {
+  private:
+    typedef Map<long int,Mutex *> AddressToMutexMap;
+    static AddressToMutexMap addressMutexMap;
+
+    bool hasLock;
+    unsigned long address;
+    Mutex * mutex;
+  public:
+    ScopedMemoryLock (unsigned long address, bool engage = false);
+    virtual ~ScopedMemoryLock (void);
+ 
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+    bool remove (void);
+
+    static bool addMemoryLock (unsigned long address);
+    static bool removeMemoryLock (unsigned long address);
+  };
+} // end of namespace
+
+#endif 
diff --git a/src/concurrent/Semaphore.cpp b/src/concurrent/Semaphore.cpp
new file mode 100755
index 0000000..4e5a58d
--- /dev/null
+++ b/src/concurrent/Semaphore.cpp
@@ -0,0 +1,42 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Semaphore.hpp"
+
+namespace concurrent {
+
+  Semaphore::Semaphore (void) {
+    sem_init (&this->semaphore, 0, 0);
+  }
+
+  Semaphore::~Semaphore (void) {
+    sem_destroy (&this->semaphore);
+  }
+
+  void
+  Semaphore::acquire (void) {
+    sem_wait (&this->semaphore);
+  }
+
+  void
+  Semaphore::release (void) {
+    sem_post (&this->semaphore);
+  }
+
+} // end of namespace
+
diff --git a/src/concurrent/Semaphore.hpp b/src/concurrent/Semaphore.hpp
new file mode 100755
index 0000000..3b9e0f4
--- /dev/null
+++ b/src/concurrent/Semaphore.hpp
@@ -0,0 +1,39 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_SEMAPHORE
+#define HPP_THREAD_SEMAPHORE
+
+#include <semaphore.h>
+
+namespace concurrent {
+
+class Semaphore {
+private:
+  sem_t semaphore;
+public:
+  Semaphore (void);
+  virtual ~Semaphore (void);
+
+  void acquire (void);
+  void release (void);
+};
+
+}
+
+#endif
diff --git a/src/concurrent/Thread.cpp b/src/concurrent/Thread.cpp
new file mode 100755
index 0000000..5b7f143
--- /dev/null
+++ b/src/concurrent/Thread.cpp
@@ -0,0 +1,129 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Thread.hpp"
+#include "ThreadGroup.hpp"
+#include <iostream>
+#include <ctime>
+
+namespace concurrent {
+
+	static void *
+	thread_run (void * runner) {
+		void * rvalue = ((IRunnable *)runner)->run (NULL);
+		return rvalue;
+	}
+
+	Thread::Thread (ThreadGroup * group,
+						 IRunnable * runner, 
+						 const std::string & name) : thread(0) {
+		this->group = group;
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (IRunnable * runner,
+						 const std::string & name) 
+		: group(NULL), thread(0) {
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (const std::string & name) 
+		: group(NULL), runner(NULL), thread(0) {
+		this->name = name;
+	}
+
+	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
+	}
+
+	Thread::~Thread (void) {
+		if (this->running == true) {
+			this->running = false;
+			this->join();
+		}
+	}
+
+	void 
+	Thread::interrupt (void) {
+		this->running = false;
+		pthread_cancel (this->thread);
+		pthread_detach (this->thread);
+	}
+
+	void 
+	Thread::yield (void) {
+		pthread_yield();
+	}
+
+	void * 
+	Thread::stop (void) {
+		this->running = false;
+		return this->join();
+	}
+
+	int 
+	Thread::sleep (unsigned long ms) {
+		struct timespec req = {0};
+		time_t sec = (int)(ms/1000);
+		ms = ms - (sec*1000);
+		req.tv_sec = sec;
+		req.tv_nsec = ms*1000000L;
+		while (nanosleep (&req, &req) == -1)
+			continue;
+		return 1;
+	}
+
+	bool 
+	Thread::start (void) {
+		if (this->running == true)
+			return false;
+
+		if (this->runner != NULL) {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this->runner))
+				return false;
+		}
+		else {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this))
+				return false;
+		}
+
+		this->running = true;
+		return true;
+	}
+
+	void *
+	Thread::join (void) {
+		void * rvalue = NULL;
+		if (this->thread > 0)
+			pthread_join (this->thread, &rvalue);
+		return rvalue;
+	}
+
+	void *
+	Thread::run (void *null) {
+		pthread_exit (null);
+	}
+
+} // end of namespace
diff --git a/src/concurrent/Thread.hpp b/src/concurrent/Thread.hpp
new file mode 100755
index 0000000..79f2cf0
--- /dev/null
+++ b/src/concurrent/Thread.hpp
@@ -0,0 +1,72 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREAD
+#define HPP_CONCURRENT_THREAD
+
+#include <shared.h>
+#include <string>
+#include <pthread.h>
+#include <map>
+#include "Runnable.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup;
+
+  class Thread : public IRunnable {
+  private:
+    friend class ThreadGroup;
+
+    ThreadGroup * group;
+    std::string name;
+    IRunnable * runner;
+    pthread_t thread;
+    bool joinable;
+    int priority;
+  public:
+    Thread (ThreadGroup * group, 
+	    IRunnable * runner, 
+	    const std::string & name);
+    Thread (IRunnable * runner,
+	    const std::string & name);
+    Thread (const std::string & name);
+    Thread (void);
+    virtual ~Thread (void);
+
+    bool start (void);
+    void * stop (void);
+    void * join (void);
+    void interrupt (void);
+    void yield (void);
+  
+    virtual void * run (void *);
+
+    inline const std::string & getName (void) const { return this->name; }
+    inline int getPriority (void) const { return this->priority; }
+    inline void setPriority (int priority) { this->priority = priority; }
+    inline const ThreadGroup * getThreadGroup (void) const { 
+      return this->group; 
+    }
+
+    static int sleep (unsigned long ms);
+  };  
+
+}
+
+#endif
diff --git a/src/concurrent/ThreadArgs.hpp b/src/concurrent/ThreadArgs.hpp
new file mode 100755
index 0000000..f44742c
--- /dev/null
+++ b/src/concurrent/ThreadArgs.hpp
@@ -0,0 +1,8 @@
+#ifndef H_THREAD_THREADARGS
+#define H_THREAD_THREADARGS
+
+#include <vector>
+
+typedef std::vector<void *> ThreadArgs;
+
+#endif
diff --git a/src/concurrent/ThreadGroup.cpp b/src/concurrent/ThreadGroup.cpp
new file mode 100755
index 0000000..f50b487
--- /dev/null
+++ b/src/concurrent/ThreadGroup.cpp
@@ -0,0 +1,105 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadGroup.hpp"
+#include <algorithm>
+
+namespace concurrent {
+
+  ThreadGroup::ThreadGroup (void) 
+    : parent(NULL), daemon(false) {
+  }
+
+  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
+    : daemon(false) {
+    this->parent = parent;
+    this->name = name;
+  }
+
+  ThreadGroup::ThreadGroup (const std::string & name) 
+    : parent(NULL), daemon(false) {
+    this->name = name;
+  }
+
+  ThreadGroup::~ThreadGroup (void) {
+    if (this->daemon == true) {
+      this->stop();
+    }
+  }
+
+  bool 
+  ThreadGroup::parentOf (ThreadGroup * parent) {
+    if ((this->parent == NULL) || (parent == NULL))
+      return false;
+    // Needs to be better than this. 
+    return (this->parent == parent) ? true : false;
+  } 
+    
+  bool
+  ThreadGroup::addThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+    if (it == this->threads.end()) {
+      thread->group = this;
+      this->threads.push_back (thread);
+      return true;
+    }
+    return false;
+  }
+
+  bool 
+  ThreadGroup::removeThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+
+    if (it == this->threads.end())
+      return false;
+    this->threads.erase(it);
+    return true;
+  }
+
+  void
+  ThreadGroup::interrupt (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->interrupt();
+    }
+  }
+
+  bool
+  ThreadGroup::start (void) {
+    bool rvalue = false;
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      rvalue = (*it++)->start();
+    }
+
+    return rvalue;
+  }
+
+  void 
+  ThreadGroup::stop (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->stop();
+    }
+  }
+} // end of namesapce
diff --git a/src/concurrent/ThreadGroup.hpp b/src/concurrent/ThreadGroup.hpp
new file mode 100755
index 0000000..f907fd4
--- /dev/null
+++ b/src/concurrent/ThreadGroup.hpp
@@ -0,0 +1,57 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREADGROUP
+#define HPP_CONCURRENT_THREADGROUP
+
+#include <string>
+#include "List.hpp"
+#include "Thread.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup {
+  private:
+    typedef concurrent::List<Thread *> ThreadList;
+    
+    ThreadGroup * parent;
+    std::string name;
+    ThreadList threads;
+    bool daemon; 
+  public:
+    ThreadGroup (void);
+    ThreadGroup (ThreadGroup * parent, const std::string & name);
+    ThreadGroup (const std::string & name);
+    virtual ~ThreadGroup (void);
+
+    bool parentOf (ThreadGroup * parent);
+    bool addThread (Thread * thread);
+    bool removeThread (Thread * thread);
+    void interrupt (void);
+    bool start (void);
+    void stop (void);
+    
+    inline bool isDaemon (void) const { return this->daemon; }
+    inline void setDaemon (bool daemon) { this->daemon = daemon; }
+    inline const std::string & getName (void) const { return this->name; }
+    inline ThreadGroup * getParent (void) const { return this->parent; }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/concurrent/ThreadPool.cpp b/src/concurrent/ThreadPool.cpp
new file mode 100755
index 0000000..cd6890e
--- /dev/null
+++ b/src/concurrent/ThreadPool.cpp
@@ -0,0 +1,123 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadPool.hpp"
+
+namespace concurrent {
+  int ThreadPool::defaultTaskMax = 5;
+
+  ThreadPool::Task::Task (ThreadPool * pool) {
+    this->pool = pool;
+  }
+
+  void *
+  ThreadPool::Task::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+		 if (this->pool->isRunning() == false)
+			 break;
+      
+		 if (this->pool->getQueueSize() > 0) {
+			 IRunnable * runner = this->pool->removeFromQueue();
+			 runner->run (NULL);
+			 delete runner;
+		 }
+		 Thread::sleep (1);
+    }
+
+    return NULL;
+  }
+
+  ThreadPool::ThreadPool (void) {
+    this->running = false;
+
+    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::ThreadPool (int N) {
+    this->running = false;
+
+    for (int ii = 0; ii < N; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::~ThreadPool (void) {
+    if (this->running == true)
+      this->stop(true);
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      Thread * t = (*it); it++;
+      delete t;
+    }
+
+    while (this->runQueue.size() > 0) {
+      IRunnable * r = this->runQueue.pop();
+      delete r;
+    }
+  }
+
+  void 
+  ThreadPool::start (void) {
+    this->running = true;
+    
+	 ThreadList::iterator it = this->threads.begin();
+	 while (it != this->threads.end())
+    {
+		 (*it)->start();
+		 it++;
+    }
+  }
+
+  void 
+  ThreadPool::stop (bool join) {
+    this->running = false;
+
+    /* Waiting to join all of the threads will mean that the thread that the
+       pool is calling the stop() method from will block until all of the 
+       threads inside of the pool have stopped.
+
+       There is a PROBLEM here. If you call this, for some reason, from inside
+       of one of the Task threads then you are going to hit a deadlock. Never
+       pass the join parameter if this is being called from inside the Tasks.*/
+    if (join == true) {
+		 ThreadList::iterator it = this->threads.begin();
+		 while (it != this->threads.end()) {
+			 (*it)->stop();
+			 it++;
+		 }
+    }
+  }
+
+  void 
+  ThreadPool::execute (IRunnable * runner) {
+    this->runQueue.push (runner);
+  }
+
+} // end of namespace
+
diff --git a/src/concurrent/ThreadPool.hpp b/src/concurrent/ThreadPool.hpp
new file mode 100755
index 0000000..1999f0e
--- /dev/null
+++ b/src/concurrent/ThreadPool.hpp
@@ -0,0 +1,72 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_THREADPOOL
+#define HPP_THREAD_THREADPOOL
+
+#include "Mutex.hpp"
+#include "Thread.hpp"
+#include "Queue.hpp"
+#include <queue>
+#include <list>
+
+namespace concurrent {
+
+  /* @description: This is a ThreadPool object that will keep N concurrent
+     threads running. Runnable objects can be attached to this object and they
+     will be executed immediately as a thread becomes available to run them. 
+     @author: John `jb Bellone (jvb4@njit.edu)
+     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
+  class ThreadPool {
+  private:
+    typedef std::list<Thread *> ThreadList;
+    
+    class Task : public IRunnable {
+    private:
+      ThreadPool * pool;
+    public:
+      Task (ThreadPool * pool);
+      
+      void * run (void * null);
+    };
+    
+    concurrent::Queue<IRunnable *> runQueue;
+    ThreadList threads;
+    bool running;
+  public:
+    static int defaultTaskMax;
+
+    ThreadPool (void);
+    ThreadPool (int N);
+    ~ThreadPool (void);
+
+    /* Thread un-Safe Methods */
+    void start (void);
+    void stop (bool join = false);
+
+    /* Thread-Safe Methods */
+    void execute (IRunnable *);
+    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
+    inline bool isRunning (void) const { return this->running; }
+    inline int getMaxThreads (void) const { return this->threads.size(); }
+    inline size_t getQueueSize (void) { return this->runQueue.size(); }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/network/Socket.hpp b/src/network/Socket.hpp
new file mode 100755
index 0000000..5a87a3d
--- /dev/null
+++ b/src/network/Socket.hpp
@@ -0,0 +1,39 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK_SOCKET
+#define HPP_NETWORK_SOCKET
+
+#include <cstring>
+
+namespace network {
+
+  class ISocket {
+  protected:
+    int sockfd;
+  public:
+    virtual ~ISocket (void) { }
+
+    virtual void close (void) = 0;
+    virtual int send (const char * bytes, size_t length) = 0;
+    virtual int receive (char * btyes, size_t size) = 0;
+  };
+
+} // end of namesapce
+
+#endif
diff --git a/src/network/Tcp.cpp b/src/network/Tcp.cpp
new file mode 100755
index 0000000..b9a0572
--- /dev/null
+++ b/src/network/Tcp.cpp
@@ -0,0 +1,153 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Tcp.hpp"
+#include <iostream>
+
+namespace network {
+
+	TcpSocket::TcpSocket (void) {
+		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	}
+
+	TcpSocket::~TcpSocket (void) {
+		this->close();
+	}
+
+	void
+	TcpSocket::close (void) {
+		if (this->sockfd > 0)
+			::close (this->sockfd);
+	}
+	
+	int
+	TcpSocket::send (const char * bytes, size_t length) {
+		return ::write (this->sockfd, bytes, length);
+	}
+
+	int
+	TcpSocket::receive (char * bytes, size_t size) {
+		return ::read (this->sockfd, bytes, size);
+	}
+
+	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
+		this->port = port;
+
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+		this->sockaddr.sin_port = htons (this->port);
+	}
+
+	TcpServerSocket::~TcpServerSocket (void) {
+		this->close();
+	}
+
+	bool
+	TcpServerSocket::start (int backlog = 5) {
+		int opt = 1;
+
+		// This is to prevent conflicts with major services' ports.
+		if (this->port < 1024)
+			return false;
+
+		if (::setsockopt (this->sockfd, 
+								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
+			return false;
+
+		if (::bind (this->sockfd,
+						(struct sockaddr *)&(this->sockaddr),
+						sizeof (this->sockaddr)) < 0)
+			return false;
+
+		if (::listen (this->sockfd, backlog) < 0)
+			return false;
+
+		return true;
+	}
+
+	void
+	TcpServerSocket::close (void) {
+		TcpSocket::close();
+	}
+
+	TcpServerSocket::Acceptor *
+	TcpServerSocket::newAcceptor (void) {
+		return new TcpServerSocket::Acceptor (this, this->sockfd);
+	}
+
+	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
+		this->socket = server;
+		this->sockfd = sockfd;
+	}
+
+	int
+	TcpServerSocket::Acceptor::acceptIncoming (void) {
+		int newfd = -1;
+		static struct sockaddr_in clientaddr;
+		unsigned int x = sizeof (clientaddr);
+
+		if ((newfd = ::accept (this->sockfd, 
+									  (struct sockaddr *)&clientaddr,
+									  &x)) < 0)
+			return -1;
+		return newfd;
+	}
+
+	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+	}
+
+	TcpClientSocket::TcpClientSocket (int newfd) {
+		this->sockfd = newfd;
+	}
+				
+	TcpClientSocket::~TcpClientSocket (void) {
+	}
+
+	bool
+	TcpClientSocket::connect (const char * host, int port) {
+		if (!host || (*host == '\0'))
+			return false;
+
+		if ((this->hp = ::gethostbyname (host)) == NULL)
+			return false;
+ 
+		// Copy over the hostname address.
+		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr 
+			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
+		this->sockaddr.sin_port = htons (port);
+
+		if (::connect (this->sockfd,
+							(struct sockaddr *)&(this->sockaddr),
+							sizeof (struct sockaddr)) < 0)
+			return false;
+    
+		return true;
+	}
+
+	void
+	TcpClientSocket::close (void) {
+		TcpSocket::close();
+	}
+
+} // end of namespace
diff --git a/src/network/Tcp.hpp b/src/network/Tcp.hpp
new file mode 100755
index 0000000..02ddc8a
--- /dev/null
+++ b/src/network/Tcp.hpp
@@ -0,0 +1,80 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK_TCP
+#define HPP_NETWORK_TCP
+
+#include "Socket.hpp"
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <netdb.h>
+
+namespace network {
+
+  class TcpSocket : public ISocket {
+  protected:
+    struct sockaddr_in sockaddr;
+  public:
+    TcpSocket (void);
+    virtual ~TcpSocket (void);
+
+    void close (void);
+    int send (const char * bytes, size_t length);
+    int receive (char * bytes, size_t size);
+  };
+
+  class TcpServerSocket : public TcpSocket {
+  private:
+    int port;
+  public:
+    class Acceptor {
+    private:
+      TcpServerSocket * socket;
+      int sockfd;
+    public:
+      Acceptor (TcpServerSocket * server, int sockfd);
+
+      int acceptIncoming (void);
+    };
+
+    TcpServerSocket (int port);
+    virtual ~TcpServerSocket (void);
+    
+    bool start (int backlog);
+    void close (void);
+    Acceptor * newAcceptor (void);
+  };
+  
+  class TcpClientSocket : public TcpSocket {
+  private:
+    struct hostent * hp;
+  public:
+    TcpClientSocket (void);
+    TcpClientSocket (int newfd);
+    virtual ~TcpClientSocket (void);
+
+    bool connect (const char * host, int port);
+    void close (void);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/proactor/Dispatcher.cpp b/src/proactor/Dispatcher.cpp
new file mode 100755
index 0000000..c7a9ded
--- /dev/null
+++ b/src/proactor/Dispatcher.cpp
@@ -0,0 +1,54 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Dispatcher.hpp"
+#include "Worker.hpp"
+#include <algorithm>
+
+namespace proactor {
+
+  Dispatcher::~Dispatcher (void) {
+      
+  }
+   
+	bool
+	Dispatcher::addWorker (Worker * w) {
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+		if (it == this->workers.end()) {
+			this->workers.push_back (w);
+			return w->start();
+      }
+		return false;
+	}
+  
+	bool
+	Dispatcher::removeWorker (Worker * w) {
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+
+		if (it == this->workers.end())
+			return false;
+  
+		this->workers.erase (it);
+		return true;
+	}
+
+} // end of namesapce
diff --git a/src/proactor/Dispatcher.hpp b/src/proactor/Dispatcher.hpp
new file mode 100755
index 0000000..124f03d
--- /dev/null
+++ b/src/proactor/Dispatcher.hpp
@@ -0,0 +1,43 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_DISPATCHER
+#define HPP_PROACTOR_DISPATCHER
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/List.hpp"
+
+namespace proactor {
+
+  class Worker;
+
+  class Dispatcher : public concurrent::Thread {
+  protected:
+    typedef concurrent::List<Worker *> WorkerListType;
+
+    WorkerListType workers;
+  public:
+    virtual ~Dispatcher (void);
+
+    bool addWorker (Worker * w);
+    bool removeWorker (Worker * w);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/proactor/Event.cpp b/src/proactor/Event.cpp
new file mode 100755
index 0000000..a1c5c2b
--- /dev/null
+++ b/src/proactor/Event.cpp
@@ -0,0 +1,38 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Event.hpp"
+
+namespace proactor {
+
+  int Event::numEvents = 0;
+
+  Event::Event (int e, const std::string & buf) {
+    this->id = e;
+    this->buf = buf;
+  }
+
+  int
+  Event::uniqueEventId (void) {
+    return Event::numEvents++;
+  }
+
+  EventDispatcher::~EventDispatcher (void) {
+  }
+ 
+} // end of namespace
diff --git a/src/proactor/Event.hpp b/src/proactor/Event.hpp
new file mode 100755
index 0000000..f5c9f7e
--- /dev/null
+++ b/src/proactor/Event.hpp
@@ -0,0 +1,56 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_EVENT
+#define HPP_PROACTOR_EVENT
+
+#include "Dispatcher.hpp"
+#include <string>
+
+namespace proactor {
+
+  class Event {
+  private:
+    static int numEvents;
+  public:
+    int id;
+    std::string buf;
+
+    Event (int id, const std::string & buf);
+
+    static int uniqueEventId (void);
+  };
+
+  class EventDispatcher : public Dispatcher {
+  private:
+    int eventId;
+  public:
+    virtual ~EventDispatcher (void);
+
+    inline void setEventId (int e) { 
+      this->eventId = e;
+    }
+
+    inline int getEventId (void) { 
+      return this->eventId;
+    }
+  };
+
+}
+
+#endif
diff --git a/src/proactor/InputDispatcher.cpp b/src/proactor/InputDispatcher.cpp
new file mode 100755
index 0000000..a46febc
--- /dev/null
+++ b/src/proactor/InputDispatcher.cpp
@@ -0,0 +1,66 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "InputDispatcher.hpp"
+#include "Proactor.hpp"
+
+namespace proactor {
+
+  InputDispatcher::~InputDispatcher (void) {
+	  this->inputQueue.lock();
+	  while (this->inputQueue.size() > 0)
+		  this->inputQueue.pop();
+	  this->inputQueue.unlock();
+  }
+
+  void *
+  InputDispatcher::stop (void) {
+    WorkerListType::iterator it = this->workers.begin();
+    while (it != this->workers.end()) {
+      (*it)->stop();
+      it = this->workers.erase(it);
+    }
+    return Thread::stop();
+  }
+
+  void *
+  InputDispatcher::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+      // Dispatch all of the input items on the queue.
+      this->inputQueue.lock();
+
+      while (this->inputQueue.size() > 0) {
+
+	if (this->running == false)
+	  break;
+
+	// For right now all we're doing is pushing up the chain.
+	this->pro->onReadComplete ( this->inputQueue.pop() );
+      }
+
+      this->inputQueue.unlock();
+
+      Thread::sleep(100);
+    }
+  
+    return NULL; 
+  }
+
+} // end of namespace
diff --git a/src/proactor/InputDispatcher.hpp b/src/proactor/InputDispatcher.hpp
new file mode 100755
index 0000000..ee49202
--- /dev/null
+++ b/src/proactor/InputDispatcher.hpp
@@ -0,0 +1,53 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_INPUTDISPATCHER
+#define HPP_PROACTOR_INPUTDISPATCHER
+
+#include "../concurrent/Queue.hpp"
+#include "Event.hpp"
+
+namespace proactor {
+
+  class Proactor;
+
+  class InputDispatcher : public EventDispatcher {
+  protected:
+    typedef concurrent::Queue<Event> InputQueueType;
+
+    Proactor * pro;
+    InputQueueType inputQueue;
+  public:
+    virtual ~InputDispatcher (void);
+
+    void * stop (void);
+    
+    inline void onReadComplete (const char * buf) {
+      this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
+    }
+
+    inline void onReadComplete (std::string buf) {
+      this->inputQueue.push ( Event (getEventId(), buf) );
+    }
+
+    void * run (void * null);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/proactor/Proactor.cpp b/src/proactor/Proactor.cpp
new file mode 100755
index 0000000..2085c63
--- /dev/null
+++ b/src/proactor/Proactor.cpp
@@ -0,0 +1,159 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Proactor.hpp"
+#include <iostream>
+#include <algorithm>
+
+namespace proactor {
+
+  Proactor::Proactor (void) {
+  }
+
+  Proactor::~Proactor (void) {
+    // Remove all of the lists of event handlers.
+    {
+      EventMapType::iterator it = this->eventsToHandlers.begin();
+      while (it != this->eventsToHandlers.end()) {
+	  WorkerListType * q = (it->second);
+	  delete q;
+	  it++;
+	}
+    }
+ 
+    // Handle the dispatchers that have not been manually removed.
+    {
+      DispatcherList::iterator it = this->dispatchers.begin();
+      while (it != this->dispatchers.end())
+	{
+	  Dispatcher * d = (*it);
+	  delete d;
+	  it++;
+	}
+    }
+  
+  }
+
+  bool
+  Proactor::addWorker (int e, Worker * job) {
+    this->eventsToHandlers.lock();
+    {
+      EventMapType::iterator it = this->eventsToHandlers.find (e);
+  
+      if (it == this->eventsToHandlers.end())
+	this->eventsToHandlers[e] = new WorkerListType;  
+      this->eventsToHandlers[e]->push_back (job);
+    }
+    this->eventsToHandlers.unlock();
+
+    return job->start();
+  }
+
+  void
+  Proactor::onReadComplete (Event e) {
+    this->events.push (e);
+  }
+
+  void 
+  Proactor::onReadComplete (int e, const char * buf) {
+    this->events.push ( Event (e, std::string (buf)) );   
+  }
+
+  bool
+  Proactor::removeWorker (int e, Worker * job) {
+    bool result = false;
+
+    this->eventsToHandlers.lock();
+    {
+      WorkerListType::iterator it = 
+	std::find (this->eventsToHandlers[e]->begin(),
+		   this->eventsToHandlers[e]->end(),
+		   job);
+    
+      if (it != this->eventsToHandlers[e]->end())
+	{
+	  this->eventsToHandlers[e]->erase (it);
+	  result = true;
+	}
+    }
+    this->eventsToHandlers.unlock();
+   
+    return result;
+  }
+
+  void
+  Proactor::addDispatcher (Dispatcher * d) {
+    this->dispatchers.push_back (d);
+  }
+
+  bool
+  Proactor::removeDispatcher (Dispatcher * d) {
+    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
+					     this->dispatchers.end(),
+					     d);
+
+    if (it == this->dispatchers.end())
+      return false;
+  
+    this->dispatchers.erase (it);
+    return true;
+  }
+
+  void *
+  Proactor::run (void * null) {
+    this->running = true;
+  
+    WorkerListType::iterator it;
+
+    while (this->running == true) {
+	this->events.lock();
+
+	while (this->events.size() > 0) {
+
+	  if (this->running == false)
+	    break;
+
+	    Event e = this->events.pop();
+
+	    // We are throwing events with no handlers to catch them.
+	    if (this->eventsToHandlers.find (e.id) == 
+		this->eventsToHandlers.end())
+	      continue;
+ 
+	    it = this->eventsToHandlers[e.id]->begin();
+	  
+	    while (it != this->eventsToHandlers[e.id]->end()) {
+
+	      if (this->running == false)
+		break;
+
+		Worker * j = (*it);
+	      
+		j->pushInputQueue (e.buf);
+		      
+		it++;
+	      }
+	  }
+	this->events.unlock();
+      
+	Thread::sleep(100);
+      }
+    return NULL;
+  }
+
+} // end of namespace
diff --git a/src/proactor/Proactor.hpp b/src/proactor/Proactor.hpp
new file mode 100755
index 0000000..793647c
--- /dev/null
+++ b/src/proactor/Proactor.hpp
@@ -0,0 +1,63 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_PROACTOR
+#define HPP_PROACTOR_PROACTOR
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/Map.hpp"
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/List.hpp"
+#include "Worker.hpp"
+#include "Event.hpp"
+#include "Dispatcher.hpp"
+#include "InputDispatcher.hpp"
+
+namespace proactor {
+
+  class Proactor : public Dispatcher {
+  private:
+    typedef concurrent::List<Dispatcher *> DispatcherList;
+    typedef concurrent::Map<int, WorkerListType *> EventMapType;
+    typedef concurrent::Queue<Event> EventQueueType;
+
+    EventMapType eventsToHandlers;
+    DispatcherList dispatchers;
+    EventQueueType events;
+  public:
+    Proactor (void);
+    virtual ~Proactor (void);
+
+    bool addWorker (int e, Worker * w);
+    bool removeWorker (int e, Worker * w);
+    void addDispatcher (Dispatcher * d);
+    bool removeDispatcher (Dispatcher * d);
+    
+    void * run (void * null);
+ 
+    void onReadComplete (Event e);
+    void onReadComplete (int e, const char * buf);
+
+    inline const std::string & peekInputQueue (void) {
+      return (this->events.front()).buf;
+    }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/proactor/Worker.cpp b/src/proactor/Worker.cpp
new file mode 100755
index 0000000..be5863f
--- /dev/null
+++ b/src/proactor/Worker.cpp
@@ -0,0 +1,26 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Worker.hpp"
+
+namespace proactor {
+
+  Worker::~Worker (void) {
+  }
+
+} // end of namesapce
diff --git a/src/proactor/Worker.hpp b/src/proactor/Worker.hpp
new file mode 100755
index 0000000..481cae1
--- /dev/null
+++ b/src/proactor/Worker.hpp
@@ -0,0 +1,46 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_WORKER
+#define HPP_PROACTOR_WORKER
+
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/Thread.hpp"
+#include <string>
+
+namespace proactor {
+
+  class InputDispatcher;
+
+  class Worker : public concurrent::Thread {
+  protected:
+    typedef concurrent::Queue<std::string> InputQueueType;
+
+    InputDispatcher * dispatcher;
+    InputQueueType inputQueue;
+  public:
+    virtual ~Worker (void);
+
+    inline void pushInputQueue (std::string buf) {
+      this->inputQueue.push (buf);
+    }
+  };
+
+} // end of namespace
+
+#endif

commit b9e799c63ccc47647c86a6395332473278627f5c
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 15:29:58 2009 -0400

    Moved configuration example and python scripts to etc folder.

diff --git a/bin/config.cfg b/bin/config.cfg
deleted file mode 100755
index 848374b..0000000
--- a/bin/config.cfg
+++ /dev/null
@@ -1,13 +0,0 @@
-%block param {
-	row :: key = value;
-}
-%block param
-{
-	glb :: batch = 1; iterations = 4; opt=1;msglatency=1;
-	GLB1 :: somevec = a,b,c;
-}
-
-%block config {
-	row :: vector = 1,2,3; key=value;
-	row :: key=value; key=value2;
-}
\ No newline at end of file
diff --git a/bin/createLargeCSV.py b/bin/createLargeCSV.py
deleted file mode 100755
index e703f87..0000000
--- a/bin/createLargeCSV.py
+++ /dev/null
@@ -1,44 +0,0 @@
-#!/usr/bin/env python
-import sys
-import os
-import time
-import optparse
-import random
-
-def main():
-    p = optparse.OptionParser()
-    p.add_option("--output", "-o", default="largefile.csv")
-    p.add_option("--rows", "-r", default=10000000)
-    p.add_option("--columns", "-c", default=20)
-    options, arguments = p.parse_args()
-
-    fp = open(options.output, "w")
-    ii = 0 
-    jj = 0
-    maxRows = int(options.rows)
-    maxCols = int(options.columns)
-
-    while ii < maxRows:
-        fp.write(str(ii+1) + ",")
-        jj = 1
-        while jj < maxCols-1:
-            choice = random.choice([1,2,3,4,5])
-
-            if choice == 1:
-                fp.write("ABCDEFG,")
-            elif choice == 2:
-                fp.write("1234567,")
-            elif choice == 3:
-                fp.write("HIJKLMN,")
-            elif choice == 4:
-                fp.write("8901234,")
-            elif choice == 5:
-                fp.write("OPQRSTU,")
-            jj = jj+1
-        fp.write("VWXYZ567890\r\n")
-        fp.flush()
-        ii = ii+1
-    fp.close()
-
-if __name__ == "__main__":
-    main()
diff --git a/bin/socketTest.py b/bin/socketTest.py
deleted file mode 100755
index cc4f19d..0000000
--- a/bin/socketTest.py
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/usr/bin/env python
-import sys
-import optparse
-import socket
-
-def main():
-    p = optparse.OptionParser()
-    p.add_option("--port", "-p", default=8888)
-    p.add_option("--input", "-i", default="test.txt")
-    options, arguments = p.parse_args()
-
-    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    sock.connect(("localhost", options.port))
-    
-    fp = open(options.input, "r")
-
-    ii = 0
-
-    sock.sendall ("^0^1^sheet1^1000000^3\n")
-    
-    while ii < 1000000:
-        sock.sendall ("^%d^0^sheet1^%d^0^^0\n" %(ii, ii))
-        ii = ii + 1
-
-    sock.close()
-        
-if __name__ == '__main__':
-    main()
diff --git a/bin/test.txt b/bin/test.txt
deleted file mode 100755
index d676b5b..0000000
--- a/bin/test.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-^2^0^sheet0^3^2^bgcolor=red,fgcolor=white^First
-^3^0^sheet0^4^6^bgcolor=blue,fgcolor=white^Second
-^4^1^sheet1^100^10
-^5^1^sheet2^100^10
-^6^1^sheet3^100^10
-^7^0^sheet1^3^2^bgcolor=red,fgcolor=white^First
-^8^0^sheet1^4^6^bgcolor=blue,fgcolor=white^Second
-^9^0^sheet2^3^2^bgcolor=red,fgcolor=white^First
-^10^0^sheet2^4^6^bgcolor=blue,fgcolor=white^Second
-^11^2^sheet1
-^12^3^sheet3^0
diff --git a/bin/yahooQuoteServer.py b/bin/yahooQuoteServer.py
deleted file mode 100755
index 69d5a1f..0000000
--- a/bin/yahooQuoteServer.py
+++ /dev/null
@@ -1,61 +0,0 @@
-#!/usr/bin/env python
-import sys
-import os
-import time
-import optparse
-import logging
-import socket
-import thread
-import urllib
-
-def acceptor(serversock, descriptors):
-    while 1:
-        # Waiting for connection...
-        clientsock,addr = serversock.accept()
-        descriptors.append((clientsock,addr))
-        time.sleep(1/100)
-        
-def main():
-    HOST = ''
-    PORT = 50000
-    MAXPENDING = 5
-    URI = "http://finance.yahoo.com/d/quotes.csv?s=JAVA+C+AAPL+MSFT&f=snl1c6ahg"
-    
-    serversock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
-    serversock.bind((HOST,PORT));
-    serversock.listen(MAXPENDING);
-    
-    descriptors = []
-
-    thread.start_new_thread(acceptor, (serversock, descriptors))
-    
-    running = 1
-
-    while running:
-        csv = urllib.urlopen(URI)
-        blob = csv.read()
-        
-        # Iterate through the clients and print, print, print!
-        for client in descriptors:
-            client[0].send(blob)
-
-        time.sleep(2)
-
-# Execute the main method of the script.
-if __name__ == "__main__":
-    main()
-
-# Copyright (C) 2009, John Bellone, Jr. <jvb4@njit.edu>
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-#
-# You should have received a copy olf the GNU General Public License
-# along with this program. If not, see <http://www.gnu.org/licenses/>.
diff --git a/etc/config.cfg b/etc/config.cfg
new file mode 100755
index 0000000..848374b
--- /dev/null
+++ b/etc/config.cfg
@@ -0,0 +1,13 @@
+%block param {
+	row :: key = value;
+}
+%block param
+{
+	glb :: batch = 1; iterations = 4; opt=1;msglatency=1;
+	GLB1 :: somevec = a,b,c;
+}
+
+%block config {
+	row :: vector = 1,2,3; key=value;
+	row :: key=value; key=value2;
+}
\ No newline at end of file
diff --git a/etc/createLargeCSV.py b/etc/createLargeCSV.py
new file mode 100755
index 0000000..e703f87
--- /dev/null
+++ b/etc/createLargeCSV.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python
+import sys
+import os
+import time
+import optparse
+import random
+
+def main():
+    p = optparse.OptionParser()
+    p.add_option("--output", "-o", default="largefile.csv")
+    p.add_option("--rows", "-r", default=10000000)
+    p.add_option("--columns", "-c", default=20)
+    options, arguments = p.parse_args()
+
+    fp = open(options.output, "w")
+    ii = 0 
+    jj = 0
+    maxRows = int(options.rows)
+    maxCols = int(options.columns)
+
+    while ii < maxRows:
+        fp.write(str(ii+1) + ",")
+        jj = 1
+        while jj < maxCols-1:
+            choice = random.choice([1,2,3,4,5])
+
+            if choice == 1:
+                fp.write("ABCDEFG,")
+            elif choice == 2:
+                fp.write("1234567,")
+            elif choice == 3:
+                fp.write("HIJKLMN,")
+            elif choice == 4:
+                fp.write("8901234,")
+            elif choice == 5:
+                fp.write("OPQRSTU,")
+            jj = jj+1
+        fp.write("VWXYZ567890\r\n")
+        fp.flush()
+        ii = ii+1
+    fp.close()
+
+if __name__ == "__main__":
+    main()
diff --git a/etc/socketTest.py b/etc/socketTest.py
new file mode 100755
index 0000000..cc4f19d
--- /dev/null
+++ b/etc/socketTest.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python
+import sys
+import optparse
+import socket
+
+def main():
+    p = optparse.OptionParser()
+    p.add_option("--port", "-p", default=8888)
+    p.add_option("--input", "-i", default="test.txt")
+    options, arguments = p.parse_args()
+
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    sock.connect(("localhost", options.port))
+    
+    fp = open(options.input, "r")
+
+    ii = 0
+
+    sock.sendall ("^0^1^sheet1^1000000^3\n")
+    
+    while ii < 1000000:
+        sock.sendall ("^%d^0^sheet1^%d^0^^0\n" %(ii, ii))
+        ii = ii + 1
+
+    sock.close()
+        
+if __name__ == '__main__':
+    main()
diff --git a/etc/yahooQuoteServer.py b/etc/yahooQuoteServer.py
new file mode 100755
index 0000000..69d5a1f
--- /dev/null
+++ b/etc/yahooQuoteServer.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python
+import sys
+import os
+import time
+import optparse
+import logging
+import socket
+import thread
+import urllib
+
+def acceptor(serversock, descriptors):
+    while 1:
+        # Waiting for connection...
+        clientsock,addr = serversock.accept()
+        descriptors.append((clientsock,addr))
+        time.sleep(1/100)
+        
+def main():
+    HOST = ''
+    PORT = 50000
+    MAXPENDING = 5
+    URI = "http://finance.yahoo.com/d/quotes.csv?s=JAVA+C+AAPL+MSFT&f=snl1c6ahg"
+    
+    serversock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
+    serversock.bind((HOST,PORT));
+    serversock.listen(MAXPENDING);
+    
+    descriptors = []
+
+    thread.start_new_thread(acceptor, (serversock, descriptors))
+    
+    running = 1
+
+    while running:
+        csv = urllib.urlopen(URI)
+        blob = csv.read()
+        
+        # Iterate through the clients and print, print, print!
+        for client in descriptors:
+            client[0].send(blob)
+
+        time.sleep(2)
+
+# Execute the main method of the script.
+if __name__ == "__main__":
+    main()
+
+# Copyright (C) 2009, John Bellone, Jr. <jvb4@njit.edu>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy olf the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.

commit cd82cd8c440270513440ac943c66c0d7d3c750e0
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jul 9 15:29:17 2009 -0400

    Deleted libcsv references, and config directory.

diff --git a/config/INIFile.c b/config/INIFile.c
deleted file mode 100755
index 7cdbbbe..0000000
--- a/config/INIFile.c
+++ /dev/null
@@ -1,428 +0,0 @@
-/* 
-   INIFile.c - INI File Object/Parser
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "parse.h"
-#include <config/INIFile.h>
-#include <string.h>
-
-/* INIFile.c (static) */
-static INIFile *inifile_object_init (const gchar *);
-static INISection *inisection_object_init (INIFile *, const gchar *);
-static INIPair *inipair_object_init (INISection *,
-				     const gchar *,
-				     const gchar *,
-				     gint);
-static void inifile_object_free (INIFile *);
-static void inisection_object_free (INISection *);
-static void inipair_object_free (INIPair *);
-static gboolean inifile_method_open (INIFile *);
-static gboolean inifile_method_save (INIFile *, const gchar *);
-static gboolean inifile_method_load (INIFile *, FILE *);
-static void inifile_method_destroy (INIFile *);
-static INISection *inifile_method_get_section (INIFile *, const gchar *);
-static INIPair *inifile_method_get_pair (INIFile *, 
-					 const gchar *, 
-					 const gchar *);
-static const gchar *inifile_method_get_value (INIFile *,
-					      const gchar *,
-					      const gchar *);
-static const gchar *inisection_method_get_value (INISection *,
-						 const gchar *);
-static INIPair *inisection_method_get_pair (INISection *, const gchar *);
-static void inisection_method_destroy (INISection *);
-static void inisection_method_add_pair (INISection *,
-					gint, 
-					const gchar *,
-					const gchar *);
-static void inipair_method_destroy (INIPair *);
-
-INIFile *inifile_new (const gchar * filename)
-{
-  return inifile_object_init (filename);
-}
-
-INISection *inisection_new (INIFile * ini, const gchar * section)
-{
-  return inisection_object_init (ini, section);
-}
-
-INIPair *inipair_new (INISection * section, 
-		      const gchar * key, 
-		      const gchar * value,
-		      gint line)
-{
-  return inipair_object_init (section, key, value, line);
-}
-
-static INIFile *
-inifile_object_init (const gchar * filename)
-{
-  if (!IS_NULLSTR (filename))
-    return NULL;
-
-  INIFile * ini = NEW (INIFile);
-
-  /* Members */
-  ini->filename = g_strdup (filename);
-
-  /* Methods */
-  ini->open = inifile_method_open;
-  ini->save = inifile_method_save;
-  ini->load = inifile_method_load;
-  ini->destroy = inifile_method_destroy;
-  ini->getSection = inifile_method_get_section;
-  ini->getPair = inifile_method_get_pair;
-  ini->getValue = inifile_method_get_value;
-
-  return ini;
-}
-
-static void
-inifile_object_free (INIFile *ini)
-{
-  ASSERT (ini != NULL);
-
-  FREE (ini);
-}
-
-static void
-inifile_method_destroy (INIFile *ini)
-{
-  ASSERT (ini != NULL);
-
-  inifile_object_free (ini);
-}
-
-static gboolean
-inifile_method_save (INIFile * ini, const gchar * filename)
-{
-  ASSERT (ini != NULL);
-
-  if (IS_NULLSTR (filename))
-    return FALSE;
-
-  return TRUE; 
-}
-
-static gboolean
-inifile_method_open (INIFile * ini)
-{
-  ASSERT (ini != NULL);
-
-  if (IS_NULLSTR (ini->filename))
-    return FALSE;
-
-  FILE * fp = NULL;
-  if ((fp = fopen (ini->filename, "r")) == NULL)
-    {
-      fprintf (stderr, "Failed opening INIFile '%s'\n", ini->filename);
-      fflush (stderr);
-      return FALSE;
-    }
-
-  if (ini->load (ini, fp) == FALSE)
-    {
-      fprintf (stderr, "Failed loading INIFile '%s'\n", ini->filename);
-      fflush (stderr);
-      FCLOSE (fp);
-      return FALSE;
-    }
-  FCLOSE (fp);
-  return TRUE;
-}
-
-static gboolean
-inifile_method_load (INIFile * ini, FILE * fp)
-{
-  ASSERT (ini != NULL);
-
-  if (IS_NULL (fp))
-    return FALSE;
-
-  gint line = 0;
-  INISection *section = NULL;
-  gchar buf[4096], key[1024], value[1024];
-  gchar * p = NULL;
-
-  do
-    {
-      p = buf;
-
-      if (IS_NULLSTR (p) || feof (fp))
-	break;
-      /* As per the INI file format a semicolon is considered a line block
-	 comment. This continues until there is a newline character. */
-      else if (*p == ';')
-	{
-	  p = munch (p);
-	  continue;
-	}
-      /* [section] */
-      else if (*p == '[') 
-	{
-	  if ((p = parse (p+1, &buf[0], 1024, ']')) == NULL)
-	    {
-	      fprintf (stderr, "Error parsing block '%s'\n", p);
-	      fflush (stderr);
-	      return FALSE;
-	    }
-
-	  section = inisection_new (ini, key);
-	}
-      /* We do not care about these characters at all. Move on to the next. */
-      else if ((*p == ']') || (*p == '\t') || (*p == '\r'))
-	{
-	  p++;					
-	  continue;
-	}
-      else if (*p == '\n')
-	{
-	  line++;
-	  p++;
-	  continue;
-	}
-
-      /* We do not suppor any type of "global" key->value pairs. There must
-	 a section associated with a pair. */
-      if (IS_NULL (section))
-	{
-	  fprintf (stderr, "Error parsing file on line %d; please check"
-		   " file integrity\n", line);
-	  fflush (stderr);
-	  return FALSE;
-	}
-
-      /* Key = Value\n */
-      if ((p = parse (p, &key[0], 1024, '=')) == NULL)
-	{
-	  fprintf (stderr, "Error parsing section %s: key->value at line %d\n",
-		   section->title, line);
-	  fflush (stderr);
-	  return FALSE;
-	}
-
-      if ((p = parse (p+1, &value[0], 1024, '\n')) == NULL)
-	{
-	  fprintf (stderr, "Error parsing section %s: %s->value at line %d\n",
-		   section->title, key, line);
-	  fflush (stderr);
-	  return FALSE;
-	}
-      
-      section->addPair (section, line, key, value);
-
-      line++;
-    } while (fgets (buf, 4096, fp) != NULL);
-  return TRUE;
-}
-
-static INISection *
-inifile_method_get_section (INIFile * ini, const gchar * section)
-{
-  ASSERT (ini != NULL);
-
-  if (!IS_NULLSTR (section))
-    {
-      ITERATE_BEGIN (INISection, ini->section_head);
-      {
-	if (strcmp (section, it->title) == 0)
-	  return it;
-      }
-      ITERATE_END();
-    }
-  return NULL;
-}
-
-static INIPair *
-inifile_method_get_pair (INIFile * ini, 
-			 const gchar * section,
-			 const gchar * key)
-{
-  ASSERT (ini != NULL);
-
-  if (!IS_NULLSTR (section) && !IS_NULLSTR (key))
-    {
-      INISection * s = ini->getSection (ini, section);
-      if (s == NULL)
-	return NULL;
-
-      return s->getPair (s, key);
-
-    }
-  return NULL;
-}
-
-static const gchar *
-inifile_method_get_value (INIFile * ini,
-			  const gchar * section,
-			  const gchar * key)
-{
-  ASSERT (ini != NULL);
-
-  if (!IS_NULLSTR (section) && !IS_NULLSTR (key))
-    {
-      INISection * s = ini->getSection (ini, section);
-      if (s == NULL)
-	return NULL;
-
-      return s->getValue (s, key);
-    }
-  return NULL;
-}
-
-static void
-inisection_object_free (INISection * section)
-{
-  ASSERT (section != NULL);
-
-  DESTROY (INIPair, section->pair_head);
-
-  FREE (section->title);
-  FREE (section);
-}
-
-static INISection *
-inisection_object_init (INIFile * ini, const gchar * section)
-{
-  ASSERT (ini != NULL);
-
-  if (IS_NULLSTR (section))
-    return NULL;
-
-  INISection * s = ini->getSection (ini, section);
-  if (IS_NULL (s))
-    {
-      s = NEW (INISection);
-      
-      /* Members */
-      s->ini = ini;
-      s->next = NULL;
-      s->pair_head = NULL;
-      s->pair_count = 0;
-      s->title = g_strdup ("");
-      
-      /* Methods */
-      s->addPair = inisection_method_add_pair;
-      s->getValue = inisection_method_get_value;
-      s->getPair = inisection_method_get_pair;
-      s->destroy = inisection_method_destroy;
-    }
-  return s;
-}
-
-static const gchar *
-inisection_method_get_value (INISection * section, const gchar * key)
-{
-  ASSERT (section != NULL);
-
-  if (!IS_NULLSTR (key))
-    {
-      ITERATE_BEGIN (INIPair, section->pair_head);
-      {
-	if (strcmp (key, it->key) == 0)
-	  return it->value;
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static INIPair *
-inisection_method_get_pair (INISection * section, const gchar * key)
-{
-  ASSERT (section != NULL);
-
-  if (!IS_NULLSTR (key))
-    {
-      ITERATE_BEGIN (INIPair, section->pair_head);
-      {
-	if (strcmp (key, it->key) == 0)
-	  return it;
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static void
-inisection_method_add_pair (INISection * section,
-			    gint line,
-			    const gchar * key,
-			    const gchar * value)
-{
-  ASSERT (section != NULL);
-  
-  if (!IS_NULLSTR (key) && !IS_NULLSTR (value))
-    {
-      INIPair * pair = inipair_new (section, key, value, line);
-      SINGLE_LINK (INIPair, section->pair_head, section->pair_tail, pair);
-    }
-}
-
-static void
-inisection_method_destroy (INISection * section)
-{
-  ASSERT (section != NULL);
-
-  DESTROY (INIPair, section->pair_head);
-  
-  inisection_object_free (section);
-}
-
-static INIPair *
-inipair_object_init (INISection * section, 
-		     const gchar * key,
-		     const gchar * value,
-		     gint line)
-{
-  ASSERT (section != NULL);
-
-  if (IS_NULLSTR (key) || IS_NULLSTR (value))
-    return NULL;
-
-  INIPair * pair = section->getPair (section, key);
-  if (IS_NULL (pair))
-    {
-      pair = NEW (INIPair);
-      
-      /* Members */
-      pair->section = section;
-      pair->next = NULL;
-      pair->key = g_strdup (key);
-      pair->value = g_strdup (value);
-      pair->line = line;
-
-      /* Methods */
-      pair->destroy = inipair_method_destroy;
-    }
-  return pair;
-}
-
-static void
-inipair_method_destroy (INIPair * pair)
-{
-  inipair_object_free (pair);
-}
-
-static void
-inipair_object_free (INIPair * pair)
-{
-  ASSERT (pair != NULL);
-}
diff --git a/config/Makefile b/config/Makefile
deleted file mode 100755
index 28308e9..0000000
--- a/config/Makefile
+++ /dev/null
@@ -1,33 +0,0 @@
-include ../Makefile.base
-
-SRCS=$(wildcard *.c)
-OBJS=$(patsubst %.c,${OBJDIR}/libconfig/%.o,${SRCS})
-
-LFLAGS = -lgobject-2.0 -ldl
-
-all: 	libconfig
-
-install:
-	${RM} ${INSLIBDIR}/libconfig.a ${INSLIBDIR}/libconfig.so \
-	${INSLIBDIR}/libconfig.so.1
-	${CP} ${PROJDIR}/lib/libconfig.so ${INSLIBDIR}/libconfig.so.1
-	${LN} ${INSLIBDIR}/libconfig.so.1 ${INSLIBDIR}/libconfig.a
-	${LN} ${INSLIBDIR}/libconfig.a ${INSLIBDIR}/libconfig.so
-#	chcon -t textrel_shlib_t ${INSLIBDIR}/libconfig.so.1	
-
-libconfig: ${OBJS}
-	${MD} ${PROJDIR}/lib 
-	${RM} ${PROJDIR}/lib/libconfig.so.1
-	${CC} -shared -Wl,-soname,libconfig.so.1 \
-	-o ${PROJDIR}/lib/libconfig.so ${OBJS} ${LIBS} ${LFLAGS}
-	${LN} ${PROJDIR}/lib/libconfig.so ${PROJDIR}/lib/libconfig.so.1
-
-clean:		
-	${MD} ${OBJDIR}/libconfig	
-	${RM} ${OBJS} ${PROJDIR}/lib/libconfig.so.1
-
-${OBJDIR}/libconfig/%.o: %.c
-	${CC} ${INCS} -c -fPIC ${CCFLAGS} $< -o $@
-
-.c.o:
-	${CC} ${INCS} -c -fPIC ${CCFLAGS} $<
diff --git a/config/config.c b/config/config.c
deleted file mode 100755
index 0fced05..0000000
--- a/config/config.c
+++ /dev/null
@@ -1,761 +0,0 @@
-/*
-  config.c - Configuration File Object/Parser
-
-  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with the library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include <config/config.h>
-#include <stdlib.h>
-#include <string.h>
-#include "parse.h"
-
-/* config.c (static) */
-
-static Config *config_object_init (const gchar *);
-static ConfigPair *configpair_object_init (ConfigRow *, 
-					   const gchar *,
-					   const gchar *);
-static ConfigRow *configrow_object_init (ConfigBlock *, const gchar *);
-static ConfigBlock *configblock_object_init (Config *, const gchar *);
-static ConfigVector *configvector_object_init (ConfigRow *,const gchar *);
-static void configrow_object_free (ConfigRow *);
-static void configblock_object_free (ConfigBlock *);
-static void configpair_object_free (ConfigPair *);
-static void config_object_free (Config *);
-static void configvector_object_free (ConfigVector *);
-static ConfigVector *config_method_get_vector (Config *,
-					       const gchar *,
-					       const gchar *,
-					       const gchar *);
-static ConfigPair *config_method_get_pair (Config *,
-					   const gchar *,
-					   const gchar *,
-					   const gchar *);
-static ConfigBlock *config_method_get_block (Config *, const gchar *);
-static ConfigPair *configblock_method_get_pair (ConfigBlock *, 
-						const gchar *,
-						const gchar *);
-static ConfigRow *config_method_get_row (Config *,
-					 const gchar *, 
-					 const gchar *);
-static ConfigRow *configblock_method_get_row (ConfigBlock *, const gchar *);
-static gchar *configrow_method_parse (ConfigRow *, gchar *);
-static void configrow_method_destroy (ConfigRow *);
-static ConfigPair *configrow_method_get_pair (ConfigRow *, const gchar *);
-static ConfigVector *configrow_method_get_vector (ConfigRow *, const gchar *);
-static void configpair_method_destroy (ConfigPair *);
-static void configblock_method_destroy (ConfigBlock *);
-static void configvector_method_destroy (ConfigVector *);
-static gint configvector_method_get_int (ConfigVector *, gint);
-static gchar *configvector_method_get (ConfigVector *, gint);
-static void configvector_method_add (ConfigVector *, const gchar *);
-static gchar *configblock_method_parse (ConfigBlock *, gchar *, FILE *);
-static void config_method_destroy (Config *);
-static gint config_method_open (Config *);
-static gint config_method_save (Config *, const gchar *);
-static gint config_method_load (Config *, FILE *);
-
-ConfigBlock *
-configblock_new (Config * c, const gchar * tag)
-{
-  /* No NULL tags. */
-  if (IS_NULLSTR (tag)) return NULL;
-  return configblock_object_init (c, tag);
-}
-
-static gchar *
-configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
-{
-  ASSERT (block != NULL);
-  ASSERT (p != NULL);
-
-  if (!fp || feof (fp)) return FALSE;
-
-  gchar buf[1024], word[1024];
-  gchar * q = NULL;
-  g_stpcpy (word, p);
-
-  /* This block of code makes sure that we indeed have an opening brace
-    to continue with parsing of the configuration file. */
-  do
-    {
-      p = word;
-      
-      if (EXPECT (p, q, '{'))
-	{
-	  g_stpcpy (buf, q + 1);
-	  break;
-	} 
-
-      if (*q == '\0')
-	continue;
-      return NULL;
-    } while (fgets (word, 1024, fp) != NULL);
-
-  /* Start actually parsing rows now. */
-  do 
-    {
-      p = buf;
-      do
-	{
-	  if (*p == '}')
-	    return p;
-	  else if (*p == '\n')
-	    {
-	      p++;
-	      continue;
-	    }
-	  else 
-	    {
-	      if ((q = parse (p, &word[0], 1024, ':')) != NULL)
-		{
-		  if (*(q+1) == ':')
-		    {
-		      ConfigRow * row 
-			= block->get_row (block, trim (&word[0]));
-		      
-		      if (row)
-			{
-			  fprintf (stderr, "**CONFIG**: row '%s' already"
-				   " defined in block '%s'; replacing\n",
-				   row->tag, block->tag);
-			  fflush (stderr);
-
-			  row->destroy (row);
-			}
-
-		      row = configrow_new (block, trim (&word[0]));
-		    
-		      if ((p = row->parse (row, q+2)) == NULL)
-			{
-			  fprintf (stderr, "Error parsing line: %s", buf);
-			  fflush (stderr);
-			  return NULL;
-			}
-		      break;
-		    }
-		}
-	    }
-	  fprintf (stderr, "Error in formatting on line: %s\n", buf);
-	  fflush (stderr);
-	  return NULL;
-	} while (*p != '\0');
-     } while (fgets (buf, 1024, fp) != NULL);
-  return NULL;
-}
-
-static void
-configblock_method_destroy (ConfigBlock * block)
-{
-  ASSERT (block != NULL);
-
-  DESTROY (ConfigRow, block->row_head);
-  SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
-		 block->cfg->block_tail, block);
-  
-  configblock_object_free (block);
-}
-
-static ConfigRow *
-configblock_method_get_row (ConfigBlock * block, const gchar * row)
-{
-  ASSERT (block != NULL);
-
-  if (!IS_NULLSTR (row))
-    {
-      ITERATE_BEGIN (ConfigRow, block->row_head);
-      {
-	if (!strcmp (it->tag, row))
-	  return it;
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static ConfigPair *
-configblock_method_get_pair (ConfigBlock * block, 
-			     const gchar * row,
-			     const gchar * key)
-{
-  ASSERT (block != NULL);
-
-  if (!IS_NULLSTR (row))
-    {
-      ITERATE_BEGIN (ConfigRow, block->row_head);
-      {
-	if (!strcmp (it->tag, row))
-	  return it->get_pair (it, key);
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static void
-configblock_object_free (ConfigBlock * block)
-{
-  ASSERT (block != NULL);
-
-  FREE (block->tag);
-  
-  FREE (block);
-  block = NULL;
-}
-
-static ConfigBlock *
-configblock_object_init (Config * c, const gchar * tag)
-{
-  ASSERT (c != NULL);
-
-  ConfigBlock * b = NEW (ConfigBlock);
-
-  /* Members */
-  b->cfg = c;
-  b->tag = g_strdup (tag);
-  b->next = NULL; 
-  b->row_head = b->row_tail = NULL;
-  
-  /* Methods */
-  b->parse = configblock_method_parse;
-  b->destroy = configblock_method_destroy;
-  b->get_row = configblock_method_get_row;
-  b->get_pair = configblock_method_get_pair;
-
-  SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
-  return b;
-}
-
-Config *
-config_new (const gchar * filename)
-{
-  return config_object_init (filename);
-}
-
-static void
-config_method_destroy (Config * c)
-{
-  ASSERT (c != NULL);
-
-  DESTROY (ConfigBlock, c->block_head);
-  
-  config_object_free (c);
-}
-
-static ConfigRow *
-config_method_get_row (Config * cfg, const gchar * block, const gchar * row)
-{
-  ASSERT (cfg != NULL);
- 
-  ConfigBlock * b = cfg->get_block (cfg, block);
-  if (b == NULL)
-    return NULL;
-  return b->get_row (b, row);
-}
-
-static ConfigBlock *
-config_method_get_block (Config * cfg, const gchar * block)
-{
-  ASSERT (cfg != NULL);
-
-  if (!IS_NULLSTR (block))
-    {
-      ITERATE_BEGIN (ConfigBlock, cfg->block_head);
-      {
-	if (!strcmp (it->tag, block))
-	  return it;
-      }
-      ITERATE_END ();
-    }
-  return NULL;
-}
-
-static ConfigPair *
-config_method_get_pair (Config * cfg, 
-			const gchar * block, 
-			const gchar * row,
-			const gchar * pair)
-{
-  ASSERT (cfg != NULL);
-
-  ConfigRow * r = cfg->get_row (cfg, block, row);
-  if (r == NULL)
-    return NULL;
-  return r->get_pair (r, pair);
-}
-
-static ConfigVector *
-config_method_get_vector (Config * cfg,
-			  const gchar * block,
-			  const gchar * row,
-			  const gchar * vector)
-{
-  ASSERT (cfg != NULL);
-  
-  ConfigRow * r = cfg->get_row (cfg, block, row);
-  if (r == NULL)
-    return NULL;
-  return r->get_vector (r, vector);
-}
-
-static void
-config_object_free (Config * c)
-{
-  ASSERT (c != NULL);
-
-  FREE (c->filename);
-
-  FREE (c);
-  c = NULL;
-}
-
-static Config *
-config_object_init (const gchar * filename)
-{
-  Config * c = NEW (Config);
-
-  /* Members */
-  c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
-  c->block_head = c->block_tail = NULL;
-
-  /* Methods */
-  c->open = config_method_open;
-  c->save = config_method_save;
-  c->load = config_method_load;
-  c->close = config_method_destroy;
-  c->get_vector = config_method_get_vector;
-  c->get_row = config_method_get_row;
-  c->get_block = config_method_get_block;
-  c->get_pair = config_method_get_pair;
-
-  return c;
-}
-
-static gint
-config_method_load (Config * c, FILE * fp)
-{
-  ASSERT (c != NULL);
-  
-  if (!fp || feof(fp))
-    {
-      /* STUB: log me? */
-      return FALSE;
-    }
-
-  gchar * buf = g_malloc (sizeof (char) * 1024);
-  gchar word[1024];
-  gchar * p = NULL, * q = NULL, * r = NULL;
-
-  while ((p = fgets (buf, 1024, fp)) != NULL) {
-      r = buf + (strlen (buf) - 1);
- 
-      while (p && (p < r) && (*p != '\n'))
-	{
-	  if (*p == '%')
-	    {
-	      if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
-		/* STUB: exit parsing with a failure. */
-		g_free (buf);	
-		return FALSE;
-	      }
-
-	      if (strcmp (word, "block") == 0)
-		{
-		  if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
-		    g_free(buf);
-		    return FALSE;
-		  }
-		  
-		  /* Replace the block if it already exists. Throw error. */
-		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
-		  if (b)
-		    {
-		      fprintf (stderr, "**CONFIG**: block '%s' already"
-			       "exists. Destroying and replacing.\n", b->tag);
-		      fflush (stderr);
-		      b->destroy (b);
-		    }
-
-		  b = configblock_new (c, trim (&word[0]));
-
-		  if ((p = b->parse (b, q, fp)) == NULL) {
-		    g_free (buf);
-		    return FALSE;
-		  }
-		}
-	      else if (strcmp (word, "include") == 0)
-		{
-		  if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
-		    g_free (buf);
-		    return FALSE;
-		  }
-
-		  /* Include the file; we're going to load up this file
-		     first and then proceed with parsing. */
-		  FILE * ifp = NULL;
-		 
-		  if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
-		    {
-		      fprintf (stderr, "**CONFIG**: include '%s' does not"
-			       " seem to exist or unable to read.\n",
-			       word);
-		      fflush (stderr);
-		      continue;
-		    }
-
-		  c->load (c, ifp);
-		}
-	      else {
-		g_free (buf);
-		return FALSE;
-	      }
-	    }
-	  /* BUGFIX: Need to check for tabs. */
-	  else if ((*p != ' ') && (*p != '\t'))
-	    {
-	      /* STUB: error out */
-	      g_free (buf);
-	      return FALSE;
-	    }
-
-	  p++;
-	}
-    }
-  g_free (buf);
-  return TRUE;
-}
-
-static gint
-config_method_save (Config * c, const gchar * filename)
-{
-  ASSERT (c != NULL);
-
-  if (IS_NULLSTR (filename)) return FALSE;
-
-  FILE * fp = NULL;
-  if ((fp = fopen (filename, "w")) == NULL)
-    {
-      /* STUB: log me? */
-      return FALSE;
-    }
-  
-  FCLOSE (fp);
-  return TRUE;
-}
-
-static gint
-config_method_open (Config * c)
-{
-  ASSERT (c != NULL);
-
-  if (IS_NULLSTR (c->filename))
-    return FALSE;
-
-  FILE * fp = NULL;
-  if ((fp = fopen (c->filename, "r")) == NULL)
-    {
-      /* STUB: log this? */
-      return FALSE;
-    }
-
-  gint result = c->load (c, fp);
-  if (result == FALSE)
-    {
-      /* STUB: log me? */
-    }
-
-  FCLOSE (fp);
-  return result;
-}
-
-ConfigPair *
-configpair_new (ConfigRow * row, const gchar * key, const gchar * value)
-{
-  return configpair_object_init (row, key, value);
-}
-
-static ConfigPair *
-configpair_object_init (ConfigRow * row, 
-			const gchar * key,
-			const gchar * value)
-{
-  ASSERT (row != NULL);
-  ASSERT (!IS_NULLSTR (key));
-  
-  ConfigPair * pair = NEW (ConfigPair);
-
-  /* Members */
-  pair->row = row;
-  pair->key = g_strdup (key);
-  pair->next = NULL;
-  pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
- 
-  /* Methods */
-  pair->destroy = configpair_method_destroy;
-  
-  DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
-  return pair;
-}
-
-static void
-configpair_method_destroy (ConfigPair * pair)
-{
-  ASSERT (pair != NULL);
-
-  DOUBLE_UNLINK (pair);
-
-  configpair_object_free (pair);
-}
-
-static void
-configpair_object_free (ConfigPair * pair)
-{
-  ASSERT (pair != NULL);
-
-  FREE (pair->key);
-  FREE (pair->value);
-  FREE (pair);
-}
-
-ConfigRow *
-configrow_new (ConfigBlock * block, const gchar * tag)
-{
-  return configrow_object_init (block, tag);
-}
-
-static ConfigRow *
-configrow_object_init (ConfigBlock * block, const gchar * tag)
-{
-  if (IS_NULLSTR (tag)) return NULL;
-
-  ConfigRow * row = NEW (ConfigRow);
-  
-  /* Members */
-  row->block = block;
-  row->tag = g_strdup (tag);
-  row->next = NULL;
-  row->vector_head = row->vector_tail = NULL;
-  row->pair_head = row->pair_tail = NULL;
-
-  /* Methods */
-  row->parse = configrow_method_parse;
-  row->destroy = configrow_method_destroy;
-  row->get_pair = configrow_method_get_pair;
-  row->get_vector = configrow_method_get_vector;
-
-  SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
-  return row;
-}
-
-static void
-configrow_object_free (ConfigRow *row)
-{
-  ASSERT (row != NULL);
-  
-  FREE (row->tag);
-
-  DESTROY (ConfigPair, row->pair_head);
-  DESTROY (ConfigVector, row->vector_head);
-
-  FREE (row);
-}
-
-static ConfigPair *
-configrow_method_get_pair (ConfigRow * row, const gchar * key)
-{
-  ASSERT (row != NULL);
-
-  if (!IS_NULLSTR (key))
-    {
-      ITERATE_BEGIN (ConfigPair, row->pair_head);
-      {
-	if (!strcmp (it->key, key))
-	  return it;
-      }
-      ITERATE_END();
-    }
-  return NULL;
-}
-
-static ConfigVector *
-configrow_method_get_vector (ConfigRow * row, const gchar * key)
-{
-  ASSERT (row != NULL);
-
-  if (!IS_NULLSTR (key))
-    {
-      ConfigPair * pair = row->get_pair (row, key);
-      if (IS_NULL (pair))
-	return NULL;
-
-      /* If we have already parsed it there is no reason to do it 
-	 a second time. Check existing linked list and return the
-	 pointer if we have already allocated it. */
-      ITERATE_BEGIN (ConfigVector, row->vector_head);
-      {
-	if (!strcmp (it->tag, key))
-	  return it;
-      }
-      ITERATE_END();
-
-      ConfigVector * vec = configvector_new (row, pair->key);
-      gchar buf[1024];
-      gchar * p = parse (pair->value, &buf[0], 1024, ','); 
-      gchar * q = pair->value + strlen (pair->value);
-    
-      do
-	{
-	  vec->add (vec, trim (&buf[0]));
-	} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
-
-      return vec;
-    }
-  return NULL;
-}
-
-static gchar *
-configrow_method_parse (ConfigRow * row, gchar * p)
-{
-  ASSERT (row != NULL);
-  ASSERT (p != NULL);
-
-  gchar key[1024], value[1024];
-  gchar * q = NULL, * s = NULL;
-
-  do
-    {
-      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
-	{
-	  break;
-	}      
-
-      if ((s = parse (q+1, &value[0], 1024, ';')) != NULL)
-	{
-	  ConfigPair * pair = row->get_pair (row, trim (&key[0]));
-	  if (pair)
-	    {
-	      fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
-		       " row '%s' block '%s'; replacing\n",
-		       pair->key, pair->value, row->tag, row->block->tag);
-	      fflush (stderr);
-	      pair->destroy (pair);
-	    }
-
-	  pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
-	}
-      p = s + 1;
-    } while (*p != '\n' && *p != '}' && *p != '\0');
-  return p;
-}
-
-static void 
-configrow_method_destroy (ConfigRow * row)
-{
-   ASSERT (row != NULL);
-
-   SINGLE_UNLINK (ConfigRow, row->block->row_head, row->block->row_tail, row);
-
-  configrow_object_free (row);
-}
-
-ConfigVector *
-configvector_new (ConfigRow * row, const gchar * tag)
-{
-  ASSERT (row != NULL);
-
-  /* No NULL Tags. */
-  if (IS_NULLSTR (tag)) return NULL;
-  return configvector_object_init (row, tag);
-}
-
-static ConfigVector *
-configvector_object_init (ConfigRow * row, const gchar * tag)
-{
-  ASSERT (row != NULL);
-
-  ConfigVector * vec = NEW (ConfigVector);
-
-  /* Members */
-  vec->row = row;
-  vec->tag = g_strdup (tag);
-  vec->next = vec->prev = NULL;
-  vec->array = g_ptr_array_sized_new (7);
-
-  /* Methods */
-  vec->destroy = configvector_method_destroy;
-  vec->get_int = configvector_method_get_int;
-  vec->get = configvector_method_get;
-  vec->add = configvector_method_add;
-
-  DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
-  return vec;
-}
-
-static void 
-configvector_object_free (ConfigVector * vec)
-{
-  ASSERT (vec != NULL);
-
-  FREE (vec->tag);
-
-  if (vec->array != NULL)
-    g_ptr_array_free (vec->array, TRUE);
-
-  FREE (vec);
-}
-
-static void
-configvector_method_destroy (ConfigVector * vec)
-{
-  ASSERT (vec != NULL);
-
-  DOUBLE_UNLINK (vec);
-
-  configvector_object_free (vec);
-}
-
-static gchar *
-configvector_method_get (ConfigVector * vec, gint index)
-{
-  ASSERT (vec != NULL);
-
-  if (index >= vec->array->len) return NULL;
-
-  gchar * rvalue = g_ptr_array_index (vec->array, index);
-  return rvalue;
-}
-
-static gint
-configvector_method_get_int (ConfigVector * vec, gint index)
-{
-  ASSERT (vec != NULL);
-
-  if (index >= vec->array->len) return -1;
-
-  gchar * rvalue = g_ptr_array_index (vec->array, index);
-  return atoi (rvalue);
-}
-
-static void
-configvector_method_add (ConfigVector * vec, const gchar * value)
-{
-  ASSERT (vec != NULL);
-  ASSERT (value != NULL);
-
-  gchar * ptr = g_strdup (value);
-  g_ptr_array_add (vec->array, ptr);
-}
diff --git a/config/parse.c b/config/parse.c
deleted file mode 100755
index d575700..0000000
--- a/config/parse.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/* 
-   parse.c - Generic Parsing Code
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "parse.h"
-#include <string.h>
-#include <stdlib.h>
-
-gchar *
-munch (gchar *p)
-{
-  ASSERT (p != NULL);
-  
-  /* Munch whitespace and ignore newlines, tabs. */
-  while (p && (*p == ' ' || *p == '\n' || *p == '\t')) { p++; } 
-  return p;
-}
-
-gchar *
-parse (gchar *p, gchar *word, gint n, const gchar delim)
-{
-  const gchar *q = p;
-  gint length = 0, ii = 0;
-
-  do 
-    {
-      if (*p == delim)
-	break;
-      p++;
-    } while (p && (*p != '\0') && (*p != '\n'));
-
-  length = (gint)(p - q);
-
-  if (n < length)    return NULL;
-
-  for (ii = 0; ii < length; ii++)
-    word[ii] = q[ii];
-  word[ii] = '\0';
-
-  return p;
-}
-
-gchar *
-trim (gchar *p)
-{
-  ASSERT (p != NULL);
-
-  gchar *q = NULL;
-
-  /* Eliminate tabs and spaces from beginning. */
-  while (p && (*p == ' ' || *p == '\t')) p++;
-
-  q = p;
-
-  /* Eliminate newlines, returns and whitespaces from end. */
-  while (*q != '\0') { q++; }
-  q--;
-  while (*q == ' ' || *q == '\n' || *q == '\r') { q--; }
-  *(q+1) = '\0';
-
-  return p;
-}
diff --git a/config/parse.h b/config/parse.h
deleted file mode 100755
index 7c4dd3b..0000000
--- a/config/parse.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* 
-   parse.h - Generic Parse Code Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef H_PARSE
-#define H_PARSE
-
-#include <glib.h>
-#include <shared.h>
-
-#define EXPECT(p,q,d) (*(q = munch (p)) == d)
-
-/* parse.c */
-extern gchar *munch (gchar *p);
-extern gchar *parse (gchar *p, gchar *word, gint n, const gchar delim);
-extern gchar *trim (gchar *p);
-
-#endif
diff --git a/csv/Changelog b/csv/Changelog
deleted file mode 100755
index 92c9806..0000000
--- a/csv/Changelog
+++ /dev/null
@@ -1,66 +0,0 @@
-Fri Oct 13 08:40:13 EDT 2006
-libcsv version 0.9.0 released - initial public release
-
-Tue Oct 24 08:22:56 EDT 2006
-libcsv version 0.9.1 released
-  * Fixed LICENSE file to include LGPL text instead of GPL text, thanks to Alejandro Mery <amery@opensde.org> for pointing this out
-  * Included a Makefile for platforms supporting make, thanks to Alejandro Mery for creating the initial Makefile
-  * Updated INSTALL file to include Makefile directions
-
-
-Thu Mar  1 10:27:30 EST 2007
-libcsv version 0.9.5 released
-  * Fixed a bug in which the closing quote of a quoted field, along with any
-  trailing spaces, would be included as part of the field data for the last field when csv_fini was called if the last record did not end with a newline sequence.  This was discovered while testing the Text-CSV-LibCSV Perl wrapper for libcsv created by Jiro Nishiguchi <jiro@cpan.org>
-  * Fixed incorrect prototype for csv_fini in the README file, thanks to Edd Edmondson <edward.edmondson@port.ac.uk> for pointing this out
-  * Minor modifications to clean up pedantic compiler warnings
-  * Added "Interfaces for other languages" to the README file
-
-Sun Mar  4 14:25:07 EST 2007
-libcsv version 1.0.0 released
-  * Changed the interface to allow arbitrary user data to be passed between the parser function and the callback functions via a void pointer eliminating the need for file-scope variables in cases where data needs to be shared and making it considerably easier to create interfaces to the library in other languages.  This change makes this version of the library incompatible with previous versions. Thanks to Jiro Nishiguchi for suggesting this change
-  * man page is now included which obsoletes the old README, pdf version also included
-  * Updated examples to use new interface
-  * Updated documentation to reflect interface changes
-  * Cleaned up INSTALL file
-  * Included license statement in example programs
-
-Sun May 20 11:44:09 EDT 2007
-libcsv version 1.0.1 released
-  * Added CSV_STRICT_FINI option which can be used to cause csv_fini() to return an error when the quoted data being parsed doesn't contain a terminating quote character
-  * Added a test program to test the parsing and writer functions
-
-Fri Jun  1 11:18:28 EDT 2007
-libcsv version 2.0.0 released
-  * This major release contains features that break binary compatibility with earlier libcsv versions.  The interface is backwards compatible with 1.x so existing programs only need to be recompiled to work with the new version, no source code modifications need to be made.
-  * Added csv_set_delim()/csv_get_delim() and csv_set_quote()/csv_get_quote() functions to set and get the field delimeter and quote characters respectively.  Thanks to Martin Ugarte <ugarte.m@gmail.com> for his input
-  * Added csv_set_space_func() and csv_set_term_func() functions that allow a user provided function to specify which characters should be considered spaces and line terminators respectively
-  * Updated documentation to include new functions
-  * Included FAQ document to answer common questions about using libcsv to solve specific problems
-  * Updated test program to include ability to test new features
-  * Updated csvinfo to show the use of some of the new functions
-  * Added csv_write2 and csv_fwrite2 which allow the quote character to be specified
-
-Thu Jun  7 14:44:23 EDT 2007
-libcsv version 2.0.1 released
-  * Fixed bug in Makefile causing library to be installed as libcsv.so.0 instead of libcsv.so.2
-  * Fixed bug in csvvalid example program where location of malformed bytes past byte 1023 were misreported
-
-Fri Jul 25 22:17:35 EDT 2008
-libcsv version 3.0.0 released
-  * This release contains interface changes that are not compatible with
-  previous versions.  Callback functions now use void * parameters
-  instead of char *, this eliminates the need to cast data read into a buffer
-  of unsigned char which is the proper way to read binary data, data is also
-  treated as an array of unsigned char internally.  The cb2 callback function
-  now uses int instead of char, char has changed to unsigned char in several
-  places, csv_opts has been replaced with csv_get_opts and csv_set_opts, and
-  csv_fini returns -1 instead of 0 when no newline if present at the end of
-  the last record.  New features also make this version binary-incompatible
-  with previous versions.
-  * Added CSV_APPEND_NULL option which will null-terminate all collected
-  fields making it easier to treat data as C strings when desired.
-  * Added C++ wrapper in csv.h to make it easier to call functions from C++.
-  * Added functions to change the memory allocation functions used, get the
-  size of the internal buffer, and get and set the size of the amount of
-  memory requested when the internal buffer gets too large.
diff --git a/csv/FAQ b/csv/FAQ
deleted file mode 100755
index 75e6f1f..0000000
--- a/csv/FAQ
+++ /dev/null
@@ -1,149 +0,0 @@
-My data contains unescaped quotes within quoted fields or quote
-characters in unquoted field.
-
-libcsv handles such malformed data by default, no special configuration
-is required.  There are cases where such malformed data is ambigous and
-might not be parsed the way you would like, see the man page for libcsv
-for details.  The csvfix and csvtest programs in the example directory
-may be useful when trying to determine how libcsv will parse your data.
-The csvvalid program can also be used to check for malformed data files.
-
-
-
-My csv file contains comments that should not be parsed as csv data,
-how can I handle this?
-
-Although there is no direct support for comment handling in libcsv you
-can preprocess the data before sending it to libcsv.  For example, say
-that you wish to ignore all lines whose first non-space, non-tab
-character is a hash (#), you could use the following piece of code to
-accomplish that:
-
-#include <stdio.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include "csv.h"
-
-int in_comment, in_record;
-
-void cb1(void *d, char *s, size_t size) { /* Data processing here */ }
-void cb2(void *d, char c) { in_record = 0; /* Record handling here */ }
-
-int main (void) {
-  int c;
-  char ch;
-  struct csv_parser *p;
-  if (csv_init(&p, 0))
-    return EXIT_FAILURE;
-
-  while ((c = getchar()) != EOF) {
-    ch = c;
-    if (in_comment) {
-      if (ch == '\012' || ch == '\015') {
-        in_comment = 0;
-      }
-    } else if (!in_record) {
-      if (ch == ' ' || ch == '\t') {
-        ;
-      } else if (ch == '#') {
-        in_comment = 1;
-      } else {
-        in_record = 1;
-        csv_parse(p, &ch, 1, cb1, cb2);
-      }
-    } else {
-      csv_parse(p, &ch, 1, cb1, cb2);
-    }
-  }
-  csv_fini(p, ...);
-  return 0;
-}
-
-If you determine that calling csv_parse for each character takes too
-much overhead (do some tests before making this decision, it usually
-doesn't) you can optimize this by processing a larger number of
-characters and calling csv_parse on a larger resulting buffer.  
-If you know that your data is text-only, you can simplify this by
-reading one line at a time, checking the first non-space character,
-skipping the line if it is a comment character and calling csv_parse
-if it isn't.
-
-
-
-My data uses a semicolon as a delimiter instead of comma but otherwise
-follows CSV conventions, how can I use libcsv to read my data?
-
-Use the csv_set_delim function introduced in libcsv 2.0.0:
-struct csv_parser *p;
-csv_init(&p);
-csv_set_delim(p, ';');
-...
-
-You can use csv_set_delim to set the delimiter to any character.  Any
-field that contains the delimiter must be quoted when using strict
-mode.  Be careful not to set the delimiter to the same character used
-as the quote character, a space character or a line terminator
-character though as libcsv won't be able to determine if the character 
-is a field delimiter or a quote, etc.
-
-
-
-My data uses a single quotes instead of double quotes for quoted
-fields, how can I accomidate this?
-
-Use the csv_set_quote function introduced in libcsv 2.0.0:
-struct csv_parser *p;
-csv_init(&p);
-csv_set_quote(p, '\'');
-...
-
-As with csv_set_delim you can set the quote character to any character
-but fields containing the quote character must still be quoted and are
-expected to be escaped by an instance of itself.  For example, if you 
-use csv_set_quote to change the quote character to a single quote, 
-instances of a single quote in field data should be escaped by a 
-preceding single quote.
-
-
-
-How can I preserve leading and trailing whitespace from non-quoted 
-fields?
-
-By default libcsv ignores leading and trailing spaces and tabs from 
-non-quoted fields as this is the most common practice and expected by 
-many applications.  The csv_set_space_func function introduced in 
-libcsv 2.0.0 allows you to specify a function that will return 1 if 
-the provided character should be considered a space character and 0 
-otherwise.  This allows you to change the characters that libcsv 
-ignores around unquoted fields.  If you create a function that always 
-returns 0 then no character will be recognized as a space character 
-and all characters will be preserved:
-
-int my_space(char c) { return 0;}
-
-struct csv_parser *p;
-csv_init(&p);
-csv_set_space_func(p, my_space);
-...
-
-
-How can I remove leading and trailing whitespace from quoted fields?
-
-By default libcsv removes surrounding space and tab characters from 
-unquoted fields but not from quoted fields.  The easiest way to remove 
-unwanted characters from a quoted field is inside the field callback 
-function, simply take the data provided to the callback function and 
-perform any manipulations directly on it.
-
-
-
-I want to be able to do things like extract or search on specific 
-fields from a CSV file, sort a CSV file, etc. but the common UNIX 
-utilities (cut, grep, sort, etc.) don't work on CSV data that contains 
-fields with embedded commas or newlines, etc.  Are there any tools 
-like this for managing CSV files?
-
-Take a look at csvutils at http://sourceforge.net/projects/csvutils.
-This package uses libcsv to provide a number of useful CSV utilities 
-including csvcut, csvgrep, and others with option syntax resembling 
-their non-CSV counterparts.
diff --git a/csv/INSTALL b/csv/INSTALL
deleted file mode 100755
index 5bdd63b..0000000
--- a/csv/INSTALL
+++ /dev/null
@@ -1,49 +0,0 @@
-[Installing on systems with make(1)]
-
-On systems with make, the installation process consists of:
-
-    make
-    make test
-    make install
-
-You may need to run ldconfig or a similiar command before dynamically
-linking your program to libcsv.
-
-This will install the csv.h header, libcsv shared and static libraries,
-and the csv(3) manual page.  You can use one of the following targets to
-fine-tune the things that are installed:
-
-    make install_man - install only the man page
-    make install_headers - install only the header
-    make install_static_lib - install only the static version of the library
-    make install_shared_lib - install only the dynamic version of the library
-    make install_static - same as install_static_lib plus install_headers
-    mnake install_shared - same as install_shared_lib plus install_headers
-
-[Installing on systems without make]
-
-libcsv is written in pure ANSI C89 and does not have any prerequisites aside
-from a compiler and the Standard C library, it should compile on any
-conforming implementation.  Below are examples of how to compile this on gcc,
-see your compiler's documentation for other compilers.
-
-libcsv can be installed as a shared library on systems that support it:
-  gcc -shared libcsv.c -o libcsv.so
-
-or simply compiled into object code an linked into your program:
-  gcc libcsv.c -c -o libcsv.o
-  gcc myproject.c libcsv.o -o myproject
-
-you can also compile libcsv as a static library:
-  gcc libcsv.c -c -o libcsv.o
-  ar -rc libcsv.a libcsv.o
-  ar -s libcsv.a
-
-
-The examples can be compiled with gcc like this:
-  gcc csvinfo.c libcsv.o -o csvinfo
-
-or using a shared library like this:
-  gcc csvinfo.c -lcsv -o csvinfo
-
-
diff --git a/csv/LICENSE b/csv/LICENSE
deleted file mode 100755
index 8c177f8..0000000
--- a/csv/LICENSE
+++ /dev/null
@@ -1,458 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
diff --git a/csv/Makefile b/csv/Makefile
deleted file mode 100755
index 7e22a9c..0000000
--- a/csv/Makefile
+++ /dev/null
@@ -1,55 +0,0 @@
-CC=gcc
-AR=ar
-CP=cp
-
-VERSION=3.0.0
-DESTDIR=
-LIBDIR=/usr/lib
-INCDIR=/usr/include
-MANDIR=/usr/share/man/man3
-
-.PHONnY: all install install_headers install_man install_shared install_static clean test
-
-all: libcsv.so libcsv.a
-
-install: install_headers install_shared_lib install_static_lib install_man
-
-install_shared: install_headers install_shared_lib
-install_static: install_headers install_static_lib
-
-install_man: csv.3.gz
-	cp -f $^ $(DESTDIR)$(MANDIR)/
-
-install_headers: csv.h
-	mkdir -p $(DESTDIR)$(INCDIR)/libcsv/
-	cp -f $^ $(DESTDIR)$(INCDIR)/libcsv/
-
-install_shared_lib: libcsv.so
-	cp -f $< $(DESTDIR)$(LIBDIR)/$<.$(VERSION)
-	ln -sf $<.$(VERSION) $(DESTDIR)$(LIBDIR)/$<.3
-	ln -sf $<.3 $(DESTDIR)$(LIBDIR)/$<
-
-install_static_lib: libcsv.a
-	cp -f $< $(DESTDIR)$(LIBDIR)/$<
-
-libcsv.o: libcsv.c csv.h
-	$(CC) -fPIC $< -c -o $@
-
-libcsv.so: libcsv.o
-	$(CC) -shared $< -o $@
-	$(CP) $@ ../lib/$@
-	$(CP) ../lib/$@ ../lib/$@.1
-
-libcsv.a: libcsv.o
-	$(AR) -rc $@ $^
-	$(AR) -s $@
-
-clean:
-	rm libcsv.o libcsv.so libcsv.a
-	rm ../lib/libcsv.*
-
-test: libcsv.o
-	$(CC) test_csv.c $< -o $@
-	./test
-	rm ./test
-
diff --git a/csv/README b/csv/README
deleted file mode 100755
index 186e971..0000000
--- a/csv/README
+++ /dev/null
@@ -1,27 +0,0 @@
-Installation
-------------
-installation usually consists of:
-make && make test && make install
-
-see the INSTALL file for details and instructions on other systems
-
-
-License
--------
-The libcsv library is licensed under the LGPL, see the LICENSE file for details
-The example programs are licensed under the GPL, see the LICENSE file in the
-examples directory for details
-
-
-Documentation
--------------
-See the accompanying man pages or pdf documentation
-
-
-libcsv interfaces for other programming languages
--------------------------------------------------
-Perl - Text-CSV-LibCSV by Jiro Nishiguchi
-       http://search.cpan.org/dist/Text-CSV-LibCSV/
-
-Ruby - SimpleCSV by Ken Date
-       http://rubyforge.org/projects/simplecsv/
diff --git a/csv/csv.3.gz b/csv/csv.3.gz
deleted file mode 100755
index 5a76348..0000000
Binary files a/csv/csv.3.gz and /dev/null differ
diff --git a/csv/csv.h b/csv/csv.h
deleted file mode 100755
index 8fd706b..0000000
--- a/csv/csv.h
+++ /dev/null
@@ -1,86 +0,0 @@
-#ifndef LIBCSV_H__
-#define LIBCSV_H__
-#include <stdlib.h>
-#include <stdio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define CSV_MAJOR 3
-#define CSV_MINOR 0
-#define CSV_RELEASE 0
-
-/* Error Codes */
-#define CSV_SUCCESS 0
-#define CSV_EPARSE 1   /* Parse error in strict mode */
-#define CSV_ENOMEM 2   /* Out of memory while increasing buffer size */
-#define CSV_ETOOBIG 3  /* Buffer larger than SIZE_MAX needed */
-#define CSV_EINVALID 4 /* Invalid code,should never be received from csv_error*/
-
-
-/* parser options */
-#define CSV_STRICT 1    /* enable strict mode */
-#define CSV_REPALL_NL 2 /* report all unquoted carriage returns and linefeeds */
-#define CSV_STRICT_FINI 4 /* causes csv_fini to return CSV_EPARSE if last
-                             field is quoted and doesn't containg ending 
-                             quote */
-#define CSV_APPEND_NULL 8 /* Ensure that all fields are null-ternimated */
-
-
-/* Character values */
-#define CSV_TAB    0x09
-#define CSV_SPACE  0x20
-#define CSV_CR     0x0d
-#define CSV_LF     0x0a
-#define CSV_COMMA  0x2c
-#define CSV_QUOTE  0x22
-
-struct csv_parser {
-  int pstate;         /* Parser state */
-  int quoted;         /* Is the current field a quoted field? */
-  size_t spaces;      /* Number of continious spaces after quote or in a non-quoted field */
-  unsigned char * entry_buf;   /* Entry buffer */
-  size_t entry_pos;   /* Current position in entry_buf (and current size of entry) */
-  size_t entry_size;  /* Size of entry buffer */
-  int status;         /* Operation status */
-  unsigned char options;
-  unsigned char quote_char;
-  unsigned char delim_char;
-  int (*is_space)(unsigned char);
-  int (*is_term)(unsigned char);
-  size_t blk_size;
-  void *(*malloc_func)(size_t);
-  void *(*realloc_func)(void *, size_t);
-  void (*free_func)(void *);
-};
-
-/* Function Prototypes */
-int csv_init(struct csv_parser *p, unsigned char options);
-int csv_fini(struct csv_parser *p, void (*cb1)(void *, size_t, void *), void (*cb2)(int, void *), void *data);
-void csv_free(struct csv_parser *p);
-int csv_error(struct csv_parser *p);
-char * csv_strerror(int error);
-size_t csv_parse(struct csv_parser *p, const void *s, size_t len, void (*cb1)(void *, size_t, void *), void (*cb2)(int, void *), void *data);
-size_t csv_write(void *dest, size_t dest_size, const void *src, size_t src_size);
-int csv_fwrite(FILE *fp, const void *src, size_t src_size);
-size_t csv_write2(void *dest, size_t dest_size, const void *src, size_t src_size, unsigned char quote);
-int csv_fwrite2(FILE *fp, const void *src, size_t src_size, unsigned char quote);
-int csv_get_opts(struct csv_parser *p);
-int csv_set_opts(struct csv_parser *p, unsigned char options);
-void csv_set_delim(struct csv_parser *p, unsigned char c);
-void csv_set_quote(struct csv_parser *p, unsigned char c);
-unsigned char csv_get_delim(struct csv_parser *p);
-unsigned char csv_get_quote(struct csv_parser *p);
-void csv_set_space_func(struct csv_parser *p, int (*f)(unsigned char));
-void csv_set_term_func(struct csv_parser *p, int (*f)(unsigned char));
-void csv_set_realloc_func(struct csv_parser *p, void *(*)(void *, size_t));
-void csv_set_free_func(struct csv_parser *p, void (*)(void *));
-void csv_set_blk_size(struct csv_parser *p, size_t);
-size_t csv_get_buffer_size(struct csv_parser *p);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/csv/csv.pdf b/csv/csv.pdf
deleted file mode 100755
index 24e35e3..0000000
Binary files a/csv/csv.pdf and /dev/null differ
diff --git a/csv/examples/LICENSE b/csv/examples/LICENSE
deleted file mode 100755
index e501bab..0000000
--- a/csv/examples/LICENSE
+++ /dev/null
@@ -1,280 +0,0 @@
-  GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
diff --git a/csv/examples/csvfix.c b/csv/examples/csvfix.c
deleted file mode 100755
index 44335f1..0000000
--- a/csv/examples/csvfix.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
-csvfix - reads (possibly malformed) CSV data from input file
-         and writes properly formed CSV to output file
-
-Copyright (C) 2007  Robert Gamble
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include "libcsv/csv.h"
-
-void cb1 (void *s, size_t i, void *outfile) {
-  csv_fwrite((FILE *)outfile, s, i);
-  fputc(',',(FILE *)outfile);
-}
-
-void cb2 (int c, void *outfile) {
-  fseek((FILE *)outfile, -1, SEEK_CUR);
-  fputc('\n', (FILE *)outfile);
-}
-
-int main (int argc, char *argv[]) {
-  char buf[1024];
-  size_t i;
-  struct csv_parser p;
-  FILE *infile, *outfile;
-  csv_init(&p, 0);
-
-  if (argc != 3) {
-    fprintf(stderr, "Usage: csv_fix infile outfile\n");
-    return EXIT_FAILURE;
-  }
-
-  if (!strcmp(argv[1], argv[2])) {
-    fprintf(stderr, "Input file and output file must not be the same!\n");
-    exit(EXIT_FAILURE);
-  }
-
-  infile = fopen(argv[1], "rb");
-  if (infile == NULL) {
-    fprintf(stderr, "Failed to open file %s: %s\n", argv[1], strerror(errno));
-    exit(EXIT_FAILURE);
-  }
-
-  outfile = fopen(argv[2], "wb");
-  if (outfile == NULL) {
-    fprintf(stderr, "Failed to open file %s: %s\n", argv[2], strerror(errno));
-    fclose(infile);
-    exit(EXIT_FAILURE);
-  }
-
-  while ((i=fread(buf, 1, 1024, infile)) > 0) {
-    if (csv_parse(&p, buf, i, cb1, cb2, outfile) != i) {
-      fprintf(stderr, "Error parsing file: %s\n", csv_strerror(csv_error(&p)));
-      fclose(infile);
-      fclose(outfile);
-      remove(argv[2]);
-      exit(EXIT_FAILURE);
-    }
-  }
-
-  csv_fini(&p, cb1, cb2, outfile);
-  csv_free(&p);
-
-  if (ferror(infile)) {
-    fprintf(stderr, "Error reading from input file");
-    fclose(infile);
-    fclose(outfile);
-    remove(argv[2]);
-    exit(EXIT_FAILURE);
-  }
-
-  fclose(infile);
-  fclose(outfile);
-  return EXIT_SUCCESS;
-}
-
diff --git a/csv/examples/csvinfo.c b/csv/examples/csvinfo.c
deleted file mode 100755
index 7f11a66..0000000
--- a/csv/examples/csvinfo.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
-csvinfo - reads CSV data from input file(s) and reports the number
-          of fields and rows encountered in each file
-
-Copyright (C) 2007  Robert Gamble
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-*/
-
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-#include "libcsv/csv.h"
-
-struct counts {
-  long unsigned fields;
-  long unsigned rows;
-};
-
-void cb1 (void *s, size_t len, void *data) { ((struct counts *)data)->fields++; }
-void cb2 (int c, void *data) { ((struct counts *)data)->rows++; }
-
-static int is_space(unsigned char c) {
-  if (c == CSV_SPACE || c == CSV_TAB) return 1;
-  return 0;
-}
-
-static int is_term(unsigned char c) {
-  if (c == CSV_CR || c == CSV_LF) return 1;
-  return 0;
-}
-
-
-int
-main (int argc, char *argv[])
-{
-  FILE *fp;
-  struct csv_parser p;
-  char buf[1024];
-  size_t bytes_read;
-  unsigned char options = 0;
-  struct counts c = {0, 0};
-
-  if (argc < 2) {
-    fprintf(stderr, "Usage: csvinfo [-s] files\n");
-    exit(EXIT_FAILURE);
-  }
-
-  if (csv_init(&p, options) != 0) {
-    fprintf(stderr, "Failed to initialize csv parser\n");
-    exit(EXIT_FAILURE);
-  }
-
-  csv_set_space_func(&p, is_space);
-  csv_set_term_func(&p, is_term);
-
-  while (*(++argv)) {
-    if (strcmp(*argv, "-s") == 0) {
-      options = CSV_STRICT;
-      csv_set_opts(&p, options);
-      continue;
-    }
-
-    fp = fopen(*argv, "rb");
-    if (!fp) {
-      fprintf(stderr, "Failed to open %s: %s\n", *argv, strerror(errno));
-      continue;
-    }
-
-    while ((bytes_read=fread(buf, 1, 1024, fp)) > 0) {
-      if (csv_parse(&p, buf, bytes_read, cb1, cb2, &c) != bytes_read) {
-        fprintf(stderr, "Error while parsing file: %s\n", csv_strerror(csv_error(&p)));
-      }
-    }
-
-    csv_fini(&p, cb1, cb2, &c);
-
-    if (ferror(fp)) {
-      fprintf(stderr, "Error while reading file %s\n", *argv);
-      fclose(fp);
-      continue;
-    }
-
-    fclose(fp);
-    printf("%s: %lu fields, %lu rows\n", *argv, c.fields, c.rows);
-  }
-
-  csv_free(&p);
-  exit(EXIT_SUCCESS);
-}
- 
diff --git a/csv/examples/csvtest.c b/csv/examples/csvtest.c
deleted file mode 100755
index c17a444..0000000
--- a/csv/examples/csvtest.c
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-csvtest - reads CSV data from stdin and output properly formed equivalent
-          useful for testing the library
-
-Copyright (C) 2007  Robert Gamble
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include "libcsv/csv.h"
-
-static int put_comma;
-
-void cb1 (void *s, size_t i, void *p) {
-  if (put_comma)
-    putc(',', stdout);
-  csv_fwrite(stdout, s, i);
-  put_comma = 1;
-}
-
-void cb2 (int c, void *p) {
-  put_comma = 0;
-  putc('\n', stdout);
-}
-
-int main (void) {
-  struct csv_parser p;
-  int i;
-  char c;
-
-  csv_init(&p, 0);
-
-  while ((i=getc(stdin)) != EOF) {
-    c = i;
-    if (csv_parse(&p, &c, 1, cb1, cb2, NULL) != 1) {
-      fprintf(stderr, "Error: %s\n", csv_strerror(csv_error(&p)));
-      exit(EXIT_FAILURE);
-    }
-  }
-
-  csv_fini(&p, cb1, cb2, NULL);
-  csv_free(&p);
-
-  return EXIT_SUCCESS;
-}
-
diff --git a/csv/examples/csvvalid.c b/csv/examples/csvvalid.c
deleted file mode 100755
index 1581521..0000000
--- a/csv/examples/csvvalid.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
-csvvalid - determine if files are properly formed CSV files and display
-           position of first offending byte if not
-
-Copyright (C) 2007  Robert Gamble
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include "libcsv/csv.h"
-
-int
-main (int argc, char *argv[])
-{
-  FILE *fp;
-  int i;
-  struct csv_parser p;
-  char buf[1024];
-  size_t bytes_read;
-  size_t pos;
-  size_t retval;
-
-  if (argc < 2) {
-    fprintf(stderr, "Usage: csvvalid files\n");
-    exit(EXIT_FAILURE);
-  }
-
-  if (csv_init(&p, CSV_STRICT) != 0) {
-    fprintf(stderr, "Failed to initialize csv parser\n");
-    exit(EXIT_FAILURE);
-  }
-
-  for (i = 1; i < argc; i++) {
-    pos = 0;
-    fp = fopen(argv[i], "rb");
-    if (!fp) {
-      fprintf(stderr, "Failed to open %s: %s, skipping\n", argv[i], strerror(errno));
-      continue;
-    }
-    while ((bytes_read=fread(buf, 1, 1024, fp)) > 0) {
-      if ((retval = csv_parse(&p, buf, bytes_read, NULL, NULL, NULL)) != bytes_read) {
-        if (csv_error(&p) == CSV_EPARSE) {
-          printf("%s: malformed at byte %lu\n", argv[i], (unsigned long)pos + retval + 1);
-          goto end;
-        } else {
-          printf("Error while processing %s: %s\n", argv[i], csv_strerror(csv_error(&p)));
-          goto end;
-        }
-      }
-      pos += bytes_read;
-    }
-    printf("%s well-formed\n", argv[i]);
-
-    end:
-    fclose(fp);
-    csv_fini(&p, NULL, NULL, NULL);
-    pos = 0;
-  }
-
-  csv_free(&p);
-  return EXIT_SUCCESS;
-}
diff --git a/csv/libcsv.c b/csv/libcsv.c
deleted file mode 100755
index 6c2f6cd..0000000
--- a/csv/libcsv.c
+++ /dev/null
@@ -1,579 +0,0 @@
-/*
-libcsv - parse and write csv data
-Copyright (C) 2008  Robert Gamble
-
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#if ___STDC_VERSION__ >= 199901L
-#  include <stdint.h>
-#else
-#  define SIZE_MAX ((size_t)-1) /* C89 doesn't have stdint.h or SIZE_MAX */
-#endif
-
-#include "csv.h"
-
-#define VERSION "3.0.0"
-
-#define ROW_NOT_BEGUN           0
-#define FIELD_NOT_BEGUN         1
-#define FIELD_BEGUN             2
-#define FIELD_MIGHT_HAVE_ENDED  3
-
-/*
-  Explanation of states
-  ROW_NOT_BEGUN    There have not been any fields encountered for this row
-  FIELD_NOT_BEGUN  There have been fields but we are currently not in one
-  FIELD_BEGUN      We are in a field
-  FIELD_MIGHT_HAVE_ENDED
-                   We encountered a double quote inside a quoted field, the
-                   field is either ended or the quote is literal
-*/
-
-#define MEM_BLK_SIZE 128
-
-#define SUBMIT_FIELD(p) \
-  do { \
-   if (!quoted) \
-     entry_pos -= spaces; \
-   if (p->options & CSV_APPEND_NULL) \
-     ((p)->entry_buf[entry_pos+1]) = '\0'; \
-   if (cb1) \
-     cb1(p->entry_buf, entry_pos, data); \
-   pstate = FIELD_NOT_BEGUN; \
-   entry_pos = quoted = spaces = 0; \
- } while (0)
-
-#define SUBMIT_ROW(p, c) \
-  do { \
-    if (cb2) \
-      cb2(c, data); \
-    pstate = ROW_NOT_BEGUN; \
-    entry_pos = quoted = spaces = 0; \
-  } while (0)
-
-#define SUBMIT_CHAR(p, c) ((p)->entry_buf[entry_pos++] = (c))
-
-static char *csv_errors[] = {"success",
-                             "error parsing data while strict checking enabled",
-                             "memory exhausted while increasing buffer size",
-                             "data size too large",
-                             "invalid status code"};
-
-int
-csv_error(struct csv_parser *p)
-{
-  /* Return the current status of the parser */
-  return p->status;
-}
-
-char *
-csv_strerror(int status)
-{
-  /* Return a textual description of status */
-  if (status >= CSV_EINVALID || status < 0)
-    return csv_errors[CSV_EINVALID];
-  else
-    return csv_errors[status];
-}
-
-int
-csv_get_opts(struct csv_parser *p)
-{
-  /* Return the currently set options of parser */
-  if (p == NULL)
-    return -1;
-
-  return p->options;
-}
-
-int
-csv_set_opts(struct csv_parser *p, unsigned char options)
-{
-  /* Set the options */
-  if (p == NULL)
-    return -1;
-
-  p->options = options;
-  return 0;
-}
-
-int
-csv_init(struct csv_parser *p, unsigned char options)
-{
-  /* Initialize a csv_parser object returns 0 on success, -1 on error */
-  if (p == NULL)
-    return -1;
-
-  p->entry_buf = NULL;
-  p->pstate = ROW_NOT_BEGUN;
-  p->quoted = 0;
-  p->spaces = 0;
-  p->entry_pos = 0;
-  p->entry_size = 0;
-  p->status = 0;
-  p->options = options;
-  p->quote_char = CSV_QUOTE;
-  p->delim_char = CSV_COMMA;
-  p->is_space = NULL;
-  p->is_term = NULL;
-  p->blk_size = MEM_BLK_SIZE;
-  p->malloc_func = NULL;
-  p->realloc_func = realloc;
-  p->free_func = free;
-
-  return 0;
-}
-
-void
-csv_free(struct csv_parser *p)
-{
-  /* Free the entry_buffer of csv_parser object */
-  if (p == NULL)
-    return;
-
-  if (p->entry_buf)
-    p->free_func(p->entry_buf);
-
-  p->entry_buf = NULL;
-  p->entry_size = 0;
-
-  return;
-}
-
-int
-csv_fini(struct csv_parser *p, void (*cb1)(void *, size_t, void *), void (*cb2)(int c, void *), void *data)
-{
-  /* Finalize parsing.  Needed, for example, when file does not end in a newline */
-  int quoted = p->quoted;
-  int pstate = p->pstate;
-  size_t spaces = p->spaces;
-  size_t entry_pos = p->entry_pos;
-
-  if (p == NULL)
-    return -1;
-
-
-  if (p->pstate == FIELD_BEGUN && p->quoted && p->options & CSV_STRICT && p->options & CSV_STRICT_FINI) {
-    /* Current field is quoted, no end-quote was seen, and CSV_STRICT_FINI is set */
-    p->status = CSV_EPARSE;
-    return -1;
-  }
-
-  switch (p->pstate) {
-    case FIELD_MIGHT_HAVE_ENDED:
-      p->entry_pos -= p->spaces + 1;  /* get rid of spaces and original quote */
-      /* Fall-through */
-    case FIELD_NOT_BEGUN:
-    case FIELD_BEGUN:
-      quoted = p->quoted, pstate = p->pstate;
-      spaces = p->spaces, entry_pos = p->entry_pos;
-      SUBMIT_FIELD(p);
-      SUBMIT_ROW(p, -1);
-    case ROW_NOT_BEGUN: /* Already ended properly */
-      ;
-  }
-
-  /* Reset parser */
-  p->spaces = p->quoted = p->entry_pos = p->status = 0;
-  p->pstate = ROW_NOT_BEGUN;
-
-  return 0;
-}
-
-void
-csv_set_delim(struct csv_parser *p, unsigned char c)
-{
-  /* Set the delimiter */
-  if (p) p->delim_char = c;
-}
-
-void
-csv_set_quote(struct csv_parser *p, unsigned char c)
-{
-  /* Set the quote character */
-  if (p) p->quote_char = c;
-}
-
-unsigned char
-csv_get_delim(struct csv_parser *p)
-{
-  /* Get the delimiter */
-  return p->delim_char;
-}
-
-unsigned char
-csv_get_quote(struct csv_parser *p)
-{
-  /* Get the quote character */
-  return p->quote_char;
-}
-
-void
-csv_set_space_func(struct csv_parser *p, int (*f)(unsigned char))
-{
-  /* Set the space function */
-  if (p) p->is_space = f;
-}
- 
-void
-csv_set_term_func(struct csv_parser *p, int (*f)(unsigned char))
-{
-  /* Set the term function */
-  if (p) p->is_term = f;
-}
-
-void
-csv_set_realloc_func(struct csv_parser *p, void *(*f)(void *, size_t))
-{
-  /* Set the realloc function used to increase buffer size */
-  if (p && f) p->realloc_func = f;
-}
- 
-void
-csv_set_free_func(struct csv_parser *p, void (*f)(void *))
-{
-  /* Set the free function used to free the buffer */
-  if (p && f) p->free_func = f;
-}
-
-void
-csv_set_blk_size(struct csv_parser *p, size_t size)
-{
-  /* Set the block size used to increment buffer size */
-  if (p) p->blk_size = size;
-}
-
-size_t
-csv_get_buffer_size(struct csv_parser *p)
-{
-  /* Get the size of the entry buffer */
-  if (p)
-    return p->entry_size;
-  return 0;
-}
- 
-static int
-csv_increase_buffer(struct csv_parser *p)
-{
-  /* Increase the size of the entry buffer.  Attempt to increase size by 
-   * p->blk_size, if this is larger than SIZE_MAX try to increase current
-   * buffer size to SIZE_MAX.  If allocation fails, try to allocate halve 
-   * the size and try again until successful or increment size is zero.
-   */
-
-  size_t to_add = p->blk_size;
-  void *vp;
-
-  if ( p->entry_size >= SIZE_MAX - to_add )
-    to_add = SIZE_MAX - p->entry_size;
-
-  if (!to_add) {
-    p->status = CSV_ETOOBIG;
-    return -1;
-  }
-
-  while ((vp = p->realloc_func(p->entry_buf, p->entry_size + to_add)) == NULL) {
-    to_add /= 2;
-    if (!to_add) {
-      p->status = CSV_ENOMEM;
-      return -1;
-    }
-  }
-
-  /* Update entry buffer pointer and entry_size if successful */
-  p->entry_buf = vp;
-  p->entry_size += to_add;
-  return 0;
-}
- 
-size_t
-csv_parse(struct csv_parser *p, const void *s, size_t len, void (*cb1)(void *, size_t, void *), void (*cb2)(int c, void *), void *data)
-{
-  unsigned const char *us = s;  /* Access input data as array of unsigned char */
-  unsigned char c;              /* The character we are currently processing */
-  size_t pos = 0;               /* The number of characters we have processed in this call */
-
-  /* Store key fields into local variables for performance */
-  unsigned char delim = p->delim_char;
-  unsigned char quote = p->quote_char;
-  int (*is_space)(unsigned char) = p->is_space;
-  int (*is_term)(unsigned char) = p->is_term;
-  int quoted = p->quoted;
-  int pstate = p->pstate;
-  size_t spaces = p->spaces;
-  size_t entry_pos = p->entry_pos;
-
-
-  if (!p->entry_buf && pos < len) {
-    /* Buffer hasn't been allocated yet and len > 0 */
-    if (csv_increase_buffer(p) != 0) { 
-      p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
-      return pos;
-    }
-  }
-
-  while (pos < len) {
-    /* Check memory usage, increase buffer if neccessary */
-    if (entry_pos == ((p->options & CSV_APPEND_NULL) ? p->entry_size - 1 : p->entry_size) ) {
-      if (csv_increase_buffer(p) != 0) {
-        p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
-        return pos;
-      }
-    }
-
-    c = us[pos++];
-
-    switch (pstate) {
-      case ROW_NOT_BEGUN:
-      case FIELD_NOT_BEGUN:
-        if (is_space ? is_space(c) : c == CSV_SPACE || c == CSV_TAB) { /* Space or Tab */
-          continue;
-        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) { /* Carriage Return or Line Feed */
-          if (pstate == FIELD_NOT_BEGUN) {
-            SUBMIT_FIELD(p);
-            SUBMIT_ROW(p, (unsigned char)c); 
-          } else {  /* ROW_NOT_BEGUN */
-            /* Don't submit empty rows by default */
-            if (p->options & CSV_REPALL_NL) {
-              SUBMIT_ROW(p, (unsigned char)c);
-            }
-          }
-          continue;
-        } else if (c == delim) { /* Comma */
-          SUBMIT_FIELD(p);
-          break;
-        } else if (c == quote) { /* Quote */
-          pstate = FIELD_BEGUN;
-          quoted = 1;
-        } else {               /* Anything else */
-          pstate = FIELD_BEGUN;
-          quoted = 0;
-          SUBMIT_CHAR(p, c);
-        }
-        break;
-      case FIELD_BEGUN:
-        if (c == quote) {         /* Quote */
-          if (quoted) {
-            SUBMIT_CHAR(p, c);
-            pstate = FIELD_MIGHT_HAVE_ENDED;
-          } else {
-            /* STRICT ERROR - double quote inside non-quoted field */
-            if (p->options & CSV_STRICT) {
-              p->status = CSV_EPARSE;
-              p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
-              return pos-1;
-            }
-            SUBMIT_CHAR(p, c);
-            spaces = 0;
-          }
-        } else if (c == delim) {  /* Comma */
-          if (quoted) {
-            SUBMIT_CHAR(p, c);
-          } else {
-            SUBMIT_FIELD(p);
-          }
-        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) {  /* Carriage Return or Line Feed */
-          if (!quoted) {
-            SUBMIT_FIELD(p);
-            SUBMIT_ROW(p, (unsigned char)c);
-          } else {
-            SUBMIT_CHAR(p, c);
-          }
-        } else if (!quoted && (is_space? is_space(c) : c == CSV_SPACE || c == CSV_TAB)) { /* Tab or space for non-quoted field */
-            SUBMIT_CHAR(p, c);
-            spaces++;
-        } else {  /* Anything else */
-          SUBMIT_CHAR(p, c);
-          spaces = 0;
-        }
-        break;
-      case FIELD_MIGHT_HAVE_ENDED:
-        /* This only happens when a quote character is encountered in a quoted field */
-        if (c == delim) {  /* Comma */
-          entry_pos -= spaces + 1;  /* get rid of spaces and original quote */
-          SUBMIT_FIELD(p);
-        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) {  /* Carriage Return or Line Feed */
-          entry_pos -= spaces + 1;  /* get rid of spaces and original quote */
-          SUBMIT_FIELD(p);
-          SUBMIT_ROW(p, (unsigned char)c);
-        } else if (is_space ? is_space(c) : c == CSV_SPACE || c == CSV_TAB) {  /* Space or Tab */
-          SUBMIT_CHAR(p, c);
-          spaces++;
-        } else if (c == quote) {  /* Quote */
-          if (spaces) {
-            /* STRICT ERROR - unescaped double quote */
-            if (p->options & CSV_STRICT) {
-              p->status = CSV_EPARSE;
-              p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
-              return pos-1;
-            }
-            spaces = 0;
-            SUBMIT_CHAR(p, c);
-          } else {
-            /* Two quotes in a row */
-            pstate = FIELD_BEGUN;
-          }
-        } else {  /* Anything else */
-          /* STRICT ERROR - unescaped double quote */
-          if (p->options & CSV_STRICT) {
-            p->status = CSV_EPARSE;
-            p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
-            return pos-1;
-          }
-          pstate = FIELD_BEGUN;
-          spaces = 0;
-          SUBMIT_CHAR(p, c);
-        }
-        break;
-     default:
-       break;
-    }
-  }
-  p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
-  return pos;
-}
-
-size_t
-csv_write (void *dest, size_t dest_size, const void *src, size_t src_size)
-{
-  unsigned char *cdest = dest;
-  const unsigned char *csrc = src;
-  size_t chars = 0;
-
-  if (src == NULL)
-    return 0;
-
-  if (cdest == NULL)
-    dest_size = 0;
-
-  if (dest_size > 0)
-    *cdest++ = '"';
-  chars++;
-
-  while (src_size) {
-    if (*csrc == '"') {
-      if (dest_size > chars)
-        *cdest++ = '"';
-      if (chars < SIZE_MAX) chars++;
-    }
-    if (dest_size > chars)
-      *cdest++ = *csrc;
-    if (chars < SIZE_MAX) chars++;
-    src_size--;
-    csrc++;
-  }
-
-  if (dest_size > chars)
-    *cdest = '"';
-  if (chars < SIZE_MAX) chars++;
-
-  return chars;
-}
-
-int
-csv_fwrite (FILE *fp, const void *src, size_t src_size)
-{
-  const unsigned char *csrc = src;
-
-  if (fp == NULL || src == NULL)
-    return 0;
-
-  if (fputc('"', fp) == EOF)
-    return EOF;
-
-  while (src_size) {
-    if (*csrc == '"') {
-      if (fputc('"', fp) == EOF)
-        return EOF;
-    }
-    if (fputc(*csrc, fp) == EOF)
-      return EOF;
-    src_size--;
-    csrc++;
-  }
-
-  if (fputc('"', fp) == EOF) {
-    return EOF;
-  }
-
-  return 0;
-}
-
-size_t
-csv_write2 (void *dest, size_t dest_size, const void *src, size_t src_size, unsigned char quote)
-{
-  unsigned char *cdest = dest;
-  const unsigned char *csrc = src;
-  size_t chars = 0;
-
-  if (src == NULL)
-    return 0;
-
-  if (dest == NULL)
-    dest_size = 0;
-
-  if (dest_size > 0)
-    *cdest++ = quote;
-  chars++;
-
-  while (src_size) {
-    if (*csrc == quote) {
-      if (dest_size > chars)
-        *cdest++ = quote;
-      if (chars < SIZE_MAX) chars++;
-    }
-    if (dest_size > chars)
-      *cdest++ = *csrc;
-    if (chars < SIZE_MAX) chars++;
-    src_size--;
-    csrc++;
-  }
-
-  if (dest_size > chars)
-    *cdest = quote;
-  if (chars < SIZE_MAX) chars++;
-
-  return chars;
-}
-
-int
-csv_fwrite2 (FILE *fp, const void *src, size_t src_size, unsigned char quote)
-{
-  const unsigned char *csrc = src;
-
-  if (fp == NULL || src == NULL)
-    return 0;
-
-  if (fputc(quote, fp) == EOF)
-    return EOF;
-
-  while (src_size) {
-    if (*csrc == quote) {
-      if (fputc(quote, fp) == EOF)
-        return EOF;
-    }
-    if (fputc(*csrc, fp) == EOF)
-      return EOF;
-    src_size--;
-    csrc++;
-  }
-
-  if (fputc(quote, fp) == EOF) {
-    return EOF;
-  }
-
-  return 0;
-}
diff --git a/csv/test_csv.c b/csv/test_csv.c
deleted file mode 100755
index 450bed4..0000000
--- a/csv/test_csv.c
+++ /dev/null
@@ -1,463 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <assert.h>
-#include <stdlib.h>
-#include "./csv.h"
-
-#define CSV_END 0
-#define CSV_COL 1
-#define CSV_ROW 2
-#define CSV_ERR 3
-
-#define DO_TEST(name, options) test_parser("test" #name, options, test ## name ## _data, \
-        sizeof(test ## name ## _data) - 1, test ## name ## _results, \
-        CSV_COMMA, CSV_QUOTE, NULL, NULL)
-
-#define DO_TEST_CUSTOM(name, options, d, q, s, t) test_parser("custom" #name, options, custom ## name ## _data, \
-        sizeof(custom ## name ## _data) - 1, custom ## name ## _results, d, q, s, t)
-
-struct event {
-  int event_type; 
-  int retval;
-  size_t size;  /* Number of bytes in this event or return value from csv_fini */
-  char *data;   /* Data for this event */
-};
-
-struct event *event_ptr;
-int event_idx;
-size_t row, col;
-
-void
-fail_parser (char * test_name, char * message)
-{
-  fprintf(stderr, "Parser test %s failed on event %d: %s\n", test_name, event_idx, message);
-  exit(EXIT_FAILURE);
-}
-
-void
-fail_writer (char * test_name, char * message)
-{
-  fprintf(stderr, "Writer test %s failed: %s\n", test_name, message);
-  exit(EXIT_FAILURE);
-}
-
-void
-cb1 (void *data, size_t len, void *t)
-{
-  char * test_name = t;
-
-  /* Make sure we were expecting a column */
-  if (event_ptr->event_type != CSV_COL)
-    fail_parser(test_name, "didn't expect a column");
-
-  /* Check the actual size against the expected size */
-  if (event_ptr->size != len)
-    fail_parser(test_name, "actual data length doesn't match expected data length");
-
-  /* Check the actual data against the expected data */
-  if (memcmp(event_ptr->data, data, len) != 0)
-    fail_parser(test_name, "actual data doesn't match expected data");
-
-  event_idx++;
-  event_ptr++;
-  col++;
-}
-
-void
-cb2 (int c, void *t)
-{
-  char * test_name = t;
-
-  /* Make sure we were expecting an the end of a row */
-  if (event_ptr->event_type != CSV_ROW)
-    fail_parser(test_name, "didn't expect end of row");
-
-  /* Check that the row ended with the character we expected */
-  if (event_ptr->retval != c)
-    fail_parser(test_name, "row ended with unexpected character");
-
-  event_idx++;
-  event_ptr++;
-  col = 1;
-  row++;
-}
-
-void
-test_parser (char *test_name, unsigned char options, void *input, size_t len, struct event expected[],
-             char delimiter, char quote, int (*space_func)(unsigned char), int (*term_func)(unsigned char))
-{
-  int result = 0;
-  size_t retval;
-  struct csv_parser p;
-  size_t size;
-
-  for (size = 1; size <= len; size++) {
-    size_t bytes_processed = 0;
-    csv_init(&p, options);
-    csv_set_delim(&p, delimiter);
-    csv_set_quote(&p, quote);
-    csv_set_space_func(&p, space_func);
-    csv_set_term_func(&p, term_func);
-
-    row = col = 1;
-    event_ptr = &expected[0];
-    event_idx = 1;
-
-    do {
-      size_t bytes = size < len - bytes_processed ? size : len - bytes_processed;
-      retval = csv_parse(&p, input + bytes_processed, bytes, cb1, cb2, test_name);
-      if (retval != bytes) {
-        if (event_ptr->event_type != CSV_ERR) {
-          fail_parser(test_name, "unexpected parse error occured");
-        } else {
-          csv_free(&p);
-          return;
-        }
-      }
-      bytes_processed += bytes;
-    } while (bytes_processed < len);
-
-    result = csv_fini(&p, cb1, cb2, test_name);
-
-    if (result != 0) {
-      if (event_ptr->event_type != CSV_ERR) {
-        fail_parser(test_name, "unexpected parse error occured");
-      } else {
-        csv_free(&p);
-        return;
-      }
-    }
-
-    csv_free(&p);
-
-    if (event_ptr->event_type != CSV_END)
-      fail_parser(test_name, "unexpected end of input");
-  }
-}
-
-void
-test_writer (char * test_name, char *input, size_t input_len, char *expected, size_t expected_len)
-{
-  size_t actual_len;
-  char *temp = malloc(input_len*2 + 2);
-  if (!temp) {
-    fprintf(stderr, "Failed to allocate memory in test_writer!\n");
-    exit(EXIT_FAILURE);
-  }
-
-  actual_len = csv_write(temp, input_len*2 + 2, input, input_len);
-  if (actual_len != expected_len)
-    fail_writer(test_name, "actual length doesn't match expected length");
-  if (memcmp(temp, expected, actual_len) != 0)
-    fail_writer(test_name, "actual data doesn't match expected data");
-}
-
-void
-test_writer2 (char * test_name, char *input, size_t input_len, char *expected, size_t expected_len, char quote)
-{
-  size_t actual_len;
-  char *temp = malloc(input_len*2 + 2);
-  if (!temp) {
-    fprintf(stderr, "Failed to allocate memory in test_writer!\n");
-    exit(EXIT_FAILURE);
-  }
-
-  actual_len = csv_write2(temp, input_len*2 + 2, input, input_len, quote);
-  if (actual_len != expected_len)
-    fail_writer(test_name, "actual length doesn't match expected length");
-  if (memcmp(temp, expected, actual_len) != 0)
-    fail_writer(test_name, "actual data doesn't match expected data");
-}
-
-
-int main (void) {
-
-  /* Parser Tests */
-
-  /* Parser tests presented here consist of two parts:
-     1. the raw data to be parsed as an array of char
-     2. the behavior expected from attempting to parse the data
-  
-     The latter is encapsulated into an array of struct event, each event
-     described the type of event that was expected at that point and details
-     of the event.  There are four event types:
-     1. CSV_END - signifies the successful end of parsing, no events should
-                  follow in this test
-     2. CSV_COL - signifies that a column or CSV element is expected to be
-                  submitted to the appropriate callback function
-     3. CSV_ROW - specifies the end of a row has been reached
-     4. CSV_ERR - signifies that an error is expected at this point, no
-                  further events should follow in this test
-
-     In addition to the event type, an event is also characterized by a size
-     and a data member in the event structure.  The meaning of these fields
-     depends on the event type.
-
-     The size member for CSV_COL is the size of the expected data column,
-     for CSV_ROW is it the size of the terminating character which should
-     always be 1.  The size for CSV_END should always be zero, for CSV_ERR
-     the size is not used.
-
-     The data member represents the actual data after parsing for a CSV_COL,
-     the terminating character for CSV_ROW (the first character of the provided
-     char array is the one used), and is not used for CSV_END or CSV_ERR, it
-     should be NULL in these cases.
-  */
-
-
-  char test01_data[] = " 1,2 ,  3         ,4,5\x0d\x0a";
-  char test02_data[] = ",,,,,\x0a";
-  char test03_data[] = "\",\",\",\",\"\"";
-  char test04_data[] = "\"I call our world Flatland,\x0a"
-                       "not because we call it so,\x0a"
-                       "but to make its nature clearer\x0a"
-                       "to you, my happy readers,\x0a"
-                       "who are privileged to live in Space.\"";
-  char test05_data[] = "\"\"\"a,b\"\"\",,\" \"\"\"\" \",\"\"\"\"\" \",\" \"\"\"\"\",\"\"\"\"\"\"";
-  char test06_data[] = "\" a, b ,c \", a b  c,";
-  char test07_data[] = "\" \"\" \" \" \"\" \"";
-  char test07b_data[] = "\" \"\" \" \" \"\" \"";
-  char test08_data[] = "\" abc\"                                             "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                          \", \"123\"";
-  char test09_data[] = "";
-  char test10_data[] = "a\x0a";
-  char test11_data[] = "1,2 ,3,4\x0a";
-  char test12_data[] = "\x0a\x0a\x0a\x0a";
-  char test12b_data[] = "\x0a\x0a\x0a\x0a";
-  char test13_data[] = "\"abc\"";
-  char test14_data[] = "1, 2, 3,\x0a\x0d\x0a  \"4\", \x0d,";
-  char test15_data[] = "1, 2, 3,\x0a\x0d\x0a  \"4\", \x0d\"\"";
-  char test16_data[] = "\"1\",\"2\",\" 3 ";
-  char test16b_data[] = "\"1\",\"2\",\" 3 ";
-  char test17_data[] = " a\0b\0c ";
-  char test18_data[] = "12345678901234567890123456789012";
-
-  /* Custom tests */
-  char custom01_data[] = "'''a;b''';;' '''' ';''''' ';' ''''';''''''";
-
-  /* |1|2|3|4|5| */
-  struct event test01_results[] =
-    { {CSV_COL, 0, 1, "1"},
-      {CSV_COL, 0, 1, "2"},
-      {CSV_COL, 0, 1, "3"},
-      {CSV_COL, 0, 1, "4"},
-      {CSV_COL, 0, 1, "5"},
-      {CSV_ROW, '\x0d', 1, NULL}, {CSV_END, 0, 0, NULL} };
-    
-  /* ||||||| */
-  struct event test02_results[] =
-    { {CSV_COL, 0, 0, ""},
-      {CSV_COL, 0, 0, ""},
-      {CSV_COL, 0, 0, ""},
-      {CSV_COL, 0, 0, ""},
-      {CSV_COL, 0, 0, ""},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, '\x0a', 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* |,|,|| */
-  struct event test03_results[] = 
-    { {CSV_COL, 0, 1, ","},
-      {CSV_COL, 0, 1, ","},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  struct event test04_results[] = 
-    { {CSV_COL, 0, 147, "I call our world Flatland,\x0a"
-                     "not because we call it so,\x0a"
-                     "but to make its nature clearer\x0a"
-                     "to you, my happy readers,\x0a"
-                     "who are privileged to live in Space."},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* |"a,b"|| "" |"" | ""|""| */
-  struct event test05_results[] = 
-    { {CSV_COL, 0, 5, "\"a,b\""},
-      {CSV_COL, 0, 0, ""},
-      {CSV_COL, 0, 4, " \"\" "},
-      {CSV_COL, 0, 3, "\"\" "},
-      {CSV_COL, 0, 3, " \"\""},
-      {CSV_COL, 0, 2, "\"\""},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* | a, b ,c |a b  c|| */
-  struct event test06_results[] = 
-    { {CSV_COL, 0, 9, " a, b ,c "},
-      {CSV_COL, 0, 6, "a b  c"},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* | " " " " | */
-  struct event test07_results[] = 
-    { {CSV_COL, 0, 9, " \" \" \" \" "},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* Will cause error with CSV_STRICT set */
-  struct event test07b_results[] = 
-    { {CSV_ERR, 0, 0, NULL} };
-
-  struct event test08_results[] = 
-    { {CSV_COL, 0, 463,   " abc\"                                               "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                                     "
-                       "                                        "},
-      {CSV_COL, 0, 3, "123"},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-                     
-  /* empty */
-  struct event test09_results[] = 
-    { {CSV_END, 0, 0, NULL} };
-
-  /* |a| */
-  struct event test10_results[] = 
-    { {CSV_COL, 0, 1, "a"},
-      {CSV_ROW, '\x0a', 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* |1|2|3|4| */
-  struct event test11_results[] = 
-    { {CSV_COL, 0, 1, "1"},
-      {CSV_COL, 0, 1, "2"},
-      {CSV_COL, 0, 1, "3"}, 
-      {CSV_COL, 0, 1, "4"},
-      {CSV_ROW, '\x0a', 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* empty */
-  struct event test12_results[] = 
-    { {CSV_END, 0, 0, NULL} };
-
-  /* Test CSV_REPALL_NL */
-  struct event test12b_results[] = 
-    { {CSV_ROW, '\x0a', 1, NULL},
-      {CSV_ROW, '\x0a', 1, NULL},
-      {CSV_ROW, '\x0a', 1, NULL},
-      {CSV_ROW, '\x0a', 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* |abc| */
-  struct event test13_results[] =
-    { {CSV_COL, 0, 3, "abc"},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* |1|2|3||
-     |4||
-     |||       */
-  struct event test14_results[] =
-    { {CSV_COL, 0, 1, "1"},
-      {CSV_COL, 0, 1, "2"},
-      {CSV_COL, 0, 1, "3"},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, '\x0a', 1, NULL},
-      {CSV_COL, 0, 1, "4"},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, '\x0d', 1, NULL},
-      {CSV_COL, 0, 0, ""},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, -1, 0, NULL}, {CSV_END, 0, 0, NULL} }; 
-      
-  /* |1|2|3||
-     |4||
-     ||       */
-  struct event test15_results[] =
-    { {CSV_COL, 0, 1, "1"},
-      {CSV_COL, 0, 1, "2"},
-      {CSV_COL, 0, 1, "3"},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, '\x0a', 1, NULL},
-      {CSV_COL, 0, 1, "4"},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, '\x0d', 1, NULL},
-      {CSV_COL, 0, 0, ""},
-      {CSV_ROW, -1, 0, NULL}, {CSV_END, 0, 0, NULL} };
-
-
-  /* |1|2| 3 | */
-  struct event test16_results[] = 
-    { {CSV_COL, 0, 1, "1"},
-      {CSV_COL, 0, 1, "2"},
-      {CSV_COL, 0, 3, " 3 "},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* Will cause an error with CSV_STRICT_FINI set */
-  struct event test16b_results[] = 
-    { {CSV_COL, 0, 1, "1"},
-      {CSV_COL, 0, 1, "2"},
-      {CSV_ERR, 0, 0, NULL} };
-
-  /* |a\0b\0c| */
-  struct event test17_results[] = 
-    { {CSV_COL, 0, 5, "a\0b\0c"},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  /* |'a;b'|| '' |'' | ''|''| */
-  struct event custom01_results[] = 
-    { {CSV_COL, 0, 5, "'a;b'"},
-      {CSV_COL, 0, 0, ""},
-      {CSV_COL, 0, 4, " '' "},
-      {CSV_COL, 0, 3, "'' "},
-      {CSV_COL, 0, 3, " ''"},
-      {CSV_COL, 0, 2, "''"},
-      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
-
-  DO_TEST(01, 0);
-  DO_TEST(01, CSV_STRICT);
-  DO_TEST(02, 0);
-  DO_TEST(02, CSV_STRICT);
-  DO_TEST(03, 0);
-  DO_TEST(03, CSV_STRICT);
-  DO_TEST(04, 0);
-  DO_TEST(04, CSV_STRICT);
-  DO_TEST(05, 0);
-  DO_TEST(05, CSV_STRICT);
-  DO_TEST(05, CSV_STRICT | CSV_STRICT_FINI);
-  DO_TEST(06, 0);
-  DO_TEST(06, CSV_STRICT);
-  DO_TEST(07, 0);
-  DO_TEST(07b, CSV_STRICT);
-  DO_TEST(08, 0);
-  DO_TEST(09, 0);
-  DO_TEST(10, 0);
-  DO_TEST(11, 0);
-  DO_TEST(12, 0);
-  DO_TEST(12b, CSV_REPALL_NL);
-  DO_TEST(13, 0);
-  DO_TEST(14, 0);
-  DO_TEST(14, CSV_STRICT);
-  DO_TEST(15, 0);
-  DO_TEST(15, CSV_STRICT);
-  DO_TEST(16, 0);
-  DO_TEST(16, CSV_STRICT);
-  DO_TEST(16b, CSV_STRICT | CSV_STRICT_FINI);
-  DO_TEST(16, 0);
-  DO_TEST(16, CSV_STRICT);
-  DO_TEST(17, 0);
-  DO_TEST(17, CSV_STRICT);
-
-  DO_TEST_CUSTOM(01, 0, ';', '\'', NULL, NULL);
-
-  /* Writer Tests */
-
-  /* The writer tests are simpler, the test_writer function is used to
-     test the csv_write function and takes five arguments: the name of
-     the test, the data to convert, the length of that data, the expected
-     resulting CSV data, and the expected length of the result.
-  */
-
-  test_writer("1", "abc", 3, "\"abc\"", 5);
-  test_writer("2", "\"\"\"\"\"\"\"\"", 8, "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"", 18);
-
-  test_writer2("1", "abc", 3, "'abc'", 5, '\'');
-  test_writer2("2", "''''''''", 8, "''''''''''''''''''", 18, '\'');
-
-  puts("All tests passed");
-  return 0;
-}
diff --git a/csv/tests/test_01.csv b/csv/tests/test_01.csv
deleted file mode 100755
index dc95b75..0000000
--- a/csv/tests/test_01.csv
+++ /dev/null
@@ -1 +0,0 @@
- 1,2 , 	3	  ,4,5
diff --git a/csv/tests/test_02.csv b/csv/tests/test_02.csv
deleted file mode 100755
index d36a458..0000000
--- a/csv/tests/test_02.csv
+++ /dev/null
@@ -1 +0,0 @@
-,,,,,
diff --git a/csv/tests/test_03.csv b/csv/tests/test_03.csv
deleted file mode 100755
index 235090b..0000000
--- a/csv/tests/test_03.csv
+++ /dev/null
@@ -1 +0,0 @@
-",",",",""
diff --git a/csv/tests/test_04.csv b/csv/tests/test_04.csv
deleted file mode 100755
index bdd2fa2..0000000
--- a/csv/tests/test_04.csv
+++ /dev/null
@@ -1,5 +0,0 @@
-"I call our world Flatland,
- not because we call it so, 
- but to make its nature clearer
- to you, my happy readers,
- who are privileged to live in Space."
diff --git a/csv/tests/test_05.csv b/csv/tests/test_05.csv
deleted file mode 100755
index 92ca7c6..0000000
--- a/csv/tests/test_05.csv
+++ /dev/null
@@ -1 +0,0 @@
-"""a,b""",," """" ",""""" "," """"",""""""
diff --git a/csv/tests/test_06.csv b/csv/tests/test_06.csv
deleted file mode 100755
index b124e7e..0000000
--- a/csv/tests/test_06.csv
+++ /dev/null
@@ -1 +0,0 @@
-" a, b ,c ", a b  c,
diff --git a/csv/tests/test_07.csv b/csv/tests/test_07.csv
deleted file mode 100755
index 0f54a76..0000000
--- a/csv/tests/test_07.csv
+++ /dev/null
@@ -1 +0,0 @@
-" "" " " "" "
diff --git a/csv/tests/test_08.csv b/csv/tests/test_08.csv
deleted file mode 100755
index 4a17b9f..0000000
--- a/csv/tests/test_08.csv
+++ /dev/null
@@ -1 +0,0 @@
-" abc"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ", "123" 
diff --git a/csv/tests/test_09.csv b/csv/tests/test_09.csv
deleted file mode 100755
index e69de29..0000000
diff --git a/csv/tests/test_10.csv b/csv/tests/test_10.csv
deleted file mode 100755
index 7898192..0000000
--- a/csv/tests/test_10.csv
+++ /dev/null
@@ -1 +0,0 @@
-a
diff --git a/csv/tests/test_11.csv b/csv/tests/test_11.csv
deleted file mode 100755
index 4eb154e..0000000
--- a/csv/tests/test_11.csv
+++ /dev/null
@@ -1 +0,0 @@
-1,2 ,3,4
diff --git a/csv/tests/test_12.csv b/csv/tests/test_12.csv
deleted file mode 100755
index fd40910..0000000
--- a/csv/tests/test_12.csv
+++ /dev/null
@@ -1,4 +0,0 @@
-
-
-
-
diff --git a/csv/tests/test_13.csv b/csv/tests/test_13.csv
deleted file mode 100755
index 4f44a21..0000000
--- a/csv/tests/test_13.csv
+++ /dev/null
@@ -1 +0,0 @@
-"abc"
\ No newline at end of file
diff --git a/include/config/INIFile.h b/include/config/INIFile.h
deleted file mode 100755
index ae8f722..0000000
--- a/include/config/INIFile.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/* 
-   INIFile.h - INI File Object/Parser Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef H_INIFILE
-#define H_INIFILE
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct _INIFile INIFile;
-typedef struct _INISection INISection;
-typedef struct _INIPair INIPair;
-
-#include <shared.h>
-
-struct _INIPair
-{
-  /* Members */
-  INISection *section;
-  INIPair *next;
-  gchar *key;
-  gchar *value;
-  gint line;
-
-  /* Methods */
-  void (*destroy) (INIPair *pair);
-};
-
-struct _INISection
-{
-  /* Members */
-  INIFile *ini;
-  INISection *next;
-  INIPair *pair_head;
-  INIPair *pair_tail;
-  gint pair_count;
-  gchar *title;
-  
-  /* Methods */
-  const gchar *(*getValue) (INISection *section, const gchar *key);
-  INIPair *(*getPair) (INISection *section, const gchar *key);
-  void (*destroy) (INISection *section);
-  void (*addPair) (INISection *section, 
-		   gint line, 
-		   const gchar *key,
-		   const gchar *value);
-};
-
-struct _INIFile
-{
-  /* Members */
-  INISection *section_head;
-  INISection *section_tail;
-  gchar *filename;
-
-  /* Methods */
-  gboolean (*open) (INIFile *);
-  gboolean (*save) (INIFile *, const gchar *);
-  gboolean (*load) (INIFile *, FILE *);
-  void (*destroy) (INIFile *);
-  INISection *(*getSection) (INIFile *ini, const gchar *section);
-  INIPair *(*getPair) (INIFile *ini, const gchar *section, const gchar *key);
-  const gchar *(*getValue) (INIFile *ini, 
-			   const gchar *section, 
-			   const gchar *key); 
-};
-
-/* INIFile.c */
-INIFile *inifile_new (const gchar *filename);
-INISection *inisection_new (INIFile *ini, const gchar *section);
-INIPair *inipair_new (INISection *section, 
-		      const gchar *key, 
-		      const gchar *value,
-		      gint line);
-#ifdef __cplusplus
-}
-#endif
-#endif /*H_INIFILE*/
diff --git a/include/config/config.h b/include/config/config.h
deleted file mode 100755
index 2113fff..0000000
--- a/include/config/config.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/* 
-   config.h - Config Object/Parser Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef H_CONFIG
-#define H_CONFIG
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct _Config Config;
-typedef struct _ConfigBlock ConfigBlock;
-typedef struct _ConfigRow ConfigRow;
-typedef struct _ConfigPair ConfigPair;
-typedef struct _ConfigVector ConfigVector;
-
-#include <shared.h>
-#include <stdlib.h>
-
-struct _ConfigPair
-{
-  /* Members */
-  ConfigRow * row;
-  ConfigPair * next;
-  ConfigPair * prev;
-  gchar * key;
-  gchar * value;
-
-  /* Methods */
-  void (*destroy) (ConfigPair *);
-};
-
-struct _ConfigVector
-{
-  /* Members */
-  ConfigRow * row;
-  ConfigVector * next;
-  ConfigVector * prev;
-  GPtrArray * array;
-  gchar * tag;
-
-  /* Methods */
-  void (*add) (ConfigVector *, const gchar *);
-  gint (*get_int) (ConfigVector *, gint);
-  gchar *(*get) (ConfigVector *, gint);
-  void (*destroy) (ConfigVector *);
-};
-
-struct _ConfigRow
-{
-  /* Members */
-  ConfigBlock * block;
-  ConfigRow * next;
-  ConfigVector * vector_head;
-  ConfigVector * vector_tail;
-  ConfigPair * pair_head;
-  ConfigPair * pair_tail;
-  gchar * tag;
-
-  /* Methods */
-  ConfigPair *(*get_pair) (ConfigRow *, const gchar *);
-  ConfigVector *(*get_vector) (ConfigRow *, const gchar *);
-  gchar *(*parse) (ConfigRow *, gchar *);
-  void (*destroy) (ConfigRow *);
-};
-
-struct _ConfigBlock
-{
-  /* Members */
-  ConfigBlock * next;
-  Config * cfg;
-  ConfigRow * row_head;
-  ConfigRow * row_tail;
-  gchar * tag;
-
-  /* Methods */
-  gchar *(*parse) (ConfigBlock *, gchar *, FILE *);
-  void (*destroy) (ConfigBlock *);
-  ConfigRow *(*get_row) (ConfigBlock *, const gchar *);
-  ConfigPair *(*get_pair) (ConfigBlock *, const gchar *, const gchar *);
-};
-
-struct _Config
-{
-  /* Members */
-  gchar * filename;
-  ConfigBlock * block_head;
-  ConfigBlock * block_tail;
-
-  /* Methods */
-  gint (*open) (Config *);
-  gint (*save) (Config *, const gchar *);
-  gint (*load) (Config *, FILE *);
-  void (*close) (Config *);
-  ConfigVector *(*get_vector) (Config *,
-			       const gchar *,
-			       const gchar *,
-			       const gchar *);
-  ConfigPair *(*get_pair) (Config *, 
-			   const gchar *, 
-			   const gchar *, 
-			   const gchar *);
-  ConfigBlock *(*get_block) (Config *, 
-			     const gchar *);
-  ConfigRow *(*get_row) (Config *, const gchar *, const gchar *);
-};
-
-/* config.c */
-ConfigBlock *configblock_new (Config *, const gchar *);
-Config *config_new (const gchar *);
-ConfigRow *configrow_new (ConfigBlock *, const gchar *);
-ConfigPair *configpair_new (ConfigRow *, const gchar *, const gchar *);
-ConfigVector *configvector_new (ConfigRow *, const gchar *);
-
-#ifdef __cplusplus
-}
-#endif
-#endif /*H_CONFIG*/
diff --git a/include/csv/csv.h b/include/csv/csv.h
deleted file mode 100755
index 8fd706b..0000000
--- a/include/csv/csv.h
+++ /dev/null
@@ -1,86 +0,0 @@
-#ifndef LIBCSV_H__
-#define LIBCSV_H__
-#include <stdlib.h>
-#include <stdio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define CSV_MAJOR 3
-#define CSV_MINOR 0
-#define CSV_RELEASE 0
-
-/* Error Codes */
-#define CSV_SUCCESS 0
-#define CSV_EPARSE 1   /* Parse error in strict mode */
-#define CSV_ENOMEM 2   /* Out of memory while increasing buffer size */
-#define CSV_ETOOBIG 3  /* Buffer larger than SIZE_MAX needed */
-#define CSV_EINVALID 4 /* Invalid code,should never be received from csv_error*/
-
-
-/* parser options */
-#define CSV_STRICT 1    /* enable strict mode */
-#define CSV_REPALL_NL 2 /* report all unquoted carriage returns and linefeeds */
-#define CSV_STRICT_FINI 4 /* causes csv_fini to return CSV_EPARSE if last
-                             field is quoted and doesn't containg ending 
-                             quote */
-#define CSV_APPEND_NULL 8 /* Ensure that all fields are null-ternimated */
-
-
-/* Character values */
-#define CSV_TAB    0x09
-#define CSV_SPACE  0x20
-#define CSV_CR     0x0d
-#define CSV_LF     0x0a
-#define CSV_COMMA  0x2c
-#define CSV_QUOTE  0x22
-
-struct csv_parser {
-  int pstate;         /* Parser state */
-  int quoted;         /* Is the current field a quoted field? */
-  size_t spaces;      /* Number of continious spaces after quote or in a non-quoted field */
-  unsigned char * entry_buf;   /* Entry buffer */
-  size_t entry_pos;   /* Current position in entry_buf (and current size of entry) */
-  size_t entry_size;  /* Size of entry buffer */
-  int status;         /* Operation status */
-  unsigned char options;
-  unsigned char quote_char;
-  unsigned char delim_char;
-  int (*is_space)(unsigned char);
-  int (*is_term)(unsigned char);
-  size_t blk_size;
-  void *(*malloc_func)(size_t);
-  void *(*realloc_func)(void *, size_t);
-  void (*free_func)(void *);
-};
-
-/* Function Prototypes */
-int csv_init(struct csv_parser *p, unsigned char options);
-int csv_fini(struct csv_parser *p, void (*cb1)(void *, size_t, void *), void (*cb2)(int, void *), void *data);
-void csv_free(struct csv_parser *p);
-int csv_error(struct csv_parser *p);
-char * csv_strerror(int error);
-size_t csv_parse(struct csv_parser *p, const void *s, size_t len, void (*cb1)(void *, size_t, void *), void (*cb2)(int, void *), void *data);
-size_t csv_write(void *dest, size_t dest_size, const void *src, size_t src_size);
-int csv_fwrite(FILE *fp, const void *src, size_t src_size);
-size_t csv_write2(void *dest, size_t dest_size, const void *src, size_t src_size, unsigned char quote);
-int csv_fwrite2(FILE *fp, const void *src, size_t src_size, unsigned char quote);
-int csv_get_opts(struct csv_parser *p);
-int csv_set_opts(struct csv_parser *p, unsigned char options);
-void csv_set_delim(struct csv_parser *p, unsigned char c);
-void csv_set_quote(struct csv_parser *p, unsigned char c);
-unsigned char csv_get_delim(struct csv_parser *p);
-unsigned char csv_get_quote(struct csv_parser *p);
-void csv_set_space_func(struct csv_parser *p, int (*f)(unsigned char));
-void csv_set_term_func(struct csv_parser *p, int (*f)(unsigned char));
-void csv_set_realloc_func(struct csv_parser *p, void *(*)(void *, size_t));
-void csv_set_free_func(struct csv_parser *p, void (*)(void *));
-void csv_set_blk_size(struct csv_parser *p, size_t);
-size_t csv_get_buffer_size(struct csv_parser *p);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif

commit 2be436810b7d2d05100603d9286af327d3721be3
Author: John Bellone <jvb4@njit.edu>
Date:   Tue Jun 30 14:26:48 2009 -0400

    Added entry to .gitignore file.

diff --git a/.gitignore b/.gitignore
index bf37f2d..6f5f9d5 100755
--- a/.gitignore
+++ b/.gitignore
@@ -5,4 +5,5 @@ bin/
 lib/
 csv/libcsv.*
 massif*
-*.log
\ No newline at end of file
+*.log
+\#*\#
\ No newline at end of file

commit 6fbf7b1242c2ddb71c80047b170e012e5a515039
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jun 24 16:40:08 2009 -0400

    (1) Added macro for control of line index maximum size
    (2) Added macro for control of line floating point precision

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 9c94129..6b62358 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -68,8 +68,8 @@ namespace largefile {
 		this->marks[0].line = 0;
 		
 		// Compute fuzzy relative position, and set line to -1 for indexing.
-		for (int ii = 1; ii < 101; ii++) {
-			double N = ii, K = 1000;
+		for (int ii = 1; ii < LINE_INDEX_MAX; ii++) {
+			double N = ii, K = LINE_PRECISION;
 			this->marks[ii].byte = (off64_t)((N/K) * byte_end);
 			this->marks[ii].line = -1;
 		}
@@ -148,12 +148,10 @@ namespace largefile {
   			if (this->marks[index].byte == cursor++) {
 				this->marks[index].line = count;
 				this->marks[index].byte = byte_beg;
-
-				std::cout<<"index: "<<index<<" byte: "<<this->marks[index].byte<<" line: "<<this->marks[index].line<<"\n";
 				
 				index++;
 				
-				if (index == 101)
+				if (index == LINE_INDEX_MAX)
 					break;
 			}
 
@@ -194,7 +192,7 @@ namespace largefile {
 		off64_t offset = 0, delta = 0;
 		off64_t read_max = this->numberOfLinesToRead;
 		
-		for (int index = 1; index < 101; index++) {
+		for (int index = 1; index < LINE_INDEX_MAX; index++) {
 			if ((this->startLine + read_max) < this->marks[index].line) {
 				delta = std::abs(this->marks[index-1].line - this->startLine);
 				offset = this->marks[index-1].byte;
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index e58496d..8f3081d 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -26,6 +26,9 @@
 #include <vector>
 #include <string>
 
+#define LINE_INDEX_MAX 1001
+#define LINE_PRECISION 10000
+
 namespace largefile {
 
 	struct LineIndex {
@@ -35,7 +38,7 @@ namespace largefile {
 	
 	class FileDispatcher : public proactor::InputDispatcher {
 	private:
-		LineIndex marks[101];
+		LineIndex marks[LINE_INDEX_MAX];
 		FILE * fp;
 		std::string filename;
 	public:
@@ -49,7 +52,7 @@ namespace largefile {
 		void read (off64_t start, off64_t N);
 		void index (void);
 
-		inline bool isIndexed(void) const { return (this->marks[100].line != -1); }
+		inline bool isIndexed(void) const { return (this->marks[LINE_INDEX_MAX-1].line != -1); }
 	};
 
 	class LineIndexer : public proactor::Worker {

commit 738434a5d848292bc90d8af1eee9c846ed69d9b2
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jun 24 16:31:48 2009 -0400

    (1) Fixed integer overflow problem in floating point math.
    (2) Converted to using 64-bit offsets for seeking and telling.
    (3) Fixed 32-bit offset bug which allowed no indexing above 2GB.

diff --git a/Makefile.base b/Makefile.base
index 533d6a6..dbec46b 100755
--- a/Makefile.base
+++ b/Makefile.base
@@ -36,4 +36,4 @@ LIBS += -Wl,-rpath ${LIBDIR}
 LIBS += `pkg-config gtk+-2.0 glib-2.0 --libs`
 
 CCFLAGS=-g -O0 -std=c99 -Wall -pthread
-CXFLAGS=-g -O0 -Wall -Wno-write-strings -D_FILE_OFFSETS_BITS=64
\ No newline at end of file
+CXFLAGS=-g -O0 -Wall -Wno-write-strings
\ No newline at end of file
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index a35982c..9c94129 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -38,7 +38,7 @@ namespace largefile {
 	}
 
 	void
-	FileDispatcher::read (long long start, long long N) {
+	FileDispatcher::read (off64_t start, off64_t N) {
 		LineReader * reader = new LineReader (this, this->fp, this->marks, start, N);
 		this->addWorker (reader);
 	}
@@ -54,27 +54,27 @@ namespace largefile {
 		if (filename.length() == 0)
 			return false;
 
-		if ((this->fp = std::fopen (filename.c_str(), "r")) == NULL) {
+		if ((this->fp = fopen64 (filename.c_str(), "r")) == NULL) {
 			// stub: throw an error somewhere
 			return false;
 		}
 
 		// Take the relative byte position, e.g. .75 * byte_end, and we now have the a relative
 		// line at that byte position for indexing at a later point in time.
-		std::fseek (this->fp, 0L, SEEK_END);
-		long long byte_end = std::ftell (this->fp);
+		fseeko64 (this->fp, 0L, SEEK_END);
+		off64_t byte_end = ftello64 (this->fp);
 
 		this->marks[0].byte = 0;
 		this->marks[0].line = 0;
 		
 		// Compute fuzzy relative position, and set line to -1 for indexing.
 		for (int ii = 1; ii < 101; ii++) {
-			float N = ii, K = 10000;
-			this->marks[ii].byte = (long long)((N/K) * byte_end);
+			double N = ii, K = 1000;
+			this->marks[ii].byte = (off64_t)((N/K) * byte_end);
 			this->marks[ii].line = -1;
 		}
 
-		std::fseek (this->fp, 0L, SEEK_SET);
+		fseeko64 (this->fp, 0L, SEEK_SET);
 		
 		concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
 		this->filename = filename;
@@ -87,7 +87,7 @@ namespace largefile {
 		if (this->fp == NULL)
 			return false;
 
-		std::fclose (this->fp); this->fp = NULL;
+		fclose (this->fp); this->fp = NULL;
 		mutex.remove();
 		return true;
 	}
@@ -99,11 +99,6 @@ namespace largefile {
 		this->index();
 		
 		while (this->running == true) {
-			if (this->fp == NULL) {
-				this->running = false;
-				break;
-			}
-
 			this->inputQueue.lock();
       
 			while (this->inputQueue.size() > 0) {
@@ -130,14 +125,13 @@ namespace largefile {
 	}
 
 	LineIndexer::~LineIndexer (void) {
-		std::cout<<"index finished\n"<<std::flush;
 	}
 
 	void *
 	LineIndexer::run (void * null) {
 		this->running = true;
 		int ch, index = 0;
-		long long cursor = 0, count = 0, byte_beg = 0;
+		off64_t cursor = 0, count = 0, byte_beg = 0;
 
 		struct timeval start, end;
 		
@@ -148,13 +142,15 @@ namespace largefile {
 		// We need to get a absoltue line number from the relative position. We're not
 		// going to get away from having to sequentially read this file in, but once we
 		// have line numbers we can jump throughout the file pretty quickly.
-		while ((ch = std::fgetc(this->fp)) != EOF) {
+		while ((ch = fgetc(this->fp)) != EOF) {
 			if (ch=='\n') count++;
 
   			if (this->marks[index].byte == cursor++) {
 				this->marks[index].line = count;
 				this->marks[index].byte = byte_beg;
 
+				std::cout<<"index: "<<index<<" byte: "<<this->marks[index].byte<<" line: "<<this->marks[index].line<<"\n";
+				
 				index++;
 				
 				if (index == 101)
@@ -176,8 +172,8 @@ namespace largefile {
 	LineReader::LineReader (proactor::InputDispatcher * d,
 									FILE * fp,
 									LineIndex * marks,
-									long long start,
-									long long N) {
+									off64_t start,
+									off64_t N) {
 		this->fp = fp;
 		this->dispatcher = d;
 		this->startLine = start;
@@ -194,9 +190,9 @@ namespace largefile {
 		char buf[4096];
 
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-		long long start = std::ftell(this->fp);
-		long long offset = 0, delta = 0;
-		long long & read_max = this->numberOfLinesToRead;
+		off64_t start = ftello64 (this->fp);
+		off64_t offset = 0, delta = 0;
+		off64_t read_max = this->numberOfLinesToRead;
 		
 		for (int index = 1; index < 101; index++) {
 			if ((this->startLine + read_max) < this->marks[index].line) {
@@ -206,7 +202,7 @@ namespace largefile {
 			}
 		}
 		
-		std::fseek (this->fp, offset, SEEK_SET);
+		fseeko64 (this->fp, offset, SEEK_SET);
 
 		// Munch lines to get to our starting point.
 		while (delta > 0) {
@@ -215,14 +211,14 @@ namespace largefile {
 			--delta;
       }
 		
-		for (long long ii = 0; ii < read_max; ii++) {
+		for (off64_t ii = 0; ii < read_max; ii++) {
 			if (std::fgets (buf, 4096, this->fp) == NULL)		
 				break;
       
 			this->dispatcher->onReadComplete (std::string (buf));
 		}
 
-		std::fseek (this->fp, start, SEEK_SET);
+		fseeko64 (this->fp, start, SEEK_SET);
 		
 		this->running = false;
 		this->dispatcher->removeWorker (this);
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 377e81e..e58496d 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -29,8 +29,8 @@
 namespace largefile {
 
 	struct LineIndex {
-		long long byte;
-		long long line;
+		off64_t byte;
+		off64_t line;
 	};
 	
 	class FileDispatcher : public proactor::InputDispatcher {
@@ -46,7 +46,7 @@ namespace largefile {
 		bool close (void);
 		void * run (void * null);
 
-		void read (long long start, long long N);
+		void read (off64_t start, off64_t N);
 		void index (void);
 
 		inline bool isIndexed(void) const { return (this->marks[100].line != -1); }
@@ -68,15 +68,15 @@ namespace largefile {
 	class LineReader : public proactor::Worker {
 	private:
 		FILE * fp;
-		long long numberOfLinesToRead;
-		long long startLine;
+		off64_t numberOfLinesToRead;
+		off64_t startLine;
 		LineIndex * marks;
 	public:
 		LineReader (proactor::InputDispatcher * d, 
 						FILE * fp,
 						LineIndex * marks,
-						long long start,
-						long long N);
+						off64_t start,
+						off64_t N);
 		virtual ~LineReader (void);
 
 		void * run (void * null);
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index 6790627..f0444a9 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -4,10 +4,12 @@ INCS += -I${PROJDIR}/shared
 SRCS=$(wildcard *.cpp) 
 OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
 
+_CXFLAGS= -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
+
 all: 	largefile
 
 largefile: ${OBJS}
-	${CX} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
+	${CX} ${_CXFLAGS} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
 	-lgthread-2.0 -lpthread -lcsv -lshared
 
 clean:		
@@ -19,7 +21,7 @@ install: all
 	${CP} ${PROJDIR}/bin/largefile.so ${INSEXTDIR}/largefile.so
 
 ${OBJDIR}/largefile/%.o: %.cpp
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
+	${CX} ${_CXFLAGS} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
 
 .cpp.o:
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
+	${CX} ${_CXFLAGS} ${INCS} -c -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 275acf5..eb9e6c6 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -52,12 +52,12 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
 
 	int vposition = std::abs((int)gtksheet->vadjustment->value);
-	static long int cursor = 0;
+	static off64_t cursor = 0;
 	//	float N = vposition, K = 24388, V = (N/K);
 	
 	switch (event->keyval) {
 		case GDK_F1: {
-			fd->read(8570218,1000);
+			fd->read(1012121,1000);
 		}
 		break;
 		
@@ -117,7 +117,7 @@ thread_main (ThreadArgs * args) {
 		return;
 	}
 
-	if (fdispatcher.open ("/home/johnb/largefile.csv") == false) {
+	if (fdispatcher.open ("/home/jbellone/largefile.csv") == false) {
 		g_critical ("Failed opening /home/johnb/largefile.csv");
 		return;
 	}

commit 6ead82086cb9092434f935f577502c32e373e073
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 19 17:26:25 2009 -0400

    Seems to be a largefile issue with fseek/ftell; need to find the right combination
    for declares to enable fseek64/ftell64 by default.

diff --git a/Makefile.base b/Makefile.base
index dbec46b..533d6a6 100755
--- a/Makefile.base
+++ b/Makefile.base
@@ -36,4 +36,4 @@ LIBS += -Wl,-rpath ${LIBDIR}
 LIBS += `pkg-config gtk+-2.0 glib-2.0 --libs`
 
 CCFLAGS=-g -O0 -std=c99 -Wall -pthread
-CXFLAGS=-g -O0 -Wall -Wno-write-strings
\ No newline at end of file
+CXFLAGS=-g -O0 -Wall -Wno-write-strings -D_FILE_OFFSETS_BITS=64
\ No newline at end of file
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 30aa68d..a35982c 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -38,7 +38,7 @@ namespace largefile {
 	}
 
 	void
-	FileDispatcher::read (long int start, long int N) {
+	FileDispatcher::read (long long start, long long N) {
 		LineReader * reader = new LineReader (this, this->fp, this->marks, start, N);
 		this->addWorker (reader);
 	}
@@ -62,7 +62,7 @@ namespace largefile {
 		// Take the relative byte position, e.g. .75 * byte_end, and we now have the a relative
 		// line at that byte position for indexing at a later point in time.
 		std::fseek (this->fp, 0L, SEEK_END);
-		long int byte_end = std::ftell (this->fp);
+		long long byte_end = std::ftell (this->fp);
 
 		this->marks[0].byte = 0;
 		this->marks[0].line = 0;
@@ -70,7 +70,7 @@ namespace largefile {
 		// Compute fuzzy relative position, and set line to -1 for indexing.
 		for (int ii = 1; ii < 101; ii++) {
 			float N = ii, K = 10000;
-			this->marks[ii].byte = (long int)((N/K) * byte_end);
+			this->marks[ii].byte = (long long)((N/K) * byte_end);
 			this->marks[ii].line = -1;
 		}
 
@@ -137,7 +137,7 @@ namespace largefile {
 	LineIndexer::run (void * null) {
 		this->running = true;
 		int ch, index = 0;
-		long long int cursor = 0, count = 0, byte_beg = 0;
+		long long cursor = 0, count = 0, byte_beg = 0;
 
 		struct timeval start, end;
 		
@@ -176,8 +176,8 @@ namespace largefile {
 	LineReader::LineReader (proactor::InputDispatcher * d,
 									FILE * fp,
 									LineIndex * marks,
-									long int start,
-									long int N) {
+									long long start,
+									long long N) {
 		this->fp = fp;
 		this->dispatcher = d;
 		this->startLine = start;
@@ -194,13 +194,13 @@ namespace largefile {
 		char buf[4096];
 
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-		long int start = std::ftell(this->fp);
-		long int offset = 0, delta = 0;
-		long int & read_max = this->numberOfLinesToRead;
+		long long start = std::ftell(this->fp);
+		long long offset = 0, delta = 0;
+		long long & read_max = this->numberOfLinesToRead;
 		
 		for (int index = 1; index < 101; index++) {
 			if ((this->startLine + read_max) < this->marks[index].line) {
-				delta = std::abs(this->marks[index-1].line - this->startLine + 1);
+				delta = std::abs(this->marks[index-1].line - this->startLine);
 				offset = this->marks[index-1].byte;
 				break;
 			}
@@ -215,7 +215,7 @@ namespace largefile {
 			--delta;
       }
 		
-		for (long int ii = 0; ii < read_max; ii++) {
+		for (long long ii = 0; ii < read_max; ii++) {
 			if (std::fgets (buf, 4096, this->fp) == NULL)		
 				break;
       
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 46ccb3d..377e81e 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -29,8 +29,8 @@
 namespace largefile {
 
 	struct LineIndex {
-		long int byte;
-		long int line;
+		long long byte;
+		long long line;
 	};
 	
 	class FileDispatcher : public proactor::InputDispatcher {
@@ -46,7 +46,7 @@ namespace largefile {
 		bool close (void);
 		void * run (void * null);
 
-		void read (long int start, long int N);
+		void read (long long start, long long N);
 		void index (void);
 
 		inline bool isIndexed(void) const { return (this->marks[100].line != -1); }
@@ -68,15 +68,15 @@ namespace largefile {
 	class LineReader : public proactor::Worker {
 	private:
 		FILE * fp;
-		long int numberOfLinesToRead;
-		long int startLine;
+		long long numberOfLinesToRead;
+		long long startLine;
 		LineIndex * marks;
 	public:
 		LineReader (proactor::InputDispatcher * d, 
 						FILE * fp,
 						LineIndex * marks,
-						long int start,
-						long int N);
+						long long start,
+						long long N);
 		virtual ~LineReader (void);
 
 		void * run (void * null);
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index ac01038..275acf5 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -53,11 +53,11 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 
 	int vposition = std::abs((int)gtksheet->vadjustment->value);
 	static long int cursor = 0;
-	float N = vposition, K = 24388, V = (N/K);
+	//	float N = vposition, K = 24388, V = (N/K);
 	
 	switch (event->keyval) {
 		case GDK_F1: {
-			fd->read(500000,1000);
+			fd->read(8570218,1000);
 		}
 		break;
 		

commit 7f59fa8cc4c42fa0bd7c2a80b9b639d4cb879273
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 19 17:02:01 2009 -0400

    (1) Fixed logic error with indexer.
    (2) Fixed integer offset by one bug with reader.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 3776add..30aa68d 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -149,11 +149,9 @@ namespace largefile {
 		// going to get away from having to sequentially read this file in, but once we
 		// have line numbers we can jump throughout the file pretty quickly.
 		while ((ch = std::fgetc(this->fp)) != EOF) {
-			cursor++;
-			
 			if (ch=='\n') count++;
-						
-			if (this->marks[index].byte <= cursor) {
+
+  			if (this->marks[index].byte == cursor++) {
 				this->marks[index].line = count;
 				this->marks[index].byte = byte_beg;
 
@@ -202,7 +200,7 @@ namespace largefile {
 		
 		for (int index = 1; index < 101; index++) {
 			if ((this->startLine + read_max) < this->marks[index].line) {
-				delta = std::abs(this->marks[index-1].line - this->startLine);
+				delta = std::abs(this->marks[index-1].line - this->startLine + 1);
 				offset = this->marks[index-1].byte;
 				break;
 			}

commit cd5d3c02551d4cbbe0e39a7f111abbaa7ef04964
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 19 16:35:01 2009 -0400

    Tracking down bug related to 1 byte offset problems. There's a larger bug
    which seems to affect the line sizes... may be integer related.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index c0147eb..3776add 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -202,7 +202,7 @@ namespace largefile {
 		
 		for (int index = 1; index < 101; index++) {
 			if ((this->startLine + read_max) < this->marks[index].line) {
-				delta = std::abs(this->marks[index-1].line - this->startLine + 1);
+				delta = std::abs(this->marks[index-1].line - this->startLine);
 				offset = this->marks[index-1].byte;
 				break;
 			}
@@ -211,9 +211,10 @@ namespace largefile {
 		std::fseek (this->fp, offset, SEEK_SET);
 
 		// Munch lines to get to our starting point.
-		while (delta-- > 0) {
+		while (delta > 0) {
 			if (std::fgets (buf, 4096, this->fp) == NULL)		
 				break;
+			--delta;
       }
 		
 		for (long int ii = 0; ii < read_max; ii++) {
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 6f3bd42..ac01038 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -57,7 +57,7 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	
 	switch (event->keyval) {
 		case GDK_F1: {
-			fd->read(102583,1000);
+			fd->read(500000,1000);
 		}
 		break;
 		

commit a8045cd7a329c3e8ae4cf7ed7fd87fb3a4093d8a
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 19 16:34:54 2009 -0400

    Updated TODO with current status of branch.

diff --git a/TODO b/TODO
index d72d2a8..385a513 100755
--- a/TODO
+++ b/TODO
@@ -1,16 +1,30 @@
-* Fix heap problem inside of libworkbook
-* libworkbook
-	- Quickly update rows 
-		o This should use native GrowSheet, CheckBounds, etc
-	- Quickly update ranges
-		o Utilzies row/tuple update and pointer arithmetic
-* File dispatcher	
-	- Input/Output
-		o Put a timeout on reader/indexer executions
-		o Automatically index based upon the last read
-	- Caching
-		o Run a periodical reader in the background
-		o Run a periodical indexer in the background
+TODO for GTKWorkbook
+
+* Application
+	- Convert the structures to C++ classes for autotools merge.
+* largefile
+	- Bug fixes
+		o Offset by one for file dispatcher read() method
+		o Integer problem (total line offset) needs to be fixed
+	- Priorities (before merge)
+		o Absolute line goto dialog
+		o Index indicator
+		o Panning/Paging controls
+		o Move shared library into application folder
+	- Priorities (after merge)
+		o Framebuffering and Caching
+		o Statistics on writing to screen, reading, and panning/paging
+		o Staging for the indexer... N percentile increments
+	- Merge
+		o Autotools merge happens *before* largefile merge
+		o Largefile merge happens into an autotools branch
+		o Final merge back into the master branch
+	- Release
+		o Release happens when master branch is fully brought up to date
+		o Largefile must be merged into autotools
+	- Documentation	
+		o Point release after main beta release
+
 * Visualization 
 	- Controls
 		o Page up, page down for panning

commit 832841da06012f4d0551c97ff65db306044e94c5
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 19 15:28:13 2009 -0400

    (1) Fixed bug with File Dispatcher read() method.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index dd21896..c0147eb 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -200,11 +200,10 @@ namespace largefile {
 		long int offset = 0, delta = 0;
 		long int & read_max = this->numberOfLinesToRead;
 		
-		for (int index = 0; index < 101; index++) {
-			if (this->startLine > this->marks[index].line) {
-				delta = this->marks[index].line - read_max - 1;
-				if (index > 0)
-					offset = this->marks[index-1].byte;
+		for (int index = 1; index < 101; index++) {
+			if ((this->startLine + read_max) < this->marks[index].line) {
+				delta = std::abs(this->marks[index-1].line - this->startLine + 1);
+				offset = this->marks[index-1].byte;
 				break;
 			}
 		}
@@ -212,7 +211,7 @@ namespace largefile {
 		std::fseek (this->fp, offset, SEEK_SET);
 
 		// Munch lines to get to our starting point.
-		while (delta > 0) {
+		while (delta-- > 0) {
 			if (std::fgets (buf, 4096, this->fp) == NULL)		
 				break;
       }

commit 51b4c8cb0aa6ff51888b67480d8f47939f0b5155
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 19 15:01:21 2009 -0400

    (1) Updated python create large file script to make first column line numbers.
    (2) Modified license header on shared library files (removed file name).
    (3) Modified license header on source files (removed file names).
    (4) Added basic timing to line indexer.
    (5) Added basic page up/down functionality.

diff --git a/bin/createLargeCSV.py b/bin/createLargeCSV.py
index 21474e6..e703f87 100755
--- a/bin/createLargeCSV.py
+++ b/bin/createLargeCSV.py
@@ -19,7 +19,8 @@ def main():
     maxCols = int(options.columns)
 
     while ii < maxRows:
-        jj = 0
+        fp.write(str(ii+1) + ",")
+        jj = 1
         while jj < maxCols-1:
             choice = random.choice([1,2,3,4,5])
 
diff --git a/shared/concurrent/List.hpp b/shared/concurrent/List.hpp
index dd9339c..130cb5d 100755
--- a/shared/concurrent/List.hpp
+++ b/shared/concurrent/List.hpp
@@ -1,6 +1,4 @@
 /* 
-   List.hpp - Mutex List Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/Lockable.hpp b/shared/concurrent/Lockable.hpp
index f3226c0..31fdc75 100755
--- a/shared/concurrent/Lockable.hpp
+++ b/shared/concurrent/Lockable.hpp
@@ -1,6 +1,4 @@
 /* 
-   Lockable.hpp - Lockable Interface Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/Map.hpp b/shared/concurrent/Map.hpp
index ae5d1c3..9f4b9ce 100755
--- a/shared/concurrent/Map.hpp
+++ b/shared/concurrent/Map.hpp
@@ -1,6 +1,4 @@
 /* 
-   Map.hpp - Mutex Map Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/Mutex.cpp b/shared/concurrent/Mutex.cpp
index d188509..43ec628 100755
--- a/shared/concurrent/Mutex.cpp
+++ b/shared/concurrent/Mutex.cpp
@@ -1,6 +1,4 @@
 /* 
-   Mutex.cpp - Mutex Object(s) Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/Mutex.hpp b/shared/concurrent/Mutex.hpp
index 4a30cda..f4be8a9 100755
--- a/shared/concurrent/Mutex.hpp
+++ b/shared/concurrent/Mutex.hpp
@@ -1,6 +1,4 @@
 /* 
-   Mutex.hpp - Mutex Object(s) Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/Queue.hpp b/shared/concurrent/Queue.hpp
index abac49b..092953b 100755
--- a/shared/concurrent/Queue.hpp
+++ b/shared/concurrent/Queue.hpp
@@ -1,6 +1,4 @@
 /* 
-   Queue.hpp - Mutex Queue Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/Semaphore.cpp b/shared/concurrent/Semaphore.cpp
index 09f0172..4e5a58d 100755
--- a/shared/concurrent/Semaphore.cpp
+++ b/shared/concurrent/Semaphore.cpp
@@ -1,6 +1,4 @@
 /* 
-   Semaphore.cpp - Semaphore Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/Semaphore.hpp b/shared/concurrent/Semaphore.hpp
index e3504cf..3b9e0f4 100755
--- a/shared/concurrent/Semaphore.hpp
+++ b/shared/concurrent/Semaphore.hpp
@@ -1,6 +1,4 @@
 /* 
-   Semaphore.hpp - Semaphore Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/ThreadGroup.cpp b/shared/concurrent/ThreadGroup.cpp
index c3eafb4..f50b487 100755
--- a/shared/concurrent/ThreadGroup.cpp
+++ b/shared/concurrent/ThreadGroup.cpp
@@ -1,6 +1,4 @@
 /* 
-   ThreadGroup.cpp - ThreadGroup Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/ThreadGroup.hpp b/shared/concurrent/ThreadGroup.hpp
index c0c5e41..f907fd4 100755
--- a/shared/concurrent/ThreadGroup.hpp
+++ b/shared/concurrent/ThreadGroup.hpp
@@ -1,6 +1,4 @@
 /* 
-   ThreadGroup.hpp - ThreadGroup Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/network/Socket.hpp b/shared/network/Socket.hpp
index 3662409..5a87a3d 100755
--- a/shared/network/Socket.hpp
+++ b/shared/network/Socket.hpp
@@ -1,6 +1,4 @@
 /* 
-   Socket.hpp - Socket Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/network/Tcp.cpp b/shared/network/Tcp.cpp
index 9a502d2..b9a0572 100755
--- a/shared/network/Tcp.cpp
+++ b/shared/network/Tcp.cpp
@@ -1,6 +1,4 @@
 /* 
-   Tcp.hpp - Tcp Implementation Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -23,133 +21,133 @@
 
 namespace network {
 
-  TcpSocket::TcpSocket (void) {
-    this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
-  }
+	TcpSocket::TcpSocket (void) {
+		this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	}
 
-  TcpSocket::~TcpSocket (void) {
-    this->close();
-  }
+	TcpSocket::~TcpSocket (void) {
+		this->close();
+	}
 
-  void
-  TcpSocket::close (void) {
-    if (this->sockfd > 0)
-      ::close (this->sockfd);
-  }
+	void
+	TcpSocket::close (void) {
+		if (this->sockfd > 0)
+			::close (this->sockfd);
+	}
 	
-  int
-  TcpSocket::send (const char * bytes, size_t length) {
-    return ::write (this->sockfd, bytes, length);
-  }
-
-  int
-  TcpSocket::receive (char * bytes, size_t size) {
-    return ::read (this->sockfd, bytes, size);
-  }
-
-  TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
-    this->port = port;
-
-    memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-    this->sockaddr.sin_family = AF_INET;
-    this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-    this->sockaddr.sin_port = htons (this->port);
-  }
-
-  TcpServerSocket::~TcpServerSocket (void) {
-    this->close();
-  }
-
-  bool
-  TcpServerSocket::start (int backlog = 5) {
-    int opt = 1;
-
-    // This is to prevent conflicts with major services' ports.
-    if (this->port < 1024)
-      return false;
-
-    if (::setsockopt (this->sockfd, 
-		      SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
-      return false;
-
-    if (::bind (this->sockfd,
-		(struct sockaddr *)&(this->sockaddr),
-		sizeof (this->sockaddr)) < 0)
-      return false;
-
-    if (::listen (this->sockfd, backlog) < 0)
-      return false;
-
-    return true;
-  }
-
-  void
-  TcpServerSocket::close (void) {
-    TcpSocket::close();
-  }
-
-  TcpServerSocket::Acceptor *
-  TcpServerSocket::newAcceptor (void) {
-    return new TcpServerSocket::Acceptor (this, this->sockfd);
-  }
-
-  TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
-    this->socket = server;
-    this->sockfd = sockfd;
-  }
-
-  int
-  TcpServerSocket::Acceptor::acceptIncoming (void) {
-    int newfd = -1;
-    static struct sockaddr_in clientaddr;
-    unsigned int x = sizeof (clientaddr);
-
-    if ((newfd = ::accept (this->sockfd, 
-			   (struct sockaddr *)&clientaddr,
-			   &x)) < 0)
-      return -1;
-    return newfd;
-  }
-
-  TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
-    memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-    this->sockaddr.sin_family = AF_INET;
-    this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-  }
-
-  TcpClientSocket::TcpClientSocket (int newfd) {
-    this->sockfd = newfd;
-  }
+	int
+	TcpSocket::send (const char * bytes, size_t length) {
+		return ::write (this->sockfd, bytes, length);
+	}
+
+	int
+	TcpSocket::receive (char * bytes, size_t size) {
+		return ::read (this->sockfd, bytes, size);
+	}
+
+	TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
+		this->port = port;
+
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+		this->sockaddr.sin_port = htons (this->port);
+	}
+
+	TcpServerSocket::~TcpServerSocket (void) {
+		this->close();
+	}
+
+	bool
+	TcpServerSocket::start (int backlog = 5) {
+		int opt = 1;
+
+		// This is to prevent conflicts with major services' ports.
+		if (this->port < 1024)
+			return false;
+
+		if (::setsockopt (this->sockfd, 
+								SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
+			return false;
+
+		if (::bind (this->sockfd,
+						(struct sockaddr *)&(this->sockaddr),
+						sizeof (this->sockaddr)) < 0)
+			return false;
+
+		if (::listen (this->sockfd, backlog) < 0)
+			return false;
+
+		return true;
+	}
+
+	void
+	TcpServerSocket::close (void) {
+		TcpSocket::close();
+	}
+
+	TcpServerSocket::Acceptor *
+	TcpServerSocket::newAcceptor (void) {
+		return new TcpServerSocket::Acceptor (this, this->sockfd);
+	}
+
+	TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
+		this->socket = server;
+		this->sockfd = sockfd;
+	}
+
+	int
+	TcpServerSocket::Acceptor::acceptIncoming (void) {
+		int newfd = -1;
+		static struct sockaddr_in clientaddr;
+		unsigned int x = sizeof (clientaddr);
+
+		if ((newfd = ::accept (this->sockfd, 
+									  (struct sockaddr *)&clientaddr,
+									  &x)) < 0)
+			return -1;
+		return newfd;
+	}
+
+	TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
+		memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+	}
+
+	TcpClientSocket::TcpClientSocket (int newfd) {
+		this->sockfd = newfd;
+	}
 				
-  TcpClientSocket::~TcpClientSocket (void) {
-  }
+	TcpClientSocket::~TcpClientSocket (void) {
+	}
 
-  bool
-  TcpClientSocket::connect (const char * host, int port) {
-    if (!host || (*host == '\0'))
-      return false;
+	bool
+	TcpClientSocket::connect (const char * host, int port) {
+		if (!host || (*host == '\0'))
+			return false;
 
-    if ((this->hp = ::gethostbyname (host)) == NULL)
-      return false;
+		if ((this->hp = ::gethostbyname (host)) == NULL)
+			return false;
  
-    // Copy over the hostname address.
-    memset (&(this->sockaddr),0, sizeof (this->sockaddr));
-    this->sockaddr.sin_family = AF_INET;
-    this->sockaddr.sin_addr.s_addr 
-      = ((struct in_addr *)(this->hp->h_addr))->s_addr;
-    this->sockaddr.sin_port = htons (port);
-
-    if (::connect (this->sockfd,
-		   (struct sockaddr *)&(this->sockaddr),
-		   sizeof (struct sockaddr)) < 0)
-      return false;
+		// Copy over the hostname address.
+		memset (&(this->sockaddr),0, sizeof (this->sockaddr));
+		this->sockaddr.sin_family = AF_INET;
+		this->sockaddr.sin_addr.s_addr 
+			= ((struct in_addr *)(this->hp->h_addr))->s_addr;
+		this->sockaddr.sin_port = htons (port);
+
+		if (::connect (this->sockfd,
+							(struct sockaddr *)&(this->sockaddr),
+							sizeof (struct sockaddr)) < 0)
+			return false;
     
-    return true;
-  }
+		return true;
+	}
 
-  void
-  TcpClientSocket::close (void) {
-    TcpSocket::close();
-  }
+	void
+	TcpClientSocket::close (void) {
+		TcpSocket::close();
+	}
 
 } // end of namespace
diff --git a/shared/network/Tcp.hpp b/shared/network/Tcp.hpp
index 552f93f..02ddc8a 100755
--- a/shared/network/Tcp.hpp
+++ b/shared/network/Tcp.hpp
@@ -1,6 +1,4 @@
 /* 
-   Tcp.hpp - Tcp Implementation Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/proactor/Dispatcher.hpp b/shared/proactor/Dispatcher.hpp
index 259fbbd..124f03d 100755
--- a/shared/proactor/Dispatcher.hpp
+++ b/shared/proactor/Dispatcher.hpp
@@ -1,6 +1,4 @@
 /* 
-   Dispatcher.hpp - Dispatcher Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/proactor/Event.cpp b/shared/proactor/Event.cpp
index 6c8f45f..a1c5c2b 100755
--- a/shared/proactor/Event.cpp
+++ b/shared/proactor/Event.cpp
@@ -1,6 +1,4 @@
 /* 
-   Event.cpp - Event Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/proactor/InputDispatcher.cpp b/shared/proactor/InputDispatcher.cpp
index 27570b3..a46febc 100755
--- a/shared/proactor/InputDispatcher.cpp
+++ b/shared/proactor/InputDispatcher.cpp
@@ -1,6 +1,4 @@
 /* 
-   InputDispatcher.cpp - Input Dispatcher Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/proactor/Proactor.cpp b/shared/proactor/Proactor.cpp
index dff5762..2085c63 100755
--- a/shared/proactor/Proactor.cpp
+++ b/shared/proactor/Proactor.cpp
@@ -1,6 +1,4 @@
 /* 
-   Proactor.cpp - Proactor Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/proactor/Proactor.hpp b/shared/proactor/Proactor.hpp
index 3a33688..793647c 100755
--- a/shared/proactor/Proactor.hpp
+++ b/shared/proactor/Proactor.hpp
@@ -1,6 +1,4 @@
 /* 
-   Proactor.hpp - Proactor Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/proactor/Worker.cpp b/shared/proactor/Worker.cpp
index 19903da..be5863f 100755
--- a/shared/proactor/Worker.cpp
+++ b/shared/proactor/Worker.cpp
@@ -1,6 +1,4 @@
 /* 
-   Worker.cpp - Worker Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/application.c b/src/application.c
index c67dd54..e8a7458 100755
--- a/src/application.c
+++ b/src/application.c
@@ -27,32 +27,32 @@
 /* application.c (static) */
 static int application_method_run (ApplicationState *);
 static guint application_signal_delete_event (GtkWindow *,
-					      GdkEvent *, 
-					      gpointer);
+															 GdkEvent *, 
+															 gpointer);
 static guint application_signal_destroy_event (GtkWidget *, gpointer);
 static void application_method_close (ApplicationState *);
 static ApplicationState* application_object_free (ApplicationState *);
 static ApplicationState* application_object_init (void);
 static Plugin* application_method_loadplugin (ApplicationState *, 
-					      const gchar *);
+															 const gchar *);
 static void application_method_openextension (ApplicationState *,
-					      const gchar *,
-					      gboolean);
+															 const gchar *,
+															 gboolean);
 static guint application_signal_gtknotebook_switchpage (GtkNotebook *,
-							GtkNotebookPage *,
-							gint,
-							Workbook *);
+																		  GtkNotebookPage *,
+																		  gint,
+																		  Workbook *);
 static guint application_signal_gtknotebook_removed (GtkNotebook *,
-						     GtkNotebookPage *,
-						     gint,
-						     Workbook *);
+																	  GtkNotebookPage *,
+																	  gint,
+																	  Workbook *);
 static guint application_signal_gtknotebook_reordered (GtkNotebook *,
-						       GtkNotebookPage *,
-						       gint,
-						       Workbook *);
+																		 GtkNotebookPage *,
+																		 gint,
+																		 Workbook *);
 static guint application_signal_gtksheet_changed (GtkWidget *,
-						  gint, gint,
-						  Sheet *);
+																  gint, gint,
+																  Sheet *);
 
 /* @description: This method takes the argument and clears the string of
    everything except for the directories. Therefore the return value would
@@ -60,16 +60,16 @@ static guint application_signal_gtksheet_changed (GtkWidget *,
 static gchar *
 munchpath (gchar * path_)
 {
-  gchar * path = g_strdup(path_);
-  path = g_strreverse (path);
-  gchar * p = path;
+	gchar * path = g_strdup(path_);
+	path = g_strreverse (path);
+	gchar * p = path;
 
-  while (p && (*p != '\0')) { if (*p == '/') break; p++; }
+	while (p && (*p != '\0')) { if (*p == '/') break; p++; }
 
-  gchar * str = g_strdup (p);
-  str = g_strreverse (str);
-  FREE (path);
-  return str;
+	gchar * str = g_strdup (p);
+	str = g_strreverse (str);
+	FREE (path);
+	return str;
 }
 
 /* @description: This method creates and returns a new initialized 
@@ -79,77 +79,77 @@ munchpath (gchar * path_)
 ApplicationState *
 application_init (int * argc, char *** argv)
 {
-  if (!g_thread_supported ())
-    {
+	if (!g_thread_supported ())
+	{
       g_thread_init (NULL);
       gdk_threads_init ();
-    }
+	}
 
-  ApplicationState * appstate = application_object_init ();
-  int c;
+	ApplicationState * appstate = application_object_init ();
+	int c;
 
-  appstate->absolute_path = munchpath (*argv[0]);
+	appstate->absolute_path = munchpath (*argv[0]);
 
-  /* This block parses the commandline for options. A better example on how
-     this code works can be found on the GNU website at the following URI:
-     http://gnu.org/software/libtool/manual/libc/Using-Getopt.html */
-  while ((c = getopt (*argc, *argv, "c:")) != -1)
-    {
-      switch (c)
+	/* This block parses the commandline for options. A better example on how
+		this code works can be found on the GNU website at the following URI:
+		http://gnu.org/software/libtool/manual/libc/Using-Getopt.html */
+	while ((c = getopt (*argc, *argv, "c:")) != -1)
 	{
-	case 'c':
-	  {
-	    Config * cfg = config_new (optarg);
-	    if (!cfg)
-	      {
-		g_critical ("Failed loading configuration file '%s';" 
-			    " which was specified with -c argument\n", optarg);
-		exit (0);
-		break;
-	      }
-	    appstate->cfg = cfg;
-	  }
-	  break;
-
-	case '?':
-	  {
-	    if (optopt == 'c')
-	      {
-		g_warning ("Option -c requires an argument in order to load"
-			   " a configuration file\n");
-	      }
-	  }
-	  break;
+      switch (c)
+		{
+			case 'c':
+			{
+				Config * cfg = config_new (optarg);
+				if (!cfg)
+				{
+					g_critical ("Failed loading configuration file '%s';" 
+									" which was specified with -c argument\n", optarg);
+					exit (0);
+					break;
+				}
+				appstate->cfg = cfg;
+			}
+			break;
+
+			case '?':
+			{
+				if (optopt == 'c')
+				{
+					g_warning ("Option -c requires an argument in order to load"
+								  " a configuration file\n");
+				}
+			}
+			break;
+		}
 	}
-    }
-
-  gdk_threads_enter ();
-  gtk_init (argc, argv);
-
-  /* Create the window and connect two callback to the signals. */
-  appstate->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-  gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
-		      "destroy",
-		      G_CALLBACK (appstate->signals[SIG_DESTROY_EVENT]),
-		      (gpointer *)appstate);
-  gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
-		      "delete_event",
-		      G_CALLBACK (appstate->signals[SIG_DELETE_EVENT]),
-		      NULL);
+
+	gdk_threads_enter ();
+	gtk_init (argc, argv);
+
+	/* Create the window and connect two callback to the signals. */
+	appstate->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
+							  "destroy",
+							  G_CALLBACK (appstate->signals[SIG_DESTROY_EVENT]),
+							  (gpointer *)appstate);
+	gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
+							  "delete_event",
+							  G_CALLBACK (appstate->signals[SIG_DELETE_EVENT]),
+							  NULL);
   
-  /* Set the initial size of the application; we could load this
-     from a configuration file eventually. */
-  gtk_widget_set_usize (appstate->gtk_window, 1024, 768);
+	/* Set the initial size of the application; we could load this
+		from a configuration file eventually. */
+	gtk_widget_set_usize (appstate->gtk_window, 1024, 768);
   
-  /* Attach the window box to the window and present to the screen. */
-  GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
-  gtk_container_add (GTK_CONTAINER (appstate->gtk_window), window_box);
-  appstate->gtk_window_vbox = window_box;
+	/* Attach the window box to the window and present to the screen. */
+	GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
+	gtk_container_add (GTK_CONTAINER (appstate->gtk_window), window_box);
+	appstate->gtk_window_vbox = window_box;
   
-  gtk_widget_show_all (appstate->gtk_window);
+	gtk_widget_show_all (appstate->gtk_window);
  
-  gdk_threads_leave ();
-  return appstate;
+	gdk_threads_leave ();
+	return appstate;
 }
 
 /* @description: This method destroys the application state object.
@@ -157,41 +157,41 @@ application_init (int * argc, char *** argv)
 static void
 application_method_close (ApplicationState *appstate)
 {
-  ASSERT (appstate != NULL);
+	ASSERT (appstate != NULL);
 
-  *appstate->shutdown = TRUE;
+	*appstate->shutdown = TRUE;
   
-  DESTROY (Workbook, appstate->workbook_first);
+	DESTROY (Workbook, appstate->workbook_first);
 
-  /* This has to be set so that we have a sentinel variable in separate threads
-     if there is a better way to do this than it should be changed inside of
-     the plugins that use these pointers to check if the object is still
-     allocated. */
-  appstate->workbook_first = appstate->workbook_last = NULL;
+	/* This has to be set so that we have a sentinel variable in separate threads
+		if there is a better way to do this than it should be changed inside of
+		the plugins that use these pointers to check if the object is still
+		allocated. */
+	appstate->workbook_first = appstate->workbook_last = NULL;
 
-  application_object_free (appstate);
+	application_object_free (appstate);
 }
 
 static guint
 application_signal_gtknotebook_removed (GtkNotebook * notebook,
-					GtkNotebookPage * page,
-					gint page_num,
-					Workbook * wb)
+													 GtkNotebookPage * page,
+													 gint page_num,
+													 Workbook * wb)
 {
-  ASSERT (wb != NULL);
+	ASSERT (wb != NULL);
 
-  return TRUE;
+	return TRUE;
 }
 
 static guint
 application_signal_gtknotebook_reordered (GtkNotebook * notebook,
-					  GtkNotebookPage * page,
-					  gint page_num,
-					  Workbook * wb)
+														GtkNotebookPage * page,
+														gint page_num,
+														Workbook * wb)
 {
-  ASSERT (wb != NULL);
+	ASSERT (wb != NULL);
 
-  return TRUE;
+	return TRUE;
 }
 
 /* @description: This is the callback for the GtkNotebook 'switch-page' 
@@ -207,63 +207,63 @@ application_signal_gtknotebook_reordered (GtkNotebook * notebook,
    @book: The Workbook object associated with the GtkNotebook.*/
 static guint
 application_signal_gtknotebook_switchpage (GtkNotebook * notebook,
-					   GtkNotebookPage * page,
-					   gint page_num,
-					   Workbook * book)
+														 GtkNotebookPage * page,
+														 gint page_num,
+														 Workbook * book)
 {
-  ASSERT (book != NULL);
+	ASSERT (book != NULL);
 
-  /* Perform the "unfocus" on the old notebook tab. */
-  if (!IS_NULL (book->focus_sheet))
-    {
+	/* Perform the "unfocus" on the old notebook tab. */
+	if (!IS_NULL (book->focus_sheet))
+	{
       book->focus_sheet->has_focus = FALSE;
       book->focus_sheet->notices = 0;
-    }
+	}
 
-  GtkWidget * widget = gtk_notebook_get_nth_page (notebook, page_num);
+	GtkWidget * widget = gtk_notebook_get_nth_page (notebook, page_num);
 
-  ITERATE_BEGIN (Sheet, book->sheet_first);
-  {
-    /* Once we find the right Sheet object we can perform what we need
-       to in order to change the "focus." Finally, set book pointer. */
-    if (it->gtk_box == widget)
+	ITERATE_BEGIN (Sheet, book->sheet_first);
+	{
+		/* Once we find the right Sheet object we can perform what we need
+			to in order to change the "focus." Finally, set book pointer. */
+		if (it->gtk_box == widget)
       {
-	it->page = page_num;
-	it->has_focus = TRUE;
-	it->notices = 0;
+			it->page = page_num;
+			it->has_focus = TRUE;
+			it->notices = 0;
 	
-	/* Reset the label on the notebook tab to the object's name. */
-	gtk_notebook_set_tab_label_text (notebook,
-					 it->gtk_box,
-					 it->name);
-	book->focus_sheet = it;
-	break;
+			/* Reset the label on the notebook tab to the object's name. */
+			gtk_notebook_set_tab_label_text (notebook,
+														it->gtk_box,
+														it->name);
+			book->focus_sheet = it;
+			break;
       }
-  }
-  ITERATE_END ();
-  return TRUE;
+	}
+	ITERATE_END ();
+	return TRUE;
 }
 
 static guint
 application_signal_gtksheet_changed (GtkWidget * gtksheet,
-				     gint row, gint column,
-				     Sheet * sheet)
+												 gint row, gint column,
+												 Sheet * sheet)
 {
-  ASSERT (sheet != NULL);
-  ASSERT (sheet->workbook != NULL);
+	ASSERT (sheet != NULL);
+	ASSERT (sheet->workbook != NULL);
 
-  Workbook * wb = sheet->workbook;
+	Workbook * wb = sheet->workbook;
 
-  if (sheet->notices > 0)
-    {
+	if (sheet->notices > 0)
+	{
       gchar * label 
-	= g_strdup_printf ("%s (%d)", sheet->name, sheet->notices);
+			= g_strdup_printf ("%s (%d)", sheet->name, sheet->notices);
       gtk_notebook_set_tab_label_text (GTK_NOTEBOOK (wb->gtk_notebook),
-				       sheet->gtk_box,
-				       label);
+													sheet->gtk_box,
+													label);
       FREE (label);
-    }
-  return FALSE;
+	}
+	return FALSE;
 }
 
 /* @description: This method frees teh application state object.   
@@ -271,12 +271,12 @@ application_signal_gtksheet_changed (GtkWidget * gtksheet,
 static ApplicationState *
 application_object_free (ApplicationState *appstate)
 {
-  ASSERT (appstate != NULL);
+	ASSERT (appstate != NULL);
 
-  FREE (appstate->shutdown);
-  FREE (appstate->absolute_path);
-  FREE (appstate);
-  return appstate;
+	FREE (appstate->shutdown);
+	FREE (appstate->absolute_path);
+	FREE (appstate);
+	return appstate;
 }
 
 /* @description: This initializes a new application state object. This
@@ -284,39 +284,39 @@ application_object_free (ApplicationState *appstate)
 static ApplicationState *
 application_object_init (void)
 {
-  ApplicationState * app = NEW (ApplicationState);
-
-  /* Members */
-  app->cfg = NULL;
-  app->workbook_first = app->workbook_last = NULL;
-  app->plugin_first = app->plugin_last = NULL;
-  app->gtk_window = NULL;
-  app->gtk_menu = NULL;
-  app->gtk_window_vbox = NULL;
-  app->shutdown = NEW (gboolean);
-  *app->shutdown = FALSE;
-
-  /* Set up the signals. */
-  app->signals[SIG_NOTEBOOK_SWITCHED]
-    = (GSourceFunc)application_signal_gtknotebook_switchpage;
-  app->signals[SIG_NOTEBOOK_REORDERED]
-    = (GSourceFunc)application_signal_gtknotebook_reordered;
-  app->signals[SIG_NOTEBOOK_REMOVED]
-    = (GSourceFunc)application_signal_gtknotebook_removed;
-  app->signals[SIG_DESTROY_EVENT]
-    = (GSourceFunc)application_signal_destroy_event;
-  app->signals[SIG_DELETE_EVENT]
-    = (GSourceFunc)application_signal_delete_event;
-  app->signals[SIG_SHEET_CHANGED]
-    = (GSourceFunc)application_signal_gtksheet_changed;
-
-  /* Methods */
-  app->run = application_method_run;
-  app->close = application_method_close;
-  app->load_plugin = application_method_loadplugin;
-  app->open_extension = application_method_openextension;
-
-  return app;
+	ApplicationState * app = NEW (ApplicationState);
+
+	/* Members */
+	app->cfg = NULL;
+	app->workbook_first = app->workbook_last = NULL;
+	app->plugin_first = app->plugin_last = NULL;
+	app->gtk_window = NULL;
+	app->gtk_menu = NULL;
+	app->gtk_window_vbox = NULL;
+	app->shutdown = NEW (gboolean);
+	*app->shutdown = FALSE;
+
+	/* Set up the signals. */
+	app->signals[SIG_NOTEBOOK_SWITCHED]
+		= (GSourceFunc)application_signal_gtknotebook_switchpage;
+	app->signals[SIG_NOTEBOOK_REORDERED]
+		= (GSourceFunc)application_signal_gtknotebook_reordered;
+	app->signals[SIG_NOTEBOOK_REMOVED]
+		= (GSourceFunc)application_signal_gtknotebook_removed;
+	app->signals[SIG_DESTROY_EVENT]
+		= (GSourceFunc)application_signal_destroy_event;
+	app->signals[SIG_DELETE_EVENT]
+		= (GSourceFunc)application_signal_delete_event;
+	app->signals[SIG_SHEET_CHANGED]
+		= (GSourceFunc)application_signal_gtksheet_changed;
+
+	/* Methods */
+	app->run = application_method_run;
+	app->close = application_method_close;
+	app->load_plugin = application_method_loadplugin;
+	app->open_extension = application_method_openextension;
+
+	return app;
 }
 
 /* @description: This is called from main() when we want to start the
@@ -326,8 +326,8 @@ application_object_init (void)
 static int
 application_method_run (ApplicationState *appstate)
 {
-  if (appstate->cfg)
-    {
+	if (appstate->cfg)
+	{
       Config * cfg = appstate->cfg;
       cfg->open (cfg);
      
@@ -335,52 +335,52 @@ application_method_run (ApplicationState *appstate)
       ConfigRow * load = cfg->get_row (cfg, "application", "load");
 
       /* Did a little bit of fixing here. We needed something to specify that
-	 certain extensions will start automatically when the application is
-	 started. */
+			certain extensions will start automatically when the application is
+			started. */
       if (!IS_NULL (load))
-	{
-	  ConfigVector * ext = load->get_vector (load, "extensions");
-	  gchar * block = NULL;
-	  gint ii = 0;
-
-	  if (IS_NULL (ext))
-	    {
-	      g_critical ("Config 'extensions' vector is NULL");
-	      return -1;
-	    }
+		{
+			ConfigVector * ext = load->get_vector (load, "extensions");
+			gchar * block = NULL;
+			gint ii = 0;
+
+			if (IS_NULL (ext))
+			{
+				g_critical ("Config 'extensions' vector is NULL");
+				return -1;
+			}
       
-	  while ((block = ext->get(ext, ii)) != NULL)
-	    {
-	      ConfigPair * run = cfg->get_pair (cfg, block, "onLoad", "run");
+			while ((block = ext->get(ext, ii)) != NULL)
+			{
+				ConfigPair * run = cfg->get_pair (cfg, block, "onLoad", "run");
 	      
-	      if (run && (strcmp (run->value, "1") == 0))
-		{
-		  ConfigPair * filename 
-		    = cfg->get_pair (cfg, block, "linux", "filename");
-
-		  if (!IS_NULL (filename) && !IS_NULLSTR (filename->value))
-		    {
-		      gboolean RelativePath 
-			= (filename->value[0] == '/') ? FALSE : TRUE;
-
-		      appstate->open_extension (appstate, 
-						filename->value, 
-						RelativePath);
-		    }
+				if (run && (strcmp (run->value, "1") == 0))
+				{
+					ConfigPair * filename 
+						= cfg->get_pair (cfg, block, "linux", "filename");
+
+					if (!IS_NULL (filename) && !IS_NULLSTR (filename->value))
+					{
+						gboolean RelativePath 
+							= (filename->value[0] == '/') ? FALSE : TRUE;
+
+						appstate->open_extension (appstate, 
+														  filename->value, 
+														  RelativePath);
+					}
+				}
+				ii++;
+			}
 		}
-	      ii++;
-	    }
 	}
-    }
-
-  /* Start the GTK+ main loop; make sure it is surrounded in the 
-     thread calls. GTK+ "releases" the current lock after every loop
-     interation. This allows us to call gdk_threads_enter/leave inside
-     of another thread. */
-  gdk_threads_enter ();
-  gtk_main ();
-  gdk_threads_leave ();
-  return 0;
+
+	/* Start the GTK+ main loop; make sure it is surrounded in the 
+		thread calls. GTK+ "releases" the current lock after every loop
+		interation. This allows us to call gdk_threads_enter/leave inside
+		of another thread. */
+	gdk_threads_enter ();
+	gtk_main ();
+	gdk_threads_leave ();
+	return 0;
 }
 
 /* @description: This method loads a shared library (plugin) from disk.
@@ -388,20 +388,20 @@ application_method_run (ApplicationState *appstate)
    @filename: The string to the file that we're looking to load.*/
 static Plugin *
 application_method_loadplugin (ApplicationState * appstate, 
-			       const gchar * filename)
+										 const gchar * filename)
 {
-  ASSERT (appstate != NULL);
+	ASSERT (appstate != NULL);
   
-  Plugin * plugin = plugin_open (filename);
+	Plugin * plugin = plugin_open (filename);
   
-  if (plugin == NULL)
-    return NULL;
+	if (plugin == NULL)
+		return NULL;
 
-  LINK_OBJECT (appstate->plugin_first, 
-	       appstate->plugin_last, 
-	       plugin);
+	LINK_OBJECT (appstate->plugin_first, 
+					 appstate->plugin_last, 
+					 plugin);
 
-  return plugin;
+	return plugin;
 }
 
 /* @description: This is the callback to GtkMain's "delete" event. This is
@@ -411,21 +411,21 @@ application_method_loadplugin (ApplicationState * appstate,
    @p: NULL */
 static guint
 application_signal_delete_event (GtkWindow * window, 
-				 GdkEvent * event,
-				 gpointer p)
+											GdkEvent * event,
+											gpointer p)
 {
-  GtkWidget * dialog 
-    = gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
-			      GTK_MESSAGE_QUESTION,
-			      GTK_BUTTONS_YES_NO,
-			      "Are you sure that you want to quit?");
-  gtk_window_set_title (GTK_WINDOW (dialog), "Close Application");
-
-  gint result = gtk_dialog_run (GTK_DIALOG (dialog));
+	GtkWidget * dialog 
+		= gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
+										  GTK_MESSAGE_QUESTION,
+										  GTK_BUTTONS_YES_NO,
+										  "Are you sure that you want to quit?");
+	gtk_window_set_title (GTK_WINDOW (dialog), "Close Application");
+
+	gint result = gtk_dialog_run (GTK_DIALOG (dialog));
   
-  gtk_widget_destroy (dialog);
+	gtk_widget_destroy (dialog);
 
-  return (result == GTK_RESPONSE_YES) ? FALSE : TRUE;
+	return (result == GTK_RESPONSE_YES) ? FALSE : TRUE;
 }
 
 /* @description: This is the callback to the "destroy" signal that is
@@ -435,20 +435,20 @@ application_signal_delete_event (GtkWindow * window,
 static guint
 application_signal_destroy_event (GtkWidget *window, gpointer data)
 {
-  ApplicationState * appstate = (ApplicationState *)data;
-  *appstate->shutdown = TRUE;
+	ApplicationState * appstate = (ApplicationState *)data;
+	*appstate->shutdown = TRUE;
 
-  /* Because of a change to the Plugin architecture it will now yield until
-     all threads that were instatiated are closed properly. We use the 
-     appstate->workbook_first variable in order to test for NULL. */
-  gdk_threads_leave();
-  DESTROY (Plugin, appstate->plugin_first);
-  gdk_threads_enter();
+	/* Because of a change to the Plugin architecture it will now yield until
+		all threads that were instatiated are closed properly. We use the 
+		appstate->workbook_first variable in order to test for NULL. */
+	gdk_threads_leave();
+	DESTROY (Plugin, appstate->plugin_first);
+	gdk_threads_enter();
 
-  appstate->plugin_first = appstate->plugin_last = NULL;
+	appstate->plugin_first = appstate->plugin_last = NULL;
 
-  gtk_main_quit ();
-  return FALSE;
+	gtk_main_quit ();
+	return FALSE;
 }
 
 /* @description: This method loads an extension from the filename
@@ -458,56 +458,56 @@ application_signal_destroy_event (GtkWidget *window, gpointer data)
    @absolute_path: Is the string an absolute or relative path? */
 static void
 application_method_openextension (ApplicationState * app, 
-				  const gchar * filename,
-				  gboolean absolute_path)
+											 const gchar * filename,
+											 gboolean absolute_path)
 {
-  ASSERT (app != NULL);
-  gchar * fname = NULL;
+	ASSERT (app != NULL);
+	gchar * fname = NULL;
   
-  if (absolute_path)
-    {
+	if (absolute_path)
+	{
       fname = g_strconcat (app->absolute_path, 
-			   filename,
-			   NULL);
-    }
-  else
-    {
+									filename,
+									NULL);
+	}
+	else
+	{
       fname = g_strdup (filename);
-    }
+	}
 
-  Plugin * plugin = NULL;
-  if ((plugin = app->load_plugin (app, fname)) != NULL)
-    {
+	Plugin * plugin = NULL;
+	if ((plugin = app->load_plugin (app, fname)) != NULL)
+	{
       typedef Workbook * (*Plugin_Main) (ApplicationState *, Plugin *);
       Plugin_Main plugin_main;
 	  
       if ((plugin_main 
-	   = plugin->method_register (plugin, "plugin_main")) == NULL)
-	{
-	  g_critical ("Unable to register method with symbol 'plugin_main'");
-	  exit (1);
-	}
+			  = plugin->method_register (plugin, "plugin_main")) == NULL)
+		{
+			g_critical ("Unable to register method with symbol 'plugin_main'");
+			exit (1);
+		}
 
       Workbook * wb = plugin_main (app, plugin);
       if (wb == NULL)
-	{
-	  g_critical ("Plugin returned a NULL pointer instead of allocated"
-		      " workbook.");
-	  exit (1);
-	}
+		{
+			g_critical ("Plugin returned a NULL pointer instead of allocated"
+							" workbook.");
+			exit (1);
+		}
       else
-	{
-	  /* Attach all of the signals for the Workbook object. */
-	  gtk_signal_connect (GTK_OBJECT (wb->gtk_notebook),
-			      "switch-page",
-			   (GtkSignalFunc)app->signals[SIG_NOTEBOOK_SWITCHED], 
-			      (gpointer)wb);
+		{
+			/* Attach all of the signals for the Workbook object. */
+			gtk_signal_connect (GTK_OBJECT (wb->gtk_notebook),
+									  "switch-page",
+									  (GtkSignalFunc)app->signals[SIG_NOTEBOOK_SWITCHED], 
+									  (gpointer)wb);
 	  
-	  LINK_OBJECT (app->workbook_first, app->workbook_last, wb);
+			LINK_OBJECT (app->workbook_first, app->workbook_last, wb);
+		}
 	}
-    }
 
-  if (absolute_path)
-    FREE (fname);
+	if (absolute_path)
+		FREE (fname);
 }
 
diff --git a/src/application.h b/src/application.h
index 97eced7..1df1b15 100755
--- a/src/application.h
+++ b/src/application.h
@@ -28,35 +28,35 @@ typedef struct _ApplicationState ApplicationState;
 #include "plugin.h"
 
 enum
-  {
-    SIG_DESTROY_EVENT = 0,
-    SIG_DELETE_EVENT,
-    SIG_NOTEBOOK_SWITCHED,
-    SIG_NOTEBOOK_REMOVED,
-    SIG_NOTEBOOK_REORDERED,
-    SIG_SHEET_CHANGED,
-    /**/
-    MAX_SIGNALS
-  };
+	{
+		SIG_DESTROY_EVENT = 0,
+		SIG_DELETE_EVENT,
+		SIG_NOTEBOOK_SWITCHED,
+		SIG_NOTEBOOK_REMOVED,
+		SIG_NOTEBOOK_REORDERED,
+		SIG_SHEET_CHANGED,
+		/**/
+		MAX_SIGNALS
+	};
 
 struct _ApplicationState
 {
-  /* Members */
-  GSourceFunc signals[MAX_SIGNALS];
-  Config * cfg;
-  Workbook * workbook_first, * workbook_last;
-  Plugin * plugin_first, * plugin_last;
-  GtkWidget * gtk_window;
-  GtkWidget * gtk_menu;
-  GtkWidget * gtk_window_vbox;
-  gchar * absolute_path;
-  gboolean * shutdown;
+	/* Members */
+	GSourceFunc signals[MAX_SIGNALS];
+	Config * cfg;
+	Workbook * workbook_first, * workbook_last;
+	Plugin * plugin_first, * plugin_last;
+	GtkWidget * gtk_window;
+	GtkWidget * gtk_menu;
+	GtkWidget * gtk_window_vbox;
+	gchar * absolute_path;
+	gboolean * shutdown;
 
-  /* Methods */
-  int (*run) (ApplicationState *);
-  void (*close) (ApplicationState *);
-  void (*open_extension) (ApplicationState *, const gchar *, gboolean);
-  Plugin *(*load_plugin) (ApplicationState *, const gchar *);
+	/* Methods */
+	int (*run) (ApplicationState *);
+	void (*close) (ApplicationState *);
+	void (*open_extension) (ApplicationState *, const gchar *, gboolean);
+	Plugin *(*load_plugin) (ApplicationState *, const gchar *);
 };
 
 /* application.c */
diff --git a/src/include.h b/src/include.h
index 6b06e6b..c46bbc9 100755
--- a/src/include.h
+++ b/src/include.h
@@ -26,48 +26,48 @@
 #define PCLOSE(fp) { if (fp != NULL) { pclose(fp); fp = NULL; } }
 
 #define UNLINK_OBJECT(current) if (current && current->next && current->prev) \
-    { \
-      current->prev->next = current->next; \
-      current->next->prev = current->prev; \
-      current->next = NULL; \
-      current->prev = NULL; \
-    } \
-  else if (current && current->next) \
-    { \
-      current->next->prev = NULL; \
-      current->next = NULL; \
-    } \
-  else if (current && current->prev) \
-    { \
-      current->prev->next = NULL; \
-      current->prev = NULL; \
-    }
+	{																							\
+      current->prev->next = current->next;										\
+      current->next->prev = current->prev;										\
+      current->next = NULL;															\
+      current->prev = NULL;															\
+	}																							\
+	else if (current && current->next)												\
+	{																							\
+      current->next->prev = NULL;													\
+      current->next = NULL;															\
+	}																							\
+	else if (current && current->prev)												\
+	{																							\
+      current->prev->next = NULL;													\
+      current->prev = NULL;															\
+	}
 
 #define LINK_OBJECT(first, last, current) if (!first) \
-    { \
-      first = current; \
-      last = NULL; \
-      current->next = NULL; \
-      current->prev = NULL; \
-    } \
-  else \
-    { \
-      if (!last) \
-        { \
-          last = current; \
-          current->next = NULL; \
-          current->prev = first; \
-          first->next = current; \
-          first->prev = NULL; \
-        } \
-      else \
-        { \
-          current->prev = last; \
-	  current->next = NULL; \
-	  last->next = current;	\
-          last = current; \
-        } \
-    }
+	{																	\
+      first = current;											\
+      last = NULL;												\
+      current->next = NULL;									\
+      current->prev = NULL;									\
+	}																	\
+	else																\
+	{																	\
+      if (!last)													\
+		{																\
+			last = current;										\
+			current->next = NULL;								\
+			current->prev = first;								\
+			first->next = current;								\
+			first->prev = NULL;									\
+		}																\
+      else															\
+		{																\
+			current->prev = last;								\
+			current->next = NULL;								\
+			last->next = current;								\
+			last = current;										\
+		}																\
+	}
 
 #define gmalloc(size) g_malloc(size)
 #define gfree(pointer) { g_free(pointer); pointer = NULL; }
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 90c82f8..dd21896 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -202,7 +202,7 @@ namespace largefile {
 		
 		for (int index = 0; index < 101; index++) {
 			if (this->startLine > this->marks[index].line) {
-				delta = this->marks[index].line - read_max;
+				delta = this->marks[index].line - read_max - 1;
 				if (index > 0)
 					offset = this->marks[index-1].byte;
 				break;
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index d4cafae..6f3bd42 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -52,7 +52,7 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
 
 	int vposition = std::abs((int)gtksheet->vadjustment->value);
-
+	static long int cursor = 0;
 	float N = vposition, K = 24388, V = (N/K);
 	
 	switch (event->keyval) {
@@ -62,14 +62,20 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 		break;
 		
 		case GDK_Page_Up: {
-			
+			fd->read(cursor, 100);
+			cursor += 100;
 		}
-		break;
+		return TRUE;
 
 		case GDK_Page_Down: {
+			if (cursor <= 100)
+				cursor = 0;
+			else
+				cursor -= 100;
 			
+			fd->read(cursor, 100);
 		}
-		break;
+		return TRUE;
 	}
 	return FALSE;
 }
diff --git a/src/main.c b/src/main.c
index 0a95610..3e5a2ac 100755
--- a/src/main.c
+++ b/src/main.c
@@ -21,12 +21,12 @@
 int 
 main(int argc, char *argv[])
 {
-  ApplicationState *app = application_init (&argc, &argv);
+	ApplicationState *app = application_init (&argc, &argv);
 
-  app->run (app);
-  app->close (app);
+	app->run (app);
+	app->close (app);
 
-  return 0; 
+	return 0; 
 }
 
 
diff --git a/src/plugin.c b/src/plugin.c
index 500240a..62b9375 100755
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -30,169 +30,169 @@ static PluginMethod *pluginmethod_object_init (Plugin *);
 static PluginMethod *pluginmethod_object_free (PluginMethod *);
 static void pluginmethod_method_deregister (PluginMethod *, Plugin *);
 static GThread *plugin_method_create_thread (Plugin *,
-					     GThreadFunc,
-					     gpointer);
+															GThreadFunc,
+															gpointer);
 
 Plugin *
 plugin_open (const gchar * filename)
 {
-  if (!filename || (*filename == '\0'))
-    return NULL;
+	if (!filename || (*filename == '\0'))
+		return NULL;
 
-  Plugin * plug = plugin_object_init ();
+	Plugin * plug = plugin_object_init ();
 
-  if ((plug->pfnhandle = LIBRARY_OPEN(filename)) == NULL)
-    {
+	if ((plug->pfnhandle = LIBRARY_OPEN(filename)) == NULL)
+	{
       fprintf (stderr, "%s\n", LIBRARY_ERROR());
       exit (1);
-    }
-  return plug;
+	}
+	return plug;
 }
 
 static Plugin *
 plugin_object_init (void)
 {
-  Plugin * plug = NEW (Plugin);
+	Plugin * plug = NEW (Plugin);
   
-  /* Members */
-  plug->pfnhandle = NULL;
-  plug->next = NULL;
-  plug->prev = NULL;
-  plug->first = NULL;
-  plug->last = NULL;
-  plug->threads = g_ptr_array_new ();
-
-  /* Methods */
-  plug->destroy = plugin_method_destroy;
-  plug->method_register = plugin_method_symbol_register;
-  plug->method_deregister = plugin_method_symbol_deregister;
-  plug->create_thread = plugin_method_create_thread;
-
-  return plug;
+	/* Members */
+	plug->pfnhandle = NULL;
+	plug->next = NULL;
+	plug->prev = NULL;
+	plug->first = NULL;
+	plug->last = NULL;
+	plug->threads = g_ptr_array_new ();
+
+	/* Methods */
+	plug->destroy = plugin_method_destroy;
+	plug->method_register = plugin_method_symbol_register;
+	plug->method_deregister = plugin_method_symbol_deregister;
+	plug->create_thread = plugin_method_create_thread;
+
+	return plug;
 }
 
 static GThread *
 plugin_method_create_thread (Plugin * plugin,
-			     GThreadFunc thread_function,
-			     gpointer data)
+									  GThreadFunc thread_function,
+									  gpointer data)
 {
-  ASSERT (plugin != NULL);
+	ASSERT (plugin != NULL);
 
-  GThread * runnable = NULL;
-  GError * err = NULL;
+	GThread * runnable = NULL;
+	GError * err = NULL;
 
-  if ((runnable = g_thread_create (thread_function, data,
-				   TRUE, &err)) == NULL)
-    {
+	if ((runnable = g_thread_create (thread_function, data,
+												TRUE, &err)) == NULL)
+	{
       g_warning ("Failed creating thread; ERROR %s", err->message);
       g_error_free (err);
       return NULL;
-    }
-  g_ptr_array_add (plugin->threads, (gpointer)runnable);
-  return runnable;
+	}
+	g_ptr_array_add (plugin->threads, (gpointer)runnable);
+	return runnable;
 } 
 
 static Plugin *
 plugin_object_free (Plugin * plugin)
 {
-  if (!plugin)
-    return NULL;
+	if (!plugin)
+		return NULL;
 
-  plugin->first = plugin->last = NULL;
+	plugin->first = plugin->last = NULL;
 
-  g_ptr_array_free (plugin->threads, TRUE);
+	g_ptr_array_free (plugin->threads, TRUE);
 
-  FREE (plugin);
-  return plugin;
+	FREE (plugin);
+	return plugin;
 }
 
 static void
 plugin_method_destroy (Plugin * plugin)
 {
-  if (!plugin)
-    return;
+	if (!plugin)
+		return;
 
-  PluginMethod * current = plugin->first, * next = NULL;
-  while (current)
-    {
+	PluginMethod * current = plugin->first, * next = NULL;
+	while (current)
+	{
       next = current->next;
       current->deregister (current, plugin);
       current = next;
-    }
+	}
 
-  for (guint ii = 0; ii < plugin->threads->len; ii++)
-    {
+	for (guint ii = 0; ii < plugin->threads->len; ii++)
+	{
       GThread * thread 
-	= (GThread *)g_ptr_array_remove_index_fast (plugin->threads, ii);
+			= (GThread *)g_ptr_array_remove_index_fast (plugin->threads, ii);
       g_thread_join (thread);
-    }
+	}
 
-  UNLINK_OBJECT (plugin);
-  LIBRARY_CLOSE (plugin->pfnhandle);
-  plugin_object_free (plugin);
+	UNLINK_OBJECT (plugin);
+	LIBRARY_CLOSE (plugin->pfnhandle);
+	plugin_object_free (plugin);
 }
 
 static void
 plugin_method_symbol_deregister (Plugin * plugin, PluginMethod * method)
 {
-  if (!plugin || !method)
-    return;
+	if (!plugin || !method)
+		return;
 
-  method->deregister (method, plugin);
+	method->deregister (method, plugin);
 }
 
 static void *
 plugin_method_symbol_register (Plugin * plugin, gchar * symbol)
 {
-  if (IS_NULLSTR (symbol))
-    return NULL;
+	if (IS_NULLSTR (symbol))
+		return NULL;
 
-  PluginMethod * plugm = pluginmethod_object_init (plugin);
+	PluginMethod * plugm = pluginmethod_object_init (plugin);
 
-  if ((plugm->pfnmethod 
-       = LIBRARY_SYM(plugin->pfnhandle, symbol)) == NULL)
-    {
+	if ((plugm->pfnmethod 
+		  = LIBRARY_SYM(plugin->pfnhandle, symbol)) == NULL)
+	{
       fprintf (stderr, "%s\n", LIBRARY_ERROR());
       exit (1);
-    }
+	}
 
-  LINK_OBJECT (plugin->first, plugin->last, plugm); 
-  return plugm->pfnmethod;
+	LINK_OBJECT (plugin->first, plugin->last, plugm); 
+	return plugm->pfnmethod;
 }
 
 static PluginMethod *
 pluginmethod_object_init (Plugin * plugin)
 {
-  PluginMethod * plugm = NEW (PluginMethod);
+	PluginMethod * plugm = NEW (PluginMethod);
 
-  /* Members */
-  plugm->pfnmethod = NULL;
-  plugm->plugin = plugin;
+	/* Members */
+	plugm->pfnmethod = NULL;
+	plugm->plugin = plugin;
 
-  /* Methods */
-  plugm->deregister = pluginmethod_method_deregister;
+	/* Methods */
+	plugm->deregister = pluginmethod_method_deregister;
 
-  plugm->next = NULL;
-  plugm->prev = NULL;
-  return plugm;
+	plugm->next = NULL;
+	plugm->prev = NULL;
+	return plugm;
 }
 
 static PluginMethod *
 pluginmethod_object_free (PluginMethod * method)
 {
-  if (!method)
-    return NULL;
+	if (!method)
+		return NULL;
 
-  FREE (method);
-  return method;
+	FREE (method);
+	return method;
 }
 
 static void
 pluginmethod_method_deregister (PluginMethod * method, Plugin * plugin)
 {
-  if (!method)
-    return;
+	if (!method)
+		return;
 
-  UNLINK_OBJECT (method);
-  pluginmethod_object_free (method);
+	UNLINK_OBJECT (method);
+	pluginmethod_object_free (method);
 }
diff --git a/src/plugin.h b/src/plugin.h
index 753fb27..6b4a68f 100755
--- a/src/plugin.h
+++ b/src/plugin.h
@@ -43,28 +43,28 @@ typedef void * LibraryHandle;
 
 struct _Plugin
 {
-  /* Members */
-  LibraryHandle pfnhandle;
-  PluginMethod * first, * last;
-  Plugin * next, * prev;
-  GPtrArray * threads;
+	/* Members */
+	LibraryHandle pfnhandle;
+	PluginMethod * first, * last;
+	Plugin * next, * prev;
+	GPtrArray * threads;
 
-  /* Methods */
-  void *(*method_register) (Plugin *, gchar *);
-  void (*method_deregister) (Plugin *, PluginMethod *);
-  void (*destroy) (Plugin *);
-  GThread *(*create_thread) (Plugin *, GThreadFunc, gpointer);
+	/* Methods */
+	void *(*method_register) (Plugin *, gchar *);
+	void (*method_deregister) (Plugin *, PluginMethod *);
+	void (*destroy) (Plugin *);
+	GThread *(*create_thread) (Plugin *, GThreadFunc, gpointer);
 };
 
 struct _PluginMethod
 {
-  /* Members */
-  void * pfnmethod;
-  PluginMethod * next, * prev;
-  Plugin * plugin;
+	/* Members */
+	void * pfnmethod;
+	PluginMethod * next, * prev;
+	Plugin * plugin;
 
-  /* Methods */
-  void (*deregister) (PluginMethod *method, Plugin *plugin);
+	/* Methods */
+	void (*deregister) (PluginMethod *method, Plugin *plugin);
 };
 
 /* plugin.c */
diff --git a/src/realtime/Packet.cpp b/src/realtime/Packet.cpp
index bd63a35..8a4d516 100755
--- a/src/realtime/Packet.cpp
+++ b/src/realtime/Packet.cpp
@@ -18,17 +18,17 @@
 */
 #include "Packet.hpp"
 
-#define WORD(d,buf,word) if (buf.length() > 0) { \
-    size_t index = buf.find_first_of (d, 0);	 \
-    if (index == std::string::npos) {		 \
-      word = buf;				 \
-      buf.clear();				 \
-    }						 \
-    else {					 \
-      word = buf.substr (0, index);		 \
-      buf = buf.substr (index+1, buf.length());	 \
-    }						 \
-  }
+#define WORD(d,buf,word) if (buf.length() > 0) {	\
+		size_t index = buf.find_first_of (d, 0);		\
+		if (index == std::string::npos) {				\
+			word = buf;											\
+			buf.clear();										\
+		}															\
+		else {													\
+			word = buf.substr (0, index);					\
+			buf = buf.substr (index+1, buf.length());	\
+		}															\
+	}
 
 namespace realtime {
 

commit fd984c7ce416494f855022a6c83f02efdd5c815b
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 19 13:33:43 2009 -0400

    (1) Removed actual line reading from FileDispatcher open().
    (2) Refactored index for actual byte position/line count on one pass.
    (3) Crude modification to FileDispatcher read() to accept absolute lines.

diff --git a/shared/proactor/Dispatcher.cpp b/shared/proactor/Dispatcher.cpp
index 18cc953..c7a9ded 100755
--- a/shared/proactor/Dispatcher.cpp
+++ b/shared/proactor/Dispatcher.cpp
@@ -1,6 +1,4 @@
 /* 
-   Dispatcher.hpp - Dispatcher Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -28,30 +26,29 @@ namespace proactor {
       
   }
    
-  bool
-  Dispatcher::addWorker (Worker * w) {
-    WorkerListType::iterator it = std::find (this->workers.begin(),
-					     this->workers.end(),
-					     w);
-    if (it == this->workers.end())
-      {
-	this->workers.push_back (w);
-	return w->start();
+	bool
+	Dispatcher::addWorker (Worker * w) {
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+		if (it == this->workers.end()) {
+			this->workers.push_back (w);
+			return w->start();
       }
-    return false;
-  }
+		return false;
+	}
   
-  bool
-  Dispatcher::removeWorker (Worker * w) {
-    WorkerListType::iterator it = std::find (this->workers.begin(),
-					     this->workers.end(),
-					     w);
-
-    if (it == this->workers.end())
-      return false;
+	bool
+	Dispatcher::removeWorker (Worker * w) {
+		WorkerListType::iterator it = std::find (this->workers.begin(),
+															  this->workers.end(),
+															  w);
+
+		if (it == this->workers.end())
+			return false;
   
-    this->workers.erase (it);
-    return true;
-  }
+		this->workers.erase (it);
+		return true;
+	}
 
 } // end of namesapce
diff --git a/shared/proactor/InputDispatcher.cpp b/shared/proactor/InputDispatcher.cpp
index faf8e51..27570b3 100755
--- a/shared/proactor/InputDispatcher.cpp
+++ b/shared/proactor/InputDispatcher.cpp
@@ -24,10 +24,10 @@
 namespace proactor {
 
   InputDispatcher::~InputDispatcher (void) {
-      this->inputQueue.lock();
-      while (this->inputQueue.size() > 0)
-	this->inputQueue.pop();
-      this->inputQueue.unlock();
+	  this->inputQueue.lock();
+	  while (this->inputQueue.size() > 0)
+		  this->inputQueue.pop();
+	  this->inputQueue.unlock();
   }
 
   void *
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 1c491f5..90c82f8 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -21,6 +21,8 @@
 #include <concurrent/ThreadPool.hpp>
 #include <concurrent/ScopedMemoryLock.hpp>
 #include <cstdio>
+#include <sys/time.h>
+#include <unistd.h>
 
 namespace largefile {
 	
@@ -37,7 +39,7 @@ namespace largefile {
 
 	void
 	FileDispatcher::read (long int start, long int N) {
-		LineReader * reader = new LineReader (this, this->fp, start, N);
+		LineReader * reader = new LineReader (this, this->fp, this->marks, start, N);
 		this->addWorker (reader);
 	}
 
@@ -57,37 +59,21 @@ namespace largefile {
 			return false;
 		}
 
-		// Take the relative byte position, e.g. .75 * byte_end, and seek backwards until
-		// we get a newline. We now have the line at that relative byte position. Set it
-		// to the marks array so that we can quick line seek.
+		// Take the relative byte position, e.g. .75 * byte_end, and we now have the a relative
+		// line at that byte position for indexing at a later point in time.
 		std::fseek (this->fp, 0L, SEEK_END);
 		long int byte_end = std::ftell (this->fp);
 
+		this->marks[0].byte = 0;
+		this->marks[0].line = 0;
+		
 		// Compute fuzzy relative position, and set line to -1 for indexing.
-		for (int ii = 0; ii < 101; ii++) {
+		for (int ii = 1; ii < 101; ii++) {
 			float N = ii, K = 10000;
 			this->marks[ii].byte = (long int)((N/K) * byte_end);
 			this->marks[ii].line = -1;
 		}
 
-		long int cursor = 1;
-				
-		// Get actual relative position (where line begins) from fuzzy.
-		while (!feof (this->fp) && (cursor < 101)) {
-			int c = 0, ii = 0;
-			std::fseek(this->fp, this->marks[cursor].byte, SEEK_SET);
-
-			// It looks fancy, but it really isn't.
-			while ((c = fgetc (this->fp)) != EOF) {
-				if ((c == '\r') || (c=='\n')) break;
-				std::fseek(this->fp, this->marks[cursor].byte - (++ii) - 1, SEEK_CUR); 
-			}
-
-			this->marks[cursor].byte = (this->marks[cursor].byte - ii);
-			cursor++;
-			clearerr(this->fp);
-		}
-		
 		std::fseek (this->fp, 0L, SEEK_SET);
 		
 		concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
@@ -110,7 +96,6 @@ namespace largefile {
 	FileDispatcher::run (void * null) {
 		this->running = true;
 
-		// Start the indexer thread. 
 		this->index();
 		
 		while (this->running == true) {
@@ -118,7 +103,7 @@ namespace largefile {
 				this->running = false;
 				break;
 			}
-			
+
 			this->inputQueue.lock();
       
 			while (this->inputQueue.size() > 0) {
@@ -130,7 +115,7 @@ namespace largefile {
 
 			this->inputQueue.unlock();
 
-			Thread::sleep (5);
+			concurrent::Thread::sleep(5);
 		}
 
 		return NULL;
@@ -151,60 +136,55 @@ namespace largefile {
 	void *
 	LineIndexer::run (void * null) {
 		this->running = true;
+		int ch, index = 0;
+		long long int cursor = 0, count = 0, byte_beg = 0;
 
-		std::cout<<"index begun..."<<std::flush;
-		
-		int pos = 1;
-		for (; pos < 101; pos++) {
-			if (this->marks[pos].line == -1)
-				break;
-		}
-
-		// Nothing to index.
-		if (pos == 100) {
-			this->running = false;
-			return NULL;
-		}
+		struct timeval start, end;
 		
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 
-		char buf[4096];
-		long int start = std::ftell (this->fp), cursor = 0, count = 0, byte_end = this->marks[pos].byte;
-		std::fseek(this->fp, (pos==0) ? 0 : this->marks[pos-1].byte, SEEK_SET);
-
-		// We need to get a absoltue line number for the relative position. We're not
+		gettimeofday(&start, NULL);
+		
+		// We need to get a absoltue line number from the relative position. We're not
 		// going to get away from having to sequentially read this file in, but once we
 		// have line numbers we can jump throughout the file pretty quickly.
-		while (cursor < byte_end) {	
-			if (std::fgets (buf, 4096, this->fp) == NULL)
-				break;
+		while ((ch = std::fgetc(this->fp)) != EOF) {
+			cursor++;
+			
+			if (ch=='\n') count++;
+						
+			if (this->marks[index].byte <= cursor) {
+				this->marks[index].line = count;
+				this->marks[index].byte = byte_beg;
 
-			cursor = std::ftell(this->fp);
-			count++;
+				index++;
+				
+				if (index == 101)
+					break;
+			}
+
+			if (ch=='\n') byte_beg = cursor + 1;
 		}
 
-		if (cursor >= byte_end)
-			this->marks[pos].line = count;
-		
-		std::fseek (this->fp, start, SEEK_SET);
+		gettimeofday(&end, NULL);
 
-		for (pos=0; pos < 101; pos++) {
-			std::cout << "pos: "<<pos<<" byte: "<<this->marks[pos].byte<<" line: "<<this->marks[pos].line<<"\n";
-		}
-		std::cout<<std::flush;
+		std::cout<<"ms: "<<((((end.tv_sec-start.tv_sec) * 1000) + ((end.tv_usec-start.tv_usec)/1000.0)) + 0.5)<<"\n";
 		
+		this->running = false;
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}
 
 	LineReader::LineReader (proactor::InputDispatcher * d,
 									FILE * fp,
+									LineIndex * marks,
 									long int start,
 									long int N) {
 		this->fp = fp;
 		this->dispatcher = d;
-		this->startOffset = start;
+		this->startLine = start;
 		this->numberOfLinesToRead = N;
+		this->marks = marks;
 	}
 
 	LineReader::~LineReader (void) {
@@ -216,11 +196,27 @@ namespace largefile {
 		char buf[4096];
 
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-
-		// Record current position and seek to where we're going to start.
+		long int start = std::ftell(this->fp);
+		long int offset = 0, delta = 0;
 		long int & read_max = this->numberOfLinesToRead;
-		std::fseek (this->fp, this->startOffset, SEEK_SET);
+		
+		for (int index = 0; index < 101; index++) {
+			if (this->startLine > this->marks[index].line) {
+				delta = this->marks[index].line - read_max;
+				if (index > 0)
+					offset = this->marks[index-1].byte;
+				break;
+			}
+		}
+		
+		std::fseek (this->fp, offset, SEEK_SET);
 
+		// Munch lines to get to our starting point.
+		while (delta > 0) {
+			if (std::fgets (buf, 4096, this->fp) == NULL)		
+				break;
+      }
+		
 		for (long int ii = 0; ii < read_max; ii++) {
 			if (std::fgets (buf, 4096, this->fp) == NULL)		
 				break;
@@ -228,6 +224,8 @@ namespace largefile {
 			this->dispatcher->onReadComplete (std::string (buf));
 		}
 
+		std::fseek (this->fp, start, SEEK_SET);
+		
 		this->running = false;
 		this->dispatcher->removeWorker (this);
 		return NULL;
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index a23cf54..46ccb3d 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -69,10 +69,12 @@ namespace largefile {
 	private:
 		FILE * fp;
 		long int numberOfLinesToRead;
-		long int startOffset;
+		long int startLine;
+		LineIndex * marks;
 	public:
 		LineReader (proactor::InputDispatcher * d, 
-						FILE * fp, 
+						FILE * fp,
+						LineIndex * marks,
 						long int start,
 						long int N);
 		virtual ~LineReader (void);
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index c7db7a3..d4cafae 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -57,7 +57,7 @@ key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	
 	switch (event->keyval) {
 		case GDK_F1: {
-			gtk_sheet_column_button_add_label (gtksheet, 0, "A");
+			fd->read(102583,1000);
 		}
 		break;
 		
@@ -120,7 +120,7 @@ thread_main (ThreadArgs * args) {
 		g_critical ("Failed starting file dispatcher; exiting thread.");
 		return;
 	}
-
+	
 	std::vector<gpointer> signal_arguments;
 	signal_arguments.push_back( (gpointer)&fdispatcher );
 	signal_arguments.push_back( (gpointer)wb );

commit 590718ff898cc226cbafbaefb29f7bac264ff240
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jun 18 12:07:42 2009 -0400

    (1) Fixed ifcheck for byte-size in indexer.
    (2) Incremented offset to not include zero index.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 8f768b7..1c491f5 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -110,12 +110,8 @@ namespace largefile {
 	FileDispatcher::run (void * null) {
 		this->running = true;
 
-		concurrent::ThreadPool pool(1);
-
-		pool.start();
-		
-		for (int ii = 0; ii < 100; ii++)
-			pool.execute (new LineIndexer (this, this->fp, this->marks));
+		// Start the indexer thread. 
+		this->index();
 		
 		while (this->running == true) {
 			if (this->fp == NULL) {
@@ -149,14 +145,16 @@ namespace largefile {
 	}
 
 	LineIndexer::~LineIndexer (void) {
-		std::cout<<"index finished!\n";
+		std::cout<<"index finished\n"<<std::flush;
 	}
 
 	void *
 	LineIndexer::run (void * null) {
 		this->running = true;
 
-		int pos = 0;
+		std::cout<<"index begun..."<<std::flush;
+		
+		int pos = 1;
 		for (; pos < 101; pos++) {
 			if (this->marks[pos].line == -1)
 				break;
@@ -181,16 +179,20 @@ namespace largefile {
 			if (std::fgets (buf, 4096, this->fp) == NULL)
 				break;
 
-			// Save our position to compare against our ending byte.
 			cursor = std::ftell(this->fp);
 			count++;
 		}
 
-		if (cursor == byte_end)
+		if (cursor >= byte_end)
 			this->marks[pos].line = count;
-
 		
 		std::fseek (this->fp, start, SEEK_SET);
+
+		for (pos=0; pos < 101; pos++) {
+			std::cout << "pos: "<<pos<<" byte: "<<this->marks[pos].byte<<" line: "<<this->marks[pos].line<<"\n";
+		}
+		std::cout<<std::flush;
+		
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}

commit 633ea8817dcb67dd4cd09095331720f24fd56a2b
Merge: b737e28... e77c7d4...
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jun 17 11:59:28 2009 -0400

    Merge commit 'origin/largefile' into largefile

commit b737e28b30afdd55af8ddc61c0ebc2a113651760
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jun 17 11:58:29 2009 -0400

    Committed for merge.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 6d038de..8f768b7 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -110,6 +110,13 @@ namespace largefile {
 	FileDispatcher::run (void * null) {
 		this->running = true;
 
+		concurrent::ThreadPool pool(1);
+
+		pool.start();
+		
+		for (int ii = 0; ii < 100; ii++)
+			pool.execute (new LineIndexer (this, this->fp, this->marks));
+		
 		while (this->running == true) {
 			if (this->fp == NULL) {
 				this->running = false;

commit 668634dd9598c922a8dbd5785417e64eb128cffe
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jun 17 11:51:22 2009 -0400

    Removed ThreadPool object from dispatcher.

diff --git a/shared/concurrent/Thread.cpp b/shared/concurrent/Thread.cpp
index 0ac484d..5b7f143 100755
--- a/shared/concurrent/Thread.cpp
+++ b/shared/concurrent/Thread.cpp
@@ -23,106 +23,107 @@
 
 namespace concurrent {
 
-  static void *
-  thread_run (void * runner) {
-    void * rvalue = ((IRunnable *)runner)->run (NULL);
-    return rvalue;
-  }
-
-  Thread::Thread (ThreadGroup * group,
-		  IRunnable * runner, 
-		  const std::string & name) {
-    this->group = group;
-    this->runner = runner;
-    this->name = name;
-  }
-
-  Thread::Thread (IRunnable * runner,
-		  const std::string & name) 
-    : group(NULL) {
-    this->runner = runner;
-    this->name = name;
-  }
-
-  Thread::Thread (const std::string & name) 
-    : group(NULL), runner(NULL) {
-    this->name = name;
-  }
-
-  Thread::Thread (void) : group(NULL), runner(NULL) {
-  }
-
-  Thread::~Thread (void) {
-    if (this->running == true) {
-      this->running = false;
-      this->join();
-    }
-  }
-
-  void 
-  Thread::interrupt (void) {
-    this->running = false;
-    pthread_cancel (this->thread);
-    pthread_detach (this->thread);
-  }
-
-  void 
-  Thread::yield (void) {
-    pthread_yield();
-  }
-
-  void * 
-  Thread::stop (void) {
-    this->running = false;
-    return this->join();
-  }
-
-  int 
-  Thread::sleep (unsigned long ms) {
-    struct timespec req = {0};
-    time_t sec = (int)(ms/1000);
-    ms = ms - (sec*1000);
-    req.tv_sec = sec;
-    req.tv_nsec = ms*1000000L;
-    while (nanosleep (&req, &req) == -1)
-      continue;
-    return 1;
-  }
-
-  bool 
-  Thread::start (void) {
-    if (this->running == true)
-      return false;
-
-    if (this->runner != NULL) {
-      if (pthread_create (&this->thread,
-			  NULL,
-			  thread_run,
-			  this->runner))
-	  return false;
-    }
-    else {
-      if (pthread_create (&this->thread,
-			  NULL,
-			  thread_run,
-			  this))
-	return false;
-    }
-
-    this->running = true;
-    return true;
-  }
-
-  void *
-  Thread::join (void) {
-    void * rvalue = NULL;
-    pthread_join (this->thread, &rvalue);
-    return rvalue;
-  }
-
-  void *
-  Thread::run (void *null) {
-    pthread_exit (null);
-  }
+	static void *
+	thread_run (void * runner) {
+		void * rvalue = ((IRunnable *)runner)->run (NULL);
+		return rvalue;
+	}
+
+	Thread::Thread (ThreadGroup * group,
+						 IRunnable * runner, 
+						 const std::string & name) : thread(0) {
+		this->group = group;
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (IRunnable * runner,
+						 const std::string & name) 
+		: group(NULL), thread(0) {
+		this->runner = runner;
+		this->name = name;
+	}
+
+	Thread::Thread (const std::string & name) 
+		: group(NULL), runner(NULL), thread(0) {
+		this->name = name;
+	}
+
+	Thread::Thread (void) : group(NULL), runner(NULL), thread(0) {
+	}
+
+	Thread::~Thread (void) {
+		if (this->running == true) {
+			this->running = false;
+			this->join();
+		}
+	}
+
+	void 
+	Thread::interrupt (void) {
+		this->running = false;
+		pthread_cancel (this->thread);
+		pthread_detach (this->thread);
+	}
+
+	void 
+	Thread::yield (void) {
+		pthread_yield();
+	}
+
+	void * 
+	Thread::stop (void) {
+		this->running = false;
+		return this->join();
+	}
+
+	int 
+	Thread::sleep (unsigned long ms) {
+		struct timespec req = {0};
+		time_t sec = (int)(ms/1000);
+		ms = ms - (sec*1000);
+		req.tv_sec = sec;
+		req.tv_nsec = ms*1000000L;
+		while (nanosleep (&req, &req) == -1)
+			continue;
+		return 1;
+	}
+
+	bool 
+	Thread::start (void) {
+		if (this->running == true)
+			return false;
+
+		if (this->runner != NULL) {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this->runner))
+				return false;
+		}
+		else {
+			if (pthread_create (&this->thread,
+									  NULL,
+									  thread_run,
+									  this))
+				return false;
+		}
+
+		this->running = true;
+		return true;
+	}
+
+	void *
+	Thread::join (void) {
+		void * rvalue = NULL;
+		if (this->thread > 0)
+			pthread_join (this->thread, &rvalue);
+		return rvalue;
+	}
+
+	void *
+	Thread::run (void *null) {
+		pthread_exit (null);
+	}
 
 } // end of namespace
diff --git a/shared/concurrent/ThreadPool.cpp b/shared/concurrent/ThreadPool.cpp
index 5b87b37..cd6890e 100755
--- a/shared/concurrent/ThreadPool.cpp
+++ b/shared/concurrent/ThreadPool.cpp
@@ -30,15 +30,15 @@ namespace concurrent {
     this->running = true;
 
     while (this->running == true) {
-      if (this->pool->isRunning() == false)
-	break;
+		 if (this->pool->isRunning() == false)
+			 break;
       
-      if (this->pool->getQueueSize() > 0) {
-	IRunnable * runner = this->pool->removeFromQueue();
-	runner->run (NULL);
-	delete runner;
-      }
-      Thread::sleep (1);
+		 if (this->pool->getQueueSize() > 0) {
+			 IRunnable * runner = this->pool->removeFromQueue();
+			 runner->run (NULL);
+			 delete runner;
+		 }
+		 Thread::sleep (1);
     }
 
     return NULL;
@@ -86,11 +86,11 @@ namespace concurrent {
   ThreadPool::start (void) {
     this->running = true;
     
-  ThreadList::iterator it = this->threads.begin();
-  while (it != this->threads.end())
+	 ThreadList::iterator it = this->threads.begin();
+	 while (it != this->threads.end())
     {
-      (*it)->start();
-      it++;
+		 (*it)->start();
+		 it++;
     }
   }
 
@@ -106,11 +106,11 @@ namespace concurrent {
        of one of the Task threads then you are going to hit a deadlock. Never
        pass the join parameter if this is being called from inside the Tasks.*/
     if (join == true) {
-      ThreadList::iterator it = this->threads.begin();
-      while (it != this->threads.end()) {
-	(*it)->stop();
-	it++;
-      }
+		 ThreadList::iterator it = this->threads.begin();
+		 while (it != this->threads.end()) {
+			 (*it)->stop();
+			 it++;
+		 }
     }
   }
 
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 13af8f7..6d038de 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -18,11 +18,12 @@
 */
 #include "File.hpp"
 #include <iostream>
+#include <concurrent/ThreadPool.hpp>
 #include <concurrent/ScopedMemoryLock.hpp>
 #include <cstdio>
 
 namespace largefile {
-
+	
 	FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
 		this->fp = NULL;
 		this->pro = pro;
@@ -36,7 +37,6 @@ namespace largefile {
 
 	void
 	FileDispatcher::read (long int start, long int N) {
-		// WARNING: Need some form of a lock on this method.
 		LineReader * reader = new LineReader (this, this->fp, start, N);
 		this->addWorker (reader);
 	}
@@ -57,15 +57,38 @@ namespace largefile {
 			return false;
 		}
 
-		std::fseek (this->fp, 0, SEEK_END);
+		// Take the relative byte position, e.g. .75 * byte_end, and seek backwards until
+		// we get a newline. We now have the line at that relative byte position. Set it
+		// to the marks array so that we can quick line seek.
+		std::fseek (this->fp, 0L, SEEK_END);
 		long int byte_end = std::ftell (this->fp);
 
+		// Compute fuzzy relative position, and set line to -1 for indexing.
 		for (int ii = 0; ii < 101; ii++) {
 			float N = ii, K = 10000;
-			this->marks[ii] = (long int)((N/K) * byte_end);
+			this->marks[ii].byte = (long int)((N/K) * byte_end);
+			this->marks[ii].line = -1;
 		}
 
-		std::fseek (this->fp, 0, SEEK_SET);
+		long int cursor = 1;
+				
+		// Get actual relative position (where line begins) from fuzzy.
+		while (!feof (this->fp) && (cursor < 101)) {
+			int c = 0, ii = 0;
+			std::fseek(this->fp, this->marks[cursor].byte, SEEK_SET);
+
+			// It looks fancy, but it really isn't.
+			while ((c = fgetc (this->fp)) != EOF) {
+				if ((c == '\r') || (c=='\n')) break;
+				std::fseek(this->fp, this->marks[cursor].byte - (++ii) - 1, SEEK_CUR); 
+			}
+
+			this->marks[cursor].byte = (this->marks[cursor].byte - ii);
+			cursor++;
+			clearerr(this->fp);
+		}
+		
+		std::fseek (this->fp, 0L, SEEK_SET);
 		
 		concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
 		this->filename = filename;
@@ -92,7 +115,7 @@ namespace largefile {
 				this->running = false;
 				break;
 			}
-
+			
 			this->inputQueue.lock();
       
 			while (this->inputQueue.size() > 0) {
@@ -112,42 +135,55 @@ namespace largefile {
   
 	LineIndexer::LineIndexer (proactor::InputDispatcher * d,
 									  FILE * fp,
-									  long int * marks) {
+									  LineIndex * marks) {
 		this->fp = fp;
 		this->dispatcher = d;
 		this->marks = marks;
 	}
 
 	LineIndexer::~LineIndexer (void) {
+		std::cout<<"index finished!\n";
 	}
 
 	void *
 	LineIndexer::run (void * null) {
 		this->running = true;
 
-		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-		
-		long int start = std::ftell (this->fp), cursor = 1;
+		int pos = 0;
+		for (; pos < 101; pos++) {
+			if (this->marks[pos].line == -1)
+				break;
+		}
+
+		// Nothing to index.
+		if (pos == 100) {
+			this->running = false;
+			return NULL;
+		}
 		
-		// Take the relative byte position, e.g. .75 * byte_end, and seek backwards until
-		// we get a newline. We now have the line at that relative byte position. Set it
-		// to the marks array so that we can quick line seek.
-		while (!feof (this->fp) && (cursor < 101)) {
-			int c = 0, ii = 0;
-			std::fseek(this->fp, this->marks[cursor], SEEK_SET);
+		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 
-			while ((c = fgetc (this->fp)) != EOF) {
-				if ((c == '\r') || (c=='\n')) break;
-				std::fseek(this->fp, this->marks[cursor] - (++ii) - 1, SEEK_CUR); 
-			}
+		char buf[4096];
+		long int start = std::ftell (this->fp), cursor = 0, count = 0, byte_end = this->marks[pos].byte;
+		std::fseek(this->fp, (pos==0) ? 0 : this->marks[pos-1].byte, SEEK_SET);
+
+		// We need to get a absoltue line number for the relative position. We're not
+		// going to get away from having to sequentially read this file in, but once we
+		// have line numbers we can jump throughout the file pretty quickly.
+		while (cursor < byte_end) {	
+			if (std::fgets (buf, 4096, this->fp) == NULL)
+				break;
 
-			this->marks[cursor] = (this->marks[cursor] - ii);
-			cursor++;
-			clearerr(this->fp);
+			// Save our position to compare against our ending byte.
+			cursor = std::ftell(this->fp);
+			count++;
 		}
 
-		std::fseek (this->fp, start, SEEK_SET);
+		if (cursor == byte_end)
+			this->marks[pos].line = count;
+
 		
+		std::fseek (this->fp, start, SEEK_SET);
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index c0bb715..a23cf54 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -28,9 +28,14 @@
 
 namespace largefile {
 
+	struct LineIndex {
+		long int byte;
+		long int line;
+	};
+	
 	class FileDispatcher : public proactor::InputDispatcher {
 	private:
-		long int marks[101];
+		LineIndex marks[101];
 		FILE * fp;
 		std::string filename;
 	public:
@@ -44,17 +49,17 @@ namespace largefile {
 		void read (long int start, long int N);
 		void index (void);
 
-		inline long int getLinePosition(int ii) const { return this->marks[ii]; }
+		inline bool isIndexed(void) const { return (this->marks[100].line != -1); }
 	};
 
 	class LineIndexer : public proactor::Worker {
 	private:
-		long int * marks;
+		LineIndex * marks;
 		FILE * fp;
 	public:
 		LineIndexer (proactor::InputDispatcher * d, 
-						 FILE * fp, 
-						 long int * marks);
+						 FILE * fp,
+						 LineIndex * marks);
 		virtual ~LineIndexer (void);
 
 		void * run (void * null);
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index fb6c66d..c7db7a3 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -48,19 +48,28 @@ static gint
 key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
 	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
-	//Workbook * wb = (Workbook *)arguments->at(1);
-	//GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
+	Workbook * wb = (Workbook *)arguments->at(1);
+	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
+
+	int vposition = std::abs((int)gtksheet->vadjustment->value);
+
+	float N = vposition, K = 24388, V = (N/K);
 	
 	switch (event->keyval) {
+		case GDK_F1: {
+			gtk_sheet_column_button_add_label (gtksheet, 0, "A");
+		}
+		break;
+		
 		case GDK_Page_Up: {
-			std::cout<<fd->getLinePosition(56)<<"\n";
+			
 		}
-		return FALSE;
+		break;
 
 		case GDK_Page_Down: {
 			
 		}
-		return FALSE;
+		break;
 	}
 	return FALSE;
 }
@@ -120,9 +129,6 @@ thread_main (ThreadArgs * args) {
 							  GTK_SIGNAL_FUNC (key_press_callback),
 							  (gpointer)&signal_arguments);
 
-	fdispatcher.index();
-	fdispatcher.read (0, 1000);
-
 	while (*SHUTDOWN == FALSE) {
 		concurrent::Thread::sleep (100);
 	}

commit e77c7d4da0f125a712f59ff1f78df65a5bb22451
Author: John Bellone <jvb4@njit.edu>
Date:   Tue Jun 16 13:01:42 2009 -0400

    Fixing problems inside of File.cpp

diff --git a/shared/concurrent/ThreadPool.cpp b/shared/concurrent/ThreadPool.cpp
index 5b87b37..cd6890e 100755
--- a/shared/concurrent/ThreadPool.cpp
+++ b/shared/concurrent/ThreadPool.cpp
@@ -30,15 +30,15 @@ namespace concurrent {
     this->running = true;
 
     while (this->running == true) {
-      if (this->pool->isRunning() == false)
-	break;
+		 if (this->pool->isRunning() == false)
+			 break;
       
-      if (this->pool->getQueueSize() > 0) {
-	IRunnable * runner = this->pool->removeFromQueue();
-	runner->run (NULL);
-	delete runner;
-      }
-      Thread::sleep (1);
+		 if (this->pool->getQueueSize() > 0) {
+			 IRunnable * runner = this->pool->removeFromQueue();
+			 runner->run (NULL);
+			 delete runner;
+		 }
+		 Thread::sleep (1);
     }
 
     return NULL;
@@ -86,11 +86,11 @@ namespace concurrent {
   ThreadPool::start (void) {
     this->running = true;
     
-  ThreadList::iterator it = this->threads.begin();
-  while (it != this->threads.end())
+	 ThreadList::iterator it = this->threads.begin();
+	 while (it != this->threads.end())
     {
-      (*it)->start();
-      it++;
+		 (*it)->start();
+		 it++;
     }
   }
 
@@ -106,11 +106,11 @@ namespace concurrent {
        of one of the Task threads then you are going to hit a deadlock. Never
        pass the join parameter if this is being called from inside the Tasks.*/
     if (join == true) {
-      ThreadList::iterator it = this->threads.begin();
-      while (it != this->threads.end()) {
-	(*it)->stop();
-	it++;
-      }
+		 ThreadList::iterator it = this->threads.begin();
+		 while (it != this->threads.end()) {
+			 (*it)->stop();
+			 it++;
+		 }
     }
   }
 
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 13af8f7..8f768b7 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -18,11 +18,12 @@
 */
 #include "File.hpp"
 #include <iostream>
+#include <concurrent/ThreadPool.hpp>
 #include <concurrent/ScopedMemoryLock.hpp>
 #include <cstdio>
 
 namespace largefile {
-
+	
 	FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
 		this->fp = NULL;
 		this->pro = pro;
@@ -36,7 +37,6 @@ namespace largefile {
 
 	void
 	FileDispatcher::read (long int start, long int N) {
-		// WARNING: Need some form of a lock on this method.
 		LineReader * reader = new LineReader (this, this->fp, start, N);
 		this->addWorker (reader);
 	}
@@ -57,15 +57,38 @@ namespace largefile {
 			return false;
 		}
 
-		std::fseek (this->fp, 0, SEEK_END);
+		// Take the relative byte position, e.g. .75 * byte_end, and seek backwards until
+		// we get a newline. We now have the line at that relative byte position. Set it
+		// to the marks array so that we can quick line seek.
+		std::fseek (this->fp, 0L, SEEK_END);
 		long int byte_end = std::ftell (this->fp);
 
+		// Compute fuzzy relative position, and set line to -1 for indexing.
 		for (int ii = 0; ii < 101; ii++) {
 			float N = ii, K = 10000;
-			this->marks[ii] = (long int)((N/K) * byte_end);
+			this->marks[ii].byte = (long int)((N/K) * byte_end);
+			this->marks[ii].line = -1;
 		}
 
-		std::fseek (this->fp, 0, SEEK_SET);
+		long int cursor = 1;
+				
+		// Get actual relative position (where line begins) from fuzzy.
+		while (!feof (this->fp) && (cursor < 101)) {
+			int c = 0, ii = 0;
+			std::fseek(this->fp, this->marks[cursor].byte, SEEK_SET);
+
+			// It looks fancy, but it really isn't.
+			while ((c = fgetc (this->fp)) != EOF) {
+				if ((c == '\r') || (c=='\n')) break;
+				std::fseek(this->fp, this->marks[cursor].byte - (++ii) - 1, SEEK_CUR); 
+			}
+
+			this->marks[cursor].byte = (this->marks[cursor].byte - ii);
+			cursor++;
+			clearerr(this->fp);
+		}
+		
+		std::fseek (this->fp, 0L, SEEK_SET);
 		
 		concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
 		this->filename = filename;
@@ -87,12 +110,19 @@ namespace largefile {
 	FileDispatcher::run (void * null) {
 		this->running = true;
 
+		concurrent::ThreadPool pool(1);
+
+		pool.start();
+		
+		for (int ii = 0; ii < 100; ii++)
+			pool.execute (new LineIndexer (this, this->fp, this->marks));
+		
 		while (this->running == true) {
 			if (this->fp == NULL) {
 				this->running = false;
 				break;
 			}
-
+			
 			this->inputQueue.lock();
       
 			while (this->inputQueue.size() > 0) {
@@ -112,42 +142,55 @@ namespace largefile {
   
 	LineIndexer::LineIndexer (proactor::InputDispatcher * d,
 									  FILE * fp,
-									  long int * marks) {
+									  LineIndex * marks) {
 		this->fp = fp;
 		this->dispatcher = d;
 		this->marks = marks;
 	}
 
 	LineIndexer::~LineIndexer (void) {
+		std::cout<<"index finished!\n";
 	}
 
 	void *
 	LineIndexer::run (void * null) {
 		this->running = true;
 
-		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-		
-		long int start = std::ftell (this->fp), cursor = 1;
+		int pos = 0;
+		for (; pos < 101; pos++) {
+			if (this->marks[pos].line == -1)
+				break;
+		}
+
+		// Nothing to index.
+		if (pos == 100) {
+			this->running = false;
+			return NULL;
+		}
 		
-		// Take the relative byte position, e.g. .75 * byte_end, and seek backwards until
-		// we get a newline. We now have the line at that relative byte position. Set it
-		// to the marks array so that we can quick line seek.
-		while (!feof (this->fp) && (cursor < 101)) {
-			int c = 0, ii = 0;
-			std::fseek(this->fp, this->marks[cursor], SEEK_SET);
+		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 
-			while ((c = fgetc (this->fp)) != EOF) {
-				if ((c == '\r') || (c=='\n')) break;
-				std::fseek(this->fp, this->marks[cursor] - (++ii) - 1, SEEK_CUR); 
-			}
+		char buf[4096];
+		long int start = std::ftell (this->fp), cursor = 0, count = 0, byte_end = this->marks[pos].byte;
+		std::fseek(this->fp, (pos==0) ? 0 : this->marks[pos-1].byte, SEEK_SET);
+
+		// We need to get a absoltue line number for the relative position. We're not
+		// going to get away from having to sequentially read this file in, but once we
+		// have line numbers we can jump throughout the file pretty quickly.
+		while (cursor < byte_end) {	
+			if (std::fgets (buf, 4096, this->fp) == NULL)
+				break;
 
-			this->marks[cursor] = (this->marks[cursor] - ii);
-			cursor++;
-			clearerr(this->fp);
+			// Save our position to compare against our ending byte.
+			cursor = std::ftell(this->fp);
+			count++;
 		}
 
-		std::fseek (this->fp, start, SEEK_SET);
+		if (cursor == byte_end)
+			this->marks[pos].line = count;
+
 		
+		std::fseek (this->fp, start, SEEK_SET);
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index c0bb715..a23cf54 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -28,9 +28,14 @@
 
 namespace largefile {
 
+	struct LineIndex {
+		long int byte;
+		long int line;
+	};
+	
 	class FileDispatcher : public proactor::InputDispatcher {
 	private:
-		long int marks[101];
+		LineIndex marks[101];
 		FILE * fp;
 		std::string filename;
 	public:
@@ -44,17 +49,17 @@ namespace largefile {
 		void read (long int start, long int N);
 		void index (void);
 
-		inline long int getLinePosition(int ii) const { return this->marks[ii]; }
+		inline bool isIndexed(void) const { return (this->marks[100].line != -1); }
 	};
 
 	class LineIndexer : public proactor::Worker {
 	private:
-		long int * marks;
+		LineIndex * marks;
 		FILE * fp;
 	public:
 		LineIndexer (proactor::InputDispatcher * d, 
-						 FILE * fp, 
-						 long int * marks);
+						 FILE * fp,
+						 LineIndex * marks);
 		virtual ~LineIndexer (void);
 
 		void * run (void * null);
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index fb6c66d..bfa33a5 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -48,19 +48,28 @@ static gint
 key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
 	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
-	//Workbook * wb = (Workbook *)arguments->at(1);
-	//GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
+	Workbook * wb = (Workbook *)arguments->at(1);
+	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
+
+	int vposition = std::abs((int)gtksheet->vadjustment->value);
+
+	float N = vposition, K = 24388, V = (N/K);
 	
 	switch (event->keyval) {
+		case GDK_F1: {
+			gtk_sheet_column_button_add_label (gtksheet, 0, "A");
+		}
+		break;
+		
 		case GDK_Page_Up: {
-			std::cout<<fd->getLinePosition(56)<<"\n";
+			
 		}
-		return FALSE;
+		break;
 
 		case GDK_Page_Down: {
 			
 		}
-		return FALSE;
+		break;
 	}
 	return FALSE;
 }
@@ -120,9 +129,9 @@ thread_main (ThreadArgs * args) {
 							  GTK_SIGNAL_FUNC (key_press_callback),
 							  (gpointer)&signal_arguments);
 
-	fdispatcher.index();
 	fdispatcher.read (0, 1000);
-
+	fdispatcher.index();
+	
 	while (*SHUTDOWN == FALSE) {
 		concurrent::Thread::sleep (100);
 	}

commit c2862fdadd365f2f8b131d2f55f91239e38c907b
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 12 14:02:57 2009 -0400

    LineIndexer now works; removed ThreadPool from FileDispatcher.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 8750ce4..13af8f7 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -27,28 +27,24 @@ namespace largefile {
 		this->fp = NULL;
 		this->pro = pro;
 		setEventId(e);
-
-		this->pool.start();
 	}
 
 	FileDispatcher::~FileDispatcher (void) {
 		if (this->fp != NULL)
 			this->close();
-
-		this->pool.stop();
 	}
 
 	void
 	FileDispatcher::read (long int start, long int N) {
 		// WARNING: Need some form of a lock on this method.
 		LineReader * reader = new LineReader (this, this->fp, start, N);
-		this->pool.execute (reader);
+		this->addWorker (reader);
 	}
 
 	void
 	FileDispatcher::index (void) {
 		LineIndexer * indexer = new LineIndexer (this, this->fp, this->marks);
-		this->pool.execute (indexer);
+		this->addWorker (indexer);
 	}
 
 	bool
@@ -62,12 +58,15 @@ namespace largefile {
 		}
 
 		std::fseek (this->fp, 0, SEEK_END);
-		this->marks[100] = std::ftell (this->fp);
-		std::fseek (this->fp, 0, SEEK_SET);
+		long int byte_end = std::ftell (this->fp);
 
-		for (int ii = 0; ii < this->marks[100]; ii++)
-			this->marks[ii] = (long int)((ii/100)*this->marks[100]);
-		 
+		for (int ii = 0; ii < 101; ii++) {
+			float N = ii, K = 10000;
+			this->marks[ii] = (long int)((N/K) * byte_end);
+		}
+
+		std::fseek (this->fp, 0, SEEK_SET);
+		
 		concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
 		this->filename = filename;
 		return true;
@@ -120,7 +119,6 @@ namespace largefile {
 	}
 
 	LineIndexer::~LineIndexer (void) {
-
 	}
 
 	void *
@@ -130,25 +128,26 @@ namespace largefile {
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 		
 		long int start = std::ftell (this->fp), cursor = 1;
-
+		
 		// Take the relative byte position, e.g. .75 * byte_end, and seek backwards until
 		// we get a newline. We now have the line at that relative byte position. Set it
 		// to the marks array so that we can quick line seek.
-		while (!feof (this->fp)
-				 && (cursor < 101)) {
+		while (!feof (this->fp) && (cursor < 101)) {
 			int c = 0, ii = 0;
 			std::fseek(this->fp, this->marks[cursor], SEEK_SET);
 
-			while ((c = fgetc (this->fp)) != '\n') {
-				if (c == '\r') break;
+			while ((c = fgetc (this->fp)) != EOF) {
+				if ((c == '\r') || (c=='\n')) break;
 				std::fseek(this->fp, this->marks[cursor] - (++ii) - 1, SEEK_CUR); 
 			}
 
-			this->marks[cursor] = (this->marks[cursor] - ii); 
+			this->marks[cursor] = (this->marks[cursor] - ii);
 			cursor++;
+			clearerr(this->fp);
 		}
 
 		std::fseek (this->fp, start, SEEK_SET);
+		
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}
@@ -161,11 +160,9 @@ namespace largefile {
 		this->dispatcher = d;
 		this->startOffset = start;
 		this->numberOfLinesToRead = N;
-		std::cout <<"reader begin\n";
 	}
 
 	LineReader::~LineReader (void) {
-		std::cout <<"reader end\n";
 	}
 
 	void *
@@ -176,7 +173,6 @@ namespace largefile {
 		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 
 		// Record current position and seek to where we're going to start.
-		//    long int cursor = std::ftell (this->fp);
 		long int & read_max = this->numberOfLinesToRead;
 		std::fseek (this->fp, this->startOffset, SEEK_SET);
 
@@ -184,12 +180,10 @@ namespace largefile {
 			if (std::fgets (buf, 4096, this->fp) == NULL)		
 				break;
       
-			// Eventually store index here?
 			this->dispatcher->onReadComplete (std::string (buf));
 		}
 
 		this->running = false;
-		//std::fseek (this->fp, cursor, SEEK_SET);
 		this->dispatcher->removeWorker (this);
 		return NULL;
 	}
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index cdfb6c2..c0bb715 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -19,7 +19,6 @@
 #ifndef FILE_HPP
 #define FILE_HPP
 
-#include <concurrent/ThreadPool.hpp>
 #include <proactor/InputDispatcher.hpp>
 #include <proactor/Proactor.hpp>
 #include <proactor/Worker.hpp>
@@ -34,7 +33,6 @@ namespace largefile {
 		long int marks[101];
 		FILE * fp;
 		std::string filename;
-		concurrent::ThreadPool pool;
 	public:
 		FileDispatcher (int e, proactor::Proactor * pro);
 		virtual ~FileDispatcher (void);
@@ -45,6 +43,8 @@ namespace largefile {
 
 		void read (long int start, long int N);
 		void index (void);
+
+		inline long int getLinePosition(int ii) const { return this->marks[ii]; }
 	};
 
 	class LineIndexer : public proactor::Worker {
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index ecf75ca..fb6c66d 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -48,12 +48,12 @@ static gint
 key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
 	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
 	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
-	Workbook * wb = (Workbook *)arguments->at(1);
-	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
+	//Workbook * wb = (Workbook *)arguments->at(1);
+	//GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
 	
 	switch (event->keyval) {
 		case GDK_Page_Up: {
-			
+			std::cout<<fd->getLinePosition(56)<<"\n";
 		}
 		return FALSE;
 
@@ -79,7 +79,7 @@ thread_main (ThreadArgs * args) {
 
 	FILE * pktlog = NULL;
 	std::string logname = std::string (logpath->value).append("/");
-	logname.append (append_pidname("realtime.").append(".log"));
+	logname.append (append_pidname("largefile.").append(".log"));
 
 	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
 		g_critical ("Failed opening file '%s' for packet logging; exiting"
@@ -119,7 +119,8 @@ thread_main (ThreadArgs * args) {
 	gtk_signal_connect (GTK_OBJECT (wb->gtk_window), "key_press_event",
 							  GTK_SIGNAL_FUNC (key_press_callback),
 							  (gpointer)&signal_arguments);
-	
+
+	fdispatcher.index();
 	fdispatcher.read (0, 1000);
 
 	while (*SHUTDOWN == FALSE) {

commit 6b50ad3c9fef4967d5d8646370f29b80209f06be
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 12 11:50:51 2009 -0400

    FileIndexer updated for relative line reading.

diff --git a/.gitignore b/.gitignore
index 7795a3c..bf37f2d 100755
--- a/.gitignore
+++ b/.gitignore
@@ -4,7 +4,5 @@ OBJS/
 bin/
 lib/
 csv/libcsv.*
-
-# Valgrind garbage
 massif*
 *.log
\ No newline at end of file
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index e84e412..8750ce4 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -17,172 +17,181 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "File.hpp"
+#include <iostream>
 #include <concurrent/ScopedMemoryLock.hpp>
 #include <cstdio>
 
 namespace largefile {
 
-  FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
-    this->fp = NULL;
-    this->pro = pro;
-    setEventId(e);
-
-    this->pool.start();
-  }
-
-  FileDispatcher::~FileDispatcher (void) {
-    if (this->fp != NULL)
-      this->close();
-
-    this->pool.stop();
-  }
-
-  void
-  FileDispatcher::read (long int start, long int N) {
-    // WARNING: Need some form of a lock on this method.
-    LineReader * reader = new LineReader (this, this->fp, start, N);
-    this->pool.execute (reader);
-  }
-
-  void
-  FileDispatcher::index (long int start, long int N) {
-    // WARNING: Need some form fo a lock on this method.
-    LineIndexer * indexer = new LineIndexer (this, this->fp, start, N);
-    this->pool.execute (indexer);
-  }
-
-  bool
-  FileDispatcher::open (const std::string & filename) {
-    if (filename.length() == 0)
-      return false;
-
-    if ((this->fp = std::fopen (filename.c_str(), "r")) == NULL) {
-      // stub: throw an error somewhere
-      return false;
-    }
-
-    concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
-    this->filename = filename;
-    return true;
-  }
-
-  bool 
-  FileDispatcher::close (void) {
-    concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp);
-    if (this->fp == NULL)
-      return false;
-
-    std::fclose (this->fp); this->fp = NULL;
-    mutex.remove();
-    return true;
-  }
+	FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
+		this->fp = NULL;
+		this->pro = pro;
+		setEventId(e);
+
+		this->pool.start();
+	}
+
+	FileDispatcher::~FileDispatcher (void) {
+		if (this->fp != NULL)
+			this->close();
+
+		this->pool.stop();
+	}
+
+	void
+	FileDispatcher::read (long int start, long int N) {
+		// WARNING: Need some form of a lock on this method.
+		LineReader * reader = new LineReader (this, this->fp, start, N);
+		this->pool.execute (reader);
+	}
+
+	void
+	FileDispatcher::index (void) {
+		LineIndexer * indexer = new LineIndexer (this, this->fp, this->marks);
+		this->pool.execute (indexer);
+	}
+
+	bool
+	FileDispatcher::open (const std::string & filename) {
+		if (filename.length() == 0)
+			return false;
+
+		if ((this->fp = std::fopen (filename.c_str(), "r")) == NULL) {
+			// stub: throw an error somewhere
+			return false;
+		}
+
+		std::fseek (this->fp, 0, SEEK_END);
+		this->marks[100] = std::ftell (this->fp);
+		std::fseek (this->fp, 0, SEEK_SET);
+
+		for (int ii = 0; ii < this->marks[100]; ii++)
+			this->marks[ii] = (long int)((ii/100)*this->marks[100]);
+		 
+		concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
+		this->filename = filename;
+		return true;
+	}
+
+	bool 
+	FileDispatcher::close (void) {
+		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp);
+		if (this->fp == NULL)
+			return false;
+
+		std::fclose (this->fp); this->fp = NULL;
+		mutex.remove();
+		return true;
+	}
   
-  void *
-  FileDispatcher::run (void * null) {
-    this->running = true;
+	void *
+	FileDispatcher::run (void * null) {
+		this->running = true;
 
-    while (this->running == true) {
-		 if (this->fp == NULL) {
-			 this->running = false;
-			 break;
-		 }
+		while (this->running == true) {
+			if (this->fp == NULL) {
+				this->running = false;
+				break;
+			}
 
-		 this->inputQueue.lock();
+			this->inputQueue.lock();
       
-		 while (this->inputQueue.size() > 0) {
-			 if (this->running == false)
-				 break;
+			while (this->inputQueue.size() > 0) {
+				if (this->running == false)
+					break;
 
-			 this->pro->onReadComplete (this->inputQueue.pop());
-		 }
+				this->pro->onReadComplete (this->inputQueue.pop());
+			}
 
-		 this->inputQueue.unlock();
+			this->inputQueue.unlock();
 
-		 Thread::sleep (5);
-    }
+			Thread::sleep (5);
+		}
 
-    return NULL;
-  }
+		return NULL;
+	}
   
-  LineIndexer::LineIndexer (proactor::InputDispatcher * d,
-			    FILE * fp,
-			    long int start,
-			    long int N) {
-    this->fp = fp;
-    this->dispatcher = d;
-    this->startOffset = start;
-    this->numberOfLinesToRead = N;
-  }
-
-  LineIndexer::~LineIndexer (void) {
-
-  }
-
-  void *
-  LineIndexer::run (void * null) {
-    this->running = true;
-    char buf[4096];
-
-    concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-
-    // Record current position and seek to where we're going to start.
-    long int cursor = std::ftell (this->fp);
-    long int & read_max = this->numberOfLinesToRead;
-    std::fseek (this->fp, this->startOffset, SEEK_SET);
-
-    for (long int ii = 0; ii < read_max; ii++) {
-      if (std::fgets (buf, 4096, this->fp) == NULL) 
-		break;
-          
-      //long int pos = std::ftell (this->fp);
-    }
-
-    // stub: Push up to our pappy.
-
-    this->running = false;
-    std::fseek (this->fp, cursor, SEEK_SET);
-    this->dispatcher->removeWorker (this);
-    return NULL;
-  }
-
-  LineReader::LineReader (proactor::InputDispatcher * d,
-						  FILE * fp,
-						  long int start,
-						  long int N) {
-    this->fp = fp;
-    this->dispatcher = d;
-    this->startOffset = start;
-    this->numberOfLinesToRead = N;
-  }
-
-  LineReader::~LineReader (void) {
-  
-  }
-
-  void *
-  LineReader::run (void * null) {
-    this->running = false;
-    char buf[4096];
-
-    concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-
-    // Record current position and seek to where we're going to start.
-    long int cursor = std::ftell (this->fp);
-    long int & read_max = this->numberOfLinesToRead;
-    std::fseek (this->fp, this->startOffset, SEEK_SET);
-
-    for (long int ii = 0; ii < read_max; ii++) {
-      if (std::fgets (buf, 4096, this->fp) == NULL)		
-	break;
+	LineIndexer::LineIndexer (proactor::InputDispatcher * d,
+									  FILE * fp,
+									  long int * marks) {
+		this->fp = fp;
+		this->dispatcher = d;
+		this->marks = marks;
+	}
+
+	LineIndexer::~LineIndexer (void) {
+
+	}
+
+	void *
+	LineIndexer::run (void * null) {
+		this->running = true;
+
+		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
+		
+		long int start = std::ftell (this->fp), cursor = 1;
+
+		// Take the relative byte position, e.g. .75 * byte_end, and seek backwards until
+		// we get a newline. We now have the line at that relative byte position. Set it
+		// to the marks array so that we can quick line seek.
+		while (!feof (this->fp)
+				 && (cursor < 101)) {
+			int c = 0, ii = 0;
+			std::fseek(this->fp, this->marks[cursor], SEEK_SET);
+
+			while ((c = fgetc (this->fp)) != '\n') {
+				if (c == '\r') break;
+				std::fseek(this->fp, this->marks[cursor] - (++ii) - 1, SEEK_CUR); 
+			}
+
+			this->marks[cursor] = (this->marks[cursor] - ii); 
+			cursor++;
+		}
+
+		std::fseek (this->fp, start, SEEK_SET);
+		this->dispatcher->removeWorker (this);
+		return NULL;
+	}
+
+	LineReader::LineReader (proactor::InputDispatcher * d,
+									FILE * fp,
+									long int start,
+									long int N) {
+		this->fp = fp;
+		this->dispatcher = d;
+		this->startOffset = start;
+		this->numberOfLinesToRead = N;
+		std::cout <<"reader begin\n";
+	}
+
+	LineReader::~LineReader (void) {
+		std::cout <<"reader end\n";
+	}
+
+	void *
+	LineReader::run (void * null) {
+		this->running = false;
+		char buf[4096];
+
+		concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
+
+		// Record current position and seek to where we're going to start.
+		//    long int cursor = std::ftell (this->fp);
+		long int & read_max = this->numberOfLinesToRead;
+		std::fseek (this->fp, this->startOffset, SEEK_SET);
+
+		for (long int ii = 0; ii < read_max; ii++) {
+			if (std::fgets (buf, 4096, this->fp) == NULL)		
+				break;
       
-      // Eventually store index here?
-      this->dispatcher->onReadComplete (std::string (buf));
-     }
-
-    this->running = false;
-    //std::fseek (this->fp, cursor, SEEK_SET);
-    this->dispatcher->removeWorker (this);
-    return NULL;
-  }
+			// Eventually store index here?
+			this->dispatcher->onReadComplete (std::string (buf));
+		}
+
+		this->running = false;
+		//std::fseek (this->fp, cursor, SEEK_SET);
+		this->dispatcher->removeWorker (this);
+		return NULL;
+	}
 
 } // end of namespace
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 8cd9e3e..cdfb6c2 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -29,52 +29,51 @@
 
 namespace largefile {
 
-  class FileDispatcher : public proactor::InputDispatcher {
-  private:
-    FILE * fp;
-    std::string filename;
-    concurrent::ThreadPool pool;
-  public:
-    FileDispatcher (int e, proactor::Proactor * pro);
-    virtual ~FileDispatcher (void);
+	class FileDispatcher : public proactor::InputDispatcher {
+	private:
+		long int marks[101];
+		FILE * fp;
+		std::string filename;
+		concurrent::ThreadPool pool;
+	public:
+		FileDispatcher (int e, proactor::Proactor * pro);
+		virtual ~FileDispatcher (void);
 
-    bool open (const std::string & filename);
-    bool close (void);
-    void * run (void * null);
+		bool open (const std::string & filename);
+		bool close (void);
+		void * run (void * null);
 
-    void read (long int start, long int N);
-    void index (long int start, long int N);
-  };
+		void read (long int start, long int N);
+		void index (void);
+	};
 
-  class LineIndexer : public proactor::Worker {
-  private:
-    FILE * fp;
-    long int numberOfLinesToRead;
-    long int startOffset; 
-  public:
-    LineIndexer (proactor::InputDispatcher * d, 
-		 FILE * fp, 
-		 long int start,
-		 long int N);
-    virtual ~LineIndexer (void);
+	class LineIndexer : public proactor::Worker {
+	private:
+		long int * marks;
+		FILE * fp;
+	public:
+		LineIndexer (proactor::InputDispatcher * d, 
+						 FILE * fp, 
+						 long int * marks);
+		virtual ~LineIndexer (void);
 
-    void * run (void * null);
-  };
+		void * run (void * null);
+	};
 
-  class LineReader : public proactor::Worker {
-  private:
-    FILE * fp;
-    long int numberOfLinesToRead;
-    long int startOffset;
-  public:
-    LineReader (proactor::InputDispatcher * d, 
-		 FILE * fp, 
-		 long int start,
-		 long int N);
-    virtual ~LineReader (void);
+	class LineReader : public proactor::Worker {
+	private:
+		FILE * fp;
+		long int numberOfLinesToRead;
+		long int startOffset;
+	public:
+		LineReader (proactor::InputDispatcher * d, 
+						FILE * fp, 
+						long int start,
+						long int N);
+		virtual ~LineReader (void);
 
-    void * run (void * null);
-  };
+		void * run (void * null);
+	};
 
 } // end of namespace
 
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 6b436a5..ecf75ca 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -45,17 +45,20 @@ append_pidname (const gchar * pre) {
 }
 
 static gint
-key_press_callback (GtkWidget * widget, GdkEventKey * event, gpointer data) {
-	FileDispatcher * fdispatcher = (FileDispatcher *)data;
+key_press_callback (GtkWidget * window, GdkEventKey * event, gpointer data) {
+	std::vector<gpointer> * arguments = (std::vector<gpointer> *)data;
+	FileDispatcher * fd = (FileDispatcher *)arguments->at(0);
+	Workbook * wb = (Workbook *)arguments->at(1);
+	GtkSheet * gtksheet = GTK_SHEET (wb->sheet_first->gtk_sheet);
 	
 	switch (event->keyval) {
 		case GDK_Page_Up: {
-			fdispatcher->read (1000,1000);
+			
 		}
 		return FALSE;
 
 		case GDK_Page_Down: {
-			std::cout<<"Down\n";
+			
 		}
 		return FALSE;
 	}
@@ -109,9 +112,13 @@ thread_main (ThreadArgs * args) {
 		return;
 	}
 
+	std::vector<gpointer> signal_arguments;
+	signal_arguments.push_back( (gpointer)&fdispatcher );
+	signal_arguments.push_back( (gpointer)wb );
+	
 	gtk_signal_connect (GTK_OBJECT (wb->gtk_window), "key_press_event",
 							  GTK_SIGNAL_FUNC (key_press_callback),
-							  (gpointer)&fdispatcher);
+							  (gpointer)&signal_arguments);
 	
 	fdispatcher.read (0, 1000);
 

commit e39f61ed66da09dfac2b1be12e5e8e6cfff86ffc
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jun 11 20:13:39 2009 -0400

    Fixed potential seek issue.

diff --git a/.gitignore b/.gitignore
index 20399b8..7795a3c 100755
--- a/.gitignore
+++ b/.gitignore
@@ -1,15 +1,10 @@
-# Ignore spotlight stores and emacs garbage
 .DS_Store
 *~
-
-# Ignore bin/, lib/ and OBJS/
 OBJS/
 bin/
 lib/
-
-# Ignore specific library outputs.
 csv/libcsv.*
 
-# Valgrind files
+# Valgrind garbage
 massif*
 *.log
\ No newline at end of file
diff --git a/TODO b/TODO
old mode 100644
new mode 100755
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index f77bfa6..e84e412 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -82,23 +82,23 @@ namespace largefile {
     this->running = true;
 
     while (this->running == true) {
-      if (this->fp == NULL) {
-		this->running = false;
-		break;
-      }
+		 if (this->fp == NULL) {
+			 this->running = false;
+			 break;
+		 }
 
-      this->inputQueue.lock();
+		 this->inputQueue.lock();
       
-      while (this->inputQueue.size() > 0) {
-	if (this->running == false)
-	  break;
+		 while (this->inputQueue.size() > 0) {
+			 if (this->running == false)
+				 break;
 
-	this->pro->onReadComplete (this->inputQueue.pop());
-      }
+			 this->pro->onReadComplete (this->inputQueue.pop());
+		 }
 
-      this->inputQueue.unlock();
+		 this->inputQueue.unlock();
 
-      Thread::sleep (5);
+		 Thread::sleep (5);
     }
 
     return NULL;
@@ -180,7 +180,7 @@ namespace largefile {
      }
 
     this->running = false;
-    std::fseek (this->fp, cursor, SEEK_SET);
+    //std::fseek (this->fp, cursor, SEEK_SET);
     this->dispatcher->removeWorker (this);
     return NULL;
   }

commit 3dd324f6e7a180aa39434dc29b017ad57a67cc5b
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 5 17:09:14 2009 -0400

    Added TODO file.

diff --git a/TODO b/TODO
new file mode 100644
index 0000000..d72d2a8
--- /dev/null
+++ b/TODO
@@ -0,0 +1,20 @@
+* Fix heap problem inside of libworkbook
+* libworkbook
+	- Quickly update rows 
+		o This should use native GrowSheet, CheckBounds, etc
+	- Quickly update ranges
+		o Utilzies row/tuple update and pointer arithmetic
+* File dispatcher	
+	- Input/Output
+		o Put a timeout on reader/indexer executions
+		o Automatically index based upon the last read
+	- Caching
+		o Run a periodical reader in the background
+		o Run a periodical indexer in the background
+* Visualization 
+	- Controls
+		o Page up, page down for panning
+		o Control + G for GOTO line
+		o Control + O for percentage offset
+		o Control + I for index up to line
+	
\ No newline at end of file

commit f7cfe8650e4dc40946da2fe60af7a78fd5aaed31
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 5 16:09:10 2009 -0400

    Basic pagination.

diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index f893be4..fc601d0 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -138,16 +138,16 @@ namespace largefile {
 
 	  this->wb->sheet_first->apply_row (this->wb->sheet_first,
 					    this->fields,
-					    column.row,
+					    column.row - 1,
 					    this->sizeOfFields);
 
 	  if (column.row >= (column.sheet)->max_rows)
 	    column.row = 0;
 
-	  concurrent::Thread::sleep(1);
+	  concurrent::Thread::sleep(5);
 	}
       }	
-      concurrent::Thread::sleep(1);
+      concurrent::Thread::sleep(5);
     }
 
     return NULL;
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 82e3329..34c7266 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -99,7 +99,7 @@ extern "C" {
         
     wb->gtk_box = box;
     
-    wb->add_new_sheet (wb, "sheet0", 10000, 20);
+    wb->add_new_sheet (wb, "sheet0", 1000, 20);
 
     ThreadArgs args;
     args.push_back ( (void *)wb );
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 40a3ae2..6b436a5 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -16,6 +16,7 @@
    License along with the library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
+#include <gdk/gdkkeysyms.h>
 #include <workbook/workbook.h>
 #include <config/config.h>
 #include <concurrent/Thread.hpp>
@@ -43,64 +44,83 @@ append_pidname (const gchar * pre) {
   return s.str();
 }
 
+static gint
+key_press_callback (GtkWidget * widget, GdkEventKey * event, gpointer data) {
+	FileDispatcher * fdispatcher = (FileDispatcher *)data;
+	
+	switch (event->keyval) {
+		case GDK_Page_Up: {
+			fdispatcher->read (1000,1000);
+		}
+		return FALSE;
+
+		case GDK_Page_Down: {
+			std::cout<<"Down\n";
+		}
+		return FALSE;
+	}
+	return FALSE;
+}
+	
 void
 thread_main (ThreadArgs * args) {
-  Workbook * wb = (Workbook *)args->at(0);
-  Config * cfg  = (Config *)args->at(1);
-  gboolean * SHUTDOWN = (gboolean *)args->at(2);
-
-  ConfigPair * logpath = cfg->get_pair (cfg, "largefile", "log", "path");
-  if (IS_NULL (logpath)) {
-      g_critical ("Failed loading log->path from configuration file; "
-		  "exiting thread");
-      return;
-    }
-
-  FILE * pktlog = NULL;
-  std::string logname = std::string (logpath->value).append("/");
-  logname.append (append_pidname("realtime.").append(".log"));
-
-  if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
-      g_critical ("Failed opening file '%s' for packet logging; exiting"
-		  " thread", logname.c_str());
-      return;
+	Workbook * wb = (Workbook *)args->at(0);
+	Config * cfg  = (Config *)args->at(1);
+	gboolean * SHUTDOWN = (gboolean *)args->at(2);
+	ConfigPair * logpath = cfg->get_pair (cfg, "largefile", "log", "path");
+	if (IS_NULL (logpath)) {
+		g_critical ("Failed loading log->path from configuration file; "
+					"exiting thread");
+		return;
+	}
+
+	FILE * pktlog = NULL;
+	std::string logname = std::string (logpath->value).append("/");
+	logname.append (append_pidname("realtime.").append(".log"));
+
+	if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
+		g_critical ("Failed opening file '%s' for packet logging; exiting"
+					" thread", logname.c_str());
+		return;
     }
 
-  int fdEventId = proactor::Event::uniqueEventId(); 
-  
-  proactor::Proactor proactor;
-  FileDispatcher fdispatcher (fdEventId, &proactor);
-  CsvParser csv_parser (wb, pktlog, 0, 20);
-
-  if (proactor.start() == false) {
-    g_critical ("Failed starting Proactor; exiting thread.");
-    return;
-  }
-
-  if (proactor.addWorker (fdEventId, &csv_parser) == false) {
-    g_critical ("Failed starting CsvParser; exiting thread.");
-    return;
-  }
-
-  if (fdispatcher.open ("/home/johnb/largefile.csv") == false) {
-    g_critical ("Failed opening /home/johnb/largefile.csv");
-    return;
-  }
-
-  if (fdispatcher.start() == false) {
-    g_critical ("Failed starting file dispatcher; exiting thread.");
-    return;
-  }
-  
-  // read first 10,000 lines
-  fdispatcher.read (0, 10000);
-
-  while (*SHUTDOWN == FALSE) {
-    concurrent::Thread::sleep (100);
-  }
-
-  csv_parser.stop();
+	int fdEventId = proactor::Event::uniqueEventId(); 
+	proactor::Proactor proactor;
+	FileDispatcher fdispatcher (fdEventId, &proactor);
+	CsvParser csv_parser (wb, pktlog, 0, 20);
+
+	if (proactor.start() == false) {
+		g_critical ("Failed starting Proactor; exiting thread.");
+		return;
+	}
+
+	if (proactor.addWorker (fdEventId, &csv_parser) == false) {
+		g_critical ("Failed starting CsvParser; exiting thread.");
+		return;
+	}
+
+	if (fdispatcher.open ("/home/johnb/largefile.csv") == false) {
+		g_critical ("Failed opening /home/johnb/largefile.csv");
+		return;
+	}
+
+	if (fdispatcher.start() == false) {
+		g_critical ("Failed starting file dispatcher; exiting thread.");
+		return;
+	}
+
+	gtk_signal_connect (GTK_OBJECT (wb->gtk_window), "key_press_event",
+							  GTK_SIGNAL_FUNC (key_press_callback),
+							  (gpointer)&fdispatcher);
+	
+	fdispatcher.read (0, 1000);
+
+	while (*SHUTDOWN == FALSE) {
+		concurrent::Thread::sleep (100);
+	}
+
+	csv_parser.stop();
   
-  FCLOSE (pktlog);
-  delete args;
+	FCLOSE (pktlog);
+	delete args;
 }
diff --git a/workbook/sheet.c b/workbook/sheet.c
index cede504..c379c26 100755
--- a/workbook/sheet.c
+++ b/workbook/sheet.c
@@ -58,6 +58,7 @@ struct geometryFileEntry {
   GdkColor cellBackground;
 };
 
+/*
 static GtkSheetCell *
 gtk_sheet_cell_new (void) {
   GtkSheetCell * cell = g_new (GtkSheetCell, 1);
@@ -66,6 +67,7 @@ gtk_sheet_cell_new (void) {
   cell->attributes = NULL;
   return cell;
 }
+*/
 /*
 static void
 GrowSheet (GtkSheet * tbl, gint newrows, gint newcols) {

commit e70e286532460289f991984304ef291f6d5925e2
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 5 13:34:36 2009 -0400

    Hacked around heap problem; needs to be fixed

diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index 8bbd4e6..f893be4 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -46,7 +46,7 @@ namespace largefile {
 	// Resize the cell array here.
 	if (column->field >= array_max) {
 	  int max = (2 * array_max);
-	  (column->array) = (Cell **) g_realloc ((column->array), max * sizeof (Cell*));
+	  (column->array) = (Cell **) g_realloc ((column->array),max*sizeof (Cell*));
 
 	  for (int ii = array_max; ii < max; ii++)
 	    (column->array)[ii] = NULL;
@@ -78,16 +78,16 @@ namespace largefile {
     this->verbosity = verbosity;
     this->sizeOfFields = 0;
     this->maxOfFields = maxOfFields;
-    this->fields = (Cell **) g_malloc (maxOfFields * sizeof (Cell*));
+    this->fields = (Cell **) g_malloc (maxOfFields*sizeof (Cell*));
 
     for (int ii = 0; ii < this->maxOfFields; ii++)
       this->fields[ii] = NULL;
   }
 
   CsvParser::~CsvParser (void) {
-    for (int ii = 0; ii <= this->maxOfFields; ii++) {
-	  if (this->fields[ii])
-		this->fields[ii]->destroy (this->fields[ii]);
+    for (int ii = 0; ii < this->maxOfFields; ii++) {
+      if (this->fields[ii])
+	    (this->fields[ii])->destroy (this->fields[ii]);
 	}
     
     g_free (this->fields);
@@ -136,12 +136,15 @@ namespace largefile {
 
 	  csv_fini (&csv, cb1, cb2, &column);
 
-	  this->wb->sheet_first->apply_array (this->wb->sheet_first,
-					      this->fields,
-					      this->sizeOfFields);
+	  this->wb->sheet_first->apply_row (this->wb->sheet_first,
+					    this->fields,
+					    column.row,
+					    this->sizeOfFields);
 
 	  if (column.row >= (column.sheet)->max_rows)
 	    column.row = 0;
+
+	  concurrent::Thread::sleep(1);
 	}
       }	
       concurrent::Thread::sleep(1);
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index ad7959c..40a3ae2 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -91,7 +91,7 @@ thread_main (ThreadArgs * args) {
     g_critical ("Failed starting file dispatcher; exiting thread.");
     return;
   }
-
+  
   // read first 10,000 lines
   fdispatcher.read (0, 10000);
 
diff --git a/workbook/cell.c b/workbook/cell.c
index 0d5cee3..3dcd154 100755
--- a/workbook/cell.c
+++ b/workbook/cell.c
@@ -47,9 +47,9 @@ cell_object_init (void)
 {
   Cell * cell = NEW (Cell);
 
-  cell->attributes.bgcolor = g_string_new_len ("", 4096);
-  cell->attributes.fgcolor = g_string_new_len ("", 4096);
   cell->value = g_string_new_len ("", 4096);
+  cell->attributes.bgcolor = g_string_new_len ("", 1024);
+  cell->attributes.fgcolor = g_string_new_len ("", 1024);
 
   /* Methods */
   cell->set_fgcolor = cell_method_set_fgcolor;
diff --git a/workbook/sheet.c b/workbook/sheet.c
index 32060d1..cede504 100755
--- a/workbook/sheet.c
+++ b/workbook/sheet.c
@@ -17,6 +17,7 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include <workbook/sheet.h>
+#include <gtkextra/gtksheet.h>
 #include <string.h>
 
 /* sheet.c (static) */
@@ -38,16 +39,15 @@ static void sheet_method_range_set_foreground (Sheet *,
 static void sheet_method_set_attention (Sheet *, gint);
 static gboolean sheet_method_load (Sheet *, const gchar *);
 static gboolean sheet_method_save (Sheet *, const gchar *);
+static void sheet_method_apply_cellrow (Sheet *, Cell **, gint, gint);
 
-struct geometryFileHeader
-{
+struct geometryFileHeader {
   gint fileVersion;
   gint maxRow;
   gint maxColumn;
 };
 
-struct geometryFileEntry
-{
+struct geometryFileEntry {
   gint cellRow;
   gint cellCol;
   gint cellTextLength;
@@ -58,6 +58,57 @@ struct geometryFileEntry
   GdkColor cellBackground;
 };
 
+static GtkSheetCell *
+gtk_sheet_cell_new (void) {
+  GtkSheetCell * cell = g_new (GtkSheetCell, 1);
+  cell->text = NULL;
+  cell->link = NULL;
+  cell->attributes = NULL;
+  return cell;
+}
+/*
+static void
+GrowSheet (GtkSheet * tbl, gint newrows, gint newcols) {
+  gint ii, jj, inirow, inicol;
+
+  inirow = tbl->maxallocrow + 1;
+  inicol = tbl->maxalloccol + 1;
+
+  tbl->maxalloccol = tbl->maxalloccol + newcols;
+  tbl->maxallocrow = tbl->maxallocrow + newrows;
+
+  if (newrows > 0) {
+    tbl->data = (GtkSheetCell ***) g_realloc (tbl->data,
+					      (tbl->maxallocrow+1)*sizeof(GtkSheetCell**)+sizeof(double));
+
+    for (ii = inirow; ii <= tbl->maxallocrow; ii++) {
+      tbl->data[ii] = (GtkSheetCell **) g_malloc ((tbl->maxcol+1)*sizeof(GtkSheetCell*)+sizeof(double));
+
+      for (jj = 0; jj < inicol; jj++)
+	tbl->data[ii][jj] = NULL;
+    }
+  }
+
+  if (newcols > 0) {
+    for (ii = 0; ii <= tbl->maxallocrow; ii++) {
+      tbl->data[ii] = (GtkSheetCell **) g_realloc (tbl->data[ii],
+						   (tbl->maxalloccol+1)*sizeof(GtkSheetCell*)+sizeof(double));
+
+      for (jj = inicol; jj <= tbl->maxalloccol; jj++)
+	tbl->data[ii][jj] = NULL;
+    }
+  }
+}
+
+static void
+CheckBounds (GtkSheet * tbl, gint row, gint col) {
+  gint newrows = 0, newcols = 0;
+
+  if (col > tbl->maxalloccol) newcols = col - tbl->maxalloccol;
+  if (row > tbl->maxallocrow) newrows = row - tbl->maxallocrow;
+  if (newrows > 0 || newcols > 0) GrowSheet (tbl, newrows, newcols);
+}
+*/
 /* @description: This method creates a new Sheet object and returns the
    pointer to that object. It calls the constructor function to do so.
    @book: A pointer to the Workbook that the object will be a part of.
@@ -131,6 +182,7 @@ sheet_object_init (Workbook * book,
   sheet->apply_range = sheet_method_apply_cellrange;
   sheet->apply_array = sheet_method_apply_cellarray;
   sheet->apply_cell = sheet_method_apply_cell;
+  sheet->apply_row = sheet_method_apply_cellrow;
   sheet->range_set_foreground = sheet_method_range_set_foreground;
   sheet->range_set_background = sheet_method_range_set_background;
   sheet->set_attention = sheet_method_set_attention;
@@ -350,6 +402,50 @@ sheet_method_apply_cellrange (Sheet * sheet,
 }
 
 static void
+sheet_method_apply_cellrow (Sheet * sheet,
+			    Cell ** array,
+			    gint row,
+			    gint size) {
+  ASSERT (sheet != NULL);
+  g_return_if_fail (array != NULL);
+
+  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+  GtkSheetCell ** cell;
+  Cell * item;
+
+  if (row > gtksheet->maxrow || row < 0) return;
+  if (size > gtksheet->maxcol || size < 0) return;
+
+  gdk_threads_enter();
+
+  for (int col = 0; col < size; col++) {
+    item = array[col]; 
+    cell = &gtksheet->data[row][col];
+    
+    gtk_sheet_set_cell_text (gtksheet,
+			     row,
+			     col,
+			     item->value->str);
+    /*
+    if (*cell == NULL)
+      (*cell) = gtk_sheet_cell_new();
+      
+    (*cell)->row = row;
+    (*cell)->col = col;
+
+    if ((*cell)->text)
+      g_free ((*cell)->text);
+      
+    (*cell)->text = g_strdup (item->value->str);
+    */
+
+    item->value->str[0] = item->attributes.bgcolor->str[0] = item->attributes.fgcolor->str[0] = 0;
+  }
+
+  gdk_threads_leave();
+}
+
+static void
 sheet_method_apply_cellarray (Sheet * sheet, 
 			      Cell ** array,
 			      gint size)
@@ -357,6 +453,8 @@ sheet_method_apply_cellarray (Sheet * sheet,
   ASSERT (sheet != NULL);
   g_return_if_fail (array != NULL);
 
+  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+
   gdk_threads_enter ();
 
   /* We'll see how this performs for now. In the future we may want to go
@@ -366,7 +464,7 @@ sheet_method_apply_cellarray (Sheet * sheet,
   for (gint ii = 0; ii < size; ii++) {
     Cell * cell = array[ii];
 
-    gtk_sheet_set_cell_text (GTK_SHEET (sheet->gtk_sheet),
+    gtk_sheet_set_cell_text (gtksheet,
 			     cell->row,
 			     cell->column,
 			     cell->value->str);
@@ -381,10 +479,7 @@ sheet_method_apply_cellarray (Sheet * sheet,
 				   &cell->range, 
 				   cell->attributes.fgcolor->str);
 
-    /* Clear all of the strings */
-    g_string_assign (cell->value, "");
-    g_string_assign (cell->attributes.bgcolor, "");
-    g_string_assign (cell->attributes.fgcolor, "");
+    cell->value->str[0] = cell->attributes.bgcolor->str[0] = cell->attributes.fgcolor->str[0] = 0;
   }
 
   gdk_threads_leave ();

commit 042e3e3271f7d422c84798e89714de9d600bcc3e
Author: John Bellone <jvb4@njit.edu>
Date:   Fri Jun 5 10:06:59 2009 -0400

    Fixed memory issue inside of workbook/sheet.c

diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index 55f117a..8bbd4e6 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -49,7 +49,7 @@ namespace largefile {
 	  (column->array) = (Cell **) g_realloc ((column->array), max * sizeof (Cell*));
 
 	  for (int ii = array_max; ii < max; ii++)
-		array[ii] = NULL;
+	    (column->array)[ii] = NULL;
 	}
 	
 	if ((column->array)[column->field] == NULL)
diff --git a/workbook/cell.c b/workbook/cell.c
index 52147ff..0d5cee3 100755
--- a/workbook/cell.c
+++ b/workbook/cell.c
@@ -1,4 +1,21 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include <workbook/cell.h>
 
 /* cell.c (static) */
diff --git a/workbook/sheet.c b/workbook/sheet.c
index 0c6dd8d..32060d1 100755
--- a/workbook/sheet.c
+++ b/workbook/sheet.c
@@ -1,4 +1,21 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include <workbook/sheet.h>
 #include <string.h>
 
@@ -284,8 +301,7 @@ sheet_method_set_attention (Sheet * sheet, gint attention)
 
   /* Do something funky to show that you should be looking at ME!
      Oh, GtkNotebook tab, why are thou so vain? */
-  if ((sheet->has_focus == FALSE) && (sheet->notices > 0))
-    {
+  if ((sheet->has_focus == FALSE) && (sheet->notices > 0)) {
       
     }
 
@@ -348,25 +364,27 @@ sheet_method_apply_cellarray (Sheet * sheet,
      boost (mainly because we should not have to check all the bounds each
      time we want to update). */
   for (gint ii = 0; ii < size; ii++) {
+    Cell * cell = array[ii];
+
     gtk_sheet_set_cell_text (GTK_SHEET (sheet->gtk_sheet),
-			     array[ii]->row,
-			     array[ii]->column,
-			     array[ii]->value->str);
+			     cell->row,
+			     cell->column,
+			     cell->value->str);
 
-    if (!IS_NULLSTR (array[ii]->attributes.bgcolor->str))
+    if (!IS_NULLSTR (cell->attributes.bgcolor->str))
       sheet->range_set_background (sheet, 
-				   &array[ii]->range, 
-				   array[ii]->attributes.bgcolor->str);
+				   &cell->range, 
+				   cell->attributes.bgcolor->str);
 
-    if (!IS_NULLSTR (array[ii]->attributes.fgcolor->str))
+    if (!IS_NULLSTR (cell->attributes.fgcolor->str))
       sheet->range_set_foreground (sheet, 
-				   &array[ii]->range, 
-				   array[ii]->attributes.fgcolor->str);
+				   &cell->range, 
+				   cell->attributes.fgcolor->str);
 
     /* Clear all of the strings */
-    g_string_assign (array[ii]->value, "");
-    g_string_assign (array[ii]->attributes.bgcolor, "");
-    g_string_assign (array[ii]->attributes.fgcolor, "");
+    g_string_assign (cell->value, "");
+    g_string_assign (cell->attributes.bgcolor, "");
+    g_string_assign (cell->attributes.fgcolor, "");
   }
 
   gdk_threads_leave ();
diff --git a/workbook/workbook.c b/workbook/workbook.c
index 15baf6c..15bcc96 100755
--- a/workbook/workbook.c
+++ b/workbook/workbook.c
@@ -1,4 +1,21 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include <workbook/workbook.h>
 #include <glib/gthread.h>
 #include <string.h>

commit dc8691a6af63b97bd1eda4af934a2ecb9aefcbfa
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jun 4 16:50:40 2009 -0400

    Heap problem.

diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index 8d12db5..55f117a 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -40,26 +40,22 @@ namespace largefile {
      is parsed and cb2 is called after a tuple/row is parsed. */
   static void 
   cb1 (void * s, size_t length, void * data) {
-	struct csv_column * column = (struct csv_column *)data;
+	struct csv_column * column = (struct csv_column *) data;
 	int & array_max = column->array_max;
 
 	// Resize the cell array here.
 	if (column->field >= array_max) {
-	  int max = array_max * 2;
-	  Cell ** new_array = (Cell **)malloc (max * sizeof (Cell*));
+	  int max = (2 * array_max);
+	  (column->array) = (Cell **) g_realloc ((column->array), max * sizeof (Cell*));
 
-	  for (int ii = 0; ii < array_max; ii++)
-		new_array[ii] = (column->array)[ii];
-
-	  for (int jj = array_max; jj < max; jj++)
-		new_array[jj] = cell_new();
-
-	  free (column->array);
-	  column->array = new_array;
-	  array_max = max;
+	  for (int ii = array_max; ii < max; ii++)
+		array[ii] = NULL;
 	}
+	
+	if ((column->array)[column->field] == NULL)
+	  (column->array)[column->field] = cell_new();
 
-	Cell * cell = column->array[column->field];
+	Cell * cell = (column->array)[column->field];
 	cell->set_row (cell, column->row);
 	cell->set_column (cell, column->field++);
 	cell->set_value_length (cell, s, length);
@@ -82,17 +78,19 @@ namespace largefile {
     this->verbosity = verbosity;
     this->sizeOfFields = 0;
     this->maxOfFields = maxOfFields;
-    this->fields = (Cell **)malloc (maxOfFields * sizeof (Cell*));
+    this->fields = (Cell **) g_malloc (maxOfFields * sizeof (Cell*));
 
     for (int ii = 0; ii < this->maxOfFields; ii++)
-      this->fields[ii] = cell_new();
+      this->fields[ii] = NULL;
   }
 
   CsvParser::~CsvParser (void) {
-    for (int ii = 0; ii < this->maxOfFields; ii++)
-      this->fields[ii]->destroy (this->fields[ii]);
+    for (int ii = 0; ii <= this->maxOfFields; ii++) {
+	  if (this->fields[ii])
+		this->fields[ii]->destroy (this->fields[ii]);
+	}
     
-    free (this->fields);
+    g_free (this->fields);
   }
 
   void *

commit 5920114992ad66eb65627d14052e08b5feac41e4
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jun 4 16:02:31 2009 -0400

    Surpressing warnings regarding string writes in GTK. -Wno-write-strings.

diff --git a/Makefile.base b/Makefile.base
index e860e8e..dbec46b 100755
--- a/Makefile.base
+++ b/Makefile.base
@@ -36,4 +36,4 @@ LIBS += -Wl,-rpath ${LIBDIR}
 LIBS += `pkg-config gtk+-2.0 glib-2.0 --libs`
 
 CCFLAGS=-g -O0 -std=c99 -Wall -pthread
-CXFLAGS=-g -O0 -Wall
\ No newline at end of file
+CXFLAGS=-g -O0 -Wall -Wno-write-strings
\ No newline at end of file

commit 572eb132151a5273a6672a547df600e473d42db5
Author: John Bellone <jvb4@njit.edu>
Date:   Thu Jun 4 15:42:45 2009 -0400

    Fixed a overrun bug found with valgrind in libconfig.

diff --git a/config/config.c b/config/config.c
index 98adcbf..0fced05 100755
--- a/config/config.c
+++ b/config/config.c
@@ -87,24 +87,24 @@ configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
 
   gchar buf[1024], word[1024];
   gchar * q = NULL;
-  g_stpcpy (buf, p);
+  g_stpcpy (word, p);
 
   /* This block of code makes sure that we indeed have an opening brace
     to continue with parsing of the configuration file. */
   do
     {
-      p = buf;
+      p = word;
       
       if (EXPECT (p, q, '{'))
 	{
-	  g_stpcpy (buf, q+1);
+	  g_stpcpy (buf, q + 1);
 	  break;
 	} 
 
       if (*q == '\0')
 	continue;
       return NULL;
-    } while (fgets (buf, 1024, fp) != NULL);
+    } while (fgets (word, 1024, fp) != NULL);
 
   /* Start actually parsing rows now. */
   do 
@@ -356,29 +356,29 @@ config_method_load (Config * c, FILE * fp)
       return FALSE;
     }
 
-  gchar buf[1024], word[1024];
-  gchar * p = NULL, * q = NULL;
-
-  while (fgets (buf, 1024, fp) != NULL)
-    {
-      p = buf;
+  gchar * buf = g_malloc (sizeof (char) * 1024);
+  gchar word[1024];
+  gchar * p = NULL, * q = NULL, * r = NULL;
 
-      while ((*p != '\0') && (*p != '\n'))
+  while ((p = fgets (buf, 1024, fp)) != NULL) {
+      r = buf + (strlen (buf) - 1);
+ 
+      while (p && (p < r) && (*p != '\n'))
 	{
 	  if (*p == '%')
 	    {
-	      if ((q = parse (p+1, &word[0], 1024, ' ')) == NULL)
-		{
-		  /* STUB: exit parsing with a failure. */
-		  return FALSE;
-		}
+	      if ((q = parse (p+1, &word[0], 1023, ' ')) == NULL) {
+		/* STUB: exit parsing with a failure. */
+		g_free (buf);	
+		return FALSE;
+	      }
 
 	      if (strcmp (word, "block") == 0)
 		{
-		  if ((q = parse (q+1, &word[0], 1024, ' ')) == NULL)
-		    {
-		      return FALSE;
-		    }
+		  if ((q = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+		    g_free(buf);
+		    return FALSE;
+		  }
 		  
 		  /* Replace the block if it already exists. Throw error. */
 		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
@@ -392,17 +392,17 @@ config_method_load (Config * c, FILE * fp)
 
 		  b = configblock_new (c, trim (&word[0]));
 
-		  if ((p = b->parse (b, q, fp)) == NULL)
-		    {
-		      return FALSE;
-		    }
+		  if ((p = b->parse (b, q, fp)) == NULL) {
+		    g_free (buf);
+		    return FALSE;
+		  }
 		}
 	      else if (strcmp (word, "include") == 0)
 		{
-		  if ((p = parse (q+1, &word[0], 1024, ' ')) == NULL)
-		    {
-		      return FALSE;
-		    }
+		  if ((p = parse (q+1, &word[0], 1023, ' ')) == NULL) {
+		    g_free (buf);
+		    return FALSE;
+		  }
 
 		  /* Include the file; we're going to load up this file
 		     first and then proceed with parsing. */
@@ -419,21 +419,23 @@ config_method_load (Config * c, FILE * fp)
 
 		  c->load (c, ifp);
 		}
-	      else
+	      else {
+		g_free (buf);
 		return FALSE;
+	      }
 	    }
 	  /* BUGFIX: Need to check for tabs. */
 	  else if ((*p != ' ') && (*p != '\t'))
 	    {
 	      /* STUB: error out */
+	      g_free (buf);
 	      return FALSE;
 	    }
 
-	  if (*p == '\0')
-	    break;
 	  p++;
 	}
     }
+  g_free (buf);
   return TRUE;
 }
 
@@ -460,7 +462,8 @@ config_method_open (Config * c)
 {
   ASSERT (c != NULL);
 
-  if (IS_NULLSTR (c->filename)) return FALSE;
+  if (IS_NULLSTR (c->filename))
+    return FALSE;
 
   FILE * fp = NULL;
   if ((fp = fopen (c->filename, "r")) == NULL)

commit 13c44774c420bf2d6863053ee65ee1435b090ea9
Author: John Bellone <jvb4@njit.edu>
Date:   Wed Jun 3 22:48:57 2009 -0400

    Added logfiles to .gitignore

diff --git a/.gitignore b/.gitignore
index 1341dcb..20399b8 100755
--- a/.gitignore
+++ b/.gitignore
@@ -11,4 +11,5 @@ lib/
 csv/libcsv.*
 
 # Valgrind files
-massif*
\ No newline at end of file
+massif*
+*.log
\ No newline at end of file

commit 322939be7ae0ade685bd015b1f912bdef989b072
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 29 16:33:44 2009 -0400

    Added massif excludes.

diff --git a/.gitignore b/.gitignore
index c734445..1341dcb 100755
--- a/.gitignore
+++ b/.gitignore
@@ -8,4 +8,7 @@ bin/
 lib/
 
 # Ignore specific library outputs.
-csv/libcsv.*
\ No newline at end of file
+csv/libcsv.*
+
+# Valgrind files
+massif*
\ No newline at end of file

commit 5f5e117b96447624a1ea0433320cd63a146afe38
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 29 14:29:31 2009 -0400

    Fixed typo.

diff --git a/etc/TERMS b/etc/TERMS
index dce5a1b..860344c 100755
--- a/etc/TERMS
+++ b/etc/TERMS
@@ -5,7 +5,7 @@ the Free Software Foundation, either version 2 of the License, or
 
 GTKWorkbook is distributed in the hoe that it will be useful, but WITHOUT
 ANY WARRANTY; without even the impled warranty of MERCHANTABILITY or
-FITNESS FO A PARTICULAR PURPOSE. See the GNU Lesser General Public License
+FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 for more details.
 
 You should have received a copy of the GNU Lesser General Public License

commit 0475f1c4c4a03cf3bdcba0b4b8bed8de9a378092
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 29 14:29:10 2009 -0400

    Changed license header to remove the name of the file.

diff --git a/include/workbook/cell.h b/include/workbook/cell.h
index 87a6022..fb956cd 100755
--- a/include/workbook/cell.h
+++ b/include/workbook/cell.h
@@ -1,6 +1,4 @@
 /* 
-   cell.h - Cell Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/include/workbook/sheet.h b/include/workbook/sheet.h
index 0f46c30..6156459 100755
--- a/include/workbook/sheet.h
+++ b/include/workbook/sheet.h
@@ -1,6 +1,4 @@
 /* 
-   sheet.h - Sheet Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -73,6 +71,7 @@ typedef struct _Sheet Sheet;
 			 const CellAttributes *);
     void (*apply_array) (Sheet *, Cell **, gint);
     void (*apply_cell) (Sheet *, const Cell *);
+    void (*apply_row) (Sheet *, Cell **, gint, gint);
 
     void (*set_cell) (Sheet *, gint, gint, const gchar *);  
     void (*range_set_background) (Sheet *, 
diff --git a/include/workbook/workbook.h b/include/workbook/workbook.h
index 5fdb31c..0e39324 100755
--- a/include/workbook/workbook.h
+++ b/include/workbook/workbook.h
@@ -1,6 +1,4 @@
 /* 
-   workbook.h - Workbook Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 

commit 65d7acf906762f3a548140f778bde583f9672227
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 29 12:25:32 2009 -0400

    Fixed line read bug/memory leak; was being caused by miscalculation of maximum row.

diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index bdd46b8..8d12db5 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -42,26 +42,22 @@ namespace largefile {
   cb1 (void * s, size_t length, void * data) {
 	struct csv_column * column = (struct csv_column *)data;
 	int & array_max = column->array_max;
-	int & array_size = column->array_size;
 
 	// Resize the cell array here.
-	if (array_max >= array_size) {
+	if (column->field >= array_max) {
 	  int max = array_max * 2;
 	  Cell ** new_array = (Cell **)malloc (max * sizeof (Cell*));
 
 	  for (int ii = 0; ii < array_max; ii++)
 		new_array[ii] = (column->array)[ii];
 
-	  for (int ii = array_max; ii < max; ii++)
-		new_array[ii] = cell_new();
+	  for (int jj = array_max; jj < max; jj++)
+		new_array[jj] = cell_new();
 
 	  free (column->array);
-	  (column->array) = new_array;
+	  column->array = new_array;
 	  array_max = max;
 	}
-	
-	if (array_size >= column->field)
-	  array_size++;
 
 	Cell * cell = column->array[column->field];
 	cell->set_row (cell, column->row);
@@ -73,8 +69,8 @@ namespace largefile {
   cb2 (int c, void * data) {
     struct csv_column * column = (struct csv_column *)data;
     column->row++;
+    column->array_size = column->field - 1;
     column->field = 0;
-    column->array_size = 0;
   }
 
   CsvParser::CsvParser (Workbook * wb,
@@ -84,13 +80,12 @@ namespace largefile {
     this->wb = wb;
     this->log = log;
     this->verbosity = verbosity;
-    this->fields = (Cell **)malloc (maxOfFields * sizeof (Cell*));
     this->sizeOfFields = 0;
+    this->maxOfFields = maxOfFields;
+    this->fields = (Cell **)malloc (maxOfFields * sizeof (Cell*));
 
-    for (int ii = 0; ii < maxOfFields; ii++)
+    for (int ii = 0; ii < this->maxOfFields; ii++)
       this->fields[ii] = cell_new();
-
-    this->maxOfFields = maxOfFields;
   }
 
   CsvParser::~CsvParser (void) {
@@ -106,12 +101,12 @@ namespace largefile {
     std::queue<std::string> queue;
     struct csv_parser csv;
     struct csv_column column = {this->wb->sheet_first,
-								this->fields,
-								this->maxOfFields,
-								this->sizeOfFields,
-								0,
-								0,
-								new char [1024]};
+				this->fields,
+				this->maxOfFields,
+				this->sizeOfFields,
+				0,
+				0,
+				new char [1024]};
     
     if (csv_init (&csv, CSV_STRICT) != 0) {
       std::cerr << "Failed initializing libcsv parser library\n";
@@ -121,37 +116,38 @@ namespace largefile {
     while (this->running == true) {
       if (this->inputQueue.size() > 0) {
 	
-		// Lock, copy, clear, unlock. - Free this up.
-		this->inputQueue.lock();
-		this->inputQueue.copy (queue);
-		this->inputQueue.clear();
-		this->inputQueue.unlock();
-
-		while (queue.size() > 0) {
-		  std::string & buf = queue.front(); queue.pop();
-		  size_t bytes = buf.length();
-
-		  if (this->running == false)
-			break;
-
-		  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
-			if (csv_error (&csv) == CSV_EPARSE)	
-			  std::cerr << "Parsing error on input: "<<buf<<"\n";
-		  }
-
-		  csv_fini (&csv, cb1, cb2, &column);
-
-		  this->wb->sheet_first->apply_array (this->wb->sheet_first,
-											  this->fields,
-											  this->sizeOfFields);
-
-		  if (column.row >= (column.sheet)->max_rows)
-			column.row = 0;
-		}
-	  }	
-
-	  concurrent::Thread::sleep (5);
+	// Lock, copy, clear, unlock. - Free this up.
+	this->inputQueue.lock();
+	this->inputQueue.copy (queue);
+	this->inputQueue.clear();
+	this->inputQueue.unlock();
+
+	while (queue.size() > 0) {
+	  std::string buf = queue.front(); queue.pop();
+	  size_t bytes = buf.length();
+
+	  if (this->running == false)
+	    break;
+
+	  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
+	    if (csv_error (&csv) == CSV_EPARSE) {
+	      std::cerr << "Parsing error on input: "<<"\n";
+	      continue;
+	    }
+	  }
+
+	  csv_fini (&csv, cb1, cb2, &column);
+
+	  this->wb->sheet_first->apply_array (this->wb->sheet_first,
+					      this->fields,
+					      this->sizeOfFields);
+
+	  if (column.row >= (column.sheet)->max_rows)
+	    column.row = 0;
 	}
+      }	
+      concurrent::Thread::sleep(1);
+    }
 
     return NULL;
   }
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 0f30f7b..f77bfa6 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -172,8 +172,8 @@ namespace largefile {
     std::fseek (this->fp, this->startOffset, SEEK_SET);
 
     for (long int ii = 0; ii < read_max; ii++) {
-	  if (std::fgets (buf, 4096, this->fp) == NULL)		
-		break;
+      if (std::fgets (buf, 4096, this->fp) == NULL)		
+	break;
       
       // Eventually store index here?
       this->dispatcher->onReadComplete (std::string (buf));
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index a13ebc2..82e3329 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -99,7 +99,7 @@ extern "C" {
         
     wb->gtk_box = box;
     
-    wb->add_new_sheet (wb, "sheet0", 100, 20);
+    wb->add_new_sheet (wb, "sheet0", 10000, 20);
 
     ThreadArgs args;
     args.push_back ( (void *)wb );
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index b3c48d1..ad7959c 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -70,7 +70,7 @@ thread_main (ThreadArgs * args) {
   
   proactor::Proactor proactor;
   FileDispatcher fdispatcher (fdEventId, &proactor);
-  CsvParser csv_parser (wb, pktlog, 20);
+  CsvParser csv_parser (wb, pktlog, 0, 20);
 
   if (proactor.start() == false) {
     g_critical ("Failed starting Proactor; exiting thread.");
@@ -93,7 +93,7 @@ thread_main (ThreadArgs * args) {
   }
 
   // read first 10,000 lines
-  fdispatcher.read (0, 10);
+  fdispatcher.read (0, 10000);
 
   while (*SHUTDOWN == FALSE) {
     concurrent::Thread::sleep (100);

commit 8158b929ae193e8e8a3177aba724b4d4a600445c
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 29 12:25:05 2009 -0400

    Changes to etc/ files.

diff --git a/etc/BUGS b/etc/BUGS
old mode 100644
new mode 100755
diff --git a/etc/FEDORA8.install b/etc/FEDORA8.install
old mode 100644
new mode 100755
diff --git a/etc/PROBLEMS b/etc/PROBLEMS
old mode 100644
new mode 100755
diff --git a/etc/TERMS b/etc/TERMS
old mode 100644
new mode 100755
diff --git a/etc/TESTING b/etc/TESTING
old mode 100644
new mode 100755
diff --git a/etc/dotemacs b/etc/dotemacs
old mode 100644
new mode 100755

commit 41a31ea5cd446465a48fc8d53766fa738230214a
Merge: a38154b... d128627...
Author: John Bellone <jvb4@njit.edu>
Date:   Thu May 28 16:07:37 2009 -0400

    Merge branch 'master' of ssh://j_bellone,gtkworkbook@gtkworkbook.git.sourceforge.net/gitroot/gtkworkbook into largefile

commit d128627e56ad7c243a8d32b20435aea6c8b97f00
Author: John Bellone <jvb4@njit.edu>
Date:   Thu May 28 16:06:12 2009 -0400

    Changed README/INSTALL and added additional etc/ files.

diff --git a/INSTALL b/INSTALL
index 20dcd38..4e8318b 100644
--- a/INSTALL
+++ b/INSTALL
@@ -1,43 +1,79 @@
-GTKWorkbook Installation
-------------------------
+GTKWorkbook Installation Guide
+Copyright (C) 2008, 2009 John Bellone, Jr.
+ See etc/TERMS for license information.
 
-0.	Testing Systems
+This file contains general information on the installation of GTKWorkbook.
+Right now there are not any build tools used other than GNU Make so
+dependency checking must be done manually. In the future this will change
+but I do not have the time to get acquantied with automake yet.
 
-	CentOS 5.2 (Redhat)
-	GCC 4.1.2
-	Python 2.4.3
+DEPENDENCIES
 
-1. 	Requirements
+	A. GTK	
 
-	A. GtkExtra
+	   This is obvious but I figured I should state it anyway. 
+	   	
+	B. GtkExtra
 
-	The libworkbook library wraps the GTK+ calls to the GtkSheet widget
-	which is included inside of the GtkExtra library available on
-	sourceforge.net. Due to the age of the gtkextra2 release I would
-	highly suggest downloading directly from the CVS repository.
+	   The libworkbook library wraps GTK+ calls to the GtkSheet widget
+	   which is included inside of the GtkExtra library available on
+	   the FEDORA REPOSITORY, and the SOURCEFORGE.NET project website.
+	   
+	   I have been performing development on gtkextra3 and gtkextra2
+	   which both work with GTKWorkbook; but I would suggest downloading
+	   the latest version of either depending on which version of GTK+
+	   you have installed. You can use their CVS repository on their
+	   project's website:
 
-	http://gtkextra.cvs.sourceforge.net/viewvc/gtkextra/gtkextra-2/
+	   http://gtkextra.cvs.sourceforge.net/viewvc/gtkextra
 
-	B. Pixman
+	C. Pixman
 
-	The GtkExtra library requires this to be installed with the version
-	of GTK that ships with CentOS 5.2. I believe that it is available with
-	newer versions of GTK, but here is the location of the repository if
-	you need to find it. Grab the newest release, compile and install.
+	   The GtkExtra library requires this to be installed with the version	
+	   of GTK+ that ships with CentOS 5.2; but later versions of Fedora 
+	   seem to include this in their distribution. If you are using either
+	   CentOS 5.2 (or the equivalient RedHat distribution) you'll need to
+	   grab this release and go through the motions.
 
-	http://cairographics.org/releases/
-		
-2.	Installation
+	   http://cairographics.org/releases/
 
-	Once all of the dependencies (above) have been installed you can
-	finally get on to the fun stuff. The compliation of the project is
-	rather easy (and quick).
+	   The newest version should suffice as long as it compiles and installs.
 
-	Inside of the root directory of the project, type:
+BASIC INSTALLATION
 
-	make clean all
+      So as I stated before my build system merely uses some shell commands, and a
+      set of Makefiles. I do not use automake as of the writing of this document
+      therefore some care may have to be taken when linking dependencies. The only
+      issue I have ran into is that YUM properly installs GtkExtra include files
+      into: /usr/include instead of /usr/local/include
 
-	If you wish to install:
+      This can be easily (and quickly) changed inside of the Makefile.base which 
+      has a specific include line for the GtkExtra headers. Once this change is
+      made and as long as the dependencies have all been installed you are ready
+      to rock on compliation/installation of this project.
 
-	make clean install
+      1. Copy the .gtkworkbook file from the project directory, and change the
+      paths to where you would like the compiled libraries to be installed to
+      and where your project directory is located.
 
+      You will get compliation errors if your project directory is not correct.
+
+      2. make clean all
+
+      3. Modify the application.cfg file inside of the `bin' directory to account
+      for any changes for the application; this includes the absolute path of the
+      example .so files.
+
+      4. The binaries and .so files are located in the `bin' directory for testing.
+
+      5. Execute with ./bin/gtkworkbook -c ./bin/application.cfg and enjoy!
+
+ADVANCED INSTALLATION
+
+ 	 If you have plans to install the application in a separate directory than
+	 the .so plugin files be sure to remember that the application.cfg input
+	 file must point to the absolute path of the individual files. Relative paths
+	 will work but are currently tied to the execution path of the binary. 
+
+
+      
\ No newline at end of file
diff --git a/README b/README
index e6a8ec8..22dad62 100644
--- a/README
+++ b/README
@@ -1,47 +1,25 @@
-GTKWorkbook README
-------------------
+Copyright (C) 2008, 2009 John Bellone, Jr.
+See the file etc/TERMS for more information on this software's license.
 
-0. Project Website
+The file INSTALL in this directory says how to build and install
+GTKWorkbook on various systems, and if you are reading this document we are
+making the assumption that you have the whole source tree.
 
-	The project has moved to sourceforge.net:
+See the file etc/NEWS for information on new features, and other user-visible
+changes in the recent versions of GTKWorkbook.
 
-	http://gtkworkbook.sourceforge.net/
+The file etc/PROBLEMS contains information on common problems that may occur
+during the use of GTKWorkbook, which may include, compiling, runtime, and
+writing extensions.
 
-	The subversion repository has moved there as well:
+The file etc/BUGS contains known bugs that are being worked on. If you find
+any bugs please report them on sourceforge.net so that they can be added
+to the queue.
 
-	https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook
-	
-1. Installation
-	
-	Please see the INSTALL file in the root directory of the project for
-	more details on how to properly install this project.
+`etc'  holds miscellaneous files that are useful for development purposes but
+       not critical to the application itself.
 
-2. License
-	
-	There should be a file entitled LICENSE in the root directory of the
-	project. All of the code, unless otherwise specified, is licensed
-	under the GNU Lesser General Public License 2.1. There may be
-	individual scripts or files that are licensed under the GNU General
-	Public License 2, but those should be far and few between.
+`src' holds the C/C++ code for the GTKWorkbook application.
 
-	The <libcsv> library included is licensed under the LGPL 2.1 and all
-	the documentation information is included in the library's directory.
 
-3. Documentation
-	
-	Most of the library code is commented pretty well, but much of the
-	example application code has not been documented yet. Any specific
-	questions should be directly asked on the project's forum on the
-	sourceforge.net website.
-
-	In the future there will be an API PDF. 
-
-4. Contact
-	
-	The best means of contact would be through the sourceforge.net project
-	website (information at the top of this document) but if it is urgent
-	then you may contact me directly via email.
-
-	John Bellone, Jr.
-	<https://blogs.njit.edu/jvb4>
-	<jvb4@njit.edu>
\ No newline at end of file
+       
diff --git a/config/Makefile b/config/Makefile
index bb46529..28308e9 100755
--- a/config/Makefile
+++ b/config/Makefile
@@ -16,6 +16,7 @@ install:
 #	chcon -t textrel_shlib_t ${INSLIBDIR}/libconfig.so.1	
 
 libconfig: ${OBJS}
+	${MD} ${PROJDIR}/lib 
 	${RM} ${PROJDIR}/lib/libconfig.so.1
 	${CC} -shared -Wl,-soname,libconfig.so.1 \
 	-o ${PROJDIR}/lib/libconfig.so ${OBJS} ${LIBS} ${LFLAGS}
diff --git a/etc/BUGS b/etc/BUGS
new file mode 100644
index 0000000..e69de29
diff --git a/etc/PROBLEMS b/etc/PROBLEMS
new file mode 100644
index 0000000..e69de29
diff --git a/etc/TERMS b/etc/TERMS
new file mode 100644
index 0000000..dce5a1b
--- /dev/null
+++ b/etc/TERMS
@@ -0,0 +1,12 @@
+GTKWorkbook is free software: you can resdistribute it and/or modify it
+under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2 of the License, or 
+(at your option) any later version.
+
+GTKWorkbook is distributed in the hoe that it will be useful, but WITHOUT
+ANY WARRANTY; without even the impled warranty of MERCHANTABILITY or
+FITNESS FO A PARTICULAR PURPOSE. See the GNU Lesser General Public License
+for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with GTKWorkbook. If not, see <http://www.gnu.org/licenses/>.
\ No newline at end of file
diff --git a/workbook/Makefile b/workbook/Makefile
index ccf9b7d..db5f84e 100755
--- a/workbook/Makefile
+++ b/workbook/Makefile
@@ -14,6 +14,7 @@ install:
 #	chcon -t textrel_shlib_t ${INSLIBDIR}/libworkbook.so.1
 
 libworkbook: ${OBJS}
+	${MD} ${PROJDIR}/lib
 	${RM} ${PROJDIR}/lib/libworkbook.so.1 ${PROJDIR}/lib/libworkbook.so
 	${CC} -shared -Wl,-soname,libworkbook.so.1 \
 	-o ${PROJDIR}/lib/libworkbook.so ${OBJS} ${LIBS} \

commit a38154bb716f095ee96ef6a0593e8824518403e5
Author: John Bellone <jvb4@njit.edu>
Date:   Thu May 28 09:53:22 2009 -0400

    Tinkering with CsvParser/File Dispatcher.

diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index cf1e282..bdd46b8 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -45,7 +45,6 @@ namespace largefile {
 	int & array_size = column->array_size;
 
 	// Resize the cell array here.
-	/*
 	if (array_max >= array_size) {
 	  int max = array_max * 2;
 	  Cell ** new_array = (Cell **)malloc (max * sizeof (Cell*));
@@ -60,8 +59,7 @@ namespace largefile {
 	  (column->array) = new_array;
 	  array_max = max;
 	}
-	*/
-
+	
 	if (array_size >= column->field)
 	  array_size++;
 
@@ -108,12 +106,12 @@ namespace largefile {
     std::queue<std::string> queue;
     struct csv_parser csv;
     struct csv_column column = {this->wb->sheet_first,
-				this->fields,
-				this->maxOfFields,
-				this->sizeOfFields,
-				0,
-				0,
-				new char [1024]};
+								this->fields,
+								this->maxOfFields,
+								this->sizeOfFields,
+								0,
+								0,
+								new char [1024]};
     
     if (csv_init (&csv, CSV_STRICT) != 0) {
       std::cerr << "Failed initializing libcsv parser library\n";
@@ -123,37 +121,37 @@ namespace largefile {
     while (this->running == true) {
       if (this->inputQueue.size() > 0) {
 	
-	// Lock, copy, clear, unlock. - Free this up.
-	this->inputQueue.lock();
-	this->inputQueue.copy (queue);
-	this->inputQueue.clear();
-	this->inputQueue.unlock();
-
-	while (queue.size() > 0) {
-	  std::string buf = queue.front(); queue.pop();
-	  size_t bytes = buf.length();
-
-	  if (this->running == false)
-	    break;
-
-	  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
-	    if (csv_error (&csv) == CSV_EPARSE)	
-	      std::cerr << "Parsing error on input: "<<buf<<"\n";
-	  }
-		  
-	  csv_fini (&csv, cb1, cb2, &column);
-	  
-	  this->wb->sheet_first->apply_array (this->wb->sheet_first,
-					      this->fields,
-					      this->sizeOfFields);
-
-	  if (column.row >= (column.sheet)->max_rows)
-	    column.row = 0;
+		// Lock, copy, clear, unlock. - Free this up.
+		this->inputQueue.lock();
+		this->inputQueue.copy (queue);
+		this->inputQueue.clear();
+		this->inputQueue.unlock();
+
+		while (queue.size() > 0) {
+		  std::string & buf = queue.front(); queue.pop();
+		  size_t bytes = buf.length();
+
+		  if (this->running == false)
+			break;
+
+		  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
+			if (csv_error (&csv) == CSV_EPARSE)	
+			  std::cerr << "Parsing error on input: "<<buf<<"\n";
+		  }
+
+		  csv_fini (&csv, cb1, cb2, &column);
+
+		  this->wb->sheet_first->apply_array (this->wb->sheet_first,
+											  this->fields,
+											  this->sizeOfFields);
+
+		  if (column.row >= (column.sheet)->max_rows)
+			column.row = 0;
+		}
+	  }	
+
+	  concurrent::Thread::sleep (5);
 	}
-      }
-	  
-      concurrent::Thread::sleep (5);
-    }
 
     return NULL;
   }
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 35a8f07..0f30f7b 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -132,7 +132,7 @@ namespace largefile {
 
     for (long int ii = 0; ii < read_max; ii++) {
       if (std::fgets (buf, 4096, this->fp) == NULL) 
-	break;
+		break;
           
       //long int pos = std::ftell (this->fp);
     }
@@ -146,9 +146,9 @@ namespace largefile {
   }
 
   LineReader::LineReader (proactor::InputDispatcher * d,
-			  FILE * fp,
-			  long int start,
-			  long int N) {
+						  FILE * fp,
+						  long int start,
+						  long int N) {
     this->fp = fp;
     this->dispatcher = d;
     this->startOffset = start;
@@ -172,9 +172,8 @@ namespace largefile {
     std::fseek (this->fp, this->startOffset, SEEK_SET);
 
     for (long int ii = 0; ii < read_max; ii++) {
-      
-      if (std::fgets (buf, 4096, this->fp) == NULL)		
-	break;
+	  if (std::fgets (buf, 4096, this->fp) == NULL)		
+		break;
       
       // Eventually store index here?
       this->dispatcher->onReadComplete (std::string (buf));

commit 37e0e75a31111f0ef951128eb424688b667b481d
Merge: 0d78d9d... 44f1199...
Author: John Bellone <jvb4@njit.edu>
Date:   Wed May 27 12:32:54 2009 -0400

    Merged from origin/master.

commit 44f1199883d1b76d30fdef065b24157eac9a2433
Author: John Bellone <jvb4@njit.edu>
Date:   Wed May 27 12:02:21 2009 -0400

    Added /etc with FEDORA8 installation instructions, TESTING information and a dotemacs file.

diff --git a/etc/FEDORA8.install b/etc/FEDORA8.install
new file mode 100644
index 0000000..f715bdb
--- /dev/null
+++ b/etc/FEDORA8.install
@@ -0,0 +1,67 @@
+GTKWorkbook Installation on Fedora 8
+
+Installation Instructions From Clean Fedora 8 DVD Image
+
+1. yum install git-core     	  
+       	       gtk+extra-devel
+	       subversion
+       update
+
+2. git clone git://gtkworkbook.git.sourceforge.net/gitroot/gtkworkbook gtkworkbook-sf
+
+3. cd gtkworkbook-sf
+
+4. cp .gtkworkbook ~/.gtkworkbook
+
+5. [Edit directory paths inside of ~/.gtkworkbook to match where you want the 
+    libraries to compile to, where your project directory is located, and 
+    where any external libraries are.]
+
+6. [Yum installs the gtkextra headers into the following directory:
+    /usr/include/gtkextra-2.0
+
+    You must change the Makefile.base include from:
+    /usr/local/include/gtkextra-2.0 
+    
+    To that directory.]
+
+6. make clean all
+
+7. [Edit the configuration file in (project root)/bin/application.cfg to the proper
+    locations where you will be loading the .so libraries, and writing log files to.
+
+    For example:
+
+    %block newplugin {
+    	   onLoad :: run=1;
+	   linux :: filename=/home/johnb/realtime.so;
+	   log :: path=/home/johnb/logs;
+    }
+
+    Tells the loader to look for the plugin at that *absolute path* and:
+
+    %block newplugin {
+    	   onLoad :: run=1;
+	   linux :: filename=../realtime.so;
+	   log :: path=/home/johnb/logs;
+    }
+
+    Tells the loader to look for the plugin at the *relative path to EXECUTION* which
+    means if you are executing from your home directory it will assume the plugin is
+    in /home (in the above example).
+
+    If you execute in ~/work/gtkworkbook it will assume realtime.so is in ~/work.
+
+    Generally you will always want to use absolute paths.]
+
+8. [Execute gtkworkbook with the -c parameter to include the application.cfg:
+
+   ./bin/gtkworkbook -c ./bin/application.cfg 
+   
+    (OR) 
+   
+   ./gtkworkbook -c (some path to application config)]
+
+9. Enjoy!
+
+(Tested on Sun VirtualBox 2.2 on or about May 22nd 2009 with image from fedoraproject.org)
diff --git a/etc/TESTING b/etc/TESTING
new file mode 100644
index 0000000..e0c29f7
--- /dev/null
+++ b/etc/TESTING
@@ -0,0 +1,7 @@
+Testing
+
+Unless otherwise specified testing has been done via Sun's VirtualBox virtual machine software. This lets me quickly
+test the different configurations that are needed for each branch of the project. If you have any specific problems
+with runtime (or compliation) please remember to indicate if you are running it in a virtual machine, which software,
+and any other information that may be needed (version of GTK+, etc).
+
diff --git a/etc/dotemacs b/etc/dotemacs
new file mode 100644
index 0000000..f11ffc1
--- /dev/null
+++ b/etc/dotemacs
@@ -0,0 +1,2 @@
+;; Do not leave backup files inside of directories!
+(setq make-backup-files nil)
\ No newline at end of file

commit 0d78d9da556d020d8313bb335e42115812ac150b
Author: John Bellone <jvb4@njit.edu>
Date:   Wed May 27 11:25:55 2009 -0400

    Making an attempt to track down major memory leak; seems to be reading in all lines into memory.

diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
index 66431ef..cf1e282 100755
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -1,6 +1,6 @@
 /*
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -45,6 +45,7 @@ namespace largefile {
 	int & array_size = column->array_size;
 
 	// Resize the cell array here.
+	/*
 	if (array_max >= array_size) {
 	  int max = array_max * 2;
 	  Cell ** new_array = (Cell **)malloc (max * sizeof (Cell*));
@@ -59,6 +60,7 @@ namespace largefile {
 	  (column->array) = new_array;
 	  array_max = max;
 	}
+	*/
 
 	if (array_size >= column->field)
 	  array_size++;
@@ -127,13 +129,13 @@ namespace largefile {
 	this->inputQueue.clear();
 	this->inputQueue.unlock();
 
-	if (this->running == false)
-	  break;
-
 	while (queue.size() > 0) {
 	  std::string buf = queue.front(); queue.pop();
 	  size_t bytes = buf.length();
 
+	  if (this->running == false)
+	    break;
+
 	  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
 	    if (csv_error (&csv) == CSV_EPARSE)	
 	      std::cerr << "Parsing error on input: "<<buf<<"\n";
@@ -150,7 +152,7 @@ namespace largefile {
 	}
       }
 	  
-      concurrent::Thread::sleep (100);
+      concurrent::Thread::sleep (5);
     }
 
     return NULL;
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index ebd0fe2..35a8f07 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -76,23 +76,34 @@ namespace largefile {
     mutex.remove();
     return true;
   }
-
+  
   void *
   FileDispatcher::run (void * null) {
     this->running = true;
 
     while (this->running == true) {
       if (this->fp == NULL) {
-	this->running = false;
-	break;
+		this->running = false;
+		break;
+      }
+
+      this->inputQueue.lock();
+      
+      while (this->inputQueue.size() > 0) {
+	if (this->running == false)
+	  break;
+
+	this->pro->onReadComplete (this->inputQueue.pop());
       }
 
-      Thread::sleep (100);
+      this->inputQueue.unlock();
+
+      Thread::sleep (5);
     }
 
     return NULL;
   }
-
+  
   LineIndexer::LineIndexer (proactor::InputDispatcher * d,
 			    FILE * fp,
 			    long int start,
@@ -130,6 +141,7 @@ namespace largefile {
 
     this->running = false;
     std::fseek (this->fp, cursor, SEEK_SET);
+    this->dispatcher->removeWorker (this);
     return NULL;
   }
 
@@ -138,7 +150,7 @@ namespace largefile {
 			  long int start,
 			  long int N) {
     this->fp = fp;
-    this->dispatcher = dispatcher;
+    this->dispatcher = d;
     this->startOffset = start;
     this->numberOfLinesToRead = N;
   }
@@ -163,16 +175,14 @@ namespace largefile {
       
       if (std::fgets (buf, 4096, this->fp) == NULL)		
 	break;
-         
-      //long int pos = std::ftell (this->fp);
       
-      // stub: store index and buf
-    }
-
-    // stub: Push up to our pappy.
+      // Eventually store index here?
+      this->dispatcher->onReadComplete (std::string (buf));
+     }
 
     this->running = false;
     std::fseek (this->fp, cursor, SEEK_SET);
+    this->dispatcher->removeWorker (this);
     return NULL;
   }
 
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 9be7642..a13ebc2 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -99,7 +99,7 @@ extern "C" {
         
     wb->gtk_box = box;
     
-    wb->add_new_sheet (wb, "sheet0", 100, 15);
+    wb->add_new_sheet (wb, "sheet0", 100, 20);
 
     ThreadArgs args;
     args.push_back ( (void *)wb );
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 03251db..b3c48d1 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -70,7 +70,7 @@ thread_main (ThreadArgs * args) {
   
   proactor::Proactor proactor;
   FileDispatcher fdispatcher (fdEventId, &proactor);
-  CsvParser csv_parser (wb, pktlog, 0);
+  CsvParser csv_parser (wb, pktlog, 20);
 
   if (proactor.start() == false) {
     g_critical ("Failed starting Proactor; exiting thread.");
@@ -93,7 +93,7 @@ thread_main (ThreadArgs * args) {
   }
 
   // read first 10,000 lines
-  fdispatcher.read (0, 10000);
+  fdispatcher.read (0, 10);
 
   while (*SHUTDOWN == FALSE) {
     concurrent::Thread::sleep (100);

commit 3d5becd4f82207ae5a068327d4bd21beac24ab54
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 22 15:59:15 2009 -0400

    Modified license headers.

diff --git a/shared/concurrent/ScopedMemoryLock.cpp b/shared/concurrent/ScopedMemoryLock.cpp
index 0d37195..eb9b901 100755
--- a/shared/concurrent/ScopedMemoryLock.cpp
+++ b/shared/concurrent/ScopedMemoryLock.cpp
@@ -30,9 +30,9 @@ namespace concurrent {
     AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
     ScopedMemoryLock::addressMutexMap.unlock();
 
-    /* Now the reason behind setting this pointer to NULL is to force a coredump. Because
-       if someone is passing a pointer that has not been formally added via the static method
-       calls then that means it is very unlikely that they are not removing it either. We do
+    /* Now the reason behind keeping this pointer to NULL is to force a coredump. Because
+       if someone is passing an address that has not been formally added via the static method
+       call then that means it is very unlikely that they are not removing it either. We do
        not want a memory leak therefore this seems like the best method. */
     if (it != ScopedMemoryLock::addressMutexMap.end()) 
       this->mutex = it->second;
diff --git a/shared/proactor/Event.hpp b/shared/proactor/Event.hpp
index 09133bc..f5c9f7e 100755
--- a/shared/proactor/Event.hpp
+++ b/shared/proactor/Event.hpp
@@ -1,6 +1,4 @@
 /* 
-   Event.hpp - Event Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/proactor/InputDispatcher.hpp b/shared/proactor/InputDispatcher.hpp
index cf54f36..ee49202 100755
--- a/shared/proactor/InputDispatcher.hpp
+++ b/shared/proactor/InputDispatcher.hpp
@@ -1,6 +1,4 @@
 /* 
-   InputDispatcher.hpp - Input Dispatcher Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 

commit 16f5f5a93733b13778fa786a1242ab92bb68e2ff
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 22 14:01:21 2009 -0400

    Removed file title names from license header at the top of files.

diff --git a/shared/concurrent/Runnable.hpp b/shared/concurrent/Runnable.hpp
index 9e9cacc..f2241b5 100755
--- a/shared/concurrent/Runnable.hpp
+++ b/shared/concurrent/Runnable.hpp
@@ -1,6 +1,4 @@
 /* 
-   Runnable.hpp - Runnable Interface Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/concurrent/Thread.cpp b/shared/concurrent/Thread.cpp
index 42a93bb..0ac484d 100755
--- a/shared/concurrent/Thread.cpp
+++ b/shared/concurrent/Thread.cpp
@@ -1,6 +1,4 @@
 /* 
-   Thread.cpp - Thread Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -37,7 +35,6 @@ namespace concurrent {
     this->group = group;
     this->runner = runner;
     this->name = name;
-    this->running = false;
   }
 
   Thread::Thread (IRunnable * runner,
@@ -45,17 +42,14 @@ namespace concurrent {
     : group(NULL) {
     this->runner = runner;
     this->name = name;
-    this->running = false;
   }
 
   Thread::Thread (const std::string & name) 
     : group(NULL), runner(NULL) {
     this->name = name;
-    this->running = false;
   }
 
   Thread::Thread (void) : group(NULL), runner(NULL) {
-    this->running = false;
   }
 
   Thread::~Thread (void) {
diff --git a/shared/concurrent/Thread.hpp b/shared/concurrent/Thread.hpp
index 7b284df..79f2cf0 100755
--- a/shared/concurrent/Thread.hpp
+++ b/shared/concurrent/Thread.hpp
@@ -1,6 +1,4 @@
 /* 
-   Thread.hpp - Thread Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/shared/proactor/Worker.hpp b/shared/proactor/Worker.hpp
index 5810e5e..481cae1 100755
--- a/shared/proactor/Worker.hpp
+++ b/shared/proactor/Worker.hpp
@@ -1,6 +1,4 @@
 /* 
-   Worker.hpp - Worker Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/application.c b/src/application.c
index 382ae41..c67dd54 100755
--- a/src/application.c
+++ b/src/application.c
@@ -1,6 +1,4 @@
 /* 
-   application.c - Application Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/application.h b/src/application.h
index eb4a6ef..97eced7 100755
--- a/src/application.h
+++ b/src/application.h
@@ -1,6 +1,4 @@
 /* 
-   application.h - Application Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/include.h b/src/include.h
index c7799ed..6b06e6b 100755
--- a/src/include.h
+++ b/src/include.h
@@ -1,6 +1,4 @@
 /* 
-   include.h - Include Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
old mode 100644
new mode 100755
index a51252a..66431ef
--- a/src/largefile/CsvParser.cpp
+++ b/src/largefile/CsvParser.cpp
@@ -36,8 +36,8 @@ namespace largefile {
   };
 
   /* This structure is due to the libcsv parser; it uses function pointers to
-	 do any work inside of an actual tuple. So the cb1 is called after a field
-	 is parsed and cb2 is called after a tuple/row is parsed. */
+     do any work inside of an actual tuple. So the cb1 is called after a field
+     is parsed and cb2 is called after a tuple/row is parsed. */
   static void 
   cb1 (void * s, size_t length, void * data) {
 	struct csv_column * column = (struct csv_column *)data;
@@ -71,89 +71,89 @@ namespace largefile {
   
   static void
   cb2 (int c, void * data) {
-	struct csv_column * column = (struct csv_column *)data;
-	column->row++;
-	column->field = 0;
-	column->array_size = 0;
+    struct csv_column * column = (struct csv_column *)data;
+    column->row++;
+    column->field = 0;
+    column->array_size = 0;
   }
 
   CsvParser::CsvParser (Workbook * wb,
-						FILE * log,
-						int verbosity,
-						int maxOfFields) {
-	this->wb = wb;
-	this->log = log;
-	this->verbosity = verbosity;
-	this->fields = (Cell **)malloc (maxOfFields * sizeof (Cell*));
-	this->sizeOfFields = 0;
-
-	for (int ii = 0; ii < maxOfFields; ii++)
-	  this->fields[ii] = cell_new();
-
-	this->maxOfFields = maxOfFields;
+			FILE * log,
+			int verbosity,
+			int maxOfFields) {
+    this->wb = wb;
+    this->log = log;
+    this->verbosity = verbosity;
+    this->fields = (Cell **)malloc (maxOfFields * sizeof (Cell*));
+    this->sizeOfFields = 0;
+
+    for (int ii = 0; ii < maxOfFields; ii++)
+      this->fields[ii] = cell_new();
+
+    this->maxOfFields = maxOfFields;
   }
 
   CsvParser::~CsvParser (void) {
-	for (int ii = 0; ii < this->maxOfFields; ii++)
-	  this->fields[ii]->destroy (this->fields[ii]);
-
-	free (this->fields);
+    for (int ii = 0; ii < this->maxOfFields; ii++)
+      this->fields[ii]->destroy (this->fields[ii]);
+    
+    free (this->fields);
   }
 
   void *
   CsvParser::run (void * null) {
-	this->running = true;
-	std::queue<std::string> queue;
-	struct csv_parser csv;
-	struct csv_column column = {this->wb->sheet_first,
-								this->fields,
-								this->maxOfFields,
-								this->sizeOfFields,
-								0,
-								0,
-								new char [1024]};
-
-	if (csv_init (&csv, CSV_STRICT) != 0) {
-	  std::cerr << "Failed initializing libcsv parser library\n";
-	  return NULL;
-	}
-
-	while (this->running == true) {
-	  if (this->inputQueue.size() > 0) {
-
-		// Lock, copy, clear, unlock. - Free this up.
-		this->inputQueue.lock();
-		this->inputQueue.copy (queue);
-		this->inputQueue.clear();
-		this->inputQueue.unlock();
-
-		if (this->running == false)
-		  break;
-
-		while (queue.size() > 0) {
-		  std::string buf = queue.front(); queue.pop();
-		  size_t bytes = buf.length();
-
-		  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
-			if (csv_error (&csv) == CSV_EPARSE)	
-			  std::cerr << "Parsing error on input: "<<buf<<"\n";
-		  }
-		  
-		  csv_fini (&csv, cb1, cb2, &column);
-
-		  this->wb->sheet_first->apply_array (this->wb->sheet_first,
-											  this->fields,
-											  this->sizeOfFields);
-
-		  if (column.row >= (column.sheet)->max_rows)
-			column.row = 0;
-		}
+    this->running = true;
+    std::queue<std::string> queue;
+    struct csv_parser csv;
+    struct csv_column column = {this->wb->sheet_first,
+				this->fields,
+				this->maxOfFields,
+				this->sizeOfFields,
+				0,
+				0,
+				new char [1024]};
+    
+    if (csv_init (&csv, CSV_STRICT) != 0) {
+      std::cerr << "Failed initializing libcsv parser library\n";
+      return NULL;
+    }
+
+    while (this->running == true) {
+      if (this->inputQueue.size() > 0) {
+	
+	// Lock, copy, clear, unlock. - Free this up.
+	this->inputQueue.lock();
+	this->inputQueue.copy (queue);
+	this->inputQueue.clear();
+	this->inputQueue.unlock();
+
+	if (this->running == false)
+	  break;
+
+	while (queue.size() > 0) {
+	  std::string buf = queue.front(); queue.pop();
+	  size_t bytes = buf.length();
+
+	  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
+	    if (csv_error (&csv) == CSV_EPARSE)	
+	      std::cerr << "Parsing error on input: "<<buf<<"\n";
 	  }
+		  
+	  csv_fini (&csv, cb1, cb2, &column);
 	  
-	  concurrent::Thread::sleep (100);
+	  this->wb->sheet_first->apply_array (this->wb->sheet_first,
+					      this->fields,
+					      this->sizeOfFields);
+
+	  if (column.row >= (column.sheet)->max_rows)
+	    column.row = 0;
 	}
+      }
+	  
+      concurrent::Thread::sleep (100);
+    }
 
-	return NULL;
+    return NULL;
   }
 
 } // end of namespace
diff --git a/src/largefile/CsvParser.hpp b/src/largefile/CsvParser.hpp
index b809974..b84a9a7 100755
--- a/src/largefile/CsvParser.hpp
+++ b/src/largefile/CsvParser.hpp
@@ -29,10 +29,10 @@ namespace largefile {
   private:
     Workbook * wb;
     Cell ** fields;
-	FILE * log;
+    FILE * log;
     int verbosity;
-	int maxOfFields;
-	int sizeOfFields;
+    int maxOfFields;
+    int sizeOfFields;
   public:
     CsvParser (Workbook * wb, FILE * log, int verbosity, int maxOfFields = 10);
     virtual ~CsvParser (void);
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index b07c3ef..9be7642 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -1,6 +1,4 @@
 /* 
-   plugin_main.cpp - Largefile Plugin DLL Entry Point
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -31,8 +29,24 @@ extern void thread_main (ThreadArgs *);
 static void
 open_csv_file (GtkWidget * w, gpointer data) {
   ApplicationState * app = (ApplicationState *)data;
-  Config * cfg = app->cfg;
+  //Config * cfg = app->cfg;
+  
+  GtkWidget * dialog = gtk_file_chooser_dialog_new ("Open File",
+						    GTK_WINDOW (app->gtk_window),
+						    GTK_FILE_CHOOSER_ACTION_OPEN,
+						    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+						    GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+						    NULL);  
   
+  gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (dialog), TRUE);
+
+  if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
+    gchar * filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
+
+    g_free (filename);
+  }
+
+  gtk_widget_destroy (dialog);
 }
 
 static GtkWidget *
@@ -46,9 +60,11 @@ largefile_mainmenu_new (ApplicationState * appstate, GtkWidget * window) {
   };
   
   gint nmenu_items = sizeof (menu_items) / sizeof (menu_items[0]);
-  GtkAccelGroup * accel = gtk_accel_group_new ();	
+  GtkAccelGroup * accel 
+    = gtk_accel_group_new ();
+	
   GtkItemFactory * item_factory 
-	= gtk_item_factory_new (GTK_TYPE_MENU_BAR, "<main>", accel);
+    = gtk_item_factory_new (GTK_TYPE_MENU_BAR, "<main>", accel);
   
   gtk_item_factory_create_items (item_factory, nmenu_items, menu_items, appstate);
 
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 6e7bb9b..03251db 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -1,6 +1,4 @@
 /* 
-   thread_main.cpp - Largefile Main Thread Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -94,6 +92,9 @@ thread_main (ThreadArgs * args) {
     return;
   }
 
+  // read first 10,000 lines
+  fdispatcher.read (0, 10000);
+
   while (*SHUTDOWN == FALSE) {
     concurrent::Thread::sleep (100);
   }
diff --git a/src/main.c b/src/main.c
index 4867f2c..0a95610 100755
--- a/src/main.c
+++ b/src/main.c
@@ -1,6 +1,4 @@
 /* 
-   main.c - main() Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/plugin.c b/src/plugin.c
index 23b0493..500240a 100755
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -1,6 +1,4 @@
 /* 
-   plugin.c - Plugin Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/plugin.h b/src/plugin.h
index 598275d..753fb27 100755
--- a/src/plugin.h
+++ b/src/plugin.h
@@ -1,6 +1,4 @@
 /* 
-   plugin.h - Plugin Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
index 39b4a50..f1f98bf 100755
--- a/src/realtime/CsvParser.cpp
+++ b/src/realtime/CsvParser.cpp
@@ -1,6 +1,4 @@
 /*
-   CsvParser.cpp - CSV Parser Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
index 00aed05..05230a5 100755
--- a/src/realtime/CsvParser.hpp
+++ b/src/realtime/CsvParser.hpp
@@ -1,6 +1,4 @@
 /*
-   CsvParser.cpp - CSV Parser Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
index fa52beb..540a4ce 100755
--- a/src/realtime/Network.cpp
+++ b/src/realtime/Network.cpp
@@ -1,6 +1,4 @@
 /*
-   Connection.cpp - Connection Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
index a3a366f..c72fa9a 100755
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -1,6 +1,4 @@
 /* 
-   Connection.hpp - Connection Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/Packet.cpp b/src/realtime/Packet.cpp
index e1b61c1..bd63a35 100755
--- a/src/realtime/Packet.cpp
+++ b/src/realtime/Packet.cpp
@@ -1,6 +1,4 @@
 /* 
-   Packet.cpp - Packet Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/Packet.hpp b/src/realtime/Packet.hpp
index 7ee5935..39e580e 100755
--- a/src/realtime/Packet.hpp
+++ b/src/realtime/Packet.hpp
@@ -1,6 +1,4 @@
 /* 
-   Packet.hpp - Packet Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index 44c76d5..74bd7ce 100755
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -1,6 +1,4 @@
 /* 
-   PacketParser.cpp - PacketParser Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
index c136d69..1e8c0f1 100755
--- a/src/realtime/plugin_main.cpp
+++ b/src/realtime/plugin_main.cpp
@@ -1,6 +1,4 @@
 /* 
-   plugin_main.cpp - Plugin DLL Entry Point
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index 793b9d7..9949e86 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -1,6 +1,4 @@
 /* 
-   thread_main.cpp - Plugin Main Thread Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 

commit 36beb835cd39b6dfe855fb3f334e95cfb3119f99
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 22 14:00:57 2009 -0400

    Added ThreadPool object as private member of FileDispatcher to handle LineIndexer and LineReader objects.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index 4f25a6b..ebd0fe2 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -1,6 +1,4 @@
 /* 
-   File.cpp
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -28,11 +26,29 @@ namespace largefile {
     this->fp = NULL;
     this->pro = pro;
     setEventId(e);
+
+    this->pool.start();
   }
 
   FileDispatcher::~FileDispatcher (void) {
     if (this->fp != NULL)
       this->close();
+
+    this->pool.stop();
+  }
+
+  void
+  FileDispatcher::read (long int start, long int N) {
+    // WARNING: Need some form of a lock on this method.
+    LineReader * reader = new LineReader (this, this->fp, start, N);
+    this->pool.execute (reader);
+  }
+
+  void
+  FileDispatcher::index (long int start, long int N) {
+    // WARNING: Need some form fo a lock on this method.
+    LineIndexer * indexer = new LineIndexer (this, this->fp, start, N);
+    this->pool.execute (indexer);
   }
 
   bool
@@ -40,7 +56,7 @@ namespace largefile {
     if (filename.length() == 0)
       return false;
 
-    if ((this->fp = fopen (filename.c_str(), "r")) == NULL) {
+    if ((this->fp = std::fopen (filename.c_str(), "r")) == NULL) {
       // stub: throw an error somewhere
       return false;
     }
@@ -56,7 +72,7 @@ namespace largefile {
     if (this->fp == NULL)
       return false;
 
-    ::fclose (this->fp); this->fp = NULL;
+    std::fclose (this->fp); this->fp = NULL;
     mutex.remove();
     return true;
   }
@@ -66,7 +82,6 @@ namespace largefile {
     this->running = true;
 
     while (this->running == true) {
-
       if (this->fp == NULL) {
 	this->running = false;
 	break;
@@ -100,23 +115,21 @@ namespace largefile {
     concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 
     // Record current position and seek to where we're going to start.
-    long int cursor = ::ftell (this->fp);
-    ::fseek (this->fp, this->startOffset, SEEK_SET);
+    long int cursor = std::ftell (this->fp);
+    long int & read_max = this->numberOfLinesToRead;
+    std::fseek (this->fp, this->startOffset, SEEK_SET);
 
-    for (long int ii = 0; ii < this->numberOfLinesToRead; ii++) {
-      
-      if (fgets (buf, 4096, this->fp) == NULL) {
-	
+    for (long int ii = 0; ii < read_max; ii++) {
+      if (std::fgets (buf, 4096, this->fp) == NULL) 
 	break;
-      }
-      
-      long int pos = ::ftell (this->fp);
+          
+      //long int pos = std::ftell (this->fp);
     }
 
     // stub: Push up to our pappy.
 
     this->running = false;
-    ::fseek (this->fp, cursor, SEEK_SET);
+    std::fseek (this->fp, cursor, SEEK_SET);
     return NULL;
   }
 
@@ -142,17 +155,16 @@ namespace largefile {
     concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 
     // Record current position and seek to where we're going to start.
-    long int cursor = ::ftell (this->fp);
-    ::fseek (this->fp, this->startOffset, SEEK_SET);
+    long int cursor = std::ftell (this->fp);
+    long int & read_max = this->numberOfLinesToRead;
+    std::fseek (this->fp, this->startOffset, SEEK_SET);
 
-    for (long int ii = 0; ii < this->numberOfLinesToRead; ii++) {
+    for (long int ii = 0; ii < read_max; ii++) {
       
-      if (fgets (buf, 4096, this->fp) == NULL) {
-	
+      if (std::fgets (buf, 4096, this->fp) == NULL)		
 	break;
-      }
-      
-      long int pos = ::ftell (this->fp);
+         
+      //long int pos = std::ftell (this->fp);
       
       // stub: store index and buf
     }
@@ -160,7 +172,7 @@ namespace largefile {
     // stub: Push up to our pappy.
 
     this->running = false;
-    ::fseek (this->fp, cursor, SEEK_SET);
+    std::fseek (this->fp, cursor, SEEK_SET);
     return NULL;
   }
 
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 98d463e..8cd9e3e 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -1,6 +1,4 @@
 /* 
-   File.hpp - File Object handlers
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -21,6 +19,7 @@
 #ifndef FILE_HPP
 #define FILE_HPP
 
+#include <concurrent/ThreadPool.hpp>
 #include <proactor/InputDispatcher.hpp>
 #include <proactor/Proactor.hpp>
 #include <proactor/Worker.hpp>
@@ -34,6 +33,7 @@ namespace largefile {
   private:
     FILE * fp;
     std::string filename;
+    concurrent::ThreadPool pool;
   public:
     FileDispatcher (int e, proactor::Proactor * pro);
     virtual ~FileDispatcher (void);
@@ -41,6 +41,9 @@ namespace largefile {
     bool open (const std::string & filename);
     bool close (void);
     void * run (void * null);
+
+    void read (long int start, long int N);
+    void index (long int start, long int N);
   };
 
   class LineIndexer : public proactor::Worker {
@@ -73,11 +76,6 @@ namespace largefile {
     void * run (void * null);
   };
 
-  struct LineStruct {
-	std::string line;
-	long int position;
-  };
-
 } // end of namespace
 
 #endif

commit 1f056a2ac36aacdb09b43645f06782352d169270
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 22 14:00:05 2009 -0400

    Added defaultTaskMax static variable for default constructor inside of ThreadPool objects. ThreadPool::Task object implementation moved into ThreadPool.cpp

diff --git a/shared/concurrent/ThreadPool.cpp b/shared/concurrent/ThreadPool.cpp
index cebb30f..5b87b37 100755
--- a/shared/concurrent/ThreadPool.cpp
+++ b/shared/concurrent/ThreadPool.cpp
@@ -1,6 +1,4 @@
 /* 
-   ThreadPool.cpp - ThreadPool Object Source File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -21,11 +19,46 @@
 #include "ThreadPool.hpp"
 
 namespace concurrent {
+  int ThreadPool::defaultTaskMax = 5;
+
+  ThreadPool::Task::Task (ThreadPool * pool) {
+    this->pool = pool;
+  }
+
+  void *
+  ThreadPool::Task::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+      if (this->pool->isRunning() == false)
+	break;
+      
+      if (this->pool->getQueueSize() > 0) {
+	IRunnable * runner = this->pool->removeFromQueue();
+	runner->run (NULL);
+	delete runner;
+      }
+      Thread::sleep (1);
+    }
+
+    return NULL;
+  }
+
+  ThreadPool::ThreadPool (void) {
+    this->running = false;
+
+    for (int ii = 0; ii < ThreadPool::defaultTaskMax; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
 
-  ThreadPool::ThreadPool (int nMaxThreads) {
+  ThreadPool::ThreadPool (int N) {
     this->running = false;
 
-    for (int ii = 0; ii < nMaxThreads; ii++) {
+    for (int ii = 0; ii < N; ii++) {
       std::string name = std::string("Thread ");
       name.push_back (ii);
       Thread * t = new Thread (new Task (this), name);
@@ -37,9 +70,9 @@ namespace concurrent {
     if (this->running == true)
       this->stop(true);
 
-    std::list<Thread *>::iterator it = this->threads.begin();
+    ThreadList::iterator it = this->threads.begin();
     while (it != this->threads.end()) {
-      Thread * t = (*it++);
+      Thread * t = (*it); it++;
       delete t;
     }
 
@@ -53,7 +86,7 @@ namespace concurrent {
   ThreadPool::start (void) {
     this->running = true;
     
-  std::list<Thread *>::iterator it = this->threads.begin();
+  ThreadList::iterator it = this->threads.begin();
   while (it != this->threads.end())
     {
       (*it)->start();
@@ -62,7 +95,7 @@ namespace concurrent {
   }
 
   void 
-  ThreadPool::stop (bool join = false) {
+  ThreadPool::stop (bool join) {
     this->running = false;
 
     /* Waiting to join all of the threads will mean that the thread that the
@@ -73,9 +106,9 @@ namespace concurrent {
        of one of the Task threads then you are going to hit a deadlock. Never
        pass the join parameter if this is being called from inside the Tasks.*/
     if (join == true) {
-      std::list<Thread *>::iterator it = this->threads.begin();
+      ThreadList::iterator it = this->threads.begin();
       while (it != this->threads.end()) {
-	(*it)->join ();
+	(*it)->stop();
 	it++;
       }
     }
diff --git a/shared/concurrent/ThreadPool.hpp b/shared/concurrent/ThreadPool.hpp
index a09dd58..1999f0e 100755
--- a/shared/concurrent/ThreadPool.hpp
+++ b/shared/concurrent/ThreadPool.hpp
@@ -1,6 +1,4 @@
 /* 
-   ThreadPool.hpp - ThreadPool Object Header File
-
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
    Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
 
@@ -35,48 +33,31 @@ namespace concurrent {
      @author: John `jb Bellone (jvb4@njit.edu)
      @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
   class ThreadPool {
-    /* @description: This object is an individual task that will be spawned at
-       the start of the ThreadPool. Each thread periodically checks the pool
-       object for any available Runnable objects from the queue. If there are
-       such objects it will take them off, run them and delete them. */
+  private:
+    typedef std::list<Thread *> ThreadList;
+    
     class Task : public IRunnable {
     private:
       ThreadPool * pool;
     public:
-      Task (ThreadPool * pool) {
-	this->pool = pool;
-      }
+      Task (ThreadPool * pool);
       
-      void * run (void *) {
-	this->running = true;
-
-	while (this->running == true)
-	  {
-	    if (pool->isRunning() == false)
-	      break;
-
-	    if (pool->getQueueSize() > 0)
-	      {
-		IRunnable * runner = pool->removeFromQueue();
-		runner->run(NULL);
-		delete runner;
-	      }
-	    ::sleep (1);
-	  }
-	return NULL;
-      }
+      void * run (void * null);
     };
-  private:
+    
     concurrent::Queue<IRunnable *> runQueue;
-    std::list<Thread *> threads;
+    ThreadList threads;
     bool running;
-  public:  
-    ThreadPool (int);
+  public:
+    static int defaultTaskMax;
+
+    ThreadPool (void);
+    ThreadPool (int N);
     ~ThreadPool (void);
 
     /* Thread un-Safe Methods */
     void start (void);
-    void stop (bool);
+    void stop (bool join = false);
 
     /* Thread-Safe Methods */
     void execute (IRunnable *);

commit 817aa8d33ded7f07710b5041d297a24a865affae
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 22 13:59:03 2009 -0400

    Fixed logic error while adding address mutex into the map object. It now adds and removes correctly.

diff --git a/shared/concurrent/ScopedMemoryLock.cpp b/shared/concurrent/ScopedMemoryLock.cpp
index c520d1d..0d37195 100755
--- a/shared/concurrent/ScopedMemoryLock.cpp
+++ b/shared/concurrent/ScopedMemoryLock.cpp
@@ -1,3 +1,21 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "ScopedMemoryLock.hpp"
 
 namespace concurrent {
@@ -5,21 +23,18 @@ namespace concurrent {
 
   ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
     this->hasLock = false;
-	this->address = address;
+    this->address = address;
+    this->mutex = NULL;
 
     ScopedMemoryLock::addressMutexMap.lock();
-
     AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-
     ScopedMemoryLock::addressMutexMap.unlock();
 
     /* Now the reason behind setting this pointer to NULL is to force a coredump. Because
        if someone is passing a pointer that has not been formally added via the static method
        calls then that means it is very unlikely that they are not removing it either. We do
        not want a memory leak therefore this seems like the best method. */
-    if (it == ScopedMemoryLock::addressMutexMap.end()) 
-      this->mutex = NULL;
-    else
+    if (it != ScopedMemoryLock::addressMutexMap.end()) 
       this->mutex = it->second;
 
     if (engage == true)
@@ -51,58 +66,53 @@ namespace concurrent {
 
   bool
   ScopedMemoryLock::remove (void) {
-	if (this->hasLock == false) {
- 	  return false;
-	}
-
-	addressMutexMap.lock();
-
-	AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-	if (it == addressMutexMap.end()) {
-	  addressMutexMap.unlock();
-	  return false;
-	}
+    if (this->hasLock == false) {
+      return false;
+    }
 
-	delete it->second;
-	addressMutexMap.end();
+    addressMutexMap.lock();
 
-	addressMutexMap.unlock();
-	return true;
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+    if (it != addressMutexMap.end()) {
+      delete it->second;
+      addressMutexMap.end();
+      result = true;
+    }
+    
+    addressMutexMap.unlock();
+    return result;
   }
 
   bool 
   ScopedMemoryLock::addMemoryLock (unsigned long address) {
     addressMutexMap.lock();
 
+    bool result = false;
     AddressToMutexMap::iterator it = addressMutexMap.find (address);
-
-    // Already exists inside of the map; we're going to return an error here.
     if (it == addressMutexMap.end()) {
-      addressMutexMap.unlock();
-      return false;
+      addressMutexMap.insert (std::make_pair (address, new Mutex));
+      result = true;
     }
-    
-    addressMutexMap.insert (std::make_pair (address, new Mutex));
 
     addressMutexMap.unlock();
-    return true;
+    return result;
   }
 
   bool 
   ScopedMemoryLock::removeMemoryLock (unsigned long address) {
     addressMutexMap.lock();
 
-	AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it == addressMutexMap.end()) {
-      addressMutexMap.unlock();
-      return false;
+    bool result = false;
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
+    if (it != addressMutexMap.end()) {
+      delete it->second;
+      addressMutexMap.erase(it);
+      result = true;
     }
 
-    delete it->second;
-    addressMutexMap.erase(it);
-
     addressMutexMap.unlock();
-    return true;
+    return result;
   }
 
 } // end of namespace
diff --git a/shared/concurrent/ScopedMemoryLock.hpp b/shared/concurrent/ScopedMemoryLock.hpp
index 0febdc6..eadab0b 100755
--- a/shared/concurrent/ScopedMemoryLock.hpp
+++ b/shared/concurrent/ScopedMemoryLock.hpp
@@ -1,3 +1,21 @@
+/* 
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_CONCURRENT_SCOPEDMEMORYLOCK
 #define HPP_CONCURRENT_SCOPEDMEMORYLOCK
 
@@ -13,7 +31,7 @@ namespace concurrent {
     static AddressToMutexMap addressMutexMap;
 
     bool hasLock;
-	unsigned long address;
+    unsigned long address;
     Mutex * mutex;
   public:
     ScopedMemoryLock (unsigned long address, bool engage = false);
@@ -22,7 +40,7 @@ namespace concurrent {
     void lock (void);
     void unlock (void);
     bool trylock (void);
-	bool remove (void);
+    bool remove (void);
 
     static bool addMemoryLock (unsigned long address);
     static bool removeMemoryLock (unsigned long address);

commit d7ec25cfd5ee91c1b9645c771be3b055fb8398fc
Author: John Bellone <jvb4@njit.edu>
Date:   Tue May 19 10:57:41 2009 -0400

    Changed WorkbookUpdater to CsvParser and incorporated most of the code from realtime CsvParser.

diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/src/largefile/CsvParser.cpp b/src/largefile/CsvParser.cpp
new file mode 100644
index 0000000..a51252a
--- /dev/null
+++ b/src/largefile/CsvParser.cpp
@@ -0,0 +1,159 @@
+/*
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "CsvParser.hpp"
+#include <csv/csv.h>
+#include <workbook/sheet.h>
+#include <queue>
+#include <string>
+#include <iostream>
+
+namespace largefile {
+
+  struct csv_column {
+	Sheet * sheet;
+	Cell ** array;
+	int & array_max;
+	int & array_size;
+	int row;
+	int field;
+	char * value;
+  };
+
+  /* This structure is due to the libcsv parser; it uses function pointers to
+	 do any work inside of an actual tuple. So the cb1 is called after a field
+	 is parsed and cb2 is called after a tuple/row is parsed. */
+  static void 
+  cb1 (void * s, size_t length, void * data) {
+	struct csv_column * column = (struct csv_column *)data;
+	int & array_max = column->array_max;
+	int & array_size = column->array_size;
+
+	// Resize the cell array here.
+	if (array_max >= array_size) {
+	  int max = array_max * 2;
+	  Cell ** new_array = (Cell **)malloc (max * sizeof (Cell*));
+
+	  for (int ii = 0; ii < array_max; ii++)
+		new_array[ii] = (column->array)[ii];
+
+	  for (int ii = array_max; ii < max; ii++)
+		new_array[ii] = cell_new();
+
+	  free (column->array);
+	  (column->array) = new_array;
+	  array_max = max;
+	}
+
+	if (array_size >= column->field)
+	  array_size++;
+
+	Cell * cell = column->array[column->field];
+	cell->set_row (cell, column->row);
+	cell->set_column (cell, column->field++);
+	cell->set_value_length (cell, s, length);
+  }
+  
+  static void
+  cb2 (int c, void * data) {
+	struct csv_column * column = (struct csv_column *)data;
+	column->row++;
+	column->field = 0;
+	column->array_size = 0;
+  }
+
+  CsvParser::CsvParser (Workbook * wb,
+						FILE * log,
+						int verbosity,
+						int maxOfFields) {
+	this->wb = wb;
+	this->log = log;
+	this->verbosity = verbosity;
+	this->fields = (Cell **)malloc (maxOfFields * sizeof (Cell*));
+	this->sizeOfFields = 0;
+
+	for (int ii = 0; ii < maxOfFields; ii++)
+	  this->fields[ii] = cell_new();
+
+	this->maxOfFields = maxOfFields;
+  }
+
+  CsvParser::~CsvParser (void) {
+	for (int ii = 0; ii < this->maxOfFields; ii++)
+	  this->fields[ii]->destroy (this->fields[ii]);
+
+	free (this->fields);
+  }
+
+  void *
+  CsvParser::run (void * null) {
+	this->running = true;
+	std::queue<std::string> queue;
+	struct csv_parser csv;
+	struct csv_column column = {this->wb->sheet_first,
+								this->fields,
+								this->maxOfFields,
+								this->sizeOfFields,
+								0,
+								0,
+								new char [1024]};
+
+	if (csv_init (&csv, CSV_STRICT) != 0) {
+	  std::cerr << "Failed initializing libcsv parser library\n";
+	  return NULL;
+	}
+
+	while (this->running == true) {
+	  if (this->inputQueue.size() > 0) {
+
+		// Lock, copy, clear, unlock. - Free this up.
+		this->inputQueue.lock();
+		this->inputQueue.copy (queue);
+		this->inputQueue.clear();
+		this->inputQueue.unlock();
+
+		if (this->running == false)
+		  break;
+
+		while (queue.size() > 0) {
+		  std::string buf = queue.front(); queue.pop();
+		  size_t bytes = buf.length();
+
+		  if ((bytes = csv_parse (&csv, buf.c_str(), bytes, cb1, cb2, &column)) == bytes) {
+			if (csv_error (&csv) == CSV_EPARSE)	
+			  std::cerr << "Parsing error on input: "<<buf<<"\n";
+		  }
+		  
+		  csv_fini (&csv, cb1, cb2, &column);
+
+		  this->wb->sheet_first->apply_array (this->wb->sheet_first,
+											  this->fields,
+											  this->sizeOfFields);
+
+		  if (column.row >= (column.sheet)->max_rows)
+			column.row = 0;
+		}
+	  }
+	  
+	  concurrent::Thread::sleep (100);
+	}
+
+	return NULL;
+  }
+
+} // end of namespace
diff --git a/src/largefile/CsvParser.hpp b/src/largefile/CsvParser.hpp
new file mode 100755
index 0000000..b809974
--- /dev/null
+++ b/src/largefile/CsvParser.hpp
@@ -0,0 +1,45 @@
+/*
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_LF_CSVPARSER
+#define HPP_LF_CSVPARSER
+
+#include <proactor/Worker.hpp>
+#include <workbook/workbook.h>
+#include <concurrent/Thread.hpp>
+
+namespace largefile {
+
+  class CsvParser : public proactor::Worker {
+  private:
+    Workbook * wb;
+    Cell ** fields;
+	FILE * log;
+    int verbosity;
+	int maxOfFields;
+	int sizeOfFields;
+  public:
+    CsvParser (Workbook * wb, FILE * log, int verbosity, int maxOfFields = 10);
+    virtual ~CsvParser (void);
+
+    void * run (void * null);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 3f65563..98d463e 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -73,6 +73,11 @@ namespace largefile {
     void * run (void * null);
   };
 
+  struct LineStruct {
+	std::string line;
+	long int position;
+  };
+
 } // end of namespace
 
 #endif
diff --git a/src/largefile/WorkbookUpdater.hpp b/src/largefile/WorkbookUpdater.hpp
deleted file mode 100644
index d55b4b5..0000000
--- a/src/largefile/WorkbookUpdater.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-#ifndef HPP_WORKBOOKUPDATER
-#define HPP_WORKBOOKUPDATER
-
-#include <proactor/Worker.hpp>
-#include <workbook/workbook.h>
-#include <concurrent/Thread.hpp>
-
-namespace largefile {
-
-  class WorkbookUpdater : public proactor::Worker {
-  private:
-    Workbook * wb;
-    FILE * log;
-    int verbosity;
-  public:
-    WorkbookUpdater (Workbook * wb, FILE * log, int verbosity) {
-      this->wb = wb;
-      this->log = log;
-      this->verbosity = verbosity;
-    }
-
-    virtual ~WorkbookUpdater (void) {
-
-    }
-
-    void * run (void * null) {
-      this->running = true;
-      
-      while (this->running == true) {
-
-	concurrent::Thread::sleep (100);
-      }
-
-      return NULL;
-    }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index a733b22..6e7bb9b 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -31,7 +31,7 @@
 #include <string>
 #include <sstream>
 #include "File.hpp"
-#include "WorkbookUpdater.hpp"
+#include "CsvParser.hpp"
 
 using namespace largefile;
 
@@ -72,15 +72,15 @@ thread_main (ThreadArgs * args) {
   
   proactor::Proactor proactor;
   FileDispatcher fdispatcher (fdEventId, &proactor);
-  WorkbookUpdater wbupdater (wb, pktlog, 0);
+  CsvParser csv_parser (wb, pktlog, 0);
 
   if (proactor.start() == false) {
     g_critical ("Failed starting Proactor; exiting thread.");
     return;
   }
 
-  if (proactor.addWorker (fdEventId, &wbupdater) == false) {
-    g_critical ("Failed starting workbook updater; exiting thread.");
+  if (proactor.addWorker (fdEventId, &csv_parser) == false) {
+    g_critical ("Failed starting CsvParser; exiting thread.");
     return;
   }
 
@@ -98,7 +98,7 @@ thread_main (ThreadArgs * args) {
     concurrent::Thread::sleep (100);
   }
 
-  wbupdater.stop();
+  csv_parser.stop();
   
   FCLOSE (pktlog);
   delete args;

commit d9de53d8408c816c26add9059f418d7a5107e297
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 15 16:18:07 2009 -0400

    Added .gitignore

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..c734445
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,11 @@
+# Ignore spotlight stores and emacs garbage
+.DS_Store
+*~
+
+# Ignore bin/, lib/ and OBJS/
+OBJS/
+bin/
+lib/
+
+# Ignore specific library outputs.
+csv/libcsv.*
\ No newline at end of file

commit 6a80b7cfc64e91dbfa635ed8bf550838f176efe0
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 15 16:16:49 2009 -0400

    Added proper Proactor hooks for largefile support
    (hopefully) and fixed some gtk menu foul ups.

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..c734445
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,11 @@
+# Ignore spotlight stores and emacs garbage
+.DS_Store
+*~
+
+# Ignore bin/, lib/ and OBJS/
+OBJS/
+bin/
+lib/
+
+# Ignore specific library outputs.
+csv/libcsv.*
\ No newline at end of file
diff --git a/bin/application.cfg b/bin/application.cfg
index 2d257a1..1cb1b40 100755
--- a/bin/application.cfg
+++ b/bin/application.cfg
@@ -13,4 +13,6 @@
 {
 	onLoad :: run=1;
 	linux :: filename=largefile.so;
+	log :: path=/home/johnb;
+	debug :: verbosity=0;
 }
diff --git a/src/application.c b/src/application.c
index 270e0fa..382ae41 100755
--- a/src/application.c
+++ b/src/application.c
@@ -499,9 +499,6 @@ application_method_openextension (ApplicationState * app,
 	}
       else
 	{
-	  gtk_box_pack_end (GTK_BOX (app->gtk_window_vbox),
-			    wb->gtk_box, 1,1,1);
-
 	  /* Attach all of the signals for the Workbook object. */
 	  gtk_signal_connect (GTK_OBJECT (wb->gtk_notebook),
 			      "switch-page",
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index d1fb1ea..4f25a6b 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -19,84 +19,149 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "File.hpp"
+#include <concurrent/ScopedMemoryLock.hpp>
 #include <cstdio>
 
 namespace largefile {
 
-  Line::Line (int startByte, FILE * fp) {
-    this->position = startByte;
-    this->fp = fp;
-    
-    this->read();
+  FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
+    this->fp = NULL;
+    this->pro = pro;
+    setEventId(e);
   }
 
-  Line::~Line (void) {
-    this->line.clear();
+  FileDispatcher::~FileDispatcher (void) {
+    if (this->fp != NULL)
+      this->close();
   }
 
-  void
-  Line::read (void) {
-    char buf[4096];
-
-    if (this->line.length() > 0)
-      return;
+  bool
+  FileDispatcher::open (const std::string & filename) {
+    if (filename.length() == 0)
+      return false;
 
-    std::fgets (buf, 4096, this->fp);
+    if ((this->fp = fopen (filename.c_str(), "r")) == NULL) {
+      // stub: throw an error somewhere
+      return false;
+    }
 
-    this->line = buf;
+    concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
+    this->filename = filename;
+    return true;
   }
 
-  File::File (FILE * fp) {
-    this->fp = fp;
-    
-    reindex();
+  bool 
+  FileDispatcher::close (void) {
+    concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp);
+    if (this->fp == NULL)
+      return false;
+
+    ::fclose (this->fp); this->fp = NULL;
+    mutex.remove();
+    return true;
   }
 
-  File::File (const std::string & path) {
-    this->fp = std::fopen (path.c_str(), "r");
+  void *
+  FileDispatcher::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+
+      if (this->fp == NULL) {
+	this->running = false;
+	break;
+      }
 
-    reindex();
+      Thread::sleep (100);
+    }
+
+    return NULL;
   }
 
-  File::~File (void) {
+  LineIndexer::LineIndexer (proactor::InputDispatcher * d,
+			    FILE * fp,
+			    long int start,
+			    long int N) {
+    this->fp = fp;
+    this->dispatcher = d;
+    this->startOffset = start;
+    this->numberOfLinesToRead = N;
   }
 
-  void 
-  File::reindex (void) {
+  LineIndexer::~LineIndexer (void) {
+
+  }
+
+  void *
+  LineIndexer::run (void * null) {
+    this->running = true;
     char buf[4096];
-    long int pos = 0;
 
-    this->lineIndex.clear();
+    concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
+
+    // Record current position and seek to where we're going to start.
+    long int cursor = ::ftell (this->fp);
+    ::fseek (this->fp, this->startOffset, SEEK_SET);
 
-    std::fseek (this->fp, 0, SEEK_SET);
-    pos = std::ftell (this->fp);
-    
-    while (std::fgets (buf, 4096, this->fp) != NULL) {
-	  //   this->lineIndex.push_back (pos);
-      pos = std::ftell (this->fp);
+    for (long int ii = 0; ii < this->numberOfLinesToRead; ii++) {
+      
+      if (fgets (buf, 4096, this->fp) == NULL) {
+	
+	break;
+      }
+      
+      long int pos = ::ftell (this->fp);
     }
 
-	//    this->lineIndex.push_back (pos);
+    // stub: Push up to our pappy.
+
+    this->running = false;
+    ::fseek (this->fp, cursor, SEEK_SET);
+    return NULL;
+  }
+
+  LineReader::LineReader (proactor::InputDispatcher * d,
+			  FILE * fp,
+			  long int start,
+			  long int N) {
+    this->fp = fp;
+    this->dispatcher = dispatcher;
+    this->startOffset = start;
+    this->numberOfLinesToRead = N;
+  }
+
+  LineReader::~LineReader (void) {
   
-    std::fseek (this->fp, 0, SEEK_SET);
   }
 
-  Lines &
-  File::getLines (long int S, long int T, Lines & V) {
-    V.clear();
+  void *
+  LineReader::run (void * null) {
+    this->running = false;
+    char buf[4096];
+
+    concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 
-    if (S < 0) S = 0;
-    
-    if ((S < T) && (S < (signed)this->lineIndex.size())) {
+    // Record current position and seek to where we're going to start.
+    long int cursor = ::ftell (this->fp);
+    ::fseek (this->fp, this->startOffset, SEEK_SET);
 
-      // Make sure we're not going out of bounds of the array.
-      if (T > (signed)this->lineIndex.size()) T = this->lineIndex.size();
+    for (long int ii = 0; ii < this->numberOfLinesToRead; ii++) {
+      
+      if (fgets (buf, 4096, this->fp) == NULL) {
+	
+	break;
+      }
       
-      for (long int ii = S; ii < T; ii++)
-	V.push_back ( Line (this->lineIndex[ ii ], this->fp) );
+      long int pos = ::ftell (this->fp);
+      
+      // stub: store index and buf
     }
-   
-    return V;
+
+    // stub: Push up to our pappy.
+
+    this->running = false;
+    ::fseek (this->fp, cursor, SEEK_SET);
+    return NULL;
   }
 
-}
+} // end of namespace
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
index 472b941..3f65563 100755
--- a/src/largefile/File.hpp
+++ b/src/largefile/File.hpp
@@ -22,6 +22,7 @@
 #define FILE_HPP
 
 #include <proactor/InputDispatcher.hpp>
+#include <proactor/Proactor.hpp>
 #include <proactor/Worker.hpp>
 #include <cstdio>
 #include <vector>
@@ -29,36 +30,47 @@
 
 namespace largefile {
 
-  class Line {
+  class FileDispatcher : public proactor::InputDispatcher {
   private:
     FILE * fp;
-    int position;
-    std::string line;
+    std::string filename;
   public:
-    Line (int startByte, FILE * fp);
-    ~Line (void);
-    
-    void read (void);
+    FileDispatcher (int e, proactor::Proactor * pro);
+    virtual ~FileDispatcher (void);
 
-    int getByteStart (void) const { return this->position; }
-    std::string getLine (void) const { return this->line; }
+    bool open (const std::string & filename);
+    bool close (void);
+    void * run (void * null);
   };
 
-  typedef std::vector<Line> Lines;
+  class LineIndexer : public proactor::Worker {
+  private:
+    FILE * fp;
+    long int numberOfLinesToRead;
+    long int startOffset; 
+  public:
+    LineIndexer (proactor::InputDispatcher * d, 
+		 FILE * fp, 
+		 long int start,
+		 long int N);
+    virtual ~LineIndexer (void);
+
+    void * run (void * null);
+  };
 
-  class File {
+  class LineReader : public proactor::Worker {
   private:
-    typedef std::vector<long int> LineIndexMap;
-    
     FILE * fp;
-    LineIndexMap lineIndex;
+    long int numberOfLinesToRead;
+    long int startOffset;
   public:
-    File (FILE * fp);
-    File (const std::string & path);
-    ~File (void);
+    LineReader (proactor::InputDispatcher * d, 
+		 FILE * fp, 
+		 long int start,
+		 long int N);
+    virtual ~LineReader (void);
 
-    void reindex (void);
-    Lines & getLines (long int S, long int T, Lines & V);
+    void * run (void * null);
   };
 
 } // end of namespace
diff --git a/src/largefile/FileDispatcher.cpp b/src/largefile/FileDispatcher.cpp
deleted file mode 100755
index f777cd4..0000000
--- a/src/largefile/FileDispatcher.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-#include "FileDispatcher.hpp"
-#include <concurrent/ScopedMemoryLock.hpp>
-
-namespace largefile {
-
-  FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
-	this->pro = pro;
-	this->fp = NULL;
-	setEventId(e);
-  }
-
-  FileDispatcher::~FileDispatcher (void) {
-  }
-
-  bool
-  FileDispatcher::open (const std::string & filename) {
-	if (filename.length() == 0)
-	  return false;
-	
-	if ((this->fp = fopen (filename.c_str(), "r")) == NULL) {
-	  // stub: Throw an error somewhere.
-	  return false;
-	}
-
-	concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
-	return true;
-  }
-
-  bool 
-  FileDispatcher::close (void) {
-	concurrent::ScopedMemoryLock lock ((unsigned long int)this->fp, true);
-	  
-	fclose (this->fp);
-	this->fp = NULL;
-
-	lock.remove();
-	return true;
-  }
-
-} // end of namespace
diff --git a/src/largefile/FileDispatcher.hpp b/src/largefile/FileDispatcher.hpp
deleted file mode 100755
index 4dfe56b..0000000
--- a/src/largefile/FileDispatcher.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-#ifndef HPP_FILEDISPATCHER
-#define HPP_FILEDISPATCHER
-
-#include <proactor/InputDispatcher.hpp>
-#include <proactor/Proactor.hpp>
-#include <string>
-
-namespace largefile {
-
-  class FileDispatcher : public proactor::InputDispatcher {
-  private:
-	FILE * fp;
-  public:
-	FileDispatcher (int e, proactor::Proactor * pro);
-	virtual ~FileDispatcher (void);
-
-	bool open (const std::string & filename);
-	bool close (void);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/largefile/Indexer.cpp b/src/largefile/Indexer.cpp
deleted file mode 100755
index e0a0e14..0000000
--- a/src/largefile/Indexer.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-#include "Indexer.hpp"
-#include <concurrent/ScopedMemoryLock.hpp>
-
-namespace largefile {
-
-  Indexer::Indexer (proactor::InputDispatcher * d, FILE * fp) {
-    this->dispatcher = d;
-    this->fp = fp;
-  }
-
-  Indexer::~Indexer (void) {
-
-  }
-
-  void *
-  Indexer::run (void * null) {
-    char buf[4096];
-	this->running = true;
-
-	concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
-
-	if (!feof (this->fp)) {
-
-	  fseek (this->fp, this->startOffset, SEEK_SET);
-	  
-	  while (this->windowSize > 0) {
-		if (fgets (buf, 4096, this->fp) == NULL)
-		  break;
-
-		index->push_back ( ftell (this->fp) );
-
-		this->windowSize--;
-	  }
-	}
-    return index;
-  }
-
-} // end of namespace
diff --git a/src/largefile/Indexer.hpp b/src/largefile/Indexer.hpp
deleted file mode 100755
index 40ee128..0000000
--- a/src/largefile/Indexer.hpp
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef HPP_INDEXER
-#define HPP_INDEXER
-
-#include <proactor/InputDispatcher.hpp>
-#include <proactor/Worker.hpp>
-#include <cstdio>
-
-namespace largefile {
-  typedef std::vector<unsigned int> FileIndex;
-
-  class Indexer : public proactor::Worker {
-  private:
-    FILE * fp;
-	FileIndex * index;
-	long int startOffset;
-	long int windowSize;
-  public:
-    Indexer (proactor::InputDispatcher *d, FILE * fp);
-    virtual ~Indexer (void);
-
-    void * run (void * null);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/largefile/WorkbookUpdater.hpp b/src/largefile/WorkbookUpdater.hpp
new file mode 100644
index 0000000..d55b4b5
--- /dev/null
+++ b/src/largefile/WorkbookUpdater.hpp
@@ -0,0 +1,40 @@
+#ifndef HPP_WORKBOOKUPDATER
+#define HPP_WORKBOOKUPDATER
+
+#include <proactor/Worker.hpp>
+#include <workbook/workbook.h>
+#include <concurrent/Thread.hpp>
+
+namespace largefile {
+
+  class WorkbookUpdater : public proactor::Worker {
+  private:
+    Workbook * wb;
+    FILE * log;
+    int verbosity;
+  public:
+    WorkbookUpdater (Workbook * wb, FILE * log, int verbosity) {
+      this->wb = wb;
+      this->log = log;
+      this->verbosity = verbosity;
+    }
+
+    virtual ~WorkbookUpdater (void) {
+
+    }
+
+    void * run (void * null) {
+      this->running = true;
+      
+      while (this->running == true) {
+
+	concurrent::Thread::sleep (100);
+      }
+
+      return NULL;
+    }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index dad9481..b07c3ef 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -29,26 +29,29 @@
 extern void thread_main (ThreadArgs *);
 
 static void
-print_hello (GtkWidget * widget, gpointer data) {
-  g_message ("Hello, world!\n");
+open_csv_file (GtkWidget * w, gpointer data) {
+  ApplicationState * app = (ApplicationState *)data;
+  Config * cfg = app->cfg;
+  
 }
 
 static GtkWidget *
-largefile_mainmenu_new (GtkWidget * window) {
+largefile_mainmenu_new (ApplicationState * appstate, GtkWidget * window) {
   GtkItemFactoryEntry menu_items[] = {
-	{ "/_File",		NULL,			NULL, 				0, 		"<Branch>" },
-	{ "/File/_Open",	"<CTRL>O",		NULL,		1,		"<Item>" },
-	{ "/File/_Close", "<CTRL>C",		NULL,		1,		"<Item>" },
-	{ "/File/sep1", 	NULL,			NULL,				0,		"<Separator>" },
-	{ "/File/_Quit", 	"<CTRL>Q", 		gtk_main_quit,		0,		"<StockItem>", GTK_STOCK_QUIT},
+    {"/_File",         NULL,		NULL, 		0, 	"<Branch>"},
+    {"/File/_Open",    "<CTRL>O",	(GtkItemFactoryCallback)open_csv_file,	0,	"<StockItem>", GTK_STOCK_OPEN},
+    {"/File/_Close",   "<CTRL>C",	NULL,		0,	"<Item>"},
+    {"/File/sep1",     NULL,		NULL,		0,	"<Separator>"},
+    {"/File/_Quit",    "<CTRL>Q", 	gtk_main_quit,	0,	"<StockItem>", GTK_STOCK_QUIT},
   };
+  
   gint nmenu_items = sizeof (menu_items) / sizeof (menu_items[0]);
   GtkAccelGroup * accel = gtk_accel_group_new ();	
   GtkItemFactory * item_factory 
 	= gtk_item_factory_new (GTK_TYPE_MENU_BAR, "<main>", accel);
   
-  gtk_item_factory_create_items (item_factory, nmenu_items, menu_items, NULL);
-  
+  gtk_item_factory_create_items (item_factory, nmenu_items, menu_items, appstate);
+
   gtk_window_add_accel_group (GTK_WINDOW (window), accel);
 
   GtkWidget * menu = gtk_item_factory_get_widget (item_factory, "<main>");
@@ -63,19 +66,18 @@ extern "C" {
   plugin_main (ApplicationState * appstate, Plugin * plugin) {
     ASSERT (appstate != NULL);
     ASSERT (plugin != NULL);
-
-    GtkWidget * box = gtk_vbox_new (FALSE, 0);
 	
-	GtkWidget * mainmenu = largefile_mainmenu_new (appstate->gtk_window);
-	gtk_box_pack_start (GTK_BOX (box), mainmenu, FALSE, FALSE, 0);
+    GtkWidget * box = gtk_vbox_new (FALSE, 0);
+    GtkWidget * mainmenu = largefile_mainmenu_new (appstate, appstate->gtk_window);
+    gtk_box_pack_start (GTK_BOX (box), mainmenu, FALSE, FALSE, 0);
 
-	Workbook * wb = NULL;
+    Workbook * wb = NULL;
     if ((wb = workbook_open (appstate->gtk_window, "largefile")) == NULL) {
       g_critical ("Failed opening workbook; exiting largefile plugin");
       return NULL;
     }
 
-	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
+    gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
 
     wb->signals[SIG_WORKBOOK_CHANGED] = appstate->signals[SIG_SHEET_CHANGED];
         
@@ -95,8 +97,8 @@ extern "C" {
       return NULL;
     }
 
-	gtk_box_pack_start (GTK_BOX (appstate->gtk_window_vbox), box, FALSE, FALSE, 0);
-	gtk_widget_show (box);	
+    gtk_box_pack_start (GTK_BOX (appstate->gtk_window_vbox), box, FALSE, FALSE, 0);
+    gtk_widget_show (box);	
     return wb;
   }
 
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 04cc027..a733b22 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -27,29 +27,79 @@
 #include <proactor/Event.hpp>
 #include <gtkextra/gtksheet.h>
 #include <fstream>
-#include "File.hpp"
 #include <iostream>
 #include <string>
 #include <sstream>
+#include "File.hpp"
+#include "WorkbookUpdater.hpp"
 
 using namespace largefile;
 
+/* @description: This method creates a filename with the prefix supplied and
+   uses the pid of the process as its suffix. 
+   @pre: The prefix (should be a file path, obviously). */
+static std::string
+append_pidname (const gchar * pre) {
+  std::stringstream s;
+  s << pre << getppid();
+  return s.str();
+}
+
 void
 thread_main (ThreadArgs * args) {
   Workbook * wb = (Workbook *)args->at(0);
   Config * cfg  = (Config *)args->at(1);
   gboolean * SHUTDOWN = (gboolean *)args->at(2);
-  GtkSheet * sheet = (GtkSheet *)wb->sheet_first->gtk_sheet;
 
-  FILE * fp = NULL;
-  if ((fp = fopen ("/home/johnb/largefile.csv", "r")) == NULL) {
-	return;
+  ConfigPair * logpath = cfg->get_pair (cfg, "largefile", "log", "path");
+  if (IS_NULL (logpath)) {
+      g_critical ("Failed loading log->path from configuration file; "
+		  "exiting thread");
+      return;
+    }
+
+  FILE * pktlog = NULL;
+  std::string logname = std::string (logpath->value).append("/");
+  logname.append (append_pidname("realtime.").append(".log"));
+
+  if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
+      g_critical ("Failed opening file '%s' for packet logging; exiting"
+		  " thread", logname.c_str());
+      return;
+    }
+
+  int fdEventId = proactor::Event::uniqueEventId(); 
+  
+  proactor::Proactor proactor;
+  FileDispatcher fdispatcher (fdEventId, &proactor);
+  WorkbookUpdater wbupdater (wb, pktlog, 0);
+
+  if (proactor.start() == false) {
+    g_critical ("Failed starting Proactor; exiting thread.");
+    return;
+  }
+
+  if (proactor.addWorker (fdEventId, &wbupdater) == false) {
+    g_critical ("Failed starting workbook updater; exiting thread.");
+    return;
+  }
+
+  if (fdispatcher.open ("/home/johnb/largefile.csv") == false) {
+    g_critical ("Failed opening /home/johnb/largefile.csv");
+    return;
+  }
+
+  if (fdispatcher.start() == false) {
+    g_critical ("Failed starting file dispatcher; exiting thread.");
+    return;
   }
 
   while (*SHUTDOWN == FALSE) {
-	   
     concurrent::Thread::sleep (100);
   }
 
+  wbupdater.stop();
+  
+  FCLOSE (pktlog);
   delete args;
 }
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
index e1e49a2..c136d69 100755
--- a/src/realtime/plugin_main.cpp
+++ b/src/realtime/plugin_main.cpp
@@ -66,7 +66,8 @@ extern "C"
 	g_critical ("Failed creating thread; exiting plugin");
 	return NULL;
       }
-   
+
+    gtk_box_pack_start (GTK_BOX (app->gtk_window_vbox), hbox, FALSE,FALSE, 0);
     gtk_widget_show (hbox);
     return wb;
   }
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index d2cdf69..793b9d7 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -161,4 +161,5 @@ thread_main (ThreadArgs * args) {
   socket.close();  
 
   FCLOSE (pktlog);
+  delete args;
 }

commit ddaa746c0553962a27dc367e7e7aa65096098efa
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 15 09:13:49 2009 -0400

    Updated largefile branch; ScopedMemoryLock and FileDispatcher.

diff --git a/shared/concurrent/ScopedMemoryLock.cpp b/shared/concurrent/ScopedMemoryLock.cpp
old mode 100644
new mode 100755
diff --git a/shared/concurrent/ScopedMemoryLock.hpp b/shared/concurrent/ScopedMemoryLock.hpp
old mode 100644
new mode 100755
diff --git a/src/largefile/FileDispatcher.cpp b/src/largefile/FileDispatcher.cpp
old mode 100644
new mode 100755
diff --git a/src/largefile/FileDispatcher.hpp b/src/largefile/FileDispatcher.hpp
old mode 100644
new mode 100755
diff --git a/src/largefile/Indexer.cpp b/src/largefile/Indexer.cpp
old mode 100644
new mode 100755
diff --git a/src/largefile/Indexer.hpp b/src/largefile/Indexer.hpp
old mode 100644
new mode 100755

commit 83769db06e290625d36574cebe14e5d956e41798
Author: John Bellone <jvb4@njit.edu>
Date:   Thu May 14 15:16:36 2009 -0400

    Added GTK menu for largefile plugin.

diff --git a/shared/concurrent/ScopedMemoryLock.cpp b/shared/concurrent/ScopedMemoryLock.cpp
new file mode 100644
index 0000000..c520d1d
--- /dev/null
+++ b/shared/concurrent/ScopedMemoryLock.cpp
@@ -0,0 +1,108 @@
+#include "ScopedMemoryLock.hpp"
+
+namespace concurrent {
+  ScopedMemoryLock::AddressToMutexMap ScopedMemoryLock::addressMutexMap;
+
+  ScopedMemoryLock::ScopedMemoryLock (unsigned long address, bool engage) {
+    this->hasLock = false;
+	this->address = address;
+
+    ScopedMemoryLock::addressMutexMap.lock();
+
+    AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+
+    ScopedMemoryLock::addressMutexMap.unlock();
+
+    /* Now the reason behind setting this pointer to NULL is to force a coredump. Because
+       if someone is passing a pointer that has not been formally added via the static method
+       calls then that means it is very unlikely that they are not removing it either. We do
+       not want a memory leak therefore this seems like the best method. */
+    if (it == ScopedMemoryLock::addressMutexMap.end()) 
+      this->mutex = NULL;
+    else
+      this->mutex = it->second;
+
+    if (engage == true)
+      this->lock();
+  }
+
+  ScopedMemoryLock::~ScopedMemoryLock (void) {
+    if (this->hasLock == true)
+      unlock();
+  }
+
+  void
+  ScopedMemoryLock::lock (void) {
+    this->mutex->lock();
+    this->hasLock = true;
+  }
+
+  void 
+  ScopedMemoryLock::unlock (void) {
+    this->mutex->unlock();
+    this->hasLock = false;
+  }
+
+  bool
+  ScopedMemoryLock::trylock (void) {
+    this->hasLock = this->mutex->trylock();
+    return this->hasLock;
+  }
+
+  bool
+  ScopedMemoryLock::remove (void) {
+	if (this->hasLock == false) {
+ 	  return false;
+	}
+
+	addressMutexMap.lock();
+
+	AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+	if (it == addressMutexMap.end()) {
+	  addressMutexMap.unlock();
+	  return false;
+	}
+
+	delete it->second;
+	addressMutexMap.end();
+
+	addressMutexMap.unlock();
+	return true;
+  }
+
+  bool 
+  ScopedMemoryLock::addMemoryLock (unsigned long address) {
+    addressMutexMap.lock();
+
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
+
+    // Already exists inside of the map; we're going to return an error here.
+    if (it == addressMutexMap.end()) {
+      addressMutexMap.unlock();
+      return false;
+    }
+    
+    addressMutexMap.insert (std::make_pair (address, new Mutex));
+
+    addressMutexMap.unlock();
+    return true;
+  }
+
+  bool 
+  ScopedMemoryLock::removeMemoryLock (unsigned long address) {
+    addressMutexMap.lock();
+
+	AddressToMutexMap::iterator it = addressMutexMap.find (address);
+    if (it == addressMutexMap.end()) {
+      addressMutexMap.unlock();
+      return false;
+    }
+
+    delete it->second;
+    addressMutexMap.erase(it);
+
+    addressMutexMap.unlock();
+    return true;
+  }
+
+} // end of namespace
diff --git a/shared/concurrent/ScopedMemoryLock.hpp b/shared/concurrent/ScopedMemoryLock.hpp
new file mode 100644
index 0000000..0febdc6
--- /dev/null
+++ b/shared/concurrent/ScopedMemoryLock.hpp
@@ -0,0 +1,32 @@
+#ifndef HPP_CONCURRENT_SCOPEDMEMORYLOCK
+#define HPP_CONCURRENT_SCOPEDMEMORYLOCK
+
+#include "Map.hpp"
+#include "Mutex.hpp"
+#include <string>
+
+namespace concurrent {
+
+  class ScopedMemoryLock : public ILockable {
+  private:
+    typedef Map<long int,Mutex *> AddressToMutexMap;
+    static AddressToMutexMap addressMutexMap;
+
+    bool hasLock;
+	unsigned long address;
+    Mutex * mutex;
+  public:
+    ScopedMemoryLock (unsigned long address, bool engage = false);
+    virtual ~ScopedMemoryLock (void);
+ 
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+	bool remove (void);
+
+    static bool addMemoryLock (unsigned long address);
+    static bool removeMemoryLock (unsigned long address);
+  };
+} // end of namespace
+
+#endif 
diff --git a/shared/concurrent/SharedMemoryLock.cpp b/shared/concurrent/SharedMemoryLock.cpp
deleted file mode 100644
index f5cf318..0000000
--- a/shared/concurrent/SharedMemoryLock.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-#include "SharedMemoryLock.hpp"
-#include <sstream>
-
-namespace concurrent {
-  SharedMemoryLock::AddressToMutexMap SharedMemoryLock::addressMutexMap;
-
-  SharedMemoryLock::SharedMemoryLock (unsigned long address, bool engage) {
-    this->hasLock = false;
-	this->address = address;
-
-    SharedMemoryLock::addressMutexMap.lock();
-
-    AddressToMutexMap::iterator it = SharedMemoryLock::addressMutexMap.find (this->address);
-
-    SharedMemoryLock::addressMutexMap.unlock();
-
-    /* Now the reason behind setting this pointer to NULL is to force a coredump. Because
-       if someone is passing a pointer that has not been formally added via the static method
-       calls then that means it is very unlikely that they are not removing it either. We do
-       not want a memory leak therefore this seems like the best method. */
-    if (it == SharedMemoryLock::addressMutexMap.end()) 
-      this->mutex = NULL;
-    else
-      this->mutex = it->second;
-
-    if (engage == true)
-      this->lock();
-  }
-
-  SharedMemoryLock::~SharedMemoryLock (void) {
-    if (this->hasLock == true)
-      unlock();
-  }
-
-  void
-  SharedMemoryLock::lock (void) {
-    this->mutex->lock();
-    this->hasLock = true;
-  }
-
-  void 
-  SharedMemoryLock::unlock (void) {
-    this->mutex->unlock();
-    this->hasLock = false;
-  }
-
-  bool
-  SharedMemoryLock::trylock (void) {
-    this->hasLock = this->mutex->trylock();
-    return this->hasLock;
-  }
-
-  bool
-  SharedMemoryLock::remove (void) {
-	if (this->hasLock == false) {
- 	  return false;
-	}
-
-	addressMutexMap.lock();
-
-	AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
-	if (it == addressMutexMap.end()) {
-	  addressMutexMap.unlock();
-	  return false;
-	}
-
-	delete it->second;
-	addressMutexMap.end();
-
-	addressMutexMap.unlock();
-	return true;
-  }
-
-  bool 
-  SharedMemoryLock::addMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-    AddressToMutexMap::iterator it = addressMutexMap.find (address);
-
-    // Already exists inside of the map; we're going to return an error here.
-    if (it == addressMutexMap.end()) {
-      addressMutexMap.unlock();
-      return false;
-    }
-    
-    addressMutexMap.insert (std::make_pair (address, new Mutex));
-
-    addressMutexMap.unlock();
-    return true;
-  }
-
-  bool 
-  SharedMemoryLock::removeMemoryLock (unsigned long address) {
-    addressMutexMap.lock();
-
-	AddressToMutexMap::iterator it = addressMutexMap.find (address);
-    if (it == addressMutexMap.end()) {
-      addressMutexMap.unlock();
-      return false;
-    }
-
-    delete it->second;
-    addressMutexMap.erase(it);
-
-    addressMutexMap.unlock();
-    return true;
-  }
-
-} // end of namespace
diff --git a/shared/concurrent/SharedMemoryLock.hpp b/shared/concurrent/SharedMemoryLock.hpp
deleted file mode 100644
index 1a3c617..0000000
--- a/shared/concurrent/SharedMemoryLock.hpp
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef HPP_CONCURRENT_SHAREDMEMORYLOCK
-#define HPP_CONCURRENT_SHAREDMEMORYLOCK
-
-#include "Map.hpp"
-#include "Mutex.hpp"
-#include <string>
-
-namespace concurrent {
-
-  class SharedMemoryLock : public ILockable {
-  private:
-    typedef Map<long int,Mutex *> AddressToMutexMap;
-    static AddressToMutexMap addressMutexMap;
-
-    bool hasLock;
-	unsigned long address;
-    Mutex * mutex;
-  public:
-    SharedMemoryLock (unsigned long address, bool engage = false);
-    virtual ~SharedMemoryLock (void);
- 
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-	bool remove (void);
-
-    static bool addMemoryLock (unsigned long address);
-    static bool removeMemoryLock (unsigned long address);
-  };
-} // end of namespace
-
-#endif 
diff --git a/src/largefile/FileDispatcher.cpp b/src/largefile/FileDispatcher.cpp
index 7cc7123..f777cd4 100644
--- a/src/largefile/FileDispatcher.cpp
+++ b/src/largefile/FileDispatcher.cpp
@@ -1,44 +1,37 @@
 #include "FileDispatcher.hpp"
-#include <concurrent/SharedMemoryLock.hpp>
+#include <concurrent/ScopedMemoryLock.hpp>
 
 namespace largefile {
 
   FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
 	this->pro = pro;
+	this->fp = NULL;
 	setEventId(e);
   }
 
   FileDispatcher::~FileDispatcher (void) {
   }
 
-  
-
   bool
   FileDispatcher::open (const std::string & filename) {
 	if (filename.length() == 0)
 	  return false;
-
-	FILE * fp = NULL;
 	
-	if ((fp = fopen (filename.c_str(), "r")) == NULL) {
+	if ((this->fp = fopen (filename.c_str(), "r")) == NULL) {
 	  // stub: Throw an error somewhere.
 	  return false;
 	}
 
-	concurrent::SharedMemoryLock::addMemoryLock ((unsigned long int)&fp);
+	concurrent::ScopedMemoryLock::addMemoryLock ((unsigned long int)this->fp);
 	return true;
   }
 
   bool 
   FileDispatcher::close (void) {
-	if (filename.length() == 0)
-	  return false;
-	
-	FILE * fp = it->second;
-	concurrent::SharedMemoryLock lock ((unsigned long int)&fp, true);
+	concurrent::ScopedMemoryLock lock ((unsigned long int)this->fp, true);
 	  
-	fclose (fp);
-	fp = NULL;
+	fclose (this->fp);
+	this->fp = NULL;
 
 	lock.remove();
 	return true;
diff --git a/src/largefile/FileDispatcher.hpp b/src/largefile/FileDispatcher.hpp
index c81b36c..4dfe56b 100644
--- a/src/largefile/FileDispatcher.hpp
+++ b/src/largefile/FileDispatcher.hpp
@@ -9,6 +9,7 @@ namespace largefile {
 
   class FileDispatcher : public proactor::InputDispatcher {
   private:
+	FILE * fp;
   public:
 	FileDispatcher (int e, proactor::Proactor * pro);
 	virtual ~FileDispatcher (void);
diff --git a/src/largefile/Indexer.cpp b/src/largefile/Indexer.cpp
index 9d8fb81..e0a0e14 100644
--- a/src/largefile/Indexer.cpp
+++ b/src/largefile/Indexer.cpp
@@ -1,5 +1,5 @@
 #include "Indexer.hpp"
-#include <concurrent/SharedMemoryLock.hpp>
+#include <concurrent/ScopedMemoryLock.hpp>
 
 namespace largefile {
 
@@ -17,7 +17,7 @@ namespace largefile {
     char buf[4096];
 	this->running = true;
 
-	concurrent::SharedMemoryLock mutex ((unsigned long int)this->fp, true);
+	concurrent::ScopedMemoryLock mutex ((unsigned long int)this->fp, true);
 
 	if (!feof (this->fp)) {
 
diff --git a/src/largefile/Indexer.hpp b/src/largefile/Indexer.hpp
index a0f0612..40ee128 100644
--- a/src/largefile/Indexer.hpp
+++ b/src/largefile/Indexer.hpp
@@ -15,11 +15,7 @@ namespace largefile {
 	long int startOffset;
 	long int windowSize;
   public:
-    Indexer (proactor::InputDispatcher *d, 
-			 FILE * fp, 
-			 FileIndex * index, 
-			 long int offset, 
-			 long int window);
+    Indexer (proactor::InputDispatcher *d, FILE * fp);
     virtual ~Indexer (void);
 
     void * run (void * null);
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 1e1bfb6..dad9481 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -21,12 +21,42 @@
 #include <iostream>
 #include <workbook/workbook.h>
 #include <concurrent/ThreadArgs.hpp>
+#include <gtk/gtk.h>
 #include "../application.h"
 #include "../plugin.h"
 
 /* Prototypes */
 extern void thread_main (ThreadArgs *);
 
+static void
+print_hello (GtkWidget * widget, gpointer data) {
+  g_message ("Hello, world!\n");
+}
+
+static GtkWidget *
+largefile_mainmenu_new (GtkWidget * window) {
+  GtkItemFactoryEntry menu_items[] = {
+	{ "/_File",		NULL,			NULL, 				0, 		"<Branch>" },
+	{ "/File/_Open",	"<CTRL>O",		NULL,		1,		"<Item>" },
+	{ "/File/_Close", "<CTRL>C",		NULL,		1,		"<Item>" },
+	{ "/File/sep1", 	NULL,			NULL,				0,		"<Separator>" },
+	{ "/File/_Quit", 	"<CTRL>Q", 		gtk_main_quit,		0,		"<StockItem>", GTK_STOCK_QUIT},
+  };
+  gint nmenu_items = sizeof (menu_items) / sizeof (menu_items[0]);
+  GtkAccelGroup * accel = gtk_accel_group_new ();	
+  GtkItemFactory * item_factory 
+	= gtk_item_factory_new (GTK_TYPE_MENU_BAR, "<main>", accel);
+  
+  gtk_item_factory_create_items (item_factory, nmenu_items, menu_items, NULL);
+  
+  gtk_window_add_accel_group (GTK_WINDOW (window), accel);
+
+  GtkWidget * menu = gtk_item_factory_get_widget (item_factory, "<main>");
+  gtk_widget_show (menu);
+
+  return menu;
+}
+
 extern "C" {
 
   Workbook *
@@ -34,19 +64,22 @@ extern "C" {
     ASSERT (appstate != NULL);
     ASSERT (plugin != NULL);
 
-    Workbook * wb = NULL;
-    GtkWidget * hbox = gtk_handle_box_new();
-    
+    GtkWidget * box = gtk_vbox_new (FALSE, 0);
+	
+	GtkWidget * mainmenu = largefile_mainmenu_new (appstate->gtk_window);
+	gtk_box_pack_start (GTK_BOX (box), mainmenu, FALSE, FALSE, 0);
+
+	Workbook * wb = NULL;
     if ((wb = workbook_open (appstate->gtk_window, "largefile")) == NULL) {
       g_critical ("Failed opening workbook; exiting largefile plugin");
       return NULL;
     }
 
+	gtk_box_pack_end (GTK_BOX (box), wb->gtk_notebook, FALSE, FALSE, 0);
+
     wb->signals[SIG_WORKBOOK_CHANGED] = appstate->signals[SIG_SHEET_CHANGED];
-    
-    gtk_container_add (GTK_CONTAINER (hbox), wb->gtk_notebook);
-    
-    wb->gtk_box = hbox;
+        
+    wb->gtk_box = box;
     
     wb->add_new_sheet (wb, "sheet0", 100, 15);
 
@@ -62,8 +95,9 @@ extern "C" {
       return NULL;
     }
 
-    gtk_widget_show (hbox);
+	gtk_box_pack_start (GTK_BOX (appstate->gtk_window_vbox), box, FALSE, FALSE, 0);
+	gtk_widget_show (box);	
     return wb;
   }
 
-}
+} 
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index e76643c..04cc027 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -22,7 +22,7 @@
 #include <config/config.h>
 #include <concurrent/Thread.hpp>
 #include <concurrent/ThreadArgs.hpp>
-#include <concurrent/SharedMemoryLock.hpp>
+#include <concurrent/ScopedMemoryLock.hpp>
 #include <proactor/Proactor.hpp>
 #include <proactor/Event.hpp>
 #include <gtkextra/gtksheet.h>
@@ -41,12 +41,13 @@ thread_main (ThreadArgs * args) {
   gboolean * SHUTDOWN = (gboolean *)args->at(2);
   GtkSheet * sheet = (GtkSheet *)wb->sheet_first->gtk_sheet;
 
-  proactor::Proactor proactor;
-  FileDispatcher fd (&proactor);
+  FILE * fp = NULL;
+  if ((fp = fopen ("/home/johnb/largefile.csv", "r")) == NULL) {
+	return;
+  }
 
   while (*SHUTDOWN == FALSE) {
-    
-    // Continually sleep basically until our application terminates.
+	   
     concurrent::Thread::sleep (100);
   }
 

commit 27a074df2a34bf83e857d493d749579067d9eda9
Author: John Bellone <jvb4@njit.edu>
Date:   Wed May 13 17:17:11 2009 -0400

    Updated largefile implementation.

diff --git a/shared/concurrent/SharedMemoryLock.cpp b/shared/concurrent/SharedMemoryLock.cpp
index 2269ac9..f5cf318 100644
--- a/shared/concurrent/SharedMemoryLock.cpp
+++ b/shared/concurrent/SharedMemoryLock.cpp
@@ -4,10 +4,9 @@
 namespace concurrent {
   SharedMemoryLock::AddressToMutexMap SharedMemoryLock::addressMutexMap;
 
-  SharedMemoryLock::SharedMemoryLock (const void * pointer, bool engage) {
-    std::stringstream ss; ss<<pointer;
-    this->address = ss.str();
+  SharedMemoryLock::SharedMemoryLock (unsigned long address, bool engage) {
     this->hasLock = false;
+	this->address = address;
 
     SharedMemoryLock::addressMutexMap.lock();
 
@@ -22,7 +21,7 @@ namespace concurrent {
     if (it == SharedMemoryLock::addressMutexMap.end()) 
       this->mutex = NULL;
     else
-      this->mutex = (*it).second;
+      this->mutex = it->second;
 
     if (engage == true)
       this->lock();
@@ -51,13 +50,32 @@ namespace concurrent {
     return this->hasLock;
   }
 
+  bool
+  SharedMemoryLock::remove (void) {
+	if (this->hasLock == false) {
+ 	  return false;
+	}
+
+	addressMutexMap.lock();
+
+	AddressToMutexMap::iterator it = addressMutexMap.find (this->address);
+	if (it == addressMutexMap.end()) {
+	  addressMutexMap.unlock();
+	  return false;
+	}
+
+	delete it->second;
+	addressMutexMap.end();
+
+	addressMutexMap.unlock();
+	return true;
+  }
+
   bool 
-  SharedMemoryLock::addMemoryLock (const void * pointer) {
+  SharedMemoryLock::addMemoryLock (unsigned long address) {
     addressMutexMap.lock();
 
-    std::stringstream ss; ss << pointer;
-    std::string the_address = ss.str();
-    AddressToMutexMap::iterator it = addressMutexMap.find (the_address);
+    AddressToMutexMap::iterator it = addressMutexMap.find (address);
 
     // Already exists inside of the map; we're going to return an error here.
     if (it == addressMutexMap.end()) {
@@ -65,25 +83,23 @@ namespace concurrent {
       return false;
     }
     
-    addressMutexMap.insert (std::make_pair (the_address, new Mutex));
+    addressMutexMap.insert (std::make_pair (address, new Mutex));
 
     addressMutexMap.unlock();
     return true;
   }
 
   bool 
-  SharedMemoryLock::removeMemoryLock (const void * pointer) {
+  SharedMemoryLock::removeMemoryLock (unsigned long address) {
     addressMutexMap.lock();
 
-    std::stringstream ss; ss << pointer;
-    std::string the_address = ss.str();
-    AddressToMutexMap::iterator it = addressMutexMap.find (the_address);
+	AddressToMutexMap::iterator it = addressMutexMap.find (address);
     if (it == addressMutexMap.end()) {
       addressMutexMap.unlock();
       return false;
     }
 
-    delete (*it).second;
+    delete it->second;
     addressMutexMap.erase(it);
 
     addressMutexMap.unlock();
diff --git a/shared/concurrent/SharedMemoryLock.hpp b/shared/concurrent/SharedMemoryLock.hpp
index f31c88b..1a3c617 100644
--- a/shared/concurrent/SharedMemoryLock.hpp
+++ b/shared/concurrent/SharedMemoryLock.hpp
@@ -9,23 +9,24 @@ namespace concurrent {
 
   class SharedMemoryLock : public ILockable {
   private:
-    typedef Map<std::string,Mutex *> AddressToMutexMap;
+    typedef Map<long int,Mutex *> AddressToMutexMap;
     static AddressToMutexMap addressMutexMap;
 
     bool hasLock;
-    std::string address;
+	unsigned long address;
     Mutex * mutex;
   public:
-    SharedMemoryLock (const void * pointer, bool engage = false);
+    SharedMemoryLock (unsigned long address, bool engage = false);
     virtual ~SharedMemoryLock (void);
  
     void lock (void);
     void unlock (void);
     bool trylock (void);
+	bool remove (void);
 
-    static bool addMemoryLock (const void * pointer);
-    static bool removeMemoryLock (const void * pointer);
+    static bool addMemoryLock (unsigned long address);
+    static bool removeMemoryLock (unsigned long address);
   };
-}
+} // end of namespace
 
 #endif 
diff --git a/src/largefile/FileDispatcher.cpp b/src/largefile/FileDispatcher.cpp
new file mode 100644
index 0000000..7cc7123
--- /dev/null
+++ b/src/largefile/FileDispatcher.cpp
@@ -0,0 +1,47 @@
+#include "FileDispatcher.hpp"
+#include <concurrent/SharedMemoryLock.hpp>
+
+namespace largefile {
+
+  FileDispatcher::FileDispatcher (int e, proactor::Proactor * pro) {
+	this->pro = pro;
+	setEventId(e);
+  }
+
+  FileDispatcher::~FileDispatcher (void) {
+  }
+
+  
+
+  bool
+  FileDispatcher::open (const std::string & filename) {
+	if (filename.length() == 0)
+	  return false;
+
+	FILE * fp = NULL;
+	
+	if ((fp = fopen (filename.c_str(), "r")) == NULL) {
+	  // stub: Throw an error somewhere.
+	  return false;
+	}
+
+	concurrent::SharedMemoryLock::addMemoryLock ((unsigned long int)&fp);
+	return true;
+  }
+
+  bool 
+  FileDispatcher::close (void) {
+	if (filename.length() == 0)
+	  return false;
+	
+	FILE * fp = it->second;
+	concurrent::SharedMemoryLock lock ((unsigned long int)&fp, true);
+	  
+	fclose (fp);
+	fp = NULL;
+
+	lock.remove();
+	return true;
+  }
+
+} // end of namespace
diff --git a/src/largefile/FileDispatcher.hpp b/src/largefile/FileDispatcher.hpp
new file mode 100644
index 0000000..c81b36c
--- /dev/null
+++ b/src/largefile/FileDispatcher.hpp
@@ -0,0 +1,22 @@
+#ifndef HPP_FILEDISPATCHER
+#define HPP_FILEDISPATCHER
+
+#include <proactor/InputDispatcher.hpp>
+#include <proactor/Proactor.hpp>
+#include <string>
+
+namespace largefile {
+
+  class FileDispatcher : public proactor::InputDispatcher {
+  private:
+  public:
+	FileDispatcher (int e, proactor::Proactor * pro);
+	virtual ~FileDispatcher (void);
+
+	bool open (const std::string & filename);
+	bool close (void);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/largefile/Indexer.cpp b/src/largefile/Indexer.cpp
index 4a61ddd..9d8fb81 100644
--- a/src/largefile/Indexer.cpp
+++ b/src/largefile/Indexer.cpp
@@ -9,18 +9,29 @@ namespace largefile {
   }
 
   Indexer::~Indexer (void) {
+
   }
 
   void *
-  Indexer::run (void * index) {
-    this->running = true;
+  Indexer::run (void * null) {
+    char buf[4096];
+	this->running = true;
+
+	concurrent::SharedMemoryLock mutex ((unsigned long int)this->fp, true);
+
+	if (!feof (this->fp)) {
+
+	  fseek (this->fp, this->startOffset, SEEK_SET);
+	  
+	  while (this->windowSize > 0) {
+		if (fgets (buf, 4096, this->fp) == NULL)
+		  break;
 
-    while (this->running == true) {
-      //      concurrent::SharedMemoryLock mutex (this->fp, true);
-      
-      
-    }
+		index->push_back ( ftell (this->fp) );
 
+		this->windowSize--;
+	  }
+	}
     return index;
   }
 
diff --git a/src/largefile/Indexer.hpp b/src/largefile/Indexer.hpp
index cd40c9e..a0f0612 100644
--- a/src/largefile/Indexer.hpp
+++ b/src/largefile/Indexer.hpp
@@ -6,15 +6,23 @@
 #include <cstdio>
 
 namespace largefile {
+  typedef std::vector<unsigned int> FileIndex;
 
   class Indexer : public proactor::Worker {
   private:
     FILE * fp;
+	FileIndex * index;
+	long int startOffset;
+	long int windowSize;
   public:
-    Indexer (proactor::InputDispatcher *d, FILE * fp);
+    Indexer (proactor::InputDispatcher *d, 
+			 FILE * fp, 
+			 FileIndex * index, 
+			 long int offset, 
+			 long int window);
     virtual ~Indexer (void);
 
-    void * run (void * index);
+    void * run (void * null);
   };
 
 } // end of namespace
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 2019f01..e76643c 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -41,34 +41,14 @@ thread_main (ThreadArgs * args) {
   gboolean * SHUTDOWN = (gboolean *)args->at(2);
   GtkSheet * sheet = (GtkSheet *)wb->sheet_first->gtk_sheet;
 
-  std::clog << "Indexing... " << std::flush;
-
-  FILE * fp = fopen ("/home/johnb/largefile.csv", "r");
-  concurrent::SharedMemoryLock::addMemoryLock (fp);
-  Lines L;
-  File file (fp);
-
-  std::clog << "Done!\n" << std::flush;
-
-  for (int ii = 0; ii < 100; ii++) {
-    wb->sheet_first->set_cell (wb->sheet_first,
-			       ii, 0,
-			       L[ii].getLine().c_str());
-  }
-  
+  proactor::Proactor proactor;
+  FileDispatcher fd (&proactor);
 
   while (*SHUTDOWN == FALSE) {
-    double delta = gtk_adjustment_get_value (sheet->vadjustment);
-    std::ostringstream o; o<<delta;
-
-    wb->sheet_first->set_cell (wb->sheet_first,
-			       0, 0,
-			       o.str().c_str());
     
     // Continually sleep basically until our application terminates.
     concurrent::Thread::sleep (100);
   }
 
-  concurrent::SharedMemoryLock::removeMemoryLock (fp);
   delete args;
 }

commit ab4803cb7dd4712098d865b9b63bc163454f0cac
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 8 19:13:56 2009 -0400

    Added SharedMemoryLock and Indexer.

diff --git a/shared/concurrent/SharedMemoryLock.cpp b/shared/concurrent/SharedMemoryLock.cpp
new file mode 100644
index 0000000..2269ac9
--- /dev/null
+++ b/shared/concurrent/SharedMemoryLock.cpp
@@ -0,0 +1,93 @@
+#include "SharedMemoryLock.hpp"
+#include <sstream>
+
+namespace concurrent {
+  SharedMemoryLock::AddressToMutexMap SharedMemoryLock::addressMutexMap;
+
+  SharedMemoryLock::SharedMemoryLock (const void * pointer, bool engage) {
+    std::stringstream ss; ss<<pointer;
+    this->address = ss.str();
+    this->hasLock = false;
+
+    SharedMemoryLock::addressMutexMap.lock();
+
+    AddressToMutexMap::iterator it = SharedMemoryLock::addressMutexMap.find (this->address);
+
+    SharedMemoryLock::addressMutexMap.unlock();
+
+    /* Now the reason behind setting this pointer to NULL is to force a coredump. Because
+       if someone is passing a pointer that has not been formally added via the static method
+       calls then that means it is very unlikely that they are not removing it either. We do
+       not want a memory leak therefore this seems like the best method. */
+    if (it == SharedMemoryLock::addressMutexMap.end()) 
+      this->mutex = NULL;
+    else
+      this->mutex = (*it).second;
+
+    if (engage == true)
+      this->lock();
+  }
+
+  SharedMemoryLock::~SharedMemoryLock (void) {
+    if (this->hasLock == true)
+      unlock();
+  }
+
+  void
+  SharedMemoryLock::lock (void) {
+    this->mutex->lock();
+    this->hasLock = true;
+  }
+
+  void 
+  SharedMemoryLock::unlock (void) {
+    this->mutex->unlock();
+    this->hasLock = false;
+  }
+
+  bool
+  SharedMemoryLock::trylock (void) {
+    this->hasLock = this->mutex->trylock();
+    return this->hasLock;
+  }
+
+  bool 
+  SharedMemoryLock::addMemoryLock (const void * pointer) {
+    addressMutexMap.lock();
+
+    std::stringstream ss; ss << pointer;
+    std::string the_address = ss.str();
+    AddressToMutexMap::iterator it = addressMutexMap.find (the_address);
+
+    // Already exists inside of the map; we're going to return an error here.
+    if (it == addressMutexMap.end()) {
+      addressMutexMap.unlock();
+      return false;
+    }
+    
+    addressMutexMap.insert (std::make_pair (the_address, new Mutex));
+
+    addressMutexMap.unlock();
+    return true;
+  }
+
+  bool 
+  SharedMemoryLock::removeMemoryLock (const void * pointer) {
+    addressMutexMap.lock();
+
+    std::stringstream ss; ss << pointer;
+    std::string the_address = ss.str();
+    AddressToMutexMap::iterator it = addressMutexMap.find (the_address);
+    if (it == addressMutexMap.end()) {
+      addressMutexMap.unlock();
+      return false;
+    }
+
+    delete (*it).second;
+    addressMutexMap.erase(it);
+
+    addressMutexMap.unlock();
+    return true;
+  }
+
+} // end of namespace
diff --git a/shared/concurrent/SharedMemoryLock.hpp b/shared/concurrent/SharedMemoryLock.hpp
new file mode 100644
index 0000000..f31c88b
--- /dev/null
+++ b/shared/concurrent/SharedMemoryLock.hpp
@@ -0,0 +1,31 @@
+#ifndef HPP_CONCURRENT_SHAREDMEMORYLOCK
+#define HPP_CONCURRENT_SHAREDMEMORYLOCK
+
+#include "Map.hpp"
+#include "Mutex.hpp"
+#include <string>
+
+namespace concurrent {
+
+  class SharedMemoryLock : public ILockable {
+  private:
+    typedef Map<std::string,Mutex *> AddressToMutexMap;
+    static AddressToMutexMap addressMutexMap;
+
+    bool hasLock;
+    std::string address;
+    Mutex * mutex;
+  public:
+    SharedMemoryLock (const void * pointer, bool engage = false);
+    virtual ~SharedMemoryLock (void);
+ 
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+
+    static bool addMemoryLock (const void * pointer);
+    static bool removeMemoryLock (const void * pointer);
+  };
+}
+
+#endif 
diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
index f7ecb3e..d1fb1ea 100755
--- a/src/largefile/File.cpp
+++ b/src/largefile/File.cpp
@@ -72,11 +72,11 @@ namespace largefile {
     pos = std::ftell (this->fp);
     
     while (std::fgets (buf, 4096, this->fp) != NULL) {
-      this->lineIndex.push_back (pos);
+	  //   this->lineIndex.push_back (pos);
       pos = std::ftell (this->fp);
     }
 
-    this->lineIndex.push_back (pos);
+	//    this->lineIndex.push_back (pos);
   
     std::fseek (this->fp, 0, SEEK_SET);
   }
diff --git a/src/largefile/Indexer.cpp b/src/largefile/Indexer.cpp
new file mode 100644
index 0000000..4a61ddd
--- /dev/null
+++ b/src/largefile/Indexer.cpp
@@ -0,0 +1,27 @@
+#include "Indexer.hpp"
+#include <concurrent/SharedMemoryLock.hpp>
+
+namespace largefile {
+
+  Indexer::Indexer (proactor::InputDispatcher * d, FILE * fp) {
+    this->dispatcher = d;
+    this->fp = fp;
+  }
+
+  Indexer::~Indexer (void) {
+  }
+
+  void *
+  Indexer::run (void * index) {
+    this->running = true;
+
+    while (this->running == true) {
+      //      concurrent::SharedMemoryLock mutex (this->fp, true);
+      
+      
+    }
+
+    return index;
+  }
+
+} // end of namespace
diff --git a/src/largefile/Indexer.hpp b/src/largefile/Indexer.hpp
new file mode 100644
index 0000000..cd40c9e
--- /dev/null
+++ b/src/largefile/Indexer.hpp
@@ -0,0 +1,22 @@
+#ifndef HPP_INDEXER
+#define HPP_INDEXER
+
+#include <proactor/InputDispatcher.hpp>
+#include <proactor/Worker.hpp>
+#include <cstdio>
+
+namespace largefile {
+
+  class Indexer : public proactor::Worker {
+  private:
+    FILE * fp;
+  public:
+    Indexer (proactor::InputDispatcher *d, FILE * fp);
+    virtual ~Indexer (void);
+
+    void * run (void * index);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index be3c110..2019f01 100755
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -22,6 +22,7 @@
 #include <config/config.h>
 #include <concurrent/Thread.hpp>
 #include <concurrent/ThreadArgs.hpp>
+#include <concurrent/SharedMemoryLock.hpp>
 #include <proactor/Proactor.hpp>
 #include <proactor/Event.hpp>
 #include <gtkextra/gtksheet.h>
@@ -42,7 +43,8 @@ thread_main (ThreadArgs * args) {
 
   std::clog << "Indexing... " << std::flush;
 
-  FILE * fp = fopen ("/home/johnb/work/20by10MM.csv", "r");
+  FILE * fp = fopen ("/home/johnb/largefile.csv", "r");
+  concurrent::SharedMemoryLock::addMemoryLock (fp);
   Lines L;
   File file (fp);
 
@@ -67,5 +69,6 @@ thread_main (ThreadArgs * args) {
     concurrent::Thread::sleep (100);
   }
 
+  concurrent::SharedMemoryLock::removeMemoryLock (fp);
   delete args;
 }

commit 695940b06205fec47f69452c595999387e0c4a23
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 8 13:35:20 2009 -0400

    Added large CSV script

diff --git a/bin/createLargeCSV.py b/bin/createLargeCSV.py
new file mode 100755
index 0000000..21474e6
--- /dev/null
+++ b/bin/createLargeCSV.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python
+import sys
+import os
+import time
+import optparse
+import random
+
+def main():
+    p = optparse.OptionParser()
+    p.add_option("--output", "-o", default="largefile.csv")
+    p.add_option("--rows", "-r", default=10000000)
+    p.add_option("--columns", "-c", default=20)
+    options, arguments = p.parse_args()
+
+    fp = open(options.output, "w")
+    ii = 0 
+    jj = 0
+    maxRows = int(options.rows)
+    maxCols = int(options.columns)
+
+    while ii < maxRows:
+        jj = 0
+        while jj < maxCols-1:
+            choice = random.choice([1,2,3,4,5])
+
+            if choice == 1:
+                fp.write("ABCDEFG,")
+            elif choice == 2:
+                fp.write("1234567,")
+            elif choice == 3:
+                fp.write("HIJKLMN,")
+            elif choice == 4:
+                fp.write("8901234,")
+            elif choice == 5:
+                fp.write("OPQRSTU,")
+            jj = jj+1
+        fp.write("VWXYZ567890\r\n")
+        fp.flush()
+        ii = ii+1
+    fp.close()
+
+if __name__ == "__main__":
+    main()

commit d199b1481594bb90dc412d0e865985234aff7196
Author: John Bellone <jvb4@njit.edu>
Date:   Thu May 7 14:13:54 2009 -0400

    Committed largefile changes

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
old mode 100644
new mode 100755
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
old mode 100644
new mode 100755
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
old mode 100644
new mode 100755
index 96910b1..be3c110
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -47,6 +47,12 @@ thread_main (ThreadArgs * args) {
   File file (fp);
 
   std::clog << "Done!\n" << std::flush;
+
+  for (int ii = 0; ii < 100; ii++) {
+    wb->sheet_first->set_cell (wb->sheet_first,
+			       ii, 0,
+			       L[ii].getLine().c_str());
+  }
   
 
   while (*SHUTDOWN == FALSE) {

commit 839231cffe411bbb5b22af34836b25ca00793cd0
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 1 15:42:50 2009 -0400

    Updated files for largefile compliation.

diff --git a/bin/application.cfg b/bin/application.cfg
index 9c25431..2d257a1 100755
--- a/bin/application.cfg
+++ b/bin/application.cfg
@@ -1,21 +1,16 @@
 %block application {
-	load :: extensions=realtime,basic,csv;
+	load :: extensions=largefile,realtime;
 }
 %block realtime
 {
-	onLoad :: run=1;
+	onLoad :: run=0;
 	linux :: filename=realtime.so;
 	log :: path=/home/johnb;
 	tcp :: port=8888;
 	debug :: verbosity=0;
 }
-%block basic
+%block largefile
 {
-	onLoad :: run=0;
-	linux :: filename=basic.so;
+	onLoad :: run=1;
+	linux :: filename=largefile.so;
 }
-%block csv
-{
-	onLoad :: run=0;
-	linux :: filename=csv.so;
-}
\ No newline at end of file
diff --git a/src/Makefile b/src/Makefile
index 77e4c45..16537c7 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -7,8 +7,7 @@ LFLAGS=-lworkbook -lconfig -lgtkextra-x11-2.0 -lgthread-2.0
 
 all: 	gtkworkbook
 	make -C realtime/ all
-#	make -C basic/ all
-#	make -C csv/ all
+	make -C largefile/ all
 
 gtkworkbook: ${OBJS}
 	${CC} -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
@@ -17,15 +16,13 @@ clean:
 	${MD} ${OBJDIR}	
 	${RM} ${OBJS} ${INSBINDIR}/gtkworkbook
 	make -C realtime/ clean
-#	make -C basic/ clean
-#	make -C csv/ clean
+	make -C largefile/ clean
 
 install: all
 	${MD} ${INSBINDIR}
 	${CP} ${PROJDIR}/bin/gtkworkbook ${INSBINDIR}/gtkworkbook
 	make -C realtime/ install
-#	make -C basic/ install
-#	make -C csv/ install
+	make -C largefile/ install
 
 ${OBJDIR}/%.o: %.c
 	${CC} ${INCS} -c ${CCFLAGS} $< -o $@
diff --git a/src/largefile/.#thread_main.cpp b/src/largefile/.#thread_main.cpp
deleted file mode 120000
index 7109c53..0000000
--- a/src/largefile/.#thread_main.cpp
+++ /dev/null
@@ -1 +0,0 @@
-johnb@localhost.localdomain.6954:1230750316
\ No newline at end of file
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
index 61d59d6..6790627 100755
--- a/src/largefile/Makefile
+++ b/src/largefile/Makefile
@@ -1,5 +1,6 @@
 include ../../Makefile.base
 
+INCS += -I${PROJDIR}/shared
 SRCS=$(wildcard *.cpp) 
 OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
 
@@ -7,7 +8,7 @@ all: 	largefile
 
 largefile: ${OBJS}
 	${CX} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread -lcsv
+	-lgthread-2.0 -lpthread -lcsv -lshared
 
 clean:		
 	${MD} ${OBJDIR}/largefile
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
index 5ef09ba..1e1bfb6 100755
--- a/src/largefile/plugin_main.cpp
+++ b/src/largefile/plugin_main.cpp
@@ -20,10 +20,13 @@
 */
 #include <iostream>
 #include <workbook/workbook.h>
-#include <glib/gthread.h>
+#include <concurrent/ThreadArgs.hpp>
 #include "../application.h"
 #include "../plugin.h"
 
+/* Prototypes */
+extern void thread_main (ThreadArgs *);
+
 extern "C" {
 
   Workbook *
@@ -47,6 +50,18 @@ extern "C" {
     
     wb->add_new_sheet (wb, "sheet0", 100, 15);
 
+    ThreadArgs args;
+    args.push_back ( (void *)wb );
+    args.push_back ( (void *)appstate->cfg );
+    args.push_back ( (void *)appstate->shutdown );
+
+    if (plugin->create_thread (plugin,
+			       (GThreadFunc)thread_main,
+			       (gpointer)new ThreadArgs (args)) == NULL) {
+      g_critical ("Failed creating thread; exiting 'largefile' plugin");
+      return NULL;
+    }
+
     gtk_widget_show (hbox);
     return wb;
   }
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
index 9e1016b..96910b1 100644
--- a/src/largefile/thread_main.cpp
+++ b/src/largefile/thread_main.cpp
@@ -20,4 +20,46 @@
 */
 #include <workbook/workbook.h>
 #include <config/config.h>
+#include <concurrent/Thread.hpp>
+#include <concurrent/ThreadArgs.hpp>
+#include <proactor/Proactor.hpp>
+#include <proactor/Event.hpp>
+#include <gtkextra/gtksheet.h>
+#include <fstream>
+#include "File.hpp"
+#include <iostream>
+#include <string>
+#include <sstream>
 
+using namespace largefile;
+
+void
+thread_main (ThreadArgs * args) {
+  Workbook * wb = (Workbook *)args->at(0);
+  Config * cfg  = (Config *)args->at(1);
+  gboolean * SHUTDOWN = (gboolean *)args->at(2);
+  GtkSheet * sheet = (GtkSheet *)wb->sheet_first->gtk_sheet;
+
+  std::clog << "Indexing... " << std::flush;
+
+  FILE * fp = fopen ("/home/johnb/work/20by10MM.csv", "r");
+  Lines L;
+  File file (fp);
+
+  std::clog << "Done!\n" << std::flush;
+  
+
+  while (*SHUTDOWN == FALSE) {
+    double delta = gtk_adjustment_get_value (sheet->vadjustment);
+    std::ostringstream o; o<<delta;
+
+    wb->sheet_first->set_cell (wb->sheet_first,
+			       0, 0,
+			       o.str().c_str());
+    
+    // Continually sleep basically until our application terminates.
+    concurrent::Thread::sleep (100);
+  }
+
+  delete args;
+}

commit cbfbc28c76d5bcf0bd5218b6fe20d67665fd1b6b
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 1 15:38:24 2009 -0400

    Added File handler for indexing and reading lines.

diff --git a/src/largefile/File.cpp b/src/largefile/File.cpp
new file mode 100644
index 0000000..f7ecb3e
--- /dev/null
+++ b/src/largefile/File.cpp
@@ -0,0 +1,102 @@
+/* 
+   File.cpp
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "File.hpp"
+#include <cstdio>
+
+namespace largefile {
+
+  Line::Line (int startByte, FILE * fp) {
+    this->position = startByte;
+    this->fp = fp;
+    
+    this->read();
+  }
+
+  Line::~Line (void) {
+    this->line.clear();
+  }
+
+  void
+  Line::read (void) {
+    char buf[4096];
+
+    if (this->line.length() > 0)
+      return;
+
+    std::fgets (buf, 4096, this->fp);
+
+    this->line = buf;
+  }
+
+  File::File (FILE * fp) {
+    this->fp = fp;
+    
+    reindex();
+  }
+
+  File::File (const std::string & path) {
+    this->fp = std::fopen (path.c_str(), "r");
+
+    reindex();
+  }
+
+  File::~File (void) {
+  }
+
+  void 
+  File::reindex (void) {
+    char buf[4096];
+    long int pos = 0;
+
+    this->lineIndex.clear();
+
+    std::fseek (this->fp, 0, SEEK_SET);
+    pos = std::ftell (this->fp);
+    
+    while (std::fgets (buf, 4096, this->fp) != NULL) {
+      this->lineIndex.push_back (pos);
+      pos = std::ftell (this->fp);
+    }
+
+    this->lineIndex.push_back (pos);
+  
+    std::fseek (this->fp, 0, SEEK_SET);
+  }
+
+  Lines &
+  File::getLines (long int S, long int T, Lines & V) {
+    V.clear();
+
+    if (S < 0) S = 0;
+    
+    if ((S < T) && (S < (signed)this->lineIndex.size())) {
+
+      // Make sure we're not going out of bounds of the array.
+      if (T > (signed)this->lineIndex.size()) T = this->lineIndex.size();
+      
+      for (long int ii = S; ii < T; ii++)
+	V.push_back ( Line (this->lineIndex[ ii ], this->fp) );
+    }
+   
+    return V;
+  }
+
+}
diff --git a/src/largefile/File.hpp b/src/largefile/File.hpp
new file mode 100644
index 0000000..472b941
--- /dev/null
+++ b/src/largefile/File.hpp
@@ -0,0 +1,66 @@
+/* 
+   File.hpp - File Object handlers
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef FILE_HPP
+#define FILE_HPP
+
+#include <proactor/InputDispatcher.hpp>
+#include <proactor/Worker.hpp>
+#include <cstdio>
+#include <vector>
+#include <string>
+
+namespace largefile {
+
+  class Line {
+  private:
+    FILE * fp;
+    int position;
+    std::string line;
+  public:
+    Line (int startByte, FILE * fp);
+    ~Line (void);
+    
+    void read (void);
+
+    int getByteStart (void) const { return this->position; }
+    std::string getLine (void) const { return this->line; }
+  };
+
+  typedef std::vector<Line> Lines;
+
+  class File {
+  private:
+    typedef std::vector<long int> LineIndexMap;
+    
+    FILE * fp;
+    LineIndexMap lineIndex;
+  public:
+    File (FILE * fp);
+    File (const std::string & path);
+    ~File (void);
+
+    void reindex (void);
+    Lines & getLines (long int S, long int T, Lines & V);
+  };
+
+} // end of namespace
+
+#endif

commit 3ced4bbce842a52500748d7439fd202f08e4635a
Author: John Bellone <jvb4@njit.edu>
Date:   Fri May 1 10:36:16 2009 -0400

    Changed username/email.

diff --git a/.gtkworkbook b/.gtkworkbook
old mode 100644
new mode 100755
diff --git a/INSTALL b/INSTALL
old mode 100644
new mode 100755
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/Makefile b/Makefile
index 9828841..679764c 100755
--- a/Makefile
+++ b/Makefile
@@ -2,7 +2,11 @@ MD=mkdir -p
 MAKE=-make -C
 PWD=`pwd`
 
-all:	libconfig libworkbook libcsv gtkworkbook
+all:	libshared libconfig libworkbook libcsv gtkworkbook
+
+libshared:
+	${MD} OBJS/libshared
+	${MAKE} shared/ all
 
 libcsv:
 	${MD} OBJS/libcsv
@@ -21,12 +25,14 @@ gtkworkbook:
 	$(MAKE) src/ all
 
 clean:
+	${MAKE} shared/ clean
 	$(MAKE) config/ clean
 	${MAKE} workbook/ clean
 	${MAKE} csv/ clean
 	$(MAKE) src/ clean
 
 install: all
+	${MAKE} shared/ install
 	$(MAKE) config/ install
 	${MAKE} workbook/ install
 	${MAKE} csv/ install
diff --git a/README b/README
old mode 100644
new mode 100755
diff --git a/bin/socketTest.py b/bin/socketTest.py
old mode 100644
new mode 100755
diff --git a/concurrent/List.hpp b/concurrent/List.hpp
deleted file mode 100755
index dd9339c..0000000
--- a/concurrent/List.hpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/* 
-   List.hpp - Mutex List Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_LIST
-#define HPP_CONCURRENT_LIST
-
-#include <list>
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  template <typename T>
-  class List : public RecursiveMutex, public std::list<T> {
-  };
-
-} // end of namespace
-
-#endif
diff --git a/concurrent/Lockable.hpp b/concurrent/Lockable.hpp
deleted file mode 100755
index f3226c0..0000000
--- a/concurrent/Lockable.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/* 
-   Lockable.hpp - Lockable Interface Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_LOCKABLE
-#define HPP_THREAD_LOCKABLE
-
-class ILockable {
-public:
-  virtual ~ILockable (void) { }
-
-  virtual void lock (void) = 0;
-  virtual void unlock (void) = 0;
-  virtual bool trylock (void) = 0;
-};
-
-#endif
diff --git a/concurrent/Map.hpp b/concurrent/Map.hpp
deleted file mode 100755
index ae5d1c3..0000000
--- a/concurrent/Map.hpp
+++ /dev/null
@@ -1,44 +0,0 @@
-/* 
-   Map.hpp - Mutex Map Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MAP
-#define HPP_THREAD_MAP
-
-#include <iterator>
-#include <map>
-#include "Mutex.hpp"
-
-namespace concurrent {
- 
-  /* @description: This object uses the standard std::map and wraps all of
-     the calls that are exposed with a Mutex object. This object uses a
-     single lock and may cause performance issues if several threads are
-     attempting to use it. 
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template<typename K, typename V>
-  class Map : public RecursiveMutex, public std::map<K,V> {
-  private:
-  public:
-    Map (void) : RecursiveMutex() { }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/concurrent/Mutex.cpp b/concurrent/Mutex.cpp
deleted file mode 100755
index d188509..0000000
--- a/concurrent/Mutex.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/* 
-   Mutex.cpp - Mutex Object(s) Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  IMutex::IMutex (void) {
-    this->mutex = NULL;
-    this->attrib = NULL;
-  }
-
-  IMutex::IMutex (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-  }
-
-  IMutex::~IMutex (void) {
-  }
-
-  IMutex & 
-  IMutex::operator= (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-    return *this;
-  }
-
-  void
-  IMutex::lock (void) {
-    pthread_mutex_lock (this->mutex);
-  }
-
-  void 
-  IMutex::unlock (void) {
-    pthread_mutex_unlock (this->mutex);
-  }
-
-  bool
-  IMutex::trylock (void) {
-    return (pthread_mutex_trylock (this->mutex) == 0) ?
-      true : false;
-  }
-  
-  RecursiveMutex::RecursiveMutex (void) {
-    this->mutex = new pthread_mutex_t;
-    this->attrib = new pthread_mutexattr_t;
-
-    pthread_mutexattr_init (this->attrib);
-    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
-    
-    pthread_mutex_init (this->mutex, attrib);
-  }
-
-  RecursiveMutex::~RecursiveMutex (void) {
-    pthread_mutex_destroy (this->mutex);
-    pthread_mutexattr_destroy (this->attrib);
-
-    delete this->mutex;
-    delete this->attrib;
-  }
-
-  Mutex::Mutex (void) {
-    this->mutex = new pthread_mutex_t;
-
-    pthread_mutex_init (this->mutex, NULL);
-  }
-
-  Mutex::~Mutex (void) {
-    pthread_mutex_destroy (this->mutex);
-
-    delete this->mutex;
-  }
-
-} // end of namespace
diff --git a/concurrent/Mutex.hpp b/concurrent/Mutex.hpp
deleted file mode 100755
index 4a30cda..0000000
--- a/concurrent/Mutex.hpp
+++ /dev/null
@@ -1,58 +0,0 @@
-/* 
-   Mutex.hpp - Mutex Object(s) Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MUTEX
-#define HPP_THREAD_MUTEX
-
-#include <pthread.h>
-#include "Lockable.hpp"
-
-namespace concurrent {
-
-  class IMutex : public ILockable {
-  protected:
-    pthread_mutex_t * mutex;
-    pthread_mutexattr_t * attrib;
-  public:
-    IMutex (void);
-    IMutex (const IMutex & m);
-    virtual ~IMutex (void);
-
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-
-    IMutex & operator= (const IMutex & m);
-  };
-
-  class Mutex : public IMutex {
-  public:
-    Mutex (void);
-    virtual ~Mutex (void);
-  };
-
-  class RecursiveMutex : public IMutex {
-  public:
-    RecursiveMutex (void);
-    virtual ~RecursiveMutex (void);
-  };
-}
-
-#endif
diff --git a/concurrent/Queue.hpp b/concurrent/Queue.hpp
deleted file mode 100755
index abac49b..0000000
--- a/concurrent/Queue.hpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/* 
-   Queue.hpp - Mutex Queue Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_QUEUE
-#define HPP_THREAD_QUEUE
-
-#include "Mutex.hpp"
-#include <queue>
-#include <algorithm>
-
-namespace concurrent {
-  
-  /* @description: This object wraps the existing std::queue container with
-     the custom Mutex object from the concurrent namespace. The single lock
-     may be placed in the future with a read/write lock in order to gain a
-     speed advantage.
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template <typename T>
-  class Queue : public RecursiveMutex {
-  private:
-    std::queue<T> the_queue;
-  public:
-    Queue (void) { }
-    virtual ~Queue (void) { }
-
-    inline void clear (void) {
-      this->lock();
-      while (this->the_queue.size() > 0)
-	this->the_queue.pop();
-      this->unlock();
-    }
-
-    inline void copy (std::queue<T> & Q) {
-      this->lock();
-      Q = this->the_queue;
-      this->unlock();
-    }
-
-    inline const T & back (void) {
-      this->lock();
-      T & elem = this->the_queue.back();
-      this->unlock();
-      return elem;
-    }
-
-    inline const T & front (void) {
-      this->lock();
-      T & elem = this->the_queue.front();
-      this->unlock();
-      return elem;
-    }
-
-    inline void push (const T & x) {
-      this->lock();
-      this->the_queue.push (x);
-      this->unlock();
-    }
-
-    inline T pop (void) {
-      this->lock();
-      T elem = this->the_queue.front();
-      this->the_queue.pop();
-      this->unlock();
-      return elem;
-    }
-    
-    inline size_t size (void) {
-      this->lock();
-      size_t size = this->the_queue.size();
-      this->unlock();
-      return size;
-    }
-
-    inline bool empty (void) {
-      this->lock();
-      bool result = this->the_queue.empty();
-      this->unlock();
-      return result;
-    }
-  };
-}
-#endif
diff --git a/concurrent/Runnable.hpp b/concurrent/Runnable.hpp
deleted file mode 100755
index 9e9cacc..0000000
--- a/concurrent/Runnable.hpp
+++ /dev/null
@@ -1,36 +0,0 @@
-/* 
-   Runnable.hpp - Runnable Interface Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_RUNNABLE
-#define HPP_CONCURRENT_RUNNABLE
-
-class IRunnable {
-protected:
-  volatile bool running;
-public:
-  IRunnable (void) { this->running = false; }
-  virtual ~IRunnable (void) { }
-
-  virtual void * run (void *) = 0;
-  
-  inline bool isRunning (void) const { return this->running; }
-};
-
-#endif
diff --git a/concurrent/Semaphore.cpp b/concurrent/Semaphore.cpp
deleted file mode 100755
index 09f0172..0000000
--- a/concurrent/Semaphore.cpp
+++ /dev/null
@@ -1,44 +0,0 @@
-/* 
-   Semaphore.cpp - Semaphore Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Semaphore.hpp"
-
-namespace concurrent {
-
-  Semaphore::Semaphore (void) {
-    sem_init (&this->semaphore, 0, 0);
-  }
-
-  Semaphore::~Semaphore (void) {
-    sem_destroy (&this->semaphore);
-  }
-
-  void
-  Semaphore::acquire (void) {
-    sem_wait (&this->semaphore);
-  }
-
-  void
-  Semaphore::release (void) {
-    sem_post (&this->semaphore);
-  }
-
-} // end of namespace
-
diff --git a/concurrent/Semaphore.hpp b/concurrent/Semaphore.hpp
deleted file mode 100755
index e3504cf..0000000
--- a/concurrent/Semaphore.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/* 
-   Semaphore.hpp - Semaphore Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_SEMAPHORE
-#define HPP_THREAD_SEMAPHORE
-
-#include <semaphore.h>
-
-namespace concurrent {
-
-class Semaphore {
-private:
-  sem_t semaphore;
-public:
-  Semaphore (void);
-  virtual ~Semaphore (void);
-
-  void acquire (void);
-  void release (void);
-};
-
-}
-
-#endif
diff --git a/concurrent/Thread.cpp b/concurrent/Thread.cpp
deleted file mode 100755
index 42a93bb..0000000
--- a/concurrent/Thread.cpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/* 
-   Thread.cpp - Thread Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Thread.hpp"
-#include "ThreadGroup.hpp"
-#include <iostream>
-#include <ctime>
-
-namespace concurrent {
-
-  static void *
-  thread_run (void * runner) {
-    void * rvalue = ((IRunnable *)runner)->run (NULL);
-    return rvalue;
-  }
-
-  Thread::Thread (ThreadGroup * group,
-		  IRunnable * runner, 
-		  const std::string & name) {
-    this->group = group;
-    this->runner = runner;
-    this->name = name;
-    this->running = false;
-  }
-
-  Thread::Thread (IRunnable * runner,
-		  const std::string & name) 
-    : group(NULL) {
-    this->runner = runner;
-    this->name = name;
-    this->running = false;
-  }
-
-  Thread::Thread (const std::string & name) 
-    : group(NULL), runner(NULL) {
-    this->name = name;
-    this->running = false;
-  }
-
-  Thread::Thread (void) : group(NULL), runner(NULL) {
-    this->running = false;
-  }
-
-  Thread::~Thread (void) {
-    if (this->running == true) {
-      this->running = false;
-      this->join();
-    }
-  }
-
-  void 
-  Thread::interrupt (void) {
-    this->running = false;
-    pthread_cancel (this->thread);
-    pthread_detach (this->thread);
-  }
-
-  void 
-  Thread::yield (void) {
-    pthread_yield();
-  }
-
-  void * 
-  Thread::stop (void) {
-    this->running = false;
-    return this->join();
-  }
-
-  int 
-  Thread::sleep (unsigned long ms) {
-    struct timespec req = {0};
-    time_t sec = (int)(ms/1000);
-    ms = ms - (sec*1000);
-    req.tv_sec = sec;
-    req.tv_nsec = ms*1000000L;
-    while (nanosleep (&req, &req) == -1)
-      continue;
-    return 1;
-  }
-
-  bool 
-  Thread::start (void) {
-    if (this->running == true)
-      return false;
-
-    if (this->runner != NULL) {
-      if (pthread_create (&this->thread,
-			  NULL,
-			  thread_run,
-			  this->runner))
-	  return false;
-    }
-    else {
-      if (pthread_create (&this->thread,
-			  NULL,
-			  thread_run,
-			  this))
-	return false;
-    }
-
-    this->running = true;
-    return true;
-  }
-
-  void *
-  Thread::join (void) {
-    void * rvalue = NULL;
-    pthread_join (this->thread, &rvalue);
-    return rvalue;
-  }
-
-  void *
-  Thread::run (void *null) {
-    pthread_exit (null);
-  }
-
-} // end of namespace
diff --git a/concurrent/Thread.hpp b/concurrent/Thread.hpp
deleted file mode 100755
index 7b284df..0000000
--- a/concurrent/Thread.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/* 
-   Thread.hpp - Thread Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREAD
-#define HPP_CONCURRENT_THREAD
-
-#include <shared.h>
-#include <string>
-#include <pthread.h>
-#include <map>
-#include "Runnable.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup;
-
-  class Thread : public IRunnable {
-  private:
-    friend class ThreadGroup;
-
-    ThreadGroup * group;
-    std::string name;
-    IRunnable * runner;
-    pthread_t thread;
-    bool joinable;
-    int priority;
-  public:
-    Thread (ThreadGroup * group, 
-	    IRunnable * runner, 
-	    const std::string & name);
-    Thread (IRunnable * runner,
-	    const std::string & name);
-    Thread (const std::string & name);
-    Thread (void);
-    virtual ~Thread (void);
-
-    bool start (void);
-    void * stop (void);
-    void * join (void);
-    void interrupt (void);
-    void yield (void);
-  
-    virtual void * run (void *);
-
-    inline const std::string & getName (void) const { return this->name; }
-    inline int getPriority (void) const { return this->priority; }
-    inline void setPriority (int priority) { this->priority = priority; }
-    inline const ThreadGroup * getThreadGroup (void) const { 
-      return this->group; 
-    }
-
-    static int sleep (unsigned long ms);
-  };  
-
-}
-
-#endif
diff --git a/concurrent/ThreadArgs.hpp b/concurrent/ThreadArgs.hpp
deleted file mode 100755
index f44742c..0000000
--- a/concurrent/ThreadArgs.hpp
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef H_THREAD_THREADARGS
-#define H_THREAD_THREADARGS
-
-#include <vector>
-
-typedef std::vector<void *> ThreadArgs;
-
-#endif
diff --git a/concurrent/ThreadGroup.cpp b/concurrent/ThreadGroup.cpp
deleted file mode 100755
index c3eafb4..0000000
--- a/concurrent/ThreadGroup.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/* 
-   ThreadGroup.cpp - ThreadGroup Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadGroup.hpp"
-#include <algorithm>
-
-namespace concurrent {
-
-  ThreadGroup::ThreadGroup (void) 
-    : parent(NULL), daemon(false) {
-  }
-
-  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
-    : daemon(false) {
-    this->parent = parent;
-    this->name = name;
-  }
-
-  ThreadGroup::ThreadGroup (const std::string & name) 
-    : parent(NULL), daemon(false) {
-    this->name = name;
-  }
-
-  ThreadGroup::~ThreadGroup (void) {
-    if (this->daemon == true) {
-      this->stop();
-    }
-  }
-
-  bool 
-  ThreadGroup::parentOf (ThreadGroup * parent) {
-    if ((this->parent == NULL) || (parent == NULL))
-      return false;
-    // Needs to be better than this. 
-    return (this->parent == parent) ? true : false;
-  } 
-    
-  bool
-  ThreadGroup::addThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-    if (it == this->threads.end()) {
-      thread->group = this;
-      this->threads.push_back (thread);
-      return true;
-    }
-    return false;
-  }
-
-  bool 
-  ThreadGroup::removeThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-
-    if (it == this->threads.end())
-      return false;
-    this->threads.erase(it);
-    return true;
-  }
-
-  void
-  ThreadGroup::interrupt (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->interrupt();
-    }
-  }
-
-  bool
-  ThreadGroup::start (void) {
-    bool rvalue = false;
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      rvalue = (*it++)->start();
-    }
-
-    return rvalue;
-  }
-
-  void 
-  ThreadGroup::stop (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->stop();
-    }
-  }
-} // end of namesapce
diff --git a/concurrent/ThreadGroup.hpp b/concurrent/ThreadGroup.hpp
deleted file mode 100755
index c0c5e41..0000000
--- a/concurrent/ThreadGroup.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/* 
-   ThreadGroup.hpp - ThreadGroup Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREADGROUP
-#define HPP_CONCURRENT_THREADGROUP
-
-#include <string>
-#include "List.hpp"
-#include "Thread.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup {
-  private:
-    typedef concurrent::List<Thread *> ThreadList;
-    
-    ThreadGroup * parent;
-    std::string name;
-    ThreadList threads;
-    bool daemon; 
-  public:
-    ThreadGroup (void);
-    ThreadGroup (ThreadGroup * parent, const std::string & name);
-    ThreadGroup (const std::string & name);
-    virtual ~ThreadGroup (void);
-
-    bool parentOf (ThreadGroup * parent);
-    bool addThread (Thread * thread);
-    bool removeThread (Thread * thread);
-    void interrupt (void);
-    bool start (void);
-    void stop (void);
-    
-    inline bool isDaemon (void) const { return this->daemon; }
-    inline void setDaemon (bool daemon) { this->daemon = daemon; }
-    inline const std::string & getName (void) const { return this->name; }
-    inline ThreadGroup * getParent (void) const { return this->parent; }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/concurrent/ThreadPool.cpp b/concurrent/ThreadPool.cpp
deleted file mode 100755
index cebb30f..0000000
--- a/concurrent/ThreadPool.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/* 
-   ThreadPool.cpp - ThreadPool Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadPool.hpp"
-
-namespace concurrent {
-
-  ThreadPool::ThreadPool (int nMaxThreads) {
-    this->running = false;
-
-    for (int ii = 0; ii < nMaxThreads; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::~ThreadPool (void) {
-    if (this->running == true)
-      this->stop(true);
-
-    std::list<Thread *>::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      Thread * t = (*it++);
-      delete t;
-    }
-
-    while (this->runQueue.size() > 0) {
-      IRunnable * r = this->runQueue.pop();
-      delete r;
-    }
-  }
-
-  void 
-  ThreadPool::start (void) {
-    this->running = true;
-    
-  std::list<Thread *>::iterator it = this->threads.begin();
-  while (it != this->threads.end())
-    {
-      (*it)->start();
-      it++;
-    }
-  }
-
-  void 
-  ThreadPool::stop (bool join = false) {
-    this->running = false;
-
-    /* Waiting to join all of the threads will mean that the thread that the
-       pool is calling the stop() method from will block until all of the 
-       threads inside of the pool have stopped.
-
-       There is a PROBLEM here. If you call this, for some reason, from inside
-       of one of the Task threads then you are going to hit a deadlock. Never
-       pass the join parameter if this is being called from inside the Tasks.*/
-    if (join == true) {
-      std::list<Thread *>::iterator it = this->threads.begin();
-      while (it != this->threads.end()) {
-	(*it)->join ();
-	it++;
-      }
-    }
-  }
-
-  void 
-  ThreadPool::execute (IRunnable * runner) {
-    this->runQueue.push (runner);
-  }
-
-} // end of namespace
-
diff --git a/concurrent/ThreadPool.hpp b/concurrent/ThreadPool.hpp
deleted file mode 100755
index a09dd58..0000000
--- a/concurrent/ThreadPool.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/* 
-   ThreadPool.hpp - ThreadPool Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_THREADPOOL
-#define HPP_THREAD_THREADPOOL
-
-#include "Mutex.hpp"
-#include "Thread.hpp"
-#include "Queue.hpp"
-#include <queue>
-#include <list>
-
-namespace concurrent {
-
-  /* @description: This is a ThreadPool object that will keep N concurrent
-     threads running. Runnable objects can be attached to this object and they
-     will be executed immediately as a thread becomes available to run them. 
-     @author: John `jb Bellone (jvb4@njit.edu)
-     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
-  class ThreadPool {
-    /* @description: This object is an individual task that will be spawned at
-       the start of the ThreadPool. Each thread periodically checks the pool
-       object for any available Runnable objects from the queue. If there are
-       such objects it will take them off, run them and delete them. */
-    class Task : public IRunnable {
-    private:
-      ThreadPool * pool;
-    public:
-      Task (ThreadPool * pool) {
-	this->pool = pool;
-      }
-      
-      void * run (void *) {
-	this->running = true;
-
-	while (this->running == true)
-	  {
-	    if (pool->isRunning() == false)
-	      break;
-
-	    if (pool->getQueueSize() > 0)
-	      {
-		IRunnable * runner = pool->removeFromQueue();
-		runner->run(NULL);
-		delete runner;
-	      }
-	    ::sleep (1);
-	  }
-	return NULL;
-      }
-    };
-  private:
-    concurrent::Queue<IRunnable *> runQueue;
-    std::list<Thread *> threads;
-    bool running;
-  public:  
-    ThreadPool (int);
-    ~ThreadPool (void);
-
-    /* Thread un-Safe Methods */
-    void start (void);
-    void stop (bool);
-
-    /* Thread-Safe Methods */
-    void execute (IRunnable *);
-    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
-    inline bool isRunning (void) const { return this->running; }
-    inline int getMaxThreads (void) const { return this->threads.size(); }
-    inline size_t getQueueSize (void) { return this->runQueue.size(); }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/config/INIFile.c b/config/INIFile.c
old mode 100644
new mode 100755
diff --git a/config/parse.c b/config/parse.c
old mode 100644
new mode 100755
diff --git a/config/parse.h b/config/parse.h
old mode 100644
new mode 100755
diff --git a/csv/Changelog b/csv/Changelog
old mode 100644
new mode 100755
diff --git a/csv/FAQ b/csv/FAQ
old mode 100644
new mode 100755
diff --git a/csv/INSTALL b/csv/INSTALL
old mode 100644
new mode 100755
diff --git a/csv/LICENSE b/csv/LICENSE
old mode 100644
new mode 100755
diff --git a/csv/Makefile b/csv/Makefile
old mode 100644
new mode 100755
diff --git a/csv/README b/csv/README
old mode 100644
new mode 100755
diff --git a/csv/csv.3.gz b/csv/csv.3.gz
old mode 100644
new mode 100755
diff --git a/csv/csv.h b/csv/csv.h
old mode 100644
new mode 100755
diff --git a/csv/csv.pdf b/csv/csv.pdf
old mode 100644
new mode 100755
diff --git a/csv/examples/LICENSE b/csv/examples/LICENSE
old mode 100644
new mode 100755
diff --git a/csv/examples/csvfix.c b/csv/examples/csvfix.c
old mode 100644
new mode 100755
diff --git a/csv/examples/csvinfo.c b/csv/examples/csvinfo.c
old mode 100644
new mode 100755
diff --git a/csv/examples/csvtest.c b/csv/examples/csvtest.c
old mode 100644
new mode 100755
diff --git a/csv/examples/csvvalid.c b/csv/examples/csvvalid.c
old mode 100644
new mode 100755
diff --git a/csv/libcsv.c b/csv/libcsv.c
old mode 100644
new mode 100755
diff --git a/csv/test_csv.c b/csv/test_csv.c
old mode 100644
new mode 100755
diff --git a/csv/tests/test_01.csv b/csv/tests/test_01.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_02.csv b/csv/tests/test_02.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_03.csv b/csv/tests/test_03.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_04.csv b/csv/tests/test_04.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_05.csv b/csv/tests/test_05.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_06.csv b/csv/tests/test_06.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_07.csv b/csv/tests/test_07.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_08.csv b/csv/tests/test_08.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_09.csv b/csv/tests/test_09.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_10.csv b/csv/tests/test_10.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_11.csv b/csv/tests/test_11.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_12.csv b/csv/tests/test_12.csv
old mode 100644
new mode 100755
diff --git a/csv/tests/test_13.csv b/csv/tests/test_13.csv
old mode 100644
new mode 100755
diff --git a/include/config/INIFile.h b/include/config/INIFile.h
old mode 100644
new mode 100755
diff --git a/include/csv/csv.h b/include/csv/csv.h
old mode 100644
new mode 100755
diff --git a/include/workbook/cell.h b/include/workbook/cell.h
old mode 100644
new mode 100755
diff --git a/include/workbook/sheet.h b/include/workbook/sheet.h
old mode 100644
new mode 100755
diff --git a/include/workbook/workbook.h b/include/workbook/workbook.h
old mode 100644
new mode 100755
diff --git a/src/application.c b/src/application.c
old mode 100644
new mode 100755
diff --git a/src/application.h b/src/application.h
old mode 100644
new mode 100755
diff --git a/src/include.h b/src/include.h
old mode 100644
new mode 100755
diff --git a/src/largefile/plugin_main.cpp~ b/src/largefile/plugin_main.cpp~
deleted file mode 100755
index 0a9e61e..0000000
--- a/src/largefile/plugin_main.cpp~
+++ /dev/null
@@ -1,20 +0,0 @@
-/* 
-   plugin_main.cpp - Largefile Plugin DLL Entry Point
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
old mode 100644
new mode 100755
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
old mode 100644
new mode 100755
index b883704..00aed05
--- a/src/realtime/CsvParser.hpp
+++ b/src/realtime/CsvParser.hpp
@@ -21,7 +21,7 @@
 #ifndef HPP_CSVPARSER
 #define HPP_CSVPARSER
 
-#include "proactor/Worker.hpp"
+#include <proactor/Worker.hpp>
 #include <workbook/workbook.h>
 #include <workbook/sheet.h>
 #include <workbook/cell.h>
diff --git a/src/realtime/Makefile b/src/realtime/Makefile
index 4310a12..8ba5091 100755
--- a/src/realtime/Makefile
+++ b/src/realtime/Makefile
@@ -1,18 +1,17 @@
 include ../../Makefile.base
 
-SRCS=$(wildcard *.cpp) $(wildcard concurrent/*.cpp) $(wildcard network/*.cpp) \
-	$(wildcard proactor/*.cpp)
-OBJS=$(patsubst %.cpp,${OBJDIR}/realtime/%.o,${SRCS})
+INCS += -I${PROJDIR}/shared
+SRCS = $(wildcard *.cpp) 
+OBJS = $(patsubst %.cpp,${OBJDIR}/realtime/%.o,${SRCS}) 
 
 all: 	realtime
 
 realtime: ${OBJS}
 	${CX} -shared -Wl -o ${PROJDIR}/bin/realtime.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread -lcsv
+	-lgthread-2.0 -lpthread -lcsv -lshared
 
 clean:		
-	${MD} ${OBJDIR}/realtime/concurrent ${OBJDIR}/realtime/network \
-	${OBJDIR}/realtime/proactor
+	${MD} ${OBJDIR}/realtime
 	${RM} ${OBJS} ${PROJDIR}/bin/realtime.so
 
 install: all
@@ -23,4 +22,4 @@ ${OBJDIR}/realtime/%.o: %.cpp
 	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
 
 .cpp.o:
-	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<
\ No newline at end of file
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
old mode 100644
new mode 100755
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
old mode 100644
new mode 100755
index c178c96..a3a366f
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -21,9 +21,9 @@
 #ifndef HPP_NETWORK
 #define HPP_NETWORK
 
-#include "network/Tcp.hpp"
-#include "proactor/Worker.hpp"
-#include "proactor/Proactor.hpp"
+#include <network/Tcp.hpp>
+#include <proactor/Worker.hpp>
+#include <proactor/Proactor.hpp>
 #include <iostream>
 
 #define MAX_INPUT_SIZE 1024
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
old mode 100644
new mode 100755
index e262007..44c76d5
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -21,7 +21,7 @@
 #ifndef HPP_PACKETHANDLER
 #define HPP_PACKETHANDLER
 
-#include "proactor/Worker.hpp"
+#include <proactor/Worker.hpp>
 #include "Packet.hpp"
 #include <workbook/cell.h>
 #include <workbook/sheet.h>
diff --git a/src/realtime/concurrent/List.hpp b/src/realtime/concurrent/List.hpp
deleted file mode 100755
index dd9339c..0000000
--- a/src/realtime/concurrent/List.hpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/* 
-   List.hpp - Mutex List Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_LIST
-#define HPP_CONCURRENT_LIST
-
-#include <list>
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  template <typename T>
-  class List : public RecursiveMutex, public std::list<T> {
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/concurrent/Lockable.hpp b/src/realtime/concurrent/Lockable.hpp
deleted file mode 100755
index f3226c0..0000000
--- a/src/realtime/concurrent/Lockable.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/* 
-   Lockable.hpp - Lockable Interface Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_LOCKABLE
-#define HPP_THREAD_LOCKABLE
-
-class ILockable {
-public:
-  virtual ~ILockable (void) { }
-
-  virtual void lock (void) = 0;
-  virtual void unlock (void) = 0;
-  virtual bool trylock (void) = 0;
-};
-
-#endif
diff --git a/src/realtime/concurrent/Map.hpp b/src/realtime/concurrent/Map.hpp
deleted file mode 100755
index ae5d1c3..0000000
--- a/src/realtime/concurrent/Map.hpp
+++ /dev/null
@@ -1,44 +0,0 @@
-/* 
-   Map.hpp - Mutex Map Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MAP
-#define HPP_THREAD_MAP
-
-#include <iterator>
-#include <map>
-#include "Mutex.hpp"
-
-namespace concurrent {
- 
-  /* @description: This object uses the standard std::map and wraps all of
-     the calls that are exposed with a Mutex object. This object uses a
-     single lock and may cause performance issues if several threads are
-     attempting to use it. 
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template<typename K, typename V>
-  class Map : public RecursiveMutex, public std::map<K,V> {
-  private:
-  public:
-    Map (void) : RecursiveMutex() { }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/concurrent/Mutex.cpp b/src/realtime/concurrent/Mutex.cpp
deleted file mode 100755
index d188509..0000000
--- a/src/realtime/concurrent/Mutex.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/* 
-   Mutex.cpp - Mutex Object(s) Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Mutex.hpp"
-
-namespace concurrent {
-
-  IMutex::IMutex (void) {
-    this->mutex = NULL;
-    this->attrib = NULL;
-  }
-
-  IMutex::IMutex (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-  }
-
-  IMutex::~IMutex (void) {
-  }
-
-  IMutex & 
-  IMutex::operator= (const IMutex & m) {
-    this->mutex = m.mutex;
-    this->attrib = m.attrib;
-    return *this;
-  }
-
-  void
-  IMutex::lock (void) {
-    pthread_mutex_lock (this->mutex);
-  }
-
-  void 
-  IMutex::unlock (void) {
-    pthread_mutex_unlock (this->mutex);
-  }
-
-  bool
-  IMutex::trylock (void) {
-    return (pthread_mutex_trylock (this->mutex) == 0) ?
-      true : false;
-  }
-  
-  RecursiveMutex::RecursiveMutex (void) {
-    this->mutex = new pthread_mutex_t;
-    this->attrib = new pthread_mutexattr_t;
-
-    pthread_mutexattr_init (this->attrib);
-    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
-    
-    pthread_mutex_init (this->mutex, attrib);
-  }
-
-  RecursiveMutex::~RecursiveMutex (void) {
-    pthread_mutex_destroy (this->mutex);
-    pthread_mutexattr_destroy (this->attrib);
-
-    delete this->mutex;
-    delete this->attrib;
-  }
-
-  Mutex::Mutex (void) {
-    this->mutex = new pthread_mutex_t;
-
-    pthread_mutex_init (this->mutex, NULL);
-  }
-
-  Mutex::~Mutex (void) {
-    pthread_mutex_destroy (this->mutex);
-
-    delete this->mutex;
-  }
-
-} // end of namespace
diff --git a/src/realtime/concurrent/Mutex.hpp b/src/realtime/concurrent/Mutex.hpp
deleted file mode 100755
index 4a30cda..0000000
--- a/src/realtime/concurrent/Mutex.hpp
+++ /dev/null
@@ -1,58 +0,0 @@
-/* 
-   Mutex.hpp - Mutex Object(s) Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_MUTEX
-#define HPP_THREAD_MUTEX
-
-#include <pthread.h>
-#include "Lockable.hpp"
-
-namespace concurrent {
-
-  class IMutex : public ILockable {
-  protected:
-    pthread_mutex_t * mutex;
-    pthread_mutexattr_t * attrib;
-  public:
-    IMutex (void);
-    IMutex (const IMutex & m);
-    virtual ~IMutex (void);
-
-    void lock (void);
-    void unlock (void);
-    bool trylock (void);
-
-    IMutex & operator= (const IMutex & m);
-  };
-
-  class Mutex : public IMutex {
-  public:
-    Mutex (void);
-    virtual ~Mutex (void);
-  };
-
-  class RecursiveMutex : public IMutex {
-  public:
-    RecursiveMutex (void);
-    virtual ~RecursiveMutex (void);
-  };
-}
-
-#endif
diff --git a/src/realtime/concurrent/Queue.hpp b/src/realtime/concurrent/Queue.hpp
deleted file mode 100755
index abac49b..0000000
--- a/src/realtime/concurrent/Queue.hpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/* 
-   Queue.hpp - Mutex Queue Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_QUEUE
-#define HPP_THREAD_QUEUE
-
-#include "Mutex.hpp"
-#include <queue>
-#include <algorithm>
-
-namespace concurrent {
-  
-  /* @description: This object wraps the existing std::queue container with
-     the custom Mutex object from the concurrent namespace. The single lock
-     may be placed in the future with a read/write lock in order to gain a
-     speed advantage.
-     @author: John `jb Bellone <jvb4@njit.edu> */
-  template <typename T>
-  class Queue : public RecursiveMutex {
-  private:
-    std::queue<T> the_queue;
-  public:
-    Queue (void) { }
-    virtual ~Queue (void) { }
-
-    inline void clear (void) {
-      this->lock();
-      while (this->the_queue.size() > 0)
-	this->the_queue.pop();
-      this->unlock();
-    }
-
-    inline void copy (std::queue<T> & Q) {
-      this->lock();
-      Q = this->the_queue;
-      this->unlock();
-    }
-
-    inline const T & back (void) {
-      this->lock();
-      T & elem = this->the_queue.back();
-      this->unlock();
-      return elem;
-    }
-
-    inline const T & front (void) {
-      this->lock();
-      T & elem = this->the_queue.front();
-      this->unlock();
-      return elem;
-    }
-
-    inline void push (const T & x) {
-      this->lock();
-      this->the_queue.push (x);
-      this->unlock();
-    }
-
-    inline T pop (void) {
-      this->lock();
-      T elem = this->the_queue.front();
-      this->the_queue.pop();
-      this->unlock();
-      return elem;
-    }
-    
-    inline size_t size (void) {
-      this->lock();
-      size_t size = this->the_queue.size();
-      this->unlock();
-      return size;
-    }
-
-    inline bool empty (void) {
-      this->lock();
-      bool result = this->the_queue.empty();
-      this->unlock();
-      return result;
-    }
-  };
-}
-#endif
diff --git a/src/realtime/concurrent/Runnable.hpp b/src/realtime/concurrent/Runnable.hpp
deleted file mode 100755
index 9e9cacc..0000000
--- a/src/realtime/concurrent/Runnable.hpp
+++ /dev/null
@@ -1,36 +0,0 @@
-/* 
-   Runnable.hpp - Runnable Interface Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_RUNNABLE
-#define HPP_CONCURRENT_RUNNABLE
-
-class IRunnable {
-protected:
-  volatile bool running;
-public:
-  IRunnable (void) { this->running = false; }
-  virtual ~IRunnable (void) { }
-
-  virtual void * run (void *) = 0;
-  
-  inline bool isRunning (void) const { return this->running; }
-};
-
-#endif
diff --git a/src/realtime/concurrent/Semaphore.cpp b/src/realtime/concurrent/Semaphore.cpp
deleted file mode 100755
index 09f0172..0000000
--- a/src/realtime/concurrent/Semaphore.cpp
+++ /dev/null
@@ -1,44 +0,0 @@
-/* 
-   Semaphore.cpp - Semaphore Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Semaphore.hpp"
-
-namespace concurrent {
-
-  Semaphore::Semaphore (void) {
-    sem_init (&this->semaphore, 0, 0);
-  }
-
-  Semaphore::~Semaphore (void) {
-    sem_destroy (&this->semaphore);
-  }
-
-  void
-  Semaphore::acquire (void) {
-    sem_wait (&this->semaphore);
-  }
-
-  void
-  Semaphore::release (void) {
-    sem_post (&this->semaphore);
-  }
-
-} // end of namespace
-
diff --git a/src/realtime/concurrent/Semaphore.hpp b/src/realtime/concurrent/Semaphore.hpp
deleted file mode 100755
index e3504cf..0000000
--- a/src/realtime/concurrent/Semaphore.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/* 
-   Semaphore.hpp - Semaphore Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_SEMAPHORE
-#define HPP_THREAD_SEMAPHORE
-
-#include <semaphore.h>
-
-namespace concurrent {
-
-class Semaphore {
-private:
-  sem_t semaphore;
-public:
-  Semaphore (void);
-  virtual ~Semaphore (void);
-
-  void acquire (void);
-  void release (void);
-};
-
-}
-
-#endif
diff --git a/src/realtime/concurrent/Thread.cpp b/src/realtime/concurrent/Thread.cpp
deleted file mode 100755
index 42a93bb..0000000
--- a/src/realtime/concurrent/Thread.cpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/* 
-   Thread.cpp - Thread Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Thread.hpp"
-#include "ThreadGroup.hpp"
-#include <iostream>
-#include <ctime>
-
-namespace concurrent {
-
-  static void *
-  thread_run (void * runner) {
-    void * rvalue = ((IRunnable *)runner)->run (NULL);
-    return rvalue;
-  }
-
-  Thread::Thread (ThreadGroup * group,
-		  IRunnable * runner, 
-		  const std::string & name) {
-    this->group = group;
-    this->runner = runner;
-    this->name = name;
-    this->running = false;
-  }
-
-  Thread::Thread (IRunnable * runner,
-		  const std::string & name) 
-    : group(NULL) {
-    this->runner = runner;
-    this->name = name;
-    this->running = false;
-  }
-
-  Thread::Thread (const std::string & name) 
-    : group(NULL), runner(NULL) {
-    this->name = name;
-    this->running = false;
-  }
-
-  Thread::Thread (void) : group(NULL), runner(NULL) {
-    this->running = false;
-  }
-
-  Thread::~Thread (void) {
-    if (this->running == true) {
-      this->running = false;
-      this->join();
-    }
-  }
-
-  void 
-  Thread::interrupt (void) {
-    this->running = false;
-    pthread_cancel (this->thread);
-    pthread_detach (this->thread);
-  }
-
-  void 
-  Thread::yield (void) {
-    pthread_yield();
-  }
-
-  void * 
-  Thread::stop (void) {
-    this->running = false;
-    return this->join();
-  }
-
-  int 
-  Thread::sleep (unsigned long ms) {
-    struct timespec req = {0};
-    time_t sec = (int)(ms/1000);
-    ms = ms - (sec*1000);
-    req.tv_sec = sec;
-    req.tv_nsec = ms*1000000L;
-    while (nanosleep (&req, &req) == -1)
-      continue;
-    return 1;
-  }
-
-  bool 
-  Thread::start (void) {
-    if (this->running == true)
-      return false;
-
-    if (this->runner != NULL) {
-      if (pthread_create (&this->thread,
-			  NULL,
-			  thread_run,
-			  this->runner))
-	  return false;
-    }
-    else {
-      if (pthread_create (&this->thread,
-			  NULL,
-			  thread_run,
-			  this))
-	return false;
-    }
-
-    this->running = true;
-    return true;
-  }
-
-  void *
-  Thread::join (void) {
-    void * rvalue = NULL;
-    pthread_join (this->thread, &rvalue);
-    return rvalue;
-  }
-
-  void *
-  Thread::run (void *null) {
-    pthread_exit (null);
-  }
-
-} // end of namespace
diff --git a/src/realtime/concurrent/Thread.hpp b/src/realtime/concurrent/Thread.hpp
deleted file mode 100755
index 7b284df..0000000
--- a/src/realtime/concurrent/Thread.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/* 
-   Thread.hpp - Thread Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREAD
-#define HPP_CONCURRENT_THREAD
-
-#include <shared.h>
-#include <string>
-#include <pthread.h>
-#include <map>
-#include "Runnable.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup;
-
-  class Thread : public IRunnable {
-  private:
-    friend class ThreadGroup;
-
-    ThreadGroup * group;
-    std::string name;
-    IRunnable * runner;
-    pthread_t thread;
-    bool joinable;
-    int priority;
-  public:
-    Thread (ThreadGroup * group, 
-	    IRunnable * runner, 
-	    const std::string & name);
-    Thread (IRunnable * runner,
-	    const std::string & name);
-    Thread (const std::string & name);
-    Thread (void);
-    virtual ~Thread (void);
-
-    bool start (void);
-    void * stop (void);
-    void * join (void);
-    void interrupt (void);
-    void yield (void);
-  
-    virtual void * run (void *);
-
-    inline const std::string & getName (void) const { return this->name; }
-    inline int getPriority (void) const { return this->priority; }
-    inline void setPriority (int priority) { this->priority = priority; }
-    inline const ThreadGroup * getThreadGroup (void) const { 
-      return this->group; 
-    }
-
-    static int sleep (unsigned long ms);
-  };  
-
-}
-
-#endif
diff --git a/src/realtime/concurrent/ThreadArgs.hpp b/src/realtime/concurrent/ThreadArgs.hpp
deleted file mode 100755
index f44742c..0000000
--- a/src/realtime/concurrent/ThreadArgs.hpp
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef H_THREAD_THREADARGS
-#define H_THREAD_THREADARGS
-
-#include <vector>
-
-typedef std::vector<void *> ThreadArgs;
-
-#endif
diff --git a/src/realtime/concurrent/ThreadGroup.cpp b/src/realtime/concurrent/ThreadGroup.cpp
deleted file mode 100644
index c3eafb4..0000000
--- a/src/realtime/concurrent/ThreadGroup.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/* 
-   ThreadGroup.cpp - ThreadGroup Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadGroup.hpp"
-#include <algorithm>
-
-namespace concurrent {
-
-  ThreadGroup::ThreadGroup (void) 
-    : parent(NULL), daemon(false) {
-  }
-
-  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
-    : daemon(false) {
-    this->parent = parent;
-    this->name = name;
-  }
-
-  ThreadGroup::ThreadGroup (const std::string & name) 
-    : parent(NULL), daemon(false) {
-    this->name = name;
-  }
-
-  ThreadGroup::~ThreadGroup (void) {
-    if (this->daemon == true) {
-      this->stop();
-    }
-  }
-
-  bool 
-  ThreadGroup::parentOf (ThreadGroup * parent) {
-    if ((this->parent == NULL) || (parent == NULL))
-      return false;
-    // Needs to be better than this. 
-    return (this->parent == parent) ? true : false;
-  } 
-    
-  bool
-  ThreadGroup::addThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-    if (it == this->threads.end()) {
-      thread->group = this;
-      this->threads.push_back (thread);
-      return true;
-    }
-    return false;
-  }
-
-  bool 
-  ThreadGroup::removeThread (Thread * thread) {
-    ThreadList::iterator it = std::find (this->threads.begin(),
-					 this->threads.end(),
-					 thread);
-
-    if (it == this->threads.end())
-      return false;
-    this->threads.erase(it);
-    return true;
-  }
-
-  void
-  ThreadGroup::interrupt (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->interrupt();
-    }
-  }
-
-  bool
-  ThreadGroup::start (void) {
-    bool rvalue = false;
-
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      rvalue = (*it++)->start();
-    }
-
-    return rvalue;
-  }
-
-  void 
-  ThreadGroup::stop (void) {
-    ThreadList::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      (*it++)->stop();
-    }
-  }
-} // end of namesapce
diff --git a/src/realtime/concurrent/ThreadGroup.hpp b/src/realtime/concurrent/ThreadGroup.hpp
deleted file mode 100755
index c0c5e41..0000000
--- a/src/realtime/concurrent/ThreadGroup.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/* 
-   ThreadGroup.hpp - ThreadGroup Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONCURRENT_THREADGROUP
-#define HPP_CONCURRENT_THREADGROUP
-
-#include <string>
-#include "List.hpp"
-#include "Thread.hpp"
-
-namespace concurrent {
-
-  class ThreadGroup {
-  private:
-    typedef concurrent::List<Thread *> ThreadList;
-    
-    ThreadGroup * parent;
-    std::string name;
-    ThreadList threads;
-    bool daemon; 
-  public:
-    ThreadGroup (void);
-    ThreadGroup (ThreadGroup * parent, const std::string & name);
-    ThreadGroup (const std::string & name);
-    virtual ~ThreadGroup (void);
-
-    bool parentOf (ThreadGroup * parent);
-    bool addThread (Thread * thread);
-    bool removeThread (Thread * thread);
-    void interrupt (void);
-    bool start (void);
-    void stop (void);
-    
-    inline bool isDaemon (void) const { return this->daemon; }
-    inline void setDaemon (bool daemon) { this->daemon = daemon; }
-    inline const std::string & getName (void) const { return this->name; }
-    inline ThreadGroup * getParent (void) const { return this->parent; }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/concurrent/ThreadPool.cpp b/src/realtime/concurrent/ThreadPool.cpp
deleted file mode 100755
index cebb30f..0000000
--- a/src/realtime/concurrent/ThreadPool.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/* 
-   ThreadPool.cpp - ThreadPool Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "ThreadPool.hpp"
-
-namespace concurrent {
-
-  ThreadPool::ThreadPool (int nMaxThreads) {
-    this->running = false;
-
-    for (int ii = 0; ii < nMaxThreads; ii++) {
-      std::string name = std::string("Thread ");
-      name.push_back (ii);
-      Thread * t = new Thread (new Task (this), name);
-      this->threads.push_back (t);
-    }
-  }
-
-  ThreadPool::~ThreadPool (void) {
-    if (this->running == true)
-      this->stop(true);
-
-    std::list<Thread *>::iterator it = this->threads.begin();
-    while (it != this->threads.end()) {
-      Thread * t = (*it++);
-      delete t;
-    }
-
-    while (this->runQueue.size() > 0) {
-      IRunnable * r = this->runQueue.pop();
-      delete r;
-    }
-  }
-
-  void 
-  ThreadPool::start (void) {
-    this->running = true;
-    
-  std::list<Thread *>::iterator it = this->threads.begin();
-  while (it != this->threads.end())
-    {
-      (*it)->start();
-      it++;
-    }
-  }
-
-  void 
-  ThreadPool::stop (bool join = false) {
-    this->running = false;
-
-    /* Waiting to join all of the threads will mean that the thread that the
-       pool is calling the stop() method from will block until all of the 
-       threads inside of the pool have stopped.
-
-       There is a PROBLEM here. If you call this, for some reason, from inside
-       of one of the Task threads then you are going to hit a deadlock. Never
-       pass the join parameter if this is being called from inside the Tasks.*/
-    if (join == true) {
-      std::list<Thread *>::iterator it = this->threads.begin();
-      while (it != this->threads.end()) {
-	(*it)->join ();
-	it++;
-      }
-    }
-  }
-
-  void 
-  ThreadPool::execute (IRunnable * runner) {
-    this->runQueue.push (runner);
-  }
-
-} // end of namespace
-
diff --git a/src/realtime/concurrent/ThreadPool.hpp b/src/realtime/concurrent/ThreadPool.hpp
deleted file mode 100755
index a09dd58..0000000
--- a/src/realtime/concurrent/ThreadPool.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/* 
-   ThreadPool.hpp - ThreadPool Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_THREAD_THREADPOOL
-#define HPP_THREAD_THREADPOOL
-
-#include "Mutex.hpp"
-#include "Thread.hpp"
-#include "Queue.hpp"
-#include <queue>
-#include <list>
-
-namespace concurrent {
-
-  /* @description: This is a ThreadPool object that will keep N concurrent
-     threads running. Runnable objects can be attached to this object and they
-     will be executed immediately as a thread becomes available to run them. 
-     @author: John `jb Bellone (jvb4@njit.edu)
-     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
-  class ThreadPool {
-    /* @description: This object is an individual task that will be spawned at
-       the start of the ThreadPool. Each thread periodically checks the pool
-       object for any available Runnable objects from the queue. If there are
-       such objects it will take them off, run them and delete them. */
-    class Task : public IRunnable {
-    private:
-      ThreadPool * pool;
-    public:
-      Task (ThreadPool * pool) {
-	this->pool = pool;
-      }
-      
-      void * run (void *) {
-	this->running = true;
-
-	while (this->running == true)
-	  {
-	    if (pool->isRunning() == false)
-	      break;
-
-	    if (pool->getQueueSize() > 0)
-	      {
-		IRunnable * runner = pool->removeFromQueue();
-		runner->run(NULL);
-		delete runner;
-	      }
-	    ::sleep (1);
-	  }
-	return NULL;
-      }
-    };
-  private:
-    concurrent::Queue<IRunnable *> runQueue;
-    std::list<Thread *> threads;
-    bool running;
-  public:  
-    ThreadPool (int);
-    ~ThreadPool (void);
-
-    /* Thread un-Safe Methods */
-    void start (void);
-    void stop (bool);
-
-    /* Thread-Safe Methods */
-    void execute (IRunnable *);
-    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
-    inline bool isRunning (void) const { return this->running; }
-    inline int getMaxThreads (void) const { return this->threads.size(); }
-    inline size_t getQueueSize (void) { return this->runQueue.size(); }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/network/Socket.hpp b/src/realtime/network/Socket.hpp
deleted file mode 100755
index 3662409..0000000
--- a/src/realtime/network/Socket.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/* 
-   Socket.hpp - Socket Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_NETWORK_SOCKET
-#define HPP_NETWORK_SOCKET
-
-#include <cstring>
-
-namespace network {
-
-  class ISocket {
-  protected:
-    int sockfd;
-  public:
-    virtual ~ISocket (void) { }
-
-    virtual void close (void) = 0;
-    virtual int send (const char * bytes, size_t length) = 0;
-    virtual int receive (char * btyes, size_t size) = 0;
-  };
-
-} // end of namesapce
-
-#endif
diff --git a/src/realtime/network/Tcp.cpp b/src/realtime/network/Tcp.cpp
deleted file mode 100755
index 9a502d2..0000000
--- a/src/realtime/network/Tcp.cpp
+++ /dev/null
@@ -1,155 +0,0 @@
-/* 
-   Tcp.hpp - Tcp Implementation Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Tcp.hpp"
-#include <iostream>
-
-namespace network {
-
-  TcpSocket::TcpSocket (void) {
-    this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
-  }
-
-  TcpSocket::~TcpSocket (void) {
-    this->close();
-  }
-
-  void
-  TcpSocket::close (void) {
-    if (this->sockfd > 0)
-      ::close (this->sockfd);
-  }
-	
-  int
-  TcpSocket::send (const char * bytes, size_t length) {
-    return ::write (this->sockfd, bytes, length);
-  }
-
-  int
-  TcpSocket::receive (char * bytes, size_t size) {
-    return ::read (this->sockfd, bytes, size);
-  }
-
-  TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
-    this->port = port;
-
-    memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-    this->sockaddr.sin_family = AF_INET;
-    this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-    this->sockaddr.sin_port = htons (this->port);
-  }
-
-  TcpServerSocket::~TcpServerSocket (void) {
-    this->close();
-  }
-
-  bool
-  TcpServerSocket::start (int backlog = 5) {
-    int opt = 1;
-
-    // This is to prevent conflicts with major services' ports.
-    if (this->port < 1024)
-      return false;
-
-    if (::setsockopt (this->sockfd, 
-		      SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
-      return false;
-
-    if (::bind (this->sockfd,
-		(struct sockaddr *)&(this->sockaddr),
-		sizeof (this->sockaddr)) < 0)
-      return false;
-
-    if (::listen (this->sockfd, backlog) < 0)
-      return false;
-
-    return true;
-  }
-
-  void
-  TcpServerSocket::close (void) {
-    TcpSocket::close();
-  }
-
-  TcpServerSocket::Acceptor *
-  TcpServerSocket::newAcceptor (void) {
-    return new TcpServerSocket::Acceptor (this, this->sockfd);
-  }
-
-  TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
-    this->socket = server;
-    this->sockfd = sockfd;
-  }
-
-  int
-  TcpServerSocket::Acceptor::acceptIncoming (void) {
-    int newfd = -1;
-    static struct sockaddr_in clientaddr;
-    unsigned int x = sizeof (clientaddr);
-
-    if ((newfd = ::accept (this->sockfd, 
-			   (struct sockaddr *)&clientaddr,
-			   &x)) < 0)
-      return -1;
-    return newfd;
-  }
-
-  TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
-    memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-    this->sockaddr.sin_family = AF_INET;
-    this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-  }
-
-  TcpClientSocket::TcpClientSocket (int newfd) {
-    this->sockfd = newfd;
-  }
-				
-  TcpClientSocket::~TcpClientSocket (void) {
-  }
-
-  bool
-  TcpClientSocket::connect (const char * host, int port) {
-    if (!host || (*host == '\0'))
-      return false;
-
-    if ((this->hp = ::gethostbyname (host)) == NULL)
-      return false;
- 
-    // Copy over the hostname address.
-    memset (&(this->sockaddr),0, sizeof (this->sockaddr));
-    this->sockaddr.sin_family = AF_INET;
-    this->sockaddr.sin_addr.s_addr 
-      = ((struct in_addr *)(this->hp->h_addr))->s_addr;
-    this->sockaddr.sin_port = htons (port);
-
-    if (::connect (this->sockfd,
-		   (struct sockaddr *)&(this->sockaddr),
-		   sizeof (struct sockaddr)) < 0)
-      return false;
-    
-    return true;
-  }
-
-  void
-  TcpClientSocket::close (void) {
-    TcpSocket::close();
-  }
-
-} // end of namespace
diff --git a/src/realtime/network/Tcp.hpp b/src/realtime/network/Tcp.hpp
deleted file mode 100755
index 552f93f..0000000
--- a/src/realtime/network/Tcp.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/* 
-   Tcp.hpp - Tcp Implementation Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_NETWORK_TCP
-#define HPP_NETWORK_TCP
-
-#include "Socket.hpp"
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <netdb.h>
-
-namespace network {
-
-  class TcpSocket : public ISocket {
-  protected:
-    struct sockaddr_in sockaddr;
-  public:
-    TcpSocket (void);
-    virtual ~TcpSocket (void);
-
-    void close (void);
-    int send (const char * bytes, size_t length);
-    int receive (char * bytes, size_t size);
-  };
-
-  class TcpServerSocket : public TcpSocket {
-  private:
-    int port;
-  public:
-    class Acceptor {
-    private:
-      TcpServerSocket * socket;
-      int sockfd;
-    public:
-      Acceptor (TcpServerSocket * server, int sockfd);
-
-      int acceptIncoming (void);
-    };
-
-    TcpServerSocket (int port);
-    virtual ~TcpServerSocket (void);
-    
-    bool start (int backlog);
-    void close (void);
-    Acceptor * newAcceptor (void);
-  };
-  
-  class TcpClientSocket : public TcpSocket {
-  private:
-    struct hostent * hp;
-  public:
-    TcpClientSocket (void);
-    TcpClientSocket (int newfd);
-    virtual ~TcpClientSocket (void);
-
-    bool connect (const char * host, int port);
-    void close (void);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
index 0ca1514..e1e49a2 100755
--- a/src/realtime/plugin_main.cpp
+++ b/src/realtime/plugin_main.cpp
@@ -21,7 +21,7 @@
 #include <iostream>
 #include <glib/gthread.h>
 #include <workbook/workbook.h>
-#include "concurrent/ThreadArgs.hpp"
+#include <concurrent/ThreadArgs.hpp>
 #include "../application.h"
 #include "../plugin.h"
 
diff --git a/src/realtime/proactor/Dispatcher.cpp b/src/realtime/proactor/Dispatcher.cpp
deleted file mode 100644
index 18cc953..0000000
--- a/src/realtime/proactor/Dispatcher.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/* 
-   Dispatcher.hpp - Dispatcher Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Dispatcher.hpp"
-#include "Worker.hpp"
-#include <algorithm>
-
-namespace proactor {
-
-  Dispatcher::~Dispatcher (void) {
-      
-  }
-   
-  bool
-  Dispatcher::addWorker (Worker * w) {
-    WorkerListType::iterator it = std::find (this->workers.begin(),
-					     this->workers.end(),
-					     w);
-    if (it == this->workers.end())
-      {
-	this->workers.push_back (w);
-	return w->start();
-      }
-    return false;
-  }
-  
-  bool
-  Dispatcher::removeWorker (Worker * w) {
-    WorkerListType::iterator it = std::find (this->workers.begin(),
-					     this->workers.end(),
-					     w);
-
-    if (it == this->workers.end())
-      return false;
-  
-    this->workers.erase (it);
-    return true;
-  }
-
-} // end of namesapce
diff --git a/src/realtime/proactor/Dispatcher.hpp b/src/realtime/proactor/Dispatcher.hpp
deleted file mode 100755
index 259fbbd..0000000
--- a/src/realtime/proactor/Dispatcher.hpp
+++ /dev/null
@@ -1,45 +0,0 @@
-/* 
-   Dispatcher.hpp - Dispatcher Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_DISPATCHER
-#define HPP_PROACTOR_DISPATCHER
-
-#include "../concurrent/Thread.hpp"
-#include "../concurrent/List.hpp"
-
-namespace proactor {
-
-  class Worker;
-
-  class Dispatcher : public concurrent::Thread {
-  protected:
-    typedef concurrent::List<Worker *> WorkerListType;
-
-    WorkerListType workers;
-  public:
-    virtual ~Dispatcher (void);
-
-    bool addWorker (Worker * w);
-    bool removeWorker (Worker * w);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/proactor/Event.cpp b/src/realtime/proactor/Event.cpp
deleted file mode 100755
index 6c8f45f..0000000
--- a/src/realtime/proactor/Event.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-/* 
-   Event.cpp - Event Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Event.hpp"
-
-namespace proactor {
-
-  int Event::numEvents = 0;
-
-  Event::Event (int e, const std::string & buf) {
-    this->id = e;
-    this->buf = buf;
-  }
-
-  int
-  Event::uniqueEventId (void) {
-    return Event::numEvents++;
-  }
-
-  EventDispatcher::~EventDispatcher (void) {
-  }
- 
-} // end of namespace
diff --git a/src/realtime/proactor/Event.hpp b/src/realtime/proactor/Event.hpp
deleted file mode 100755
index 09133bc..0000000
--- a/src/realtime/proactor/Event.hpp
+++ /dev/null
@@ -1,58 +0,0 @@
-/* 
-   Event.hpp - Event Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_EVENT
-#define HPP_PROACTOR_EVENT
-
-#include "Dispatcher.hpp"
-#include <string>
-
-namespace proactor {
-
-  class Event {
-  private:
-    static int numEvents;
-  public:
-    int id;
-    std::string buf;
-
-    Event (int id, const std::string & buf);
-
-    static int uniqueEventId (void);
-  };
-
-  class EventDispatcher : public Dispatcher {
-  private:
-    int eventId;
-  public:
-    virtual ~EventDispatcher (void);
-
-    inline void setEventId (int e) { 
-      this->eventId = e;
-    }
-
-    inline int getEventId (void) { 
-      return this->eventId;
-    }
-  };
-
-}
-
-#endif
diff --git a/src/realtime/proactor/InputDispatcher.cpp b/src/realtime/proactor/InputDispatcher.cpp
deleted file mode 100644
index faf8e51..0000000
--- a/src/realtime/proactor/InputDispatcher.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-/* 
-   InputDispatcher.cpp - Input Dispatcher Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "InputDispatcher.hpp"
-#include "Proactor.hpp"
-
-namespace proactor {
-
-  InputDispatcher::~InputDispatcher (void) {
-      this->inputQueue.lock();
-      while (this->inputQueue.size() > 0)
-	this->inputQueue.pop();
-      this->inputQueue.unlock();
-  }
-
-  void *
-  InputDispatcher::stop (void) {
-    WorkerListType::iterator it = this->workers.begin();
-    while (it != this->workers.end()) {
-      (*it)->stop();
-      it = this->workers.erase(it);
-    }
-    return Thread::stop();
-  }
-
-  void *
-  InputDispatcher::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
-      // Dispatch all of the input items on the queue.
-      this->inputQueue.lock();
-
-      while (this->inputQueue.size() > 0) {
-
-	if (this->running == false)
-	  break;
-
-	// For right now all we're doing is pushing up the chain.
-	this->pro->onReadComplete ( this->inputQueue.pop() );
-      }
-
-      this->inputQueue.unlock();
-
-      Thread::sleep(100);
-    }
-  
-    return NULL; 
-  }
-
-} // end of namespace
diff --git a/src/realtime/proactor/InputDispatcher.hpp b/src/realtime/proactor/InputDispatcher.hpp
deleted file mode 100644
index cf54f36..0000000
--- a/src/realtime/proactor/InputDispatcher.hpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/* 
-   InputDispatcher.hpp - Input Dispatcher Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_INPUTDISPATCHER
-#define HPP_PROACTOR_INPUTDISPATCHER
-
-#include "../concurrent/Queue.hpp"
-#include "Event.hpp"
-
-namespace proactor {
-
-  class Proactor;
-
-  class InputDispatcher : public EventDispatcher {
-  protected:
-    typedef concurrent::Queue<Event> InputQueueType;
-
-    Proactor * pro;
-    InputQueueType inputQueue;
-  public:
-    virtual ~InputDispatcher (void);
-
-    void * stop (void);
-    
-    inline void onReadComplete (const char * buf) {
-      this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
-    }
-
-    inline void onReadComplete (std::string buf) {
-      this->inputQueue.push ( Event (getEventId(), buf) );
-    }
-
-    void * run (void * null);
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
deleted file mode 100755
index dff5762..0000000
--- a/src/realtime/proactor/Proactor.cpp
+++ /dev/null
@@ -1,161 +0,0 @@
-/* 
-   Proactor.cpp - Proactor Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Proactor.hpp"
-#include <iostream>
-#include <algorithm>
-
-namespace proactor {
-
-  Proactor::Proactor (void) {
-  }
-
-  Proactor::~Proactor (void) {
-    // Remove all of the lists of event handlers.
-    {
-      EventMapType::iterator it = this->eventsToHandlers.begin();
-      while (it != this->eventsToHandlers.end()) {
-	  WorkerListType * q = (it->second);
-	  delete q;
-	  it++;
-	}
-    }
- 
-    // Handle the dispatchers that have not been manually removed.
-    {
-      DispatcherList::iterator it = this->dispatchers.begin();
-      while (it != this->dispatchers.end())
-	{
-	  Dispatcher * d = (*it);
-	  delete d;
-	  it++;
-	}
-    }
-  
-  }
-
-  bool
-  Proactor::addWorker (int e, Worker * job) {
-    this->eventsToHandlers.lock();
-    {
-      EventMapType::iterator it = this->eventsToHandlers.find (e);
-  
-      if (it == this->eventsToHandlers.end())
-	this->eventsToHandlers[e] = new WorkerListType;  
-      this->eventsToHandlers[e]->push_back (job);
-    }
-    this->eventsToHandlers.unlock();
-
-    return job->start();
-  }
-
-  void
-  Proactor::onReadComplete (Event e) {
-    this->events.push (e);
-  }
-
-  void 
-  Proactor::onReadComplete (int e, const char * buf) {
-    this->events.push ( Event (e, std::string (buf)) );   
-  }
-
-  bool
-  Proactor::removeWorker (int e, Worker * job) {
-    bool result = false;
-
-    this->eventsToHandlers.lock();
-    {
-      WorkerListType::iterator it = 
-	std::find (this->eventsToHandlers[e]->begin(),
-		   this->eventsToHandlers[e]->end(),
-		   job);
-    
-      if (it != this->eventsToHandlers[e]->end())
-	{
-	  this->eventsToHandlers[e]->erase (it);
-	  result = true;
-	}
-    }
-    this->eventsToHandlers.unlock();
-   
-    return result;
-  }
-
-  void
-  Proactor::addDispatcher (Dispatcher * d) {
-    this->dispatchers.push_back (d);
-  }
-
-  bool
-  Proactor::removeDispatcher (Dispatcher * d) {
-    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
-					     this->dispatchers.end(),
-					     d);
-
-    if (it == this->dispatchers.end())
-      return false;
-  
-    this->dispatchers.erase (it);
-    return true;
-  }
-
-  void *
-  Proactor::run (void * null) {
-    this->running = true;
-  
-    WorkerListType::iterator it;
-
-    while (this->running == true) {
-	this->events.lock();
-
-	while (this->events.size() > 0) {
-
-	  if (this->running == false)
-	    break;
-
-	    Event e = this->events.pop();
-
-	    // We are throwing events with no handlers to catch them.
-	    if (this->eventsToHandlers.find (e.id) == 
-		this->eventsToHandlers.end())
-	      continue;
- 
-	    it = this->eventsToHandlers[e.id]->begin();
-	  
-	    while (it != this->eventsToHandlers[e.id]->end()) {
-
-	      if (this->running == false)
-		break;
-
-		Worker * j = (*it);
-	      
-		j->pushInputQueue (e.buf);
-		      
-		it++;
-	      }
-	  }
-	this->events.unlock();
-      
-	Thread::sleep(100);
-      }
-    return NULL;
-  }
-
-} // end of namespace
diff --git a/src/realtime/proactor/Proactor.hpp b/src/realtime/proactor/Proactor.hpp
deleted file mode 100755
index 3a33688..0000000
--- a/src/realtime/proactor/Proactor.hpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/* 
-   Proactor.hpp - Proactor Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_PROACTOR
-#define HPP_PROACTOR_PROACTOR
-
-#include "../concurrent/Thread.hpp"
-#include "../concurrent/Map.hpp"
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/List.hpp"
-#include "Worker.hpp"
-#include "Event.hpp"
-#include "Dispatcher.hpp"
-#include "InputDispatcher.hpp"
-
-namespace proactor {
-
-  class Proactor : public Dispatcher {
-  private:
-    typedef concurrent::List<Dispatcher *> DispatcherList;
-    typedef concurrent::Map<int, WorkerListType *> EventMapType;
-    typedef concurrent::Queue<Event> EventQueueType;
-
-    EventMapType eventsToHandlers;
-    DispatcherList dispatchers;
-    EventQueueType events;
-  public:
-    Proactor (void);
-    virtual ~Proactor (void);
-
-    bool addWorker (int e, Worker * w);
-    bool removeWorker (int e, Worker * w);
-    void addDispatcher (Dispatcher * d);
-    bool removeDispatcher (Dispatcher * d);
-    
-    void * run (void * null);
- 
-    void onReadComplete (Event e);
-    void onReadComplete (int e, const char * buf);
-
-    inline const std::string & peekInputQueue (void) {
-      return (this->events.front()).buf;
-    }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/proactor/Worker.cpp b/src/realtime/proactor/Worker.cpp
deleted file mode 100644
index 19903da..0000000
--- a/src/realtime/proactor/Worker.cpp
+++ /dev/null
@@ -1,28 +0,0 @@
-/* 
-   Worker.cpp - Worker Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Worker.hpp"
-
-namespace proactor {
-
-  Worker::~Worker (void) {
-  }
-
-} // end of namesapce
diff --git a/src/realtime/proactor/Worker.hpp b/src/realtime/proactor/Worker.hpp
deleted file mode 100644
index 5810e5e..0000000
--- a/src/realtime/proactor/Worker.hpp
+++ /dev/null
@@ -1,48 +0,0 @@
-/* 
-   Worker.hpp - Worker Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_WORKER
-#define HPP_PROACTOR_WORKER
-
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/Thread.hpp"
-#include <string>
-
-namespace proactor {
-
-  class InputDispatcher;
-
-  class Worker : public concurrent::Thread {
-  protected:
-    typedef concurrent::Queue<std::string> InputQueueType;
-
-    InputDispatcher * dispatcher;
-    InputQueueType inputQueue;
-  public:
-    virtual ~Worker (void);
-
-    inline void pushInputQueue (std::string buf) {
-      this->inputQueue.push (buf);
-    }
-  };
-
-} // end of namespace
-
-#endif
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index 4739b97..d2cdf69 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -28,10 +28,10 @@
 #include <iostream>
 #include <sstream>
 #include <string>
-#include "concurrent/Thread.hpp"
-#include "concurrent/ThreadArgs.hpp"
-#include "proactor/Proactor.hpp"
-#include "proactor/Event.hpp"
+#include <concurrent/Thread.hpp>
+#include <concurrent/ThreadArgs.hpp>
+#include <proactor/Proactor.hpp>
+#include <proactor/Event.hpp>
 #include "Network.hpp"
 #include "CsvParser.hpp"
 #include "PacketParser.hpp"
diff --git a/workbook/sheet.c b/workbook/sheet.c
old mode 100644
new mode 100755
diff --git a/workbook/workbook.c b/workbook/workbook.c
old mode 100644
new mode 100755

commit 8cc197b6acba3fabb9a1c171d05f06b38f184a79
Author: johnb <johnb@localhost.localdomain>
Date:   Fri May 1 10:33:34 2009 -0400

    Added largefile

diff --git a/src/largefile/.#thread_main.cpp b/src/largefile/.#thread_main.cpp
new file mode 120000
index 0000000..7109c53
--- /dev/null
+++ b/src/largefile/.#thread_main.cpp
@@ -0,0 +1 @@
+johnb@localhost.localdomain.6954:1230750316
\ No newline at end of file
diff --git a/src/largefile/Makefile b/src/largefile/Makefile
new file mode 100755
index 0000000..61d59d6
--- /dev/null
+++ b/src/largefile/Makefile
@@ -0,0 +1,24 @@
+include ../../Makefile.base
+
+SRCS=$(wildcard *.cpp) 
+OBJS=$(patsubst %.cpp,${OBJDIR}/largefile/%.o,${SRCS})
+
+all: 	largefile
+
+largefile: ${OBJS}
+	${CX} -shared -Wl -o ${PROJDIR}/bin/largefile.so ${OBJS} ${LIBS} \
+	-lgthread-2.0 -lpthread -lcsv
+
+clean:		
+	${MD} ${OBJDIR}/largefile
+	${RM} ${OBJS} ${PROJDIR}/bin/largefile.so
+
+install: all
+	${MD} ${INSEXTDIR}
+	${CP} ${PROJDIR}/bin/largefile.so ${INSEXTDIR}/largefile.so
+
+${OBJDIR}/largefile/%.o: %.cpp
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
+
+.cpp.o:
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
diff --git a/src/largefile/thread_main.cpp b/src/largefile/thread_main.cpp
new file mode 100644
index 0000000..9e1016b
--- /dev/null
+++ b/src/largefile/thread_main.cpp
@@ -0,0 +1,23 @@
+/* 
+   thread_main.cpp - Largefile Main Thread Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <workbook/workbook.h>
+#include <config/config.h>
+

commit ab12bfb6700b8608fb22cc060a4a468efe23e390
Author: johnb <johnb@localhost.localdomain>
Date:   Fri May 1 10:30:07 2009 -0400

    Updated branch.

diff --git a/concurrent/List.hpp b/concurrent/List.hpp
new file mode 100755
index 0000000..dd9339c
--- /dev/null
+++ b/concurrent/List.hpp
@@ -0,0 +1,35 @@
+/* 
+   List.hpp - Mutex List Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_LIST
+#define HPP_CONCURRENT_LIST
+
+#include <list>
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  template <typename T>
+  class List : public RecursiveMutex, public std::list<T> {
+  };
+
+} // end of namespace
+
+#endif
diff --git a/concurrent/Lockable.hpp b/concurrent/Lockable.hpp
new file mode 100755
index 0000000..f3226c0
--- /dev/null
+++ b/concurrent/Lockable.hpp
@@ -0,0 +1,33 @@
+/* 
+   Lockable.hpp - Lockable Interface Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_LOCKABLE
+#define HPP_THREAD_LOCKABLE
+
+class ILockable {
+public:
+  virtual ~ILockable (void) { }
+
+  virtual void lock (void) = 0;
+  virtual void unlock (void) = 0;
+  virtual bool trylock (void) = 0;
+};
+
+#endif
diff --git a/concurrent/Map.hpp b/concurrent/Map.hpp
new file mode 100755
index 0000000..ae5d1c3
--- /dev/null
+++ b/concurrent/Map.hpp
@@ -0,0 +1,44 @@
+/* 
+   Map.hpp - Mutex Map Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MAP
+#define HPP_THREAD_MAP
+
+#include <iterator>
+#include <map>
+#include "Mutex.hpp"
+
+namespace concurrent {
+ 
+  /* @description: This object uses the standard std::map and wraps all of
+     the calls that are exposed with a Mutex object. This object uses a
+     single lock and may cause performance issues if several threads are
+     attempting to use it. 
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template<typename K, typename V>
+  class Map : public RecursiveMutex, public std::map<K,V> {
+  private:
+  public:
+    Map (void) : RecursiveMutex() { }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/concurrent/Mutex.cpp b/concurrent/Mutex.cpp
new file mode 100755
index 0000000..d188509
--- /dev/null
+++ b/concurrent/Mutex.cpp
@@ -0,0 +1,91 @@
+/* 
+   Mutex.cpp - Mutex Object(s) Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  IMutex::IMutex (void) {
+    this->mutex = NULL;
+    this->attrib = NULL;
+  }
+
+  IMutex::IMutex (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+  }
+
+  IMutex::~IMutex (void) {
+  }
+
+  IMutex & 
+  IMutex::operator= (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+    return *this;
+  }
+
+  void
+  IMutex::lock (void) {
+    pthread_mutex_lock (this->mutex);
+  }
+
+  void 
+  IMutex::unlock (void) {
+    pthread_mutex_unlock (this->mutex);
+  }
+
+  bool
+  IMutex::trylock (void) {
+    return (pthread_mutex_trylock (this->mutex) == 0) ?
+      true : false;
+  }
+  
+  RecursiveMutex::RecursiveMutex (void) {
+    this->mutex = new pthread_mutex_t;
+    this->attrib = new pthread_mutexattr_t;
+
+    pthread_mutexattr_init (this->attrib);
+    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+    
+    pthread_mutex_init (this->mutex, attrib);
+  }
+
+  RecursiveMutex::~RecursiveMutex (void) {
+    pthread_mutex_destroy (this->mutex);
+    pthread_mutexattr_destroy (this->attrib);
+
+    delete this->mutex;
+    delete this->attrib;
+  }
+
+  Mutex::Mutex (void) {
+    this->mutex = new pthread_mutex_t;
+
+    pthread_mutex_init (this->mutex, NULL);
+  }
+
+  Mutex::~Mutex (void) {
+    pthread_mutex_destroy (this->mutex);
+
+    delete this->mutex;
+  }
+
+} // end of namespace
diff --git a/concurrent/Mutex.hpp b/concurrent/Mutex.hpp
new file mode 100755
index 0000000..4a30cda
--- /dev/null
+++ b/concurrent/Mutex.hpp
@@ -0,0 +1,58 @@
+/* 
+   Mutex.hpp - Mutex Object(s) Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MUTEX
+#define HPP_THREAD_MUTEX
+
+#include <pthread.h>
+#include "Lockable.hpp"
+
+namespace concurrent {
+
+  class IMutex : public ILockable {
+  protected:
+    pthread_mutex_t * mutex;
+    pthread_mutexattr_t * attrib;
+  public:
+    IMutex (void);
+    IMutex (const IMutex & m);
+    virtual ~IMutex (void);
+
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+
+    IMutex & operator= (const IMutex & m);
+  };
+
+  class Mutex : public IMutex {
+  public:
+    Mutex (void);
+    virtual ~Mutex (void);
+  };
+
+  class RecursiveMutex : public IMutex {
+  public:
+    RecursiveMutex (void);
+    virtual ~RecursiveMutex (void);
+  };
+}
+
+#endif
diff --git a/concurrent/Queue.hpp b/concurrent/Queue.hpp
new file mode 100755
index 0000000..abac49b
--- /dev/null
+++ b/concurrent/Queue.hpp
@@ -0,0 +1,99 @@
+/* 
+   Queue.hpp - Mutex Queue Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_QUEUE
+#define HPP_THREAD_QUEUE
+
+#include "Mutex.hpp"
+#include <queue>
+#include <algorithm>
+
+namespace concurrent {
+  
+  /* @description: This object wraps the existing std::queue container with
+     the custom Mutex object from the concurrent namespace. The single lock
+     may be placed in the future with a read/write lock in order to gain a
+     speed advantage.
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template <typename T>
+  class Queue : public RecursiveMutex {
+  private:
+    std::queue<T> the_queue;
+  public:
+    Queue (void) { }
+    virtual ~Queue (void) { }
+
+    inline void clear (void) {
+      this->lock();
+      while (this->the_queue.size() > 0)
+	this->the_queue.pop();
+      this->unlock();
+    }
+
+    inline void copy (std::queue<T> & Q) {
+      this->lock();
+      Q = this->the_queue;
+      this->unlock();
+    }
+
+    inline const T & back (void) {
+      this->lock();
+      T & elem = this->the_queue.back();
+      this->unlock();
+      return elem;
+    }
+
+    inline const T & front (void) {
+      this->lock();
+      T & elem = this->the_queue.front();
+      this->unlock();
+      return elem;
+    }
+
+    inline void push (const T & x) {
+      this->lock();
+      this->the_queue.push (x);
+      this->unlock();
+    }
+
+    inline T pop (void) {
+      this->lock();
+      T elem = this->the_queue.front();
+      this->the_queue.pop();
+      this->unlock();
+      return elem;
+    }
+    
+    inline size_t size (void) {
+      this->lock();
+      size_t size = this->the_queue.size();
+      this->unlock();
+      return size;
+    }
+
+    inline bool empty (void) {
+      this->lock();
+      bool result = this->the_queue.empty();
+      this->unlock();
+      return result;
+    }
+  };
+}
+#endif
diff --git a/concurrent/Runnable.hpp b/concurrent/Runnable.hpp
new file mode 100755
index 0000000..9e9cacc
--- /dev/null
+++ b/concurrent/Runnable.hpp
@@ -0,0 +1,36 @@
+/* 
+   Runnable.hpp - Runnable Interface Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_RUNNABLE
+#define HPP_CONCURRENT_RUNNABLE
+
+class IRunnable {
+protected:
+  volatile bool running;
+public:
+  IRunnable (void) { this->running = false; }
+  virtual ~IRunnable (void) { }
+
+  virtual void * run (void *) = 0;
+  
+  inline bool isRunning (void) const { return this->running; }
+};
+
+#endif
diff --git a/concurrent/Semaphore.cpp b/concurrent/Semaphore.cpp
new file mode 100755
index 0000000..09f0172
--- /dev/null
+++ b/concurrent/Semaphore.cpp
@@ -0,0 +1,44 @@
+/* 
+   Semaphore.cpp - Semaphore Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Semaphore.hpp"
+
+namespace concurrent {
+
+  Semaphore::Semaphore (void) {
+    sem_init (&this->semaphore, 0, 0);
+  }
+
+  Semaphore::~Semaphore (void) {
+    sem_destroy (&this->semaphore);
+  }
+
+  void
+  Semaphore::acquire (void) {
+    sem_wait (&this->semaphore);
+  }
+
+  void
+  Semaphore::release (void) {
+    sem_post (&this->semaphore);
+  }
+
+} // end of namespace
+
diff --git a/concurrent/Semaphore.hpp b/concurrent/Semaphore.hpp
new file mode 100755
index 0000000..e3504cf
--- /dev/null
+++ b/concurrent/Semaphore.hpp
@@ -0,0 +1,41 @@
+/* 
+   Semaphore.hpp - Semaphore Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_SEMAPHORE
+#define HPP_THREAD_SEMAPHORE
+
+#include <semaphore.h>
+
+namespace concurrent {
+
+class Semaphore {
+private:
+  sem_t semaphore;
+public:
+  Semaphore (void);
+  virtual ~Semaphore (void);
+
+  void acquire (void);
+  void release (void);
+};
+
+}
+
+#endif
diff --git a/concurrent/Thread.cpp b/concurrent/Thread.cpp
new file mode 100755
index 0000000..42a93bb
--- /dev/null
+++ b/concurrent/Thread.cpp
@@ -0,0 +1,134 @@
+/* 
+   Thread.cpp - Thread Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Thread.hpp"
+#include "ThreadGroup.hpp"
+#include <iostream>
+#include <ctime>
+
+namespace concurrent {
+
+  static void *
+  thread_run (void * runner) {
+    void * rvalue = ((IRunnable *)runner)->run (NULL);
+    return rvalue;
+  }
+
+  Thread::Thread (ThreadGroup * group,
+		  IRunnable * runner, 
+		  const std::string & name) {
+    this->group = group;
+    this->runner = runner;
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (IRunnable * runner,
+		  const std::string & name) 
+    : group(NULL) {
+    this->runner = runner;
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (const std::string & name) 
+    : group(NULL), runner(NULL) {
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (void) : group(NULL), runner(NULL) {
+    this->running = false;
+  }
+
+  Thread::~Thread (void) {
+    if (this->running == true) {
+      this->running = false;
+      this->join();
+    }
+  }
+
+  void 
+  Thread::interrupt (void) {
+    this->running = false;
+    pthread_cancel (this->thread);
+    pthread_detach (this->thread);
+  }
+
+  void 
+  Thread::yield (void) {
+    pthread_yield();
+  }
+
+  void * 
+  Thread::stop (void) {
+    this->running = false;
+    return this->join();
+  }
+
+  int 
+  Thread::sleep (unsigned long ms) {
+    struct timespec req = {0};
+    time_t sec = (int)(ms/1000);
+    ms = ms - (sec*1000);
+    req.tv_sec = sec;
+    req.tv_nsec = ms*1000000L;
+    while (nanosleep (&req, &req) == -1)
+      continue;
+    return 1;
+  }
+
+  bool 
+  Thread::start (void) {
+    if (this->running == true)
+      return false;
+
+    if (this->runner != NULL) {
+      if (pthread_create (&this->thread,
+			  NULL,
+			  thread_run,
+			  this->runner))
+	  return false;
+    }
+    else {
+      if (pthread_create (&this->thread,
+			  NULL,
+			  thread_run,
+			  this))
+	return false;
+    }
+
+    this->running = true;
+    return true;
+  }
+
+  void *
+  Thread::join (void) {
+    void * rvalue = NULL;
+    pthread_join (this->thread, &rvalue);
+    return rvalue;
+  }
+
+  void *
+  Thread::run (void *null) {
+    pthread_exit (null);
+  }
+
+} // end of namespace
diff --git a/concurrent/Thread.hpp b/concurrent/Thread.hpp
new file mode 100755
index 0000000..7b284df
--- /dev/null
+++ b/concurrent/Thread.hpp
@@ -0,0 +1,74 @@
+/* 
+   Thread.hpp - Thread Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREAD
+#define HPP_CONCURRENT_THREAD
+
+#include <shared.h>
+#include <string>
+#include <pthread.h>
+#include <map>
+#include "Runnable.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup;
+
+  class Thread : public IRunnable {
+  private:
+    friend class ThreadGroup;
+
+    ThreadGroup * group;
+    std::string name;
+    IRunnable * runner;
+    pthread_t thread;
+    bool joinable;
+    int priority;
+  public:
+    Thread (ThreadGroup * group, 
+	    IRunnable * runner, 
+	    const std::string & name);
+    Thread (IRunnable * runner,
+	    const std::string & name);
+    Thread (const std::string & name);
+    Thread (void);
+    virtual ~Thread (void);
+
+    bool start (void);
+    void * stop (void);
+    void * join (void);
+    void interrupt (void);
+    void yield (void);
+  
+    virtual void * run (void *);
+
+    inline const std::string & getName (void) const { return this->name; }
+    inline int getPriority (void) const { return this->priority; }
+    inline void setPriority (int priority) { this->priority = priority; }
+    inline const ThreadGroup * getThreadGroup (void) const { 
+      return this->group; 
+    }
+
+    static int sleep (unsigned long ms);
+  };  
+
+}
+
+#endif
diff --git a/concurrent/ThreadArgs.hpp b/concurrent/ThreadArgs.hpp
new file mode 100755
index 0000000..f44742c
--- /dev/null
+++ b/concurrent/ThreadArgs.hpp
@@ -0,0 +1,8 @@
+#ifndef H_THREAD_THREADARGS
+#define H_THREAD_THREADARGS
+
+#include <vector>
+
+typedef std::vector<void *> ThreadArgs;
+
+#endif
diff --git a/concurrent/ThreadGroup.cpp b/concurrent/ThreadGroup.cpp
new file mode 100755
index 0000000..c3eafb4
--- /dev/null
+++ b/concurrent/ThreadGroup.cpp
@@ -0,0 +1,107 @@
+/* 
+   ThreadGroup.cpp - ThreadGroup Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadGroup.hpp"
+#include <algorithm>
+
+namespace concurrent {
+
+  ThreadGroup::ThreadGroup (void) 
+    : parent(NULL), daemon(false) {
+  }
+
+  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
+    : daemon(false) {
+    this->parent = parent;
+    this->name = name;
+  }
+
+  ThreadGroup::ThreadGroup (const std::string & name) 
+    : parent(NULL), daemon(false) {
+    this->name = name;
+  }
+
+  ThreadGroup::~ThreadGroup (void) {
+    if (this->daemon == true) {
+      this->stop();
+    }
+  }
+
+  bool 
+  ThreadGroup::parentOf (ThreadGroup * parent) {
+    if ((this->parent == NULL) || (parent == NULL))
+      return false;
+    // Needs to be better than this. 
+    return (this->parent == parent) ? true : false;
+  } 
+    
+  bool
+  ThreadGroup::addThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+    if (it == this->threads.end()) {
+      thread->group = this;
+      this->threads.push_back (thread);
+      return true;
+    }
+    return false;
+  }
+
+  bool 
+  ThreadGroup::removeThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+
+    if (it == this->threads.end())
+      return false;
+    this->threads.erase(it);
+    return true;
+  }
+
+  void
+  ThreadGroup::interrupt (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->interrupt();
+    }
+  }
+
+  bool
+  ThreadGroup::start (void) {
+    bool rvalue = false;
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      rvalue = (*it++)->start();
+    }
+
+    return rvalue;
+  }
+
+  void 
+  ThreadGroup::stop (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->stop();
+    }
+  }
+} // end of namesapce
diff --git a/concurrent/ThreadGroup.hpp b/concurrent/ThreadGroup.hpp
new file mode 100755
index 0000000..c0c5e41
--- /dev/null
+++ b/concurrent/ThreadGroup.hpp
@@ -0,0 +1,59 @@
+/* 
+   ThreadGroup.hpp - ThreadGroup Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREADGROUP
+#define HPP_CONCURRENT_THREADGROUP
+
+#include <string>
+#include "List.hpp"
+#include "Thread.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup {
+  private:
+    typedef concurrent::List<Thread *> ThreadList;
+    
+    ThreadGroup * parent;
+    std::string name;
+    ThreadList threads;
+    bool daemon; 
+  public:
+    ThreadGroup (void);
+    ThreadGroup (ThreadGroup * parent, const std::string & name);
+    ThreadGroup (const std::string & name);
+    virtual ~ThreadGroup (void);
+
+    bool parentOf (ThreadGroup * parent);
+    bool addThread (Thread * thread);
+    bool removeThread (Thread * thread);
+    void interrupt (void);
+    bool start (void);
+    void stop (void);
+    
+    inline bool isDaemon (void) const { return this->daemon; }
+    inline void setDaemon (bool daemon) { this->daemon = daemon; }
+    inline const std::string & getName (void) const { return this->name; }
+    inline ThreadGroup * getParent (void) const { return this->parent; }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/concurrent/ThreadPool.cpp b/concurrent/ThreadPool.cpp
new file mode 100755
index 0000000..cebb30f
--- /dev/null
+++ b/concurrent/ThreadPool.cpp
@@ -0,0 +1,90 @@
+/* 
+   ThreadPool.cpp - ThreadPool Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadPool.hpp"
+
+namespace concurrent {
+
+  ThreadPool::ThreadPool (int nMaxThreads) {
+    this->running = false;
+
+    for (int ii = 0; ii < nMaxThreads; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::~ThreadPool (void) {
+    if (this->running == true)
+      this->stop(true);
+
+    std::list<Thread *>::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      Thread * t = (*it++);
+      delete t;
+    }
+
+    while (this->runQueue.size() > 0) {
+      IRunnable * r = this->runQueue.pop();
+      delete r;
+    }
+  }
+
+  void 
+  ThreadPool::start (void) {
+    this->running = true;
+    
+  std::list<Thread *>::iterator it = this->threads.begin();
+  while (it != this->threads.end())
+    {
+      (*it)->start();
+      it++;
+    }
+  }
+
+  void 
+  ThreadPool::stop (bool join = false) {
+    this->running = false;
+
+    /* Waiting to join all of the threads will mean that the thread that the
+       pool is calling the stop() method from will block until all of the 
+       threads inside of the pool have stopped.
+
+       There is a PROBLEM here. If you call this, for some reason, from inside
+       of one of the Task threads then you are going to hit a deadlock. Never
+       pass the join parameter if this is being called from inside the Tasks.*/
+    if (join == true) {
+      std::list<Thread *>::iterator it = this->threads.begin();
+      while (it != this->threads.end()) {
+	(*it)->join ();
+	it++;
+      }
+    }
+  }
+
+  void 
+  ThreadPool::execute (IRunnable * runner) {
+    this->runQueue.push (runner);
+  }
+
+} // end of namespace
+
diff --git a/concurrent/ThreadPool.hpp b/concurrent/ThreadPool.hpp
new file mode 100755
index 0000000..a09dd58
--- /dev/null
+++ b/concurrent/ThreadPool.hpp
@@ -0,0 +1,91 @@
+/* 
+   ThreadPool.hpp - ThreadPool Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_THREADPOOL
+#define HPP_THREAD_THREADPOOL
+
+#include "Mutex.hpp"
+#include "Thread.hpp"
+#include "Queue.hpp"
+#include <queue>
+#include <list>
+
+namespace concurrent {
+
+  /* @description: This is a ThreadPool object that will keep N concurrent
+     threads running. Runnable objects can be attached to this object and they
+     will be executed immediately as a thread becomes available to run them. 
+     @author: John `jb Bellone (jvb4@njit.edu)
+     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
+  class ThreadPool {
+    /* @description: This object is an individual task that will be spawned at
+       the start of the ThreadPool. Each thread periodically checks the pool
+       object for any available Runnable objects from the queue. If there are
+       such objects it will take them off, run them and delete them. */
+    class Task : public IRunnable {
+    private:
+      ThreadPool * pool;
+    public:
+      Task (ThreadPool * pool) {
+	this->pool = pool;
+      }
+      
+      void * run (void *) {
+	this->running = true;
+
+	while (this->running == true)
+	  {
+	    if (pool->isRunning() == false)
+	      break;
+
+	    if (pool->getQueueSize() > 0)
+	      {
+		IRunnable * runner = pool->removeFromQueue();
+		runner->run(NULL);
+		delete runner;
+	      }
+	    ::sleep (1);
+	  }
+	return NULL;
+      }
+    };
+  private:
+    concurrent::Queue<IRunnable *> runQueue;
+    std::list<Thread *> threads;
+    bool running;
+  public:  
+    ThreadPool (int);
+    ~ThreadPool (void);
+
+    /* Thread un-Safe Methods */
+    void start (void);
+    void stop (bool);
+
+    /* Thread-Safe Methods */
+    void execute (IRunnable *);
+    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
+    inline bool isRunning (void) const { return this->running; }
+    inline int getMaxThreads (void) const { return this->threads.size(); }
+    inline size_t getQueueSize (void) { return this->runQueue.size(); }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/Makefile b/shared/Makefile
new file mode 100755
index 0000000..13759d7
--- /dev/null
+++ b/shared/Makefile
@@ -0,0 +1,26 @@
+include ../Makefile.base
+
+SRCS=$(wildcard *.cpp) $(wildcard concurrent/*.cpp) \
+$(wildcard network/*.cpp) $(wildcard proactor/*.cpp)
+OBJS=$(patsubst %.cpp,${OBJDIR}/libshared/%.o,${SRCS})
+
+all: 	shared
+
+shared: ${OBJS}
+	${CX} -shared -Wl -o ${PROJDIR}/lib/libshared.so ${OBJS} ${LIBS} \
+	-lpthread
+	${CP} ${PROJDIR}/lib/libshared.so ${PROJDIR}/lib/libshared.so.1
+
+clean:		
+	${MD} ${OBJDIR}/libshared/concurrent ${OBJDIR}/libshared/network \
+	${OBJDIR}/libshared/proactor
+	${RM} ${OBJS} ${PROJDIR}/lib/libshared.so ${PROJDIR}/lib/libshared.so.1
+
+install: all
+	${MD} ${INSEXTDIR}
+
+${OBJDIR}/libshared/%.o: %.cpp
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
+
+.cpp.o:
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<
\ No newline at end of file
diff --git a/shared/concurrent/List.hpp b/shared/concurrent/List.hpp
new file mode 100755
index 0000000..dd9339c
--- /dev/null
+++ b/shared/concurrent/List.hpp
@@ -0,0 +1,35 @@
+/* 
+   List.hpp - Mutex List Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_LIST
+#define HPP_CONCURRENT_LIST
+
+#include <list>
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  template <typename T>
+  class List : public RecursiveMutex, public std::list<T> {
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/concurrent/Lockable.hpp b/shared/concurrent/Lockable.hpp
new file mode 100755
index 0000000..f3226c0
--- /dev/null
+++ b/shared/concurrent/Lockable.hpp
@@ -0,0 +1,33 @@
+/* 
+   Lockable.hpp - Lockable Interface Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_LOCKABLE
+#define HPP_THREAD_LOCKABLE
+
+class ILockable {
+public:
+  virtual ~ILockable (void) { }
+
+  virtual void lock (void) = 0;
+  virtual void unlock (void) = 0;
+  virtual bool trylock (void) = 0;
+};
+
+#endif
diff --git a/shared/concurrent/Map.hpp b/shared/concurrent/Map.hpp
new file mode 100755
index 0000000..ae5d1c3
--- /dev/null
+++ b/shared/concurrent/Map.hpp
@@ -0,0 +1,44 @@
+/* 
+   Map.hpp - Mutex Map Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MAP
+#define HPP_THREAD_MAP
+
+#include <iterator>
+#include <map>
+#include "Mutex.hpp"
+
+namespace concurrent {
+ 
+  /* @description: This object uses the standard std::map and wraps all of
+     the calls that are exposed with a Mutex object. This object uses a
+     single lock and may cause performance issues if several threads are
+     attempting to use it. 
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template<typename K, typename V>
+  class Map : public RecursiveMutex, public std::map<K,V> {
+  private:
+  public:
+    Map (void) : RecursiveMutex() { }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/concurrent/Mutex.cpp b/shared/concurrent/Mutex.cpp
new file mode 100755
index 0000000..d188509
--- /dev/null
+++ b/shared/concurrent/Mutex.cpp
@@ -0,0 +1,91 @@
+/* 
+   Mutex.cpp - Mutex Object(s) Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  IMutex::IMutex (void) {
+    this->mutex = NULL;
+    this->attrib = NULL;
+  }
+
+  IMutex::IMutex (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+  }
+
+  IMutex::~IMutex (void) {
+  }
+
+  IMutex & 
+  IMutex::operator= (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+    return *this;
+  }
+
+  void
+  IMutex::lock (void) {
+    pthread_mutex_lock (this->mutex);
+  }
+
+  void 
+  IMutex::unlock (void) {
+    pthread_mutex_unlock (this->mutex);
+  }
+
+  bool
+  IMutex::trylock (void) {
+    return (pthread_mutex_trylock (this->mutex) == 0) ?
+      true : false;
+  }
+  
+  RecursiveMutex::RecursiveMutex (void) {
+    this->mutex = new pthread_mutex_t;
+    this->attrib = new pthread_mutexattr_t;
+
+    pthread_mutexattr_init (this->attrib);
+    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+    
+    pthread_mutex_init (this->mutex, attrib);
+  }
+
+  RecursiveMutex::~RecursiveMutex (void) {
+    pthread_mutex_destroy (this->mutex);
+    pthread_mutexattr_destroy (this->attrib);
+
+    delete this->mutex;
+    delete this->attrib;
+  }
+
+  Mutex::Mutex (void) {
+    this->mutex = new pthread_mutex_t;
+
+    pthread_mutex_init (this->mutex, NULL);
+  }
+
+  Mutex::~Mutex (void) {
+    pthread_mutex_destroy (this->mutex);
+
+    delete this->mutex;
+  }
+
+} // end of namespace
diff --git a/shared/concurrent/Mutex.hpp b/shared/concurrent/Mutex.hpp
new file mode 100755
index 0000000..4a30cda
--- /dev/null
+++ b/shared/concurrent/Mutex.hpp
@@ -0,0 +1,58 @@
+/* 
+   Mutex.hpp - Mutex Object(s) Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_MUTEX
+#define HPP_THREAD_MUTEX
+
+#include <pthread.h>
+#include "Lockable.hpp"
+
+namespace concurrent {
+
+  class IMutex : public ILockable {
+  protected:
+    pthread_mutex_t * mutex;
+    pthread_mutexattr_t * attrib;
+  public:
+    IMutex (void);
+    IMutex (const IMutex & m);
+    virtual ~IMutex (void);
+
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+
+    IMutex & operator= (const IMutex & m);
+  };
+
+  class Mutex : public IMutex {
+  public:
+    Mutex (void);
+    virtual ~Mutex (void);
+  };
+
+  class RecursiveMutex : public IMutex {
+  public:
+    RecursiveMutex (void);
+    virtual ~RecursiveMutex (void);
+  };
+}
+
+#endif
diff --git a/shared/concurrent/Queue.hpp b/shared/concurrent/Queue.hpp
new file mode 100755
index 0000000..abac49b
--- /dev/null
+++ b/shared/concurrent/Queue.hpp
@@ -0,0 +1,99 @@
+/* 
+   Queue.hpp - Mutex Queue Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_QUEUE
+#define HPP_THREAD_QUEUE
+
+#include "Mutex.hpp"
+#include <queue>
+#include <algorithm>
+
+namespace concurrent {
+  
+  /* @description: This object wraps the existing std::queue container with
+     the custom Mutex object from the concurrent namespace. The single lock
+     may be placed in the future with a read/write lock in order to gain a
+     speed advantage.
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template <typename T>
+  class Queue : public RecursiveMutex {
+  private:
+    std::queue<T> the_queue;
+  public:
+    Queue (void) { }
+    virtual ~Queue (void) { }
+
+    inline void clear (void) {
+      this->lock();
+      while (this->the_queue.size() > 0)
+	this->the_queue.pop();
+      this->unlock();
+    }
+
+    inline void copy (std::queue<T> & Q) {
+      this->lock();
+      Q = this->the_queue;
+      this->unlock();
+    }
+
+    inline const T & back (void) {
+      this->lock();
+      T & elem = this->the_queue.back();
+      this->unlock();
+      return elem;
+    }
+
+    inline const T & front (void) {
+      this->lock();
+      T & elem = this->the_queue.front();
+      this->unlock();
+      return elem;
+    }
+
+    inline void push (const T & x) {
+      this->lock();
+      this->the_queue.push (x);
+      this->unlock();
+    }
+
+    inline T pop (void) {
+      this->lock();
+      T elem = this->the_queue.front();
+      this->the_queue.pop();
+      this->unlock();
+      return elem;
+    }
+    
+    inline size_t size (void) {
+      this->lock();
+      size_t size = this->the_queue.size();
+      this->unlock();
+      return size;
+    }
+
+    inline bool empty (void) {
+      this->lock();
+      bool result = this->the_queue.empty();
+      this->unlock();
+      return result;
+    }
+  };
+}
+#endif
diff --git a/shared/concurrent/Runnable.hpp b/shared/concurrent/Runnable.hpp
new file mode 100755
index 0000000..9e9cacc
--- /dev/null
+++ b/shared/concurrent/Runnable.hpp
@@ -0,0 +1,36 @@
+/* 
+   Runnable.hpp - Runnable Interface Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_RUNNABLE
+#define HPP_CONCURRENT_RUNNABLE
+
+class IRunnable {
+protected:
+  volatile bool running;
+public:
+  IRunnable (void) { this->running = false; }
+  virtual ~IRunnable (void) { }
+
+  virtual void * run (void *) = 0;
+  
+  inline bool isRunning (void) const { return this->running; }
+};
+
+#endif
diff --git a/shared/concurrent/Semaphore.cpp b/shared/concurrent/Semaphore.cpp
new file mode 100755
index 0000000..09f0172
--- /dev/null
+++ b/shared/concurrent/Semaphore.cpp
@@ -0,0 +1,44 @@
+/* 
+   Semaphore.cpp - Semaphore Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Semaphore.hpp"
+
+namespace concurrent {
+
+  Semaphore::Semaphore (void) {
+    sem_init (&this->semaphore, 0, 0);
+  }
+
+  Semaphore::~Semaphore (void) {
+    sem_destroy (&this->semaphore);
+  }
+
+  void
+  Semaphore::acquire (void) {
+    sem_wait (&this->semaphore);
+  }
+
+  void
+  Semaphore::release (void) {
+    sem_post (&this->semaphore);
+  }
+
+} // end of namespace
+
diff --git a/shared/concurrent/Semaphore.hpp b/shared/concurrent/Semaphore.hpp
new file mode 100755
index 0000000..e3504cf
--- /dev/null
+++ b/shared/concurrent/Semaphore.hpp
@@ -0,0 +1,41 @@
+/* 
+   Semaphore.hpp - Semaphore Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_SEMAPHORE
+#define HPP_THREAD_SEMAPHORE
+
+#include <semaphore.h>
+
+namespace concurrent {
+
+class Semaphore {
+private:
+  sem_t semaphore;
+public:
+  Semaphore (void);
+  virtual ~Semaphore (void);
+
+  void acquire (void);
+  void release (void);
+};
+
+}
+
+#endif
diff --git a/shared/concurrent/Thread.cpp b/shared/concurrent/Thread.cpp
new file mode 100755
index 0000000..42a93bb
--- /dev/null
+++ b/shared/concurrent/Thread.cpp
@@ -0,0 +1,134 @@
+/* 
+   Thread.cpp - Thread Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Thread.hpp"
+#include "ThreadGroup.hpp"
+#include <iostream>
+#include <ctime>
+
+namespace concurrent {
+
+  static void *
+  thread_run (void * runner) {
+    void * rvalue = ((IRunnable *)runner)->run (NULL);
+    return rvalue;
+  }
+
+  Thread::Thread (ThreadGroup * group,
+		  IRunnable * runner, 
+		  const std::string & name) {
+    this->group = group;
+    this->runner = runner;
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (IRunnable * runner,
+		  const std::string & name) 
+    : group(NULL) {
+    this->runner = runner;
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (const std::string & name) 
+    : group(NULL), runner(NULL) {
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (void) : group(NULL), runner(NULL) {
+    this->running = false;
+  }
+
+  Thread::~Thread (void) {
+    if (this->running == true) {
+      this->running = false;
+      this->join();
+    }
+  }
+
+  void 
+  Thread::interrupt (void) {
+    this->running = false;
+    pthread_cancel (this->thread);
+    pthread_detach (this->thread);
+  }
+
+  void 
+  Thread::yield (void) {
+    pthread_yield();
+  }
+
+  void * 
+  Thread::stop (void) {
+    this->running = false;
+    return this->join();
+  }
+
+  int 
+  Thread::sleep (unsigned long ms) {
+    struct timespec req = {0};
+    time_t sec = (int)(ms/1000);
+    ms = ms - (sec*1000);
+    req.tv_sec = sec;
+    req.tv_nsec = ms*1000000L;
+    while (nanosleep (&req, &req) == -1)
+      continue;
+    return 1;
+  }
+
+  bool 
+  Thread::start (void) {
+    if (this->running == true)
+      return false;
+
+    if (this->runner != NULL) {
+      if (pthread_create (&this->thread,
+			  NULL,
+			  thread_run,
+			  this->runner))
+	  return false;
+    }
+    else {
+      if (pthread_create (&this->thread,
+			  NULL,
+			  thread_run,
+			  this))
+	return false;
+    }
+
+    this->running = true;
+    return true;
+  }
+
+  void *
+  Thread::join (void) {
+    void * rvalue = NULL;
+    pthread_join (this->thread, &rvalue);
+    return rvalue;
+  }
+
+  void *
+  Thread::run (void *null) {
+    pthread_exit (null);
+  }
+
+} // end of namespace
diff --git a/shared/concurrent/Thread.hpp b/shared/concurrent/Thread.hpp
new file mode 100755
index 0000000..7b284df
--- /dev/null
+++ b/shared/concurrent/Thread.hpp
@@ -0,0 +1,74 @@
+/* 
+   Thread.hpp - Thread Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREAD
+#define HPP_CONCURRENT_THREAD
+
+#include <shared.h>
+#include <string>
+#include <pthread.h>
+#include <map>
+#include "Runnable.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup;
+
+  class Thread : public IRunnable {
+  private:
+    friend class ThreadGroup;
+
+    ThreadGroup * group;
+    std::string name;
+    IRunnable * runner;
+    pthread_t thread;
+    bool joinable;
+    int priority;
+  public:
+    Thread (ThreadGroup * group, 
+	    IRunnable * runner, 
+	    const std::string & name);
+    Thread (IRunnable * runner,
+	    const std::string & name);
+    Thread (const std::string & name);
+    Thread (void);
+    virtual ~Thread (void);
+
+    bool start (void);
+    void * stop (void);
+    void * join (void);
+    void interrupt (void);
+    void yield (void);
+  
+    virtual void * run (void *);
+
+    inline const std::string & getName (void) const { return this->name; }
+    inline int getPriority (void) const { return this->priority; }
+    inline void setPriority (int priority) { this->priority = priority; }
+    inline const ThreadGroup * getThreadGroup (void) const { 
+      return this->group; 
+    }
+
+    static int sleep (unsigned long ms);
+  };  
+
+}
+
+#endif
diff --git a/shared/concurrent/ThreadArgs.hpp b/shared/concurrent/ThreadArgs.hpp
new file mode 100755
index 0000000..f44742c
--- /dev/null
+++ b/shared/concurrent/ThreadArgs.hpp
@@ -0,0 +1,8 @@
+#ifndef H_THREAD_THREADARGS
+#define H_THREAD_THREADARGS
+
+#include <vector>
+
+typedef std::vector<void *> ThreadArgs;
+
+#endif
diff --git a/shared/concurrent/ThreadGroup.cpp b/shared/concurrent/ThreadGroup.cpp
new file mode 100755
index 0000000..c3eafb4
--- /dev/null
+++ b/shared/concurrent/ThreadGroup.cpp
@@ -0,0 +1,107 @@
+/* 
+   ThreadGroup.cpp - ThreadGroup Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadGroup.hpp"
+#include <algorithm>
+
+namespace concurrent {
+
+  ThreadGroup::ThreadGroup (void) 
+    : parent(NULL), daemon(false) {
+  }
+
+  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
+    : daemon(false) {
+    this->parent = parent;
+    this->name = name;
+  }
+
+  ThreadGroup::ThreadGroup (const std::string & name) 
+    : parent(NULL), daemon(false) {
+    this->name = name;
+  }
+
+  ThreadGroup::~ThreadGroup (void) {
+    if (this->daemon == true) {
+      this->stop();
+    }
+  }
+
+  bool 
+  ThreadGroup::parentOf (ThreadGroup * parent) {
+    if ((this->parent == NULL) || (parent == NULL))
+      return false;
+    // Needs to be better than this. 
+    return (this->parent == parent) ? true : false;
+  } 
+    
+  bool
+  ThreadGroup::addThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+    if (it == this->threads.end()) {
+      thread->group = this;
+      this->threads.push_back (thread);
+      return true;
+    }
+    return false;
+  }
+
+  bool 
+  ThreadGroup::removeThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+
+    if (it == this->threads.end())
+      return false;
+    this->threads.erase(it);
+    return true;
+  }
+
+  void
+  ThreadGroup::interrupt (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->interrupt();
+    }
+  }
+
+  bool
+  ThreadGroup::start (void) {
+    bool rvalue = false;
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      rvalue = (*it++)->start();
+    }
+
+    return rvalue;
+  }
+
+  void 
+  ThreadGroup::stop (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->stop();
+    }
+  }
+} // end of namesapce
diff --git a/shared/concurrent/ThreadGroup.hpp b/shared/concurrent/ThreadGroup.hpp
new file mode 100755
index 0000000..c0c5e41
--- /dev/null
+++ b/shared/concurrent/ThreadGroup.hpp
@@ -0,0 +1,59 @@
+/* 
+   ThreadGroup.hpp - ThreadGroup Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_CONCURRENT_THREADGROUP
+#define HPP_CONCURRENT_THREADGROUP
+
+#include <string>
+#include "List.hpp"
+#include "Thread.hpp"
+
+namespace concurrent {
+
+  class ThreadGroup {
+  private:
+    typedef concurrent::List<Thread *> ThreadList;
+    
+    ThreadGroup * parent;
+    std::string name;
+    ThreadList threads;
+    bool daemon; 
+  public:
+    ThreadGroup (void);
+    ThreadGroup (ThreadGroup * parent, const std::string & name);
+    ThreadGroup (const std::string & name);
+    virtual ~ThreadGroup (void);
+
+    bool parentOf (ThreadGroup * parent);
+    bool addThread (Thread * thread);
+    bool removeThread (Thread * thread);
+    void interrupt (void);
+    bool start (void);
+    void stop (void);
+    
+    inline bool isDaemon (void) const { return this->daemon; }
+    inline void setDaemon (bool daemon) { this->daemon = daemon; }
+    inline const std::string & getName (void) const { return this->name; }
+    inline ThreadGroup * getParent (void) const { return this->parent; }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/concurrent/ThreadPool.cpp b/shared/concurrent/ThreadPool.cpp
new file mode 100755
index 0000000..cebb30f
--- /dev/null
+++ b/shared/concurrent/ThreadPool.cpp
@@ -0,0 +1,90 @@
+/* 
+   ThreadPool.cpp - ThreadPool Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadPool.hpp"
+
+namespace concurrent {
+
+  ThreadPool::ThreadPool (int nMaxThreads) {
+    this->running = false;
+
+    for (int ii = 0; ii < nMaxThreads; ii++) {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+  }
+
+  ThreadPool::~ThreadPool (void) {
+    if (this->running == true)
+      this->stop(true);
+
+    std::list<Thread *>::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      Thread * t = (*it++);
+      delete t;
+    }
+
+    while (this->runQueue.size() > 0) {
+      IRunnable * r = this->runQueue.pop();
+      delete r;
+    }
+  }
+
+  void 
+  ThreadPool::start (void) {
+    this->running = true;
+    
+  std::list<Thread *>::iterator it = this->threads.begin();
+  while (it != this->threads.end())
+    {
+      (*it)->start();
+      it++;
+    }
+  }
+
+  void 
+  ThreadPool::stop (bool join = false) {
+    this->running = false;
+
+    /* Waiting to join all of the threads will mean that the thread that the
+       pool is calling the stop() method from will block until all of the 
+       threads inside of the pool have stopped.
+
+       There is a PROBLEM here. If you call this, for some reason, from inside
+       of one of the Task threads then you are going to hit a deadlock. Never
+       pass the join parameter if this is being called from inside the Tasks.*/
+    if (join == true) {
+      std::list<Thread *>::iterator it = this->threads.begin();
+      while (it != this->threads.end()) {
+	(*it)->join ();
+	it++;
+      }
+    }
+  }
+
+  void 
+  ThreadPool::execute (IRunnable * runner) {
+    this->runQueue.push (runner);
+  }
+
+} // end of namespace
+
diff --git a/shared/concurrent/ThreadPool.hpp b/shared/concurrent/ThreadPool.hpp
new file mode 100755
index 0000000..a09dd58
--- /dev/null
+++ b/shared/concurrent/ThreadPool.hpp
@@ -0,0 +1,91 @@
+/* 
+   ThreadPool.hpp - ThreadPool Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_THREAD_THREADPOOL
+#define HPP_THREAD_THREADPOOL
+
+#include "Mutex.hpp"
+#include "Thread.hpp"
+#include "Queue.hpp"
+#include <queue>
+#include <list>
+
+namespace concurrent {
+
+  /* @description: This is a ThreadPool object that will keep N concurrent
+     threads running. Runnable objects can be attached to this object and they
+     will be executed immediately as a thread becomes available to run them. 
+     @author: John `jb Bellone (jvb4@njit.edu)
+     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
+  class ThreadPool {
+    /* @description: This object is an individual task that will be spawned at
+       the start of the ThreadPool. Each thread periodically checks the pool
+       object for any available Runnable objects from the queue. If there are
+       such objects it will take them off, run them and delete them. */
+    class Task : public IRunnable {
+    private:
+      ThreadPool * pool;
+    public:
+      Task (ThreadPool * pool) {
+	this->pool = pool;
+      }
+      
+      void * run (void *) {
+	this->running = true;
+
+	while (this->running == true)
+	  {
+	    if (pool->isRunning() == false)
+	      break;
+
+	    if (pool->getQueueSize() > 0)
+	      {
+		IRunnable * runner = pool->removeFromQueue();
+		runner->run(NULL);
+		delete runner;
+	      }
+	    ::sleep (1);
+	  }
+	return NULL;
+      }
+    };
+  private:
+    concurrent::Queue<IRunnable *> runQueue;
+    std::list<Thread *> threads;
+    bool running;
+  public:  
+    ThreadPool (int);
+    ~ThreadPool (void);
+
+    /* Thread un-Safe Methods */
+    void start (void);
+    void stop (bool);
+
+    /* Thread-Safe Methods */
+    void execute (IRunnable *);
+    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
+    inline bool isRunning (void) const { return this->running; }
+    inline int getMaxThreads (void) const { return this->threads.size(); }
+    inline size_t getQueueSize (void) { return this->runQueue.size(); }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/network/Socket.hpp b/shared/network/Socket.hpp
new file mode 100755
index 0000000..3662409
--- /dev/null
+++ b/shared/network/Socket.hpp
@@ -0,0 +1,41 @@
+/* 
+   Socket.hpp - Socket Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK_SOCKET
+#define HPP_NETWORK_SOCKET
+
+#include <cstring>
+
+namespace network {
+
+  class ISocket {
+  protected:
+    int sockfd;
+  public:
+    virtual ~ISocket (void) { }
+
+    virtual void close (void) = 0;
+    virtual int send (const char * bytes, size_t length) = 0;
+    virtual int receive (char * btyes, size_t size) = 0;
+  };
+
+} // end of namesapce
+
+#endif
diff --git a/shared/network/Tcp.cpp b/shared/network/Tcp.cpp
new file mode 100755
index 0000000..9a502d2
--- /dev/null
+++ b/shared/network/Tcp.cpp
@@ -0,0 +1,155 @@
+/* 
+   Tcp.hpp - Tcp Implementation Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Tcp.hpp"
+#include <iostream>
+
+namespace network {
+
+  TcpSocket::TcpSocket (void) {
+    this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+  }
+
+  TcpSocket::~TcpSocket (void) {
+    this->close();
+  }
+
+  void
+  TcpSocket::close (void) {
+    if (this->sockfd > 0)
+      ::close (this->sockfd);
+  }
+	
+  int
+  TcpSocket::send (const char * bytes, size_t length) {
+    return ::write (this->sockfd, bytes, length);
+  }
+
+  int
+  TcpSocket::receive (char * bytes, size_t size) {
+    return ::read (this->sockfd, bytes, size);
+  }
+
+  TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
+    this->port = port;
+
+    memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+    this->sockaddr.sin_family = AF_INET;
+    this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+    this->sockaddr.sin_port = htons (this->port);
+  }
+
+  TcpServerSocket::~TcpServerSocket (void) {
+    this->close();
+  }
+
+  bool
+  TcpServerSocket::start (int backlog = 5) {
+    int opt = 1;
+
+    // This is to prevent conflicts with major services' ports.
+    if (this->port < 1024)
+      return false;
+
+    if (::setsockopt (this->sockfd, 
+		      SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
+      return false;
+
+    if (::bind (this->sockfd,
+		(struct sockaddr *)&(this->sockaddr),
+		sizeof (this->sockaddr)) < 0)
+      return false;
+
+    if (::listen (this->sockfd, backlog) < 0)
+      return false;
+
+    return true;
+  }
+
+  void
+  TcpServerSocket::close (void) {
+    TcpSocket::close();
+  }
+
+  TcpServerSocket::Acceptor *
+  TcpServerSocket::newAcceptor (void) {
+    return new TcpServerSocket::Acceptor (this, this->sockfd);
+  }
+
+  TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
+    this->socket = server;
+    this->sockfd = sockfd;
+  }
+
+  int
+  TcpServerSocket::Acceptor::acceptIncoming (void) {
+    int newfd = -1;
+    static struct sockaddr_in clientaddr;
+    unsigned int x = sizeof (clientaddr);
+
+    if ((newfd = ::accept (this->sockfd, 
+			   (struct sockaddr *)&clientaddr,
+			   &x)) < 0)
+      return -1;
+    return newfd;
+  }
+
+  TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
+    memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+    this->sockaddr.sin_family = AF_INET;
+    this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+  }
+
+  TcpClientSocket::TcpClientSocket (int newfd) {
+    this->sockfd = newfd;
+  }
+				
+  TcpClientSocket::~TcpClientSocket (void) {
+  }
+
+  bool
+  TcpClientSocket::connect (const char * host, int port) {
+    if (!host || (*host == '\0'))
+      return false;
+
+    if ((this->hp = ::gethostbyname (host)) == NULL)
+      return false;
+ 
+    // Copy over the hostname address.
+    memset (&(this->sockaddr),0, sizeof (this->sockaddr));
+    this->sockaddr.sin_family = AF_INET;
+    this->sockaddr.sin_addr.s_addr 
+      = ((struct in_addr *)(this->hp->h_addr))->s_addr;
+    this->sockaddr.sin_port = htons (port);
+
+    if (::connect (this->sockfd,
+		   (struct sockaddr *)&(this->sockaddr),
+		   sizeof (struct sockaddr)) < 0)
+      return false;
+    
+    return true;
+  }
+
+  void
+  TcpClientSocket::close (void) {
+    TcpSocket::close();
+  }
+
+} // end of namespace
diff --git a/shared/network/Tcp.hpp b/shared/network/Tcp.hpp
new file mode 100755
index 0000000..552f93f
--- /dev/null
+++ b/shared/network/Tcp.hpp
@@ -0,0 +1,82 @@
+/* 
+   Tcp.hpp - Tcp Implementation Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK_TCP
+#define HPP_NETWORK_TCP
+
+#include "Socket.hpp"
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <netdb.h>
+
+namespace network {
+
+  class TcpSocket : public ISocket {
+  protected:
+    struct sockaddr_in sockaddr;
+  public:
+    TcpSocket (void);
+    virtual ~TcpSocket (void);
+
+    void close (void);
+    int send (const char * bytes, size_t length);
+    int receive (char * bytes, size_t size);
+  };
+
+  class TcpServerSocket : public TcpSocket {
+  private:
+    int port;
+  public:
+    class Acceptor {
+    private:
+      TcpServerSocket * socket;
+      int sockfd;
+    public:
+      Acceptor (TcpServerSocket * server, int sockfd);
+
+      int acceptIncoming (void);
+    };
+
+    TcpServerSocket (int port);
+    virtual ~TcpServerSocket (void);
+    
+    bool start (int backlog);
+    void close (void);
+    Acceptor * newAcceptor (void);
+  };
+  
+  class TcpClientSocket : public TcpSocket {
+  private:
+    struct hostent * hp;
+  public:
+    TcpClientSocket (void);
+    TcpClientSocket (int newfd);
+    virtual ~TcpClientSocket (void);
+
+    bool connect (const char * host, int port);
+    void close (void);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/proactor/Dispatcher.cpp b/shared/proactor/Dispatcher.cpp
new file mode 100755
index 0000000..18cc953
--- /dev/null
+++ b/shared/proactor/Dispatcher.cpp
@@ -0,0 +1,57 @@
+/* 
+   Dispatcher.hpp - Dispatcher Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Dispatcher.hpp"
+#include "Worker.hpp"
+#include <algorithm>
+
+namespace proactor {
+
+  Dispatcher::~Dispatcher (void) {
+      
+  }
+   
+  bool
+  Dispatcher::addWorker (Worker * w) {
+    WorkerListType::iterator it = std::find (this->workers.begin(),
+					     this->workers.end(),
+					     w);
+    if (it == this->workers.end())
+      {
+	this->workers.push_back (w);
+	return w->start();
+      }
+    return false;
+  }
+  
+  bool
+  Dispatcher::removeWorker (Worker * w) {
+    WorkerListType::iterator it = std::find (this->workers.begin(),
+					     this->workers.end(),
+					     w);
+
+    if (it == this->workers.end())
+      return false;
+  
+    this->workers.erase (it);
+    return true;
+  }
+
+} // end of namesapce
diff --git a/shared/proactor/Dispatcher.hpp b/shared/proactor/Dispatcher.hpp
new file mode 100755
index 0000000..259fbbd
--- /dev/null
+++ b/shared/proactor/Dispatcher.hpp
@@ -0,0 +1,45 @@
+/* 
+   Dispatcher.hpp - Dispatcher Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_DISPATCHER
+#define HPP_PROACTOR_DISPATCHER
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/List.hpp"
+
+namespace proactor {
+
+  class Worker;
+
+  class Dispatcher : public concurrent::Thread {
+  protected:
+    typedef concurrent::List<Worker *> WorkerListType;
+
+    WorkerListType workers;
+  public:
+    virtual ~Dispatcher (void);
+
+    bool addWorker (Worker * w);
+    bool removeWorker (Worker * w);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/proactor/Event.cpp b/shared/proactor/Event.cpp
new file mode 100755
index 0000000..6c8f45f
--- /dev/null
+++ b/shared/proactor/Event.cpp
@@ -0,0 +1,40 @@
+/* 
+   Event.cpp - Event Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Event.hpp"
+
+namespace proactor {
+
+  int Event::numEvents = 0;
+
+  Event::Event (int e, const std::string & buf) {
+    this->id = e;
+    this->buf = buf;
+  }
+
+  int
+  Event::uniqueEventId (void) {
+    return Event::numEvents++;
+  }
+
+  EventDispatcher::~EventDispatcher (void) {
+  }
+ 
+} // end of namespace
diff --git a/shared/proactor/Event.hpp b/shared/proactor/Event.hpp
new file mode 100755
index 0000000..09133bc
--- /dev/null
+++ b/shared/proactor/Event.hpp
@@ -0,0 +1,58 @@
+/* 
+   Event.hpp - Event Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_EVENT
+#define HPP_PROACTOR_EVENT
+
+#include "Dispatcher.hpp"
+#include <string>
+
+namespace proactor {
+
+  class Event {
+  private:
+    static int numEvents;
+  public:
+    int id;
+    std::string buf;
+
+    Event (int id, const std::string & buf);
+
+    static int uniqueEventId (void);
+  };
+
+  class EventDispatcher : public Dispatcher {
+  private:
+    int eventId;
+  public:
+    virtual ~EventDispatcher (void);
+
+    inline void setEventId (int e) { 
+      this->eventId = e;
+    }
+
+    inline int getEventId (void) { 
+      return this->eventId;
+    }
+  };
+
+}
+
+#endif
diff --git a/shared/proactor/InputDispatcher.cpp b/shared/proactor/InputDispatcher.cpp
new file mode 100755
index 0000000..faf8e51
--- /dev/null
+++ b/shared/proactor/InputDispatcher.cpp
@@ -0,0 +1,68 @@
+/* 
+   InputDispatcher.cpp - Input Dispatcher Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "InputDispatcher.hpp"
+#include "Proactor.hpp"
+
+namespace proactor {
+
+  InputDispatcher::~InputDispatcher (void) {
+      this->inputQueue.lock();
+      while (this->inputQueue.size() > 0)
+	this->inputQueue.pop();
+      this->inputQueue.unlock();
+  }
+
+  void *
+  InputDispatcher::stop (void) {
+    WorkerListType::iterator it = this->workers.begin();
+    while (it != this->workers.end()) {
+      (*it)->stop();
+      it = this->workers.erase(it);
+    }
+    return Thread::stop();
+  }
+
+  void *
+  InputDispatcher::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+      // Dispatch all of the input items on the queue.
+      this->inputQueue.lock();
+
+      while (this->inputQueue.size() > 0) {
+
+	if (this->running == false)
+	  break;
+
+	// For right now all we're doing is pushing up the chain.
+	this->pro->onReadComplete ( this->inputQueue.pop() );
+      }
+
+      this->inputQueue.unlock();
+
+      Thread::sleep(100);
+    }
+  
+    return NULL; 
+  }
+
+} // end of namespace
diff --git a/shared/proactor/InputDispatcher.hpp b/shared/proactor/InputDispatcher.hpp
new file mode 100755
index 0000000..cf54f36
--- /dev/null
+++ b/shared/proactor/InputDispatcher.hpp
@@ -0,0 +1,55 @@
+/* 
+   InputDispatcher.hpp - Input Dispatcher Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_INPUTDISPATCHER
+#define HPP_PROACTOR_INPUTDISPATCHER
+
+#include "../concurrent/Queue.hpp"
+#include "Event.hpp"
+
+namespace proactor {
+
+  class Proactor;
+
+  class InputDispatcher : public EventDispatcher {
+  protected:
+    typedef concurrent::Queue<Event> InputQueueType;
+
+    Proactor * pro;
+    InputQueueType inputQueue;
+  public:
+    virtual ~InputDispatcher (void);
+
+    void * stop (void);
+    
+    inline void onReadComplete (const char * buf) {
+      this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
+    }
+
+    inline void onReadComplete (std::string buf) {
+      this->inputQueue.push ( Event (getEventId(), buf) );
+    }
+
+    void * run (void * null);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/proactor/Proactor.cpp b/shared/proactor/Proactor.cpp
new file mode 100755
index 0000000..dff5762
--- /dev/null
+++ b/shared/proactor/Proactor.cpp
@@ -0,0 +1,161 @@
+/* 
+   Proactor.cpp - Proactor Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Proactor.hpp"
+#include <iostream>
+#include <algorithm>
+
+namespace proactor {
+
+  Proactor::Proactor (void) {
+  }
+
+  Proactor::~Proactor (void) {
+    // Remove all of the lists of event handlers.
+    {
+      EventMapType::iterator it = this->eventsToHandlers.begin();
+      while (it != this->eventsToHandlers.end()) {
+	  WorkerListType * q = (it->second);
+	  delete q;
+	  it++;
+	}
+    }
+ 
+    // Handle the dispatchers that have not been manually removed.
+    {
+      DispatcherList::iterator it = this->dispatchers.begin();
+      while (it != this->dispatchers.end())
+	{
+	  Dispatcher * d = (*it);
+	  delete d;
+	  it++;
+	}
+    }
+  
+  }
+
+  bool
+  Proactor::addWorker (int e, Worker * job) {
+    this->eventsToHandlers.lock();
+    {
+      EventMapType::iterator it = this->eventsToHandlers.find (e);
+  
+      if (it == this->eventsToHandlers.end())
+	this->eventsToHandlers[e] = new WorkerListType;  
+      this->eventsToHandlers[e]->push_back (job);
+    }
+    this->eventsToHandlers.unlock();
+
+    return job->start();
+  }
+
+  void
+  Proactor::onReadComplete (Event e) {
+    this->events.push (e);
+  }
+
+  void 
+  Proactor::onReadComplete (int e, const char * buf) {
+    this->events.push ( Event (e, std::string (buf)) );   
+  }
+
+  bool
+  Proactor::removeWorker (int e, Worker * job) {
+    bool result = false;
+
+    this->eventsToHandlers.lock();
+    {
+      WorkerListType::iterator it = 
+	std::find (this->eventsToHandlers[e]->begin(),
+		   this->eventsToHandlers[e]->end(),
+		   job);
+    
+      if (it != this->eventsToHandlers[e]->end())
+	{
+	  this->eventsToHandlers[e]->erase (it);
+	  result = true;
+	}
+    }
+    this->eventsToHandlers.unlock();
+   
+    return result;
+  }
+
+  void
+  Proactor::addDispatcher (Dispatcher * d) {
+    this->dispatchers.push_back (d);
+  }
+
+  bool
+  Proactor::removeDispatcher (Dispatcher * d) {
+    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
+					     this->dispatchers.end(),
+					     d);
+
+    if (it == this->dispatchers.end())
+      return false;
+  
+    this->dispatchers.erase (it);
+    return true;
+  }
+
+  void *
+  Proactor::run (void * null) {
+    this->running = true;
+  
+    WorkerListType::iterator it;
+
+    while (this->running == true) {
+	this->events.lock();
+
+	while (this->events.size() > 0) {
+
+	  if (this->running == false)
+	    break;
+
+	    Event e = this->events.pop();
+
+	    // We are throwing events with no handlers to catch them.
+	    if (this->eventsToHandlers.find (e.id) == 
+		this->eventsToHandlers.end())
+	      continue;
+ 
+	    it = this->eventsToHandlers[e.id]->begin();
+	  
+	    while (it != this->eventsToHandlers[e.id]->end()) {
+
+	      if (this->running == false)
+		break;
+
+		Worker * j = (*it);
+	      
+		j->pushInputQueue (e.buf);
+		      
+		it++;
+	      }
+	  }
+	this->events.unlock();
+      
+	Thread::sleep(100);
+      }
+    return NULL;
+  }
+
+} // end of namespace
diff --git a/shared/proactor/Proactor.hpp b/shared/proactor/Proactor.hpp
new file mode 100755
index 0000000..3a33688
--- /dev/null
+++ b/shared/proactor/Proactor.hpp
@@ -0,0 +1,65 @@
+/* 
+   Proactor.hpp - Proactor Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_PROACTOR
+#define HPP_PROACTOR_PROACTOR
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/Map.hpp"
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/List.hpp"
+#include "Worker.hpp"
+#include "Event.hpp"
+#include "Dispatcher.hpp"
+#include "InputDispatcher.hpp"
+
+namespace proactor {
+
+  class Proactor : public Dispatcher {
+  private:
+    typedef concurrent::List<Dispatcher *> DispatcherList;
+    typedef concurrent::Map<int, WorkerListType *> EventMapType;
+    typedef concurrent::Queue<Event> EventQueueType;
+
+    EventMapType eventsToHandlers;
+    DispatcherList dispatchers;
+    EventQueueType events;
+  public:
+    Proactor (void);
+    virtual ~Proactor (void);
+
+    bool addWorker (int e, Worker * w);
+    bool removeWorker (int e, Worker * w);
+    void addDispatcher (Dispatcher * d);
+    bool removeDispatcher (Dispatcher * d);
+    
+    void * run (void * null);
+ 
+    void onReadComplete (Event e);
+    void onReadComplete (int e, const char * buf);
+
+    inline const std::string & peekInputQueue (void) {
+      return (this->events.front()).buf;
+    }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/shared/proactor/Worker.cpp b/shared/proactor/Worker.cpp
new file mode 100755
index 0000000..19903da
--- /dev/null
+++ b/shared/proactor/Worker.cpp
@@ -0,0 +1,28 @@
+/* 
+   Worker.cpp - Worker Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Worker.hpp"
+
+namespace proactor {
+
+  Worker::~Worker (void) {
+  }
+
+} // end of namesapce
diff --git a/shared/proactor/Worker.hpp b/shared/proactor/Worker.hpp
new file mode 100755
index 0000000..5810e5e
--- /dev/null
+++ b/shared/proactor/Worker.hpp
@@ -0,0 +1,48 @@
+/* 
+   Worker.hpp - Worker Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_WORKER
+#define HPP_PROACTOR_WORKER
+
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/Thread.hpp"
+#include <string>
+
+namespace proactor {
+
+  class InputDispatcher;
+
+  class Worker : public concurrent::Thread {
+  protected:
+    typedef concurrent::Queue<std::string> InputQueueType;
+
+    InputDispatcher * dispatcher;
+    InputQueueType inputQueue;
+  public:
+    virtual ~Worker (void);
+
+    inline void pushInputQueue (std::string buf) {
+      this->inputQueue.push (buf);
+    }
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/largefile/plugin_main.cpp b/src/largefile/plugin_main.cpp
new file mode 100755
index 0000000..5ef09ba
--- /dev/null
+++ b/src/largefile/plugin_main.cpp
@@ -0,0 +1,54 @@
+/* 
+   plugin_main.cpp - Largefile Plugin DLL Entry Point
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include <iostream>
+#include <workbook/workbook.h>
+#include <glib/gthread.h>
+#include "../application.h"
+#include "../plugin.h"
+
+extern "C" {
+
+  Workbook *
+  plugin_main (ApplicationState * appstate, Plugin * plugin) {
+    ASSERT (appstate != NULL);
+    ASSERT (plugin != NULL);
+
+    Workbook * wb = NULL;
+    GtkWidget * hbox = gtk_handle_box_new();
+    
+    if ((wb = workbook_open (appstate->gtk_window, "largefile")) == NULL) {
+      g_critical ("Failed opening workbook; exiting largefile plugin");
+      return NULL;
+    }
+
+    wb->signals[SIG_WORKBOOK_CHANGED] = appstate->signals[SIG_SHEET_CHANGED];
+    
+    gtk_container_add (GTK_CONTAINER (hbox), wb->gtk_notebook);
+    
+    wb->gtk_box = hbox;
+    
+    wb->add_new_sheet (wb, "sheet0", 100, 15);
+
+    gtk_widget_show (hbox);
+    return wb;
+  }
+
+}
diff --git a/src/largefile/plugin_main.cpp~ b/src/largefile/plugin_main.cpp~
new file mode 100755
index 0000000..0a9e61e
--- /dev/null
+++ b/src/largefile/plugin_main.cpp~
@@ -0,0 +1,20 @@
+/* 
+   plugin_main.cpp - Largefile Plugin DLL Entry Point
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/

commit c994fe8a9c2108ab67270b83b9ce8d33fbe1d3f2
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Wed Apr 29 15:12:59 2009 +0000

    Updated to first beta candidate.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@18 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/bin/socketTest.py b/bin/socketTest.py
index e4f696c..cc4f19d 100644
--- a/bin/socketTest.py
+++ b/bin/socketTest.py
@@ -16,9 +16,9 @@ def main():
 
     ii = 0
 
-    sock.sendall ("^0^1^sheet1^10000^11\n")
+    sock.sendall ("^0^1^sheet1^1000000^3\n")
     
-    while ii < 10000:
+    while ii < 1000000:
         sock.sendall ("^%d^0^sheet1^%d^0^^0\n" %(ii, ii))
         ii = ii + 1
 
diff --git a/include/workbook/sheet.h b/include/workbook/sheet.h
index e55d939..0f46c30 100644
--- a/include/workbook/sheet.h
+++ b/include/workbook/sheet.h
@@ -71,7 +71,7 @@ typedef struct _Sheet Sheet;
     void (*apply_range) (Sheet *, 
 			 const GtkSheetRange *, 
 			 const CellAttributes *);
-    void (*apply_array) (Sheet *, const Cell **, gint);
+    void (*apply_array) (Sheet *, Cell **, gint);
     void (*apply_cell) (Sheet *, const Cell *);
 
     void (*set_cell) (Sheet *, gint, gint, const gchar *);  
diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
index af2f9e9..39b4a50 100644
--- a/src/realtime/CsvParser.cpp
+++ b/src/realtime/CsvParser.cpp
@@ -27,7 +27,7 @@ namespace realtime {
 
   struct csv_column {
     Sheet * sheet;
-    Cell * cell;
+    Cell ** array;
     int row;
     int field;
     char * value;
@@ -39,13 +39,11 @@ namespace realtime {
   static void 
   cb1 (void * s, size_t length, void * data) {
     struct csv_column * column = (struct csv_column *)data;
-    Cell * cell = column->cell;
-    Sheet * sheet = column->sheet;
+    Cell * cell = column->array[column->field];
 
     cell->set_row (cell, column->row);
     cell->set_column (cell, column->field++);
     cell->set_value_length (cell, s, length);
-    sheet->apply_cell (sheet, cell);
   }
 
   static void
@@ -72,6 +70,10 @@ namespace realtime {
 
     while (this->running == true) {
       while (this->inputQueue.size() > 0) {
+
+	if (this->running == false)
+	  break;
+
 	std::string buf = this->inputQueue.pop();
 	size_t bytes = buf.length();
  
@@ -88,11 +90,18 @@ namespace realtime {
 
 	csv_fini (&csv, cb1, cb2, &column);
 
+	this->wb->sheet_first->apply_array (this->wb->sheet_first,
+					    this->cell,
+					    10);
+
 	if (column.row >= (column.sheet)->max_rows)
 	  column.row = 0;
       }
+
       Thread::sleep(100);
+
     }
+
     csv_free (&csv);
     delete column.value;
     return NULL;
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
index 2293dad..b883704 100644
--- a/src/realtime/CsvParser.hpp
+++ b/src/realtime/CsvParser.hpp
@@ -34,18 +34,21 @@ namespace realtime {
   private:
     Workbook * wb;
     FILE * pktlog;
-    Cell * cell;
+    Cell * cell[10];
     int verbosity;
   public:
     CsvParser (Workbook * wb, FILE * pktlog, int verbosity) {
       this->wb = wb;
       this->pktlog = pktlog;
-      this->cell = cell_new();
       this->verbosity = verbosity;
+
+      for (unsigned int ii = 0; ii < 10; ii++)
+	this->cell[ii] = cell_new();
     }
 
     virtual ~CsvParser (void) {
-      this->cell->destroy (cell);
+      for (unsigned int ii = 0; ii < 10; ii++)
+	this->cell[ii]->destroy (this->cell[ii]);
     }
 
     void * run (void * null);
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
index 1cabc61..fa52beb 100644
--- a/src/realtime/Network.cpp
+++ b/src/realtime/Network.cpp
@@ -27,21 +27,22 @@ namespace realtime {
 
   ConnectionThread::ConnectionThread (proactor::InputDispatcher * d, 
 				      int newfd) {
-    this->purge_socket = true;
     this->socket = new network::TcpClientSocket (newfd);
     this->dispatcher = d;
   }
 
   ConnectionThread::ConnectionThread (proactor::InputDispatcher * d,
 				      network::TcpSocket * s) {
-    this->purge_socket = false;
     this->socket = s;
     this->dispatcher = d;
   }
 
   ConnectionThread::~ConnectionThread (void) {
-    if (purge_socket == true)
-      delete socket;
+    if (this->socket != NULL) {
+      this->socket->close();
+      delete this->socket;
+      this->socket = NULL;
+    }
   }
 
   void *
@@ -55,9 +56,9 @@ namespace realtime {
     while (this->running == true) {
       packet.clear();
 
-      while ((size = this->socket->receive (buf, MAX_INPUT_SIZE)) > 0) {
+      while ((size = this->socket->receive (buf, MAX_INPUT_SIZE)) >= 0) {
 
-	if (size == -1) {
+	if ((this->running == false) || (size == 0)) {
 	  this->running = false;
 	  break;
 	}
@@ -66,6 +67,10 @@ namespace realtime {
 	packet.append(buf);
 
 	while ((pos = packet.find_first_of('\n')) != std::string::npos) {
+	  
+	  if (this->running == false)
+	    break;
+
 	  this->dispatcher->onReadComplete (packet.substr (0, pos));
 	  packet = packet.substr (pos+1, packet.length());
 	}
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
index d29d913..c178c96 100644
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -36,6 +36,7 @@ namespace realtime {
       this->pro = pro;
       setEventId(e);
     }
+
     virtual ~NetworkCsvReceiver (void) { }
   };
 
@@ -45,6 +46,7 @@ namespace realtime {
       this->pro = pro;
       setEventId(e);
     }
+
     virtual ~NetworkPktReceiver (void) { }
   };
 
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index 7ce4b09..e262007 100644
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -58,13 +58,21 @@ namespace realtime {
 
       while (this->running == true) {
 	if (this->inputQueue.size() > 0) {
+
+	  if (this->running == false)
+	    break;
+
 	  // Lock, copy, clear, unlock. - Free this up.
 	  this->inputQueue.lock();
-	  queue = this->inputQueue.copy();
+	  this->inputQueue.copy (queue);
 	  this->inputQueue.clear();
 	  this->inputQueue.unlock();
 	  
 	  while (queue.size() > 0) {
+
+	    if (this->running == false)
+	      break;
+
 	    // Never understood why pop() doesn't return the element.
 	    std::string buf = queue.front(); queue.pop();
 	    p = buf.c_str();
diff --git a/src/realtime/concurrent/Queue.hpp b/src/realtime/concurrent/Queue.hpp
index 58b7631..abac49b 100755
--- a/src/realtime/concurrent/Queue.hpp
+++ b/src/realtime/concurrent/Queue.hpp
@@ -23,6 +23,7 @@
 
 #include "Mutex.hpp"
 #include <queue>
+#include <algorithm>
 
 namespace concurrent {
   
@@ -46,8 +47,10 @@ namespace concurrent {
       this->unlock();
     }
 
-    inline std::queue<T> copy (void) {
-      return this->the_queue;
+    inline void copy (std::queue<T> & Q) {
+      this->lock();
+      Q = this->the_queue;
+      this->unlock();
     }
 
     inline const T & back (void) {
diff --git a/src/realtime/concurrent/Thread.cpp b/src/realtime/concurrent/Thread.cpp
index 333b9e7..42a93bb 100755
--- a/src/realtime/concurrent/Thread.cpp
+++ b/src/realtime/concurrent/Thread.cpp
@@ -59,12 +59,15 @@ namespace concurrent {
   }
 
   Thread::~Thread (void) {
-    this->running = false;
-    this->join();
+    if (this->running == true) {
+      this->running = false;
+      this->join();
+    }
   }
 
   void 
   Thread::interrupt (void) {
+    this->running = false;
     pthread_cancel (this->thread);
     pthread_detach (this->thread);
   }
diff --git a/src/realtime/network/Tcp.cpp b/src/realtime/network/Tcp.cpp
index 08cd791..9a502d2 100755
--- a/src/realtime/network/Tcp.cpp
+++ b/src/realtime/network/Tcp.cpp
@@ -39,12 +39,12 @@ namespace network {
 	
   int
   TcpSocket::send (const char * bytes, size_t length) {
-    return ::send (this->sockfd, bytes, length, 0);
+    return ::write (this->sockfd, bytes, length);
   }
 
   int
   TcpSocket::receive (char * bytes, size_t size) {
-    return ::recv (this->sockfd, bytes, size, 0);
+    return ::read (this->sockfd, bytes, size);
   }
 
   TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
diff --git a/src/realtime/proactor/InputDispatcher.cpp b/src/realtime/proactor/InputDispatcher.cpp
index b5a0ea9..faf8e51 100644
--- a/src/realtime/proactor/InputDispatcher.cpp
+++ b/src/realtime/proactor/InputDispatcher.cpp
@@ -31,6 +31,16 @@ namespace proactor {
   }
 
   void *
+  InputDispatcher::stop (void) {
+    WorkerListType::iterator it = this->workers.begin();
+    while (it != this->workers.end()) {
+      (*it)->stop();
+      it = this->workers.erase(it);
+    }
+    return Thread::stop();
+  }
+
+  void *
   InputDispatcher::run (void * null) {
     this->running = true;
 
@@ -39,6 +49,10 @@ namespace proactor {
       this->inputQueue.lock();
 
       while (this->inputQueue.size() > 0) {
+
+	if (this->running == false)
+	  break;
+
 	// For right now all we're doing is pushing up the chain.
 	this->pro->onReadComplete ( this->inputQueue.pop() );
       }
diff --git a/src/realtime/proactor/InputDispatcher.hpp b/src/realtime/proactor/InputDispatcher.hpp
index 8f7dc55..cf54f36 100644
--- a/src/realtime/proactor/InputDispatcher.hpp
+++ b/src/realtime/proactor/InputDispatcher.hpp
@@ -36,6 +36,8 @@ namespace proactor {
     InputQueueType inputQueue;
   public:
     virtual ~InputDispatcher (void);
+
+    void * stop (void);
     
     inline void onReadComplete (const char * buf) {
       this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
index 3a081ca..dff5762 100755
--- a/src/realtime/proactor/Proactor.cpp
+++ b/src/realtime/proactor/Proactor.cpp
@@ -126,6 +126,10 @@ namespace proactor {
 	this->events.lock();
 
 	while (this->events.size() > 0) {
+
+	  if (this->running == false)
+	    break;
+
 	    Event e = this->events.pop();
 
 	    // We are throwing events with no handlers to catch them.
@@ -136,6 +140,10 @@ namespace proactor {
 	    it = this->eventsToHandlers[e.id]->begin();
 	  
 	    while (it != this->eventsToHandlers[e.id]->end()) {
+
+	      if (this->running == false)
+		break;
+
 		Worker * j = (*it);
 	      
 		j->pushInputQueue (e.buf);
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index 8d73b8d..4739b97 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -96,9 +96,8 @@ thread_main (ThreadArgs * args) {
       return;
     }
 
-  network::TcpClientSocket client;
-  if (client.connect ("localhost", 50000) == false)
-    {
+  network::TcpClientSocket * client = new network::TcpClientSocket;
+  if (client->connect ("localhost", 50000) == false) {
       g_critical ("Failed connecting to TcpClientSocket");
       return;
     }
@@ -111,7 +110,7 @@ thread_main (ThreadArgs * args) {
   NetworkCsvReceiver csvDispatcher (csvEventID, &proactor);
   NetworkPktReceiver pktDispatcher (pktEventID, &proactor);
   AcceptThread acceptor (socket.newAcceptor(), &pktDispatcher);
-  ConnectionThread creader (&csvDispatcher, &client);
+  ConnectionThread creader (&csvDispatcher, client);
   PacketParser pkt_worker (wb, pktlog, atoi(verbosity->value));
   CsvParser csv_worker (wb, pktlog, atoi(verbosity->value));
 
@@ -145,7 +144,6 @@ thread_main (ThreadArgs * args) {
       return;
     }
   
-  
   if (csvDispatcher.addWorker (&creader) == false) {
     g_critical ("Failed starting client reader; exiting thread.");
     return;
@@ -156,9 +154,11 @@ thread_main (ThreadArgs * args) {
     concurrent::Thread::sleep (100);
   }
 
+  csv_worker.stop();
+  pkt_worker.stop();
+  creader.interrupt();
+  acceptor.interrupt();
   socket.close();  
-  client.close();
-
 
   FCLOSE (pktlog);
 }
diff --git a/workbook/sheet.c b/workbook/sheet.c
index c60d6d6..0c6dd8d 100644
--- a/workbook/sheet.c
+++ b/workbook/sheet.c
@@ -8,7 +8,7 @@ static void sheet_object_free (Sheet *);
 static void sheet_method_destroy (Sheet *);
 static void sheet_method_set_cell (Sheet *, gint, gint, const gchar *);
 static void sheet_method_apply_cell (Sheet *, const Cell *);
-static void sheet_method_apply_cellarray (Sheet *, const Cell **, gint);
+static void sheet_method_apply_cellarray (Sheet *, Cell **, gint);
 static void sheet_method_apply_cellrange (Sheet *, 
 					  const GtkSheetRange *,
 					  const CellAttributes *);
@@ -335,14 +335,40 @@ sheet_method_apply_cellrange (Sheet * sheet,
 
 static void
 sheet_method_apply_cellarray (Sheet * sheet, 
-			      const Cell ** array,
+			      Cell ** array,
 			      gint size)
 {
   ASSERT (sheet != NULL);
   g_return_if_fail (array != NULL);
 
   gdk_threads_enter ();
-  
+
+  /* We'll see how this performs for now. In the future we may want to go
+     directly into the GtkSheet structures to get a little more performance
+     boost (mainly because we should not have to check all the bounds each
+     time we want to update). */
+  for (gint ii = 0; ii < size; ii++) {
+    gtk_sheet_set_cell_text (GTK_SHEET (sheet->gtk_sheet),
+			     array[ii]->row,
+			     array[ii]->column,
+			     array[ii]->value->str);
+
+    if (!IS_NULLSTR (array[ii]->attributes.bgcolor->str))
+      sheet->range_set_background (sheet, 
+				   &array[ii]->range, 
+				   array[ii]->attributes.bgcolor->str);
+
+    if (!IS_NULLSTR (array[ii]->attributes.fgcolor->str))
+      sheet->range_set_foreground (sheet, 
+				   &array[ii]->range, 
+				   array[ii]->attributes.fgcolor->str);
+
+    /* Clear all of the strings */
+    g_string_assign (array[ii]->value, "");
+    g_string_assign (array[ii]->attributes.bgcolor, "");
+    g_string_assign (array[ii]->attributes.fgcolor, "");
+  }
+
   gdk_threads_leave ();
 }
 

commit b37a5c517d8dda6a12c12f0b699bc8b7b4426a1f
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Fri Apr 24 04:20:29 2009 +0000

    Updates to compile under Ubuntu 9.04
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@17 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/Makefile.base b/Makefile.base
index 5316eb5..e860e8e 100755
--- a/Makefile.base
+++ b/Makefile.base
@@ -19,16 +19,18 @@ LIBDIR=${SYSINSPATH}/lib
 INCDIR=${SYSINSPATH}/include
 OBJDIR=${PROJDIR}/OBJS
 
-LD_LIBRARY_PATH=${PROJDIR}/lib:${LIBDIR}
+LD_LIBRARY_PATH=${PROJDIR}/lib:${LIBDIR}:/usr/local/lib
 export LD_LIBRARY_PATH
 
 INCS = -I${INCDIR}/gtkextra-2.0
 INCS += -I${PROJDIR}/include
+INCS += -I/usr/local/include/gtkextra-2.0
 INCS += `pkg-config gtk+-2.0 glib-2.0 --cflags`
 
 LIBS = -lpixman-1
 LIBS += -L${PROJDIR}/lib
 LIBS += -Wl,-rpath ${PROJDIR}/lib
+LIBS += -L/usr/local/lib
 LIBS += -L${LIBDIR}
 LIBS += -Wl,-rpath ${LIBDIR}
 LIBS += `pkg-config gtk+-2.0 glib-2.0 --libs`
diff --git a/src/realtime/Packet.hpp b/src/realtime/Packet.hpp
index a83f3f9..7ee5935 100755
--- a/src/realtime/Packet.hpp
+++ b/src/realtime/Packet.hpp
@@ -24,6 +24,7 @@
 #include <workbook/cell.h>
 #include <glib.h>
 #include <string>
+#include <cstdlib>
 #include <vector>
 #include <map>
 
diff --git a/src/realtime/concurrent/ThreadGroup.cpp b/src/realtime/concurrent/ThreadGroup.cpp
index 696cd25..c3eafb4 100644
--- a/src/realtime/concurrent/ThreadGroup.cpp
+++ b/src/realtime/concurrent/ThreadGroup.cpp
@@ -19,6 +19,7 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "ThreadGroup.hpp"
+#include <algorithm>
 
 namespace concurrent {
 
diff --git a/src/realtime/proactor/Dispatcher.cpp b/src/realtime/proactor/Dispatcher.cpp
index 32d6fc8..18cc953 100644
--- a/src/realtime/proactor/Dispatcher.cpp
+++ b/src/realtime/proactor/Dispatcher.cpp
@@ -20,6 +20,7 @@
 */
 #include "Dispatcher.hpp"
 #include "Worker.hpp"
+#include <algorithm>
 
 namespace proactor {
 
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
index d46e7d9..3a081ca 100755
--- a/src/realtime/proactor/Proactor.cpp
+++ b/src/realtime/proactor/Proactor.cpp
@@ -20,6 +20,7 @@
 */
 #include "Proactor.hpp"
 #include <iostream>
+#include <algorithm>
 
 namespace proactor {
 

commit 08a3cfac6dbacf904c5c130bd747f72d654881e6
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Wed Apr 22 21:08:52 2009 +0000

    Updated code with some fixes to threading issues.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@16 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/include/workbook/cell.h b/include/workbook/cell.h
index 5ad0ec9..87a6022 100644
--- a/include/workbook/cell.h
+++ b/include/workbook/cell.h
@@ -75,6 +75,7 @@ extern "C" {
     /* Methods */
     void (*set) (Cell * cell, gint row, gint column, const gchar * value);
     void (*set_value) (Cell * cell, const gchar * value);  
+    void (*set_value_length) (Cell * cell, void * s, size_t length);
     void (*set_column) (Cell * cell, gint column);
     void (*set_row) (Cell * cell, gint row);
     void (*set_range) (Cell * cell, const GtkSheetRange * range);
diff --git a/include/workbook/sheet.h b/include/workbook/sheet.h
index e9d093a..e55d939 100644
--- a/include/workbook/sheet.h
+++ b/include/workbook/sheet.h
@@ -61,6 +61,8 @@ typedef struct _Sheet Sheet;
     gint page;
     gint attention;
     gint notices;
+    gint max_rows;
+    gint max_columns;
     gboolean has_focus;
 
     /* Methods */
diff --git a/src/application.c b/src/application.c
index 5da5e86..270e0fa 100644
--- a/src/application.c
+++ b/src/application.c
@@ -133,7 +133,7 @@ application_init (int * argc, char *** argv)
   gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
 		      "destroy",
 		      G_CALLBACK (appstate->signals[SIG_DESTROY_EVENT]),
-		      NULL);
+		      (gpointer *)appstate);
   gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
 		      "delete_event",
 		      G_CALLBACK (appstate->signals[SIG_DELETE_EVENT]),
@@ -161,6 +161,8 @@ application_method_close (ApplicationState *appstate)
 {
   ASSERT (appstate != NULL);
 
+  *appstate->shutdown = TRUE;
+  
   DESTROY (Workbook, appstate->workbook_first);
 
   /* This has to be set so that we have a sentinel variable in separate threads
@@ -169,13 +171,6 @@ application_method_close (ApplicationState *appstate)
      allocated. */
   appstate->workbook_first = appstate->workbook_last = NULL;
 
-  /* Because of a change to the Plugin architecture it will now yield until
-     all threads that were instatiated are closed properly. We use the 
-     appstate->workbook_first variable in order to test for NULL. */
-  DESTROY (Plugin, appstate->plugin_first);
-
-  appstate->plugin_first = appstate->plugin_last = NULL;
-  
   application_object_free (appstate);
 }
 
@@ -280,6 +275,7 @@ application_object_free (ApplicationState *appstate)
 {
   ASSERT (appstate != NULL);
 
+  FREE (appstate->shutdown);
   FREE (appstate->absolute_path);
   FREE (appstate);
   return appstate;
@@ -299,6 +295,8 @@ application_object_init (void)
   app->gtk_window = NULL;
   app->gtk_menu = NULL;
   app->gtk_window_vbox = NULL;
+  app->shutdown = NEW (gboolean);
+  *app->shutdown = FALSE;
 
   /* Set up the signals. */
   app->signals[SIG_NOTEBOOK_SWITCHED]
@@ -439,6 +437,18 @@ application_signal_delete_event (GtkWindow * window,
 static guint
 application_signal_destroy_event (GtkWidget *window, gpointer data)
 {
+  ApplicationState * appstate = (ApplicationState *)data;
+  *appstate->shutdown = TRUE;
+
+  /* Because of a change to the Plugin architecture it will now yield until
+     all threads that were instatiated are closed properly. We use the 
+     appstate->workbook_first variable in order to test for NULL. */
+  gdk_threads_leave();
+  DESTROY (Plugin, appstate->plugin_first);
+  gdk_threads_enter();
+
+  appstate->plugin_first = appstate->plugin_last = NULL;
+
   gtk_main_quit ();
   return FALSE;
 }
diff --git a/src/application.h b/src/application.h
index 8cd0e5d..eb4a6ef 100644
--- a/src/application.h
+++ b/src/application.h
@@ -52,6 +52,7 @@ struct _ApplicationState
   GtkWidget * gtk_menu;
   GtkWidget * gtk_window_vbox;
   gchar * absolute_path;
+  gboolean * shutdown;
 
   /* Methods */
   int (*run) (ApplicationState *);
diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
index 5cf1dde..af2f9e9 100644
--- a/src/realtime/CsvParser.cpp
+++ b/src/realtime/CsvParser.cpp
@@ -21,14 +21,15 @@
 #include "CsvParser.hpp"
 #include <workbook/sheet.h>
 #include <workbook/cell.h>
+#include <iostream>
 
 namespace realtime {
 
   struct csv_column {
     Sheet * sheet;
     Cell * cell;
-    long unsigned row;
-    long unsigned field;
+    int row;
+    int field;
     char * value;
   };
 
@@ -42,8 +43,8 @@ namespace realtime {
     Sheet * sheet = column->sheet;
 
     cell->set_row (cell, column->row);
-    cell->set_column (cell, ++column->field);
-    cell->set_value (cell, column->value);
+    cell->set_column (cell, column->field++);
+    cell->set_value_length (cell, s, length);
     sheet->apply_cell (sheet, cell);
   }
 
@@ -59,7 +60,10 @@ namespace realtime {
     this->running = true;
     struct csv_parser csv;
     struct csv_column column = {this->wb->sheet_first,
-			    this->cell, 0, 0, new char[1024]};
+				this->cell, 
+				0, 
+				0, 
+				new char[1024]};
     
     if (csv_init (&csv, CSV_STRICT) != 0) {
       std::cerr << "Failed initializing libcsv parser\n";
@@ -70,19 +74,22 @@ namespace realtime {
       while (this->inputQueue.size() > 0) {
 	std::string buf = this->inputQueue.pop();
 	size_t bytes = buf.length();
-	 
+ 
 	// Parse the CSV input
 	if ((bytes = csv_parse(&csv, 
 			       buf.c_str(), 
 			       bytes, 
 			       cb1,
 			       cb2,
-			       &column)) != buf.length()) {
-	  // Something went wrong here. Discard and continue.
-	  if (csv_error (&csv) == CSV_EPARSE) 
-	    std::cerr << "Parsing error on input:\n" << buf;
-	  continue;
+			       &column)) == bytes) {
+	  if (csv_error (&csv) == CSV_EPARSE)
+	    std::cerr << "Parsing error on input: " << buf << "\n";
 	}
+
+	csv_fini (&csv, cb1, cb2, &column);
+
+	if (column.row >= (column.sheet)->max_rows)
+	  column.row = 0;
       }
       Thread::sleep(100);
     }
diff --git a/src/realtime/Makefile b/src/realtime/Makefile
index 5a3ef51..4310a12 100755
--- a/src/realtime/Makefile
+++ b/src/realtime/Makefile
@@ -8,7 +8,7 @@ all: 	realtime
 
 realtime: ${OBJS}
 	${CX} -shared -Wl -o ${PROJDIR}/bin/realtime.so ${OBJS} ${LIBS} \
-	-lgthread-2.0 -lpthread
+	-lgthread-2.0 -lpthread -lcsv
 
 clean:		
 	${MD} ${OBJDIR}/realtime/concurrent ${OBJDIR}/realtime/network \
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
index a164c78..1cabc61 100644
--- a/src/realtime/Network.cpp
+++ b/src/realtime/Network.cpp
@@ -24,21 +24,24 @@
 #define IS_TERMINAL(c) ((*c == '\n') || (*c == '\r'))
 
 namespace realtime {
-  
+
   ConnectionThread::ConnectionThread (proactor::InputDispatcher * d, 
 				      int newfd) {
+    this->purge_socket = true;
     this->socket = new network::TcpClientSocket (newfd);
     this->dispatcher = d;
   }
 
   ConnectionThread::ConnectionThread (proactor::InputDispatcher * d,
 				      network::TcpSocket * s) {
+    this->purge_socket = false;
     this->socket = s;
     this->dispatcher = d;
   }
 
   ConnectionThread::~ConnectionThread (void) {
-    delete socket;
+    if (purge_socket == true)
+      delete socket;
   }
 
   void *
@@ -100,12 +103,11 @@ namespace realtime {
 
       ConnectionThread * c = new ConnectionThread (this->dispatcher, newfd);
       
-      if (c->start() == false) {
+      if (this->dispatcher->addWorker (c) == false) {
 	// Failed for some reason; cut out and quit for now.
 	break;
       }
 	
-      this->dispatcher->addWorker ( c );
       Thread::sleep (100);
     }
 
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
index b2240be..d29d913 100644
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -50,6 +50,7 @@ namespace realtime {
 
   class ConnectionThread : public proactor::Worker {
   private:
+    bool purge_socket;
     network::TcpSocket * socket;
   public:
     ConnectionThread (proactor::InputDispatcher * d, int newfd);
diff --git a/src/realtime/concurrent/Runnable.hpp b/src/realtime/concurrent/Runnable.hpp
index 740a859..9e9cacc 100755
--- a/src/realtime/concurrent/Runnable.hpp
+++ b/src/realtime/concurrent/Runnable.hpp
@@ -18,12 +18,12 @@
    License along with the library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
-#ifndef HPP_THREAD_RUNNABLE
-#define HPP_THREAD_RUNNABLE
+#ifndef HPP_CONCURRENT_RUNNABLE
+#define HPP_CONCURRENT_RUNNABLE
 
 class IRunnable {
 protected:
-  bool running;
+  volatile bool running;
 public:
   IRunnable (void) { this->running = false; }
   virtual ~IRunnable (void) { }
diff --git a/src/realtime/concurrent/Thread.cpp b/src/realtime/concurrent/Thread.cpp
index 2dd4af2..333b9e7 100755
--- a/src/realtime/concurrent/Thread.cpp
+++ b/src/realtime/concurrent/Thread.cpp
@@ -59,8 +59,8 @@ namespace concurrent {
   }
 
   Thread::~Thread (void) {
-    if (this->running == true)
-      this->interrupt();
+    this->running = false;
+    this->join();
   }
 
   void 
diff --git a/src/realtime/concurrent/Thread.hpp b/src/realtime/concurrent/Thread.hpp
index bcc4b1b..7b284df 100755
--- a/src/realtime/concurrent/Thread.hpp
+++ b/src/realtime/concurrent/Thread.hpp
@@ -18,8 +18,8 @@
    License along with the library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
-#ifndef HPP_THREAD_THREAD
-#define HPP_THREAD_THREAD
+#ifndef HPP_CONCURRENT_THREAD
+#define HPP_CONCURRENT_THREAD
 
 #include <shared.h>
 #include <string>
@@ -29,43 +29,45 @@
 
 namespace concurrent {
 
-class ThreadGroup;
+  class ThreadGroup;
 
-class Thread : public IRunnable {
-private:
-  ThreadGroup * group;
-  std::string name;
-  IRunnable * runner;
-  pthread_t thread;
-  bool joinable;
-  int priority;
-public:
-  Thread (ThreadGroup * group, 
-	  IRunnable * runner, 
-	  const std::string & name);
-  Thread (IRunnable * runner,
-	  const std::string & name);
-  Thread (const std::string & name);
-  Thread (void);
-  virtual ~Thread (void);
+  class Thread : public IRunnable {
+  private:
+    friend class ThreadGroup;
 
-  bool start (void);
-  void * stop (void);
-  void * join (void);
-  void interrupt (void);
-  void yield (void);
+    ThreadGroup * group;
+    std::string name;
+    IRunnable * runner;
+    pthread_t thread;
+    bool joinable;
+    int priority;
+  public:
+    Thread (ThreadGroup * group, 
+	    IRunnable * runner, 
+	    const std::string & name);
+    Thread (IRunnable * runner,
+	    const std::string & name);
+    Thread (const std::string & name);
+    Thread (void);
+    virtual ~Thread (void);
+
+    bool start (void);
+    void * stop (void);
+    void * join (void);
+    void interrupt (void);
+    void yield (void);
   
-  virtual void * run (void *);
+    virtual void * run (void *);
 
-  inline const std::string & getName (void) const { return this->name; }
-  inline int getPriority (void) const { return this->priority; }
-  inline void setPriority (int priority) { this->priority = priority; }
-  inline const ThreadGroup * getThreadGroup (void) const { 
-    return this->group; 
-  }
+    inline const std::string & getName (void) const { return this->name; }
+    inline int getPriority (void) const { return this->priority; }
+    inline void setPriority (int priority) { this->priority = priority; }
+    inline const ThreadGroup * getThreadGroup (void) const { 
+      return this->group; 
+    }
 
-  static int sleep (unsigned long ms);
-};  
+    static int sleep (unsigned long ms);
+  };  
 
 }
 
diff --git a/src/realtime/concurrent/ThreadGroup.cpp b/src/realtime/concurrent/ThreadGroup.cpp
new file mode 100644
index 0000000..696cd25
--- /dev/null
+++ b/src/realtime/concurrent/ThreadGroup.cpp
@@ -0,0 +1,106 @@
+/* 
+   ThreadGroup.cpp - ThreadGroup Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "ThreadGroup.hpp"
+
+namespace concurrent {
+
+  ThreadGroup::ThreadGroup (void) 
+    : parent(NULL), daemon(false) {
+  }
+
+  ThreadGroup::ThreadGroup (ThreadGroup * parent, const std::string & name) 
+    : daemon(false) {
+    this->parent = parent;
+    this->name = name;
+  }
+
+  ThreadGroup::ThreadGroup (const std::string & name) 
+    : parent(NULL), daemon(false) {
+    this->name = name;
+  }
+
+  ThreadGroup::~ThreadGroup (void) {
+    if (this->daemon == true) {
+      this->stop();
+    }
+  }
+
+  bool 
+  ThreadGroup::parentOf (ThreadGroup * parent) {
+    if ((this->parent == NULL) || (parent == NULL))
+      return false;
+    // Needs to be better than this. 
+    return (this->parent == parent) ? true : false;
+  } 
+    
+  bool
+  ThreadGroup::addThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+    if (it == this->threads.end()) {
+      thread->group = this;
+      this->threads.push_back (thread);
+      return true;
+    }
+    return false;
+  }
+
+  bool 
+  ThreadGroup::removeThread (Thread * thread) {
+    ThreadList::iterator it = std::find (this->threads.begin(),
+					 this->threads.end(),
+					 thread);
+
+    if (it == this->threads.end())
+      return false;
+    this->threads.erase(it);
+    return true;
+  }
+
+  void
+  ThreadGroup::interrupt (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->interrupt();
+    }
+  }
+
+  bool
+  ThreadGroup::start (void) {
+    bool rvalue = false;
+
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      rvalue = (*it++)->start();
+    }
+
+    return rvalue;
+  }
+
+  void 
+  ThreadGroup::stop (void) {
+    ThreadList::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
+      (*it++)->stop();
+    }
+  }
+} // end of namesapce
diff --git a/src/realtime/concurrent/ThreadGroup.hpp b/src/realtime/concurrent/ThreadGroup.hpp
index c42755f..c0c5e41 100755
--- a/src/realtime/concurrent/ThreadGroup.hpp
+++ b/src/realtime/concurrent/ThreadGroup.hpp
@@ -18,45 +18,42 @@
    License along with the library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
-#ifndef HPP_THREAD_THREADGROUP
-#define HPP_THREAD_THREADGROUP
+#ifndef HPP_CONCURRENT_THREADGROUP
+#define HPP_CONCURRENT_THREADGROUP
 
 #include <string>
-#include <list>
+#include "List.hpp"
 #include "Thread.hpp"
 
 namespace concurrent {
 
-class ThreadGroup {
-  friend class Thread;
-  typedef std::list<Thread *> ThreadList;
-private:
-  int maxPriority;
-  ThreadGroup * parent;
-  std::string name;
-  ThreadList threads;
-  bool daemon; 
-
-  void addThreadToGroup (Thread *);
-  void removeThreadFromGroup (Thread *);
-public:
-  ThreadGroup (const std::string &);
-  ThreadGroup (ThreadGroup *, const std::string &);
-  ~ThreadGroup (void);
-
-  bool parentOf (ThreadGroup *);
-  bool checkAccess (void);
-
-  inline bool isDaemon (void) const { return this->daemon; }
-  
-  inline const ThreadGroup * getParent (void) const { return this->parent; }
-  inline const std::string & getName (void) const { return this->name; }
-  inline int getMaxPriority (void) const { return this->maxPriority; }
-
-  inline void setMaxPriority (int priority) { this->maxPriority = priority; }
-  inline void setDaemon (bool daemon) { this->daemon = daemon; }
-};
-
-}
+  class ThreadGroup {
+  private:
+    typedef concurrent::List<Thread *> ThreadList;
+    
+    ThreadGroup * parent;
+    std::string name;
+    ThreadList threads;
+    bool daemon; 
+  public:
+    ThreadGroup (void);
+    ThreadGroup (ThreadGroup * parent, const std::string & name);
+    ThreadGroup (const std::string & name);
+    virtual ~ThreadGroup (void);
+
+    bool parentOf (ThreadGroup * parent);
+    bool addThread (Thread * thread);
+    bool removeThread (Thread * thread);
+    void interrupt (void);
+    bool start (void);
+    void stop (void);
+    
+    inline bool isDaemon (void) const { return this->daemon; }
+    inline void setDaemon (bool daemon) { this->daemon = daemon; }
+    inline const std::string & getName (void) const { return this->name; }
+    inline ThreadGroup * getParent (void) const { return this->parent; }
+  };
+
+} // end of namespace
 
 #endif
diff --git a/src/realtime/network/Tcp.cpp b/src/realtime/network/Tcp.cpp
index 18b5b7d..08cd791 100755
--- a/src/realtime/network/Tcp.cpp
+++ b/src/realtime/network/Tcp.cpp
@@ -20,10 +20,6 @@
 */
 #include "Tcp.hpp"
 #include <iostream>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <netdb.h>
 
 namespace network {
 
@@ -130,34 +126,25 @@ namespace network {
 
   bool
   TcpClientSocket::connect (const char * host, int port) {
-    struct sockaddr_in servAddr;
-    struct hostent * h;
-
     if (!host || (*host == '\0'))
       return false;
 
-    if (this->sockfd < 0)
-      return false;
-    
-    if ((h = ::gethostbyname (host)) == NULL)
+    if ((this->hp = ::gethostbyname (host)) == NULL)
       return false;
+ 
+    // Copy over the hostname address.
+    memset (&(this->sockaddr),0, sizeof (this->sockaddr));
+    this->sockaddr.sin_family = AF_INET;
+    this->sockaddr.sin_addr.s_addr 
+      = ((struct in_addr *)(this->hp->h_addr))->s_addr;
+    this->sockaddr.sin_port = htons (port);
 
-    servAddr.sin_family = h->h_addrtype;
-    memcpy ((char *)&(servAddr.sin_addr.s_addr),
-	    h->h_addr_list[0],
-	    h->h_length);
-    servAddr.sin_port = htons (port);
-    
-    if (::bind (this->sockfd,
-		(struct sockaddr *)&(this->sockaddr),
-		sizeof (this->sockaddr)) < 0)
-      return false;
-    
     if (::connect (this->sockfd,
 		   (struct sockaddr *)&(this->sockaddr),
-		   sizeof (this->sockaddr)) < 0)
+		   sizeof (struct sockaddr)) < 0)
       return false;
-    return true;  
+    
+    return true;
   }
 
   void
diff --git a/src/realtime/network/Tcp.hpp b/src/realtime/network/Tcp.hpp
index de8c160..552f93f 100755
--- a/src/realtime/network/Tcp.hpp
+++ b/src/realtime/network/Tcp.hpp
@@ -24,6 +24,10 @@
 #include "Socket.hpp"
 #include <arpa/inet.h>
 #include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <netdb.h>
 
 namespace network {
 
@@ -62,6 +66,8 @@ namespace network {
   };
   
   class TcpClientSocket : public TcpSocket {
+  private:
+    struct hostent * hp;
   public:
     TcpClientSocket (void);
     TcpClientSocket (int newfd);
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
index 4dff5c2..0ca1514 100755
--- a/src/realtime/plugin_main.cpp
+++ b/src/realtime/plugin_main.cpp
@@ -56,6 +56,7 @@ extern "C"
     ThreadArgs args;
     args.push_back( (void *)wb );
     args.push_back( (void *)app->cfg );
+    args.push_back( (void *)app->shutdown );
 
     if (plugin->create_thread (plugin, 
 			       (GThreadFunc)thread_main,
diff --git a/src/realtime/proactor/Dispatcher.cpp b/src/realtime/proactor/Dispatcher.cpp
index a20db5b..32d6fc8 100644
--- a/src/realtime/proactor/Dispatcher.cpp
+++ b/src/realtime/proactor/Dispatcher.cpp
@@ -23,12 +23,23 @@
 
 namespace proactor {
 
+  Dispatcher::~Dispatcher (void) {
+      
+  }
+   
   bool
   Dispatcher::addWorker (Worker * w) {
-    this->workers.push_back (w);
-    return w->start();
+    WorkerListType::iterator it = std::find (this->workers.begin(),
+					     this->workers.end(),
+					     w);
+    if (it == this->workers.end())
+      {
+	this->workers.push_back (w);
+	return w->start();
+      }
+    return false;
   }
-
+  
   bool
   Dispatcher::removeWorker (Worker * w) {
     WorkerListType::iterator it = std::find (this->workers.begin(),
diff --git a/src/realtime/proactor/Dispatcher.hpp b/src/realtime/proactor/Dispatcher.hpp
index cfc350b..259fbbd 100755
--- a/src/realtime/proactor/Dispatcher.hpp
+++ b/src/realtime/proactor/Dispatcher.hpp
@@ -29,7 +29,7 @@ namespace proactor {
   class Worker;
 
   class Dispatcher : public concurrent::Thread {
-  private:
+  protected:
     typedef concurrent::List<Worker *> WorkerListType;
 
     WorkerListType workers;
diff --git a/src/realtime/proactor/Event.cpp b/src/realtime/proactor/Event.cpp
index 1d5b755..6c8f45f 100755
--- a/src/realtime/proactor/Event.cpp
+++ b/src/realtime/proactor/Event.cpp
@@ -33,5 +33,8 @@ namespace proactor {
   Event::uniqueEventId (void) {
     return Event::numEvents++;
   }
+
+  EventDispatcher::~EventDispatcher (void) {
+  }
  
 } // end of namespace
diff --git a/src/realtime/proactor/Event.hpp b/src/realtime/proactor/Event.hpp
index 2ab3261..09133bc 100755
--- a/src/realtime/proactor/Event.hpp
+++ b/src/realtime/proactor/Event.hpp
@@ -42,7 +42,7 @@ namespace proactor {
   private:
     int eventId;
   public:
-    virtual ~EventDispatcher (void) { }
+    virtual ~EventDispatcher (void);
 
     inline void setEventId (int e) { 
       this->eventId = e;
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
index 3362504..d46e7d9 100755
--- a/src/realtime/proactor/Proactor.cpp
+++ b/src/realtime/proactor/Proactor.cpp
@@ -30,24 +30,24 @@ namespace proactor {
     // Remove all of the lists of event handlers.
     {
       EventMapType::iterator it = this->eventsToHandlers.begin();
-      while (it != this->eventsToHandlers.end())
-	{
+      while (it != this->eventsToHandlers.end()) {
 	  WorkerListType * q = (it->second);
 	  delete q;
 	  it++;
 	}
     }
-
+ 
     // Handle the dispatchers that have not been manually removed.
     {
       DispatcherList::iterator it = this->dispatchers.begin();
       while (it != this->dispatchers.end())
 	{
-	  InputDispatcher * d = (*it);
+	  Dispatcher * d = (*it);
 	  delete d;
 	  it++;
 	}
     }
+  
   }
 
   bool
@@ -67,12 +67,12 @@ namespace proactor {
 
   void
   Proactor::onReadComplete (Event e) {
-    this->inputQueue.push (e);
+    this->events.push (e);
   }
 
   void 
   Proactor::onReadComplete (int e, const char * buf) {
-    this->inputQueue.push ( Event (e, std::string (buf)) );   
+    this->events.push ( Event (e, std::string (buf)) );   
   }
 
   bool
@@ -98,12 +98,12 @@ namespace proactor {
   }
 
   void
-  Proactor::addDispatcher (InputDispatcher * d) {
+  Proactor::addDispatcher (Dispatcher * d) {
     this->dispatchers.push_back (d);
   }
 
   bool
-  Proactor::removeDispatcher (InputDispatcher * d) {
+  Proactor::removeDispatcher (Dispatcher * d) {
     DispatcherList::iterator it = std::find (this->dispatchers.begin(),
 					     this->dispatchers.end(),
 					     d);
@@ -121,12 +121,11 @@ namespace proactor {
   
     WorkerListType::iterator it;
 
-    while (this->running == true)
-      {
-	this->inputQueue.lock();
-	while (this->inputQueue.size() > 0)
-	  {
-	    Event e = this->inputQueue.pop();
+    while (this->running == true) {
+	this->events.lock();
+
+	while (this->events.size() > 0) {
+	    Event e = this->events.pop();
 
 	    // We are throwing events with no handlers to catch them.
 	    if (this->eventsToHandlers.find (e.id) == 
@@ -135,8 +134,7 @@ namespace proactor {
  
 	    it = this->eventsToHandlers[e.id]->begin();
 	  
-	    while (it != this->eventsToHandlers[e.id]->end())
-	      {
+	    while (it != this->eventsToHandlers[e.id]->end()) {
 		Worker * j = (*it);
 	      
 		j->pushInputQueue (e.buf);
@@ -144,7 +142,7 @@ namespace proactor {
 		it++;
 	      }
 	  }
-	this->inputQueue.unlock();
+	this->events.unlock();
       
 	Thread::sleep(100);
       }
diff --git a/src/realtime/proactor/Proactor.hpp b/src/realtime/proactor/Proactor.hpp
index d66465d..3a33688 100755
--- a/src/realtime/proactor/Proactor.hpp
+++ b/src/realtime/proactor/Proactor.hpp
@@ -29,27 +29,26 @@
 #include "Event.hpp"
 #include "Dispatcher.hpp"
 #include "InputDispatcher.hpp"
-#include <list>
-#include <queue>
 
 namespace proactor {
 
-  class Proactor : public InputDispatcher {
+  class Proactor : public Dispatcher {
   private:
-    typedef std::list<Worker *> WorkerListType;
-    typedef concurrent::List<InputDispatcher *> DispatcherList;
+    typedef concurrent::List<Dispatcher *> DispatcherList;
     typedef concurrent::Map<int, WorkerListType *> EventMapType;
-    
+    typedef concurrent::Queue<Event> EventQueueType;
+
     EventMapType eventsToHandlers;
     DispatcherList dispatchers;
+    EventQueueType events;
   public:
     Proactor (void);
     virtual ~Proactor (void);
 
     bool addWorker (int e, Worker * w);
     bool removeWorker (int e, Worker * w);
-    void addDispatcher (InputDispatcher * d);
-    bool removeDispatcher (InputDispatcher * d);
+    void addDispatcher (Dispatcher * d);
+    bool removeDispatcher (Dispatcher * d);
     
     void * run (void * null);
  
@@ -57,7 +56,7 @@ namespace proactor {
     void onReadComplete (int e, const char * buf);
 
     inline const std::string & peekInputQueue (void) {
-      return (this->inputQueue.front()).buf;
+      return (this->events.front()).buf;
     }
   };
 
diff --git a/src/realtime/proactor/Worker.cpp b/src/realtime/proactor/Worker.cpp
new file mode 100644
index 0000000..19903da
--- /dev/null
+++ b/src/realtime/proactor/Worker.cpp
@@ -0,0 +1,28 @@
+/* 
+   Worker.cpp - Worker Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Worker.hpp"
+
+namespace proactor {
+
+  Worker::~Worker (void) {
+  }
+
+} // end of namesapce
diff --git a/src/realtime/proactor/Worker.hpp b/src/realtime/proactor/Worker.hpp
index 3c22639..5810e5e 100644
--- a/src/realtime/proactor/Worker.hpp
+++ b/src/realtime/proactor/Worker.hpp
@@ -36,6 +36,8 @@ namespace proactor {
     InputDispatcher * dispatcher;
     InputQueueType inputQueue;
   public:
+    virtual ~Worker (void);
+
     inline void pushInputQueue (std::string buf) {
       this->inputQueue.push (buf);
     }
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index 0f53761..8d73b8d 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -28,6 +28,7 @@
 #include <iostream>
 #include <sstream>
 #include <string>
+#include "concurrent/Thread.hpp"
 #include "concurrent/ThreadArgs.hpp"
 #include "proactor/Proactor.hpp"
 #include "proactor/Event.hpp"
@@ -54,6 +55,7 @@ void
 thread_main (ThreadArgs * args) {
   Workbook * wb = (Workbook *)args->at(0);
   Config * cfg  = (Config *)args->at(1);
+  gboolean * SHUTDOWN = (gboolean *)args->at(2);
 
   ConfigPair * logpath = cfg->get_pair (cfg, "realtime", "log", "path");
   if (IS_NULL (logpath)) {
@@ -95,7 +97,7 @@ thread_main (ThreadArgs * args) {
     }
 
   network::TcpClientSocket client;
-  if (client.connect ("127.0.0.1", 50000) == false)
+  if (client.connect ("localhost", 50000) == false)
     {
       g_critical ("Failed connecting to TcpClientSocket");
       return;
@@ -104,65 +106,59 @@ thread_main (ThreadArgs * args) {
   // Get a unique event identifier that will be used throughout.
   int csvEventID = proactor::Event::uniqueEventId();
   int pktEventID = proactor::Event::uniqueEventId();
-
+  
   proactor::Proactor proactor;
   NetworkCsvReceiver csvDispatcher (csvEventID, &proactor);
   NetworkPktReceiver pktDispatcher (pktEventID, &proactor);
   AcceptThread acceptor (socket.newAcceptor(), &pktDispatcher);
   ConnectionThread creader (&csvDispatcher, &client);
-  PacketParser packet_worker (wb, pktlog, atoi(verbosity->value));
+  PacketParser pkt_worker (wb, pktlog, atoi(verbosity->value));
   CsvParser csv_worker (wb, pktlog, atoi(verbosity->value));
 
-  if (proactor.addWorker (pktEventID, &packet_worker) == false) {
-      g_critical ("Failed starting packet parser worker; exiting thread.");
-      return;
-    }
-
-  if (proactor.addWorker (csvEventID, &csv_worker) == false) {
-      g_critical ("Failed starting csv parser worker; exiting thread.");
-      return;
-    }
-
   if (proactor.start() == false) {
       g_critical ("Failed starting Proactor; exiting thread.");
       return;
     }
 
+  if (proactor.addWorker (pktEventID, &pkt_worker) == false) {
+    g_critical ("Failed starting packet parser worker; exiting thread.");
+    return;
+  }
+
+  if (proactor.addWorker (csvEventID, &csv_worker) == false) {
+    g_critical ("Failed starting csv parser worker; exiting thread.");
+    return;
+  }
+  
   if (pktDispatcher.start() == false) {
       g_critical ("Failed starting network; exiting thread.");
       return;
     }
 
+  if (pktDispatcher.addWorker (&acceptor) == false) {
+    g_critical ("Failed starting acceptor; exiting thread.");
+    return;
+  }
+  
   if (csvDispatcher.start() == false) {
       g_critical ("Failed starting network; exiting thread.");
       return;
     }
-
-  if (pktDispatcher.addWorker (&acceptor) == false) {
-      g_critical ("Failed starting acceptor; exiting thread.");
-      return;
-    }
-
+  
+  
   if (csvDispatcher.addWorker (&creader) == false) {
-    g_critical ("Failed starting client; exiting thread.");
+    g_critical ("Failed starting client reader; exiting thread.");
     return;
   }
-  
-  while (!IS_NULLSTR (wb->filename)) {
-      // Continually sleep basically until our application terminates.
-      ::sleep (1);
-    }
 
-  FCLOSE (pktlog);
+  while (*SHUTDOWN == FALSE) {
+    // Continually sleep basically until our application terminates.
+    concurrent::Thread::sleep (100);
+  }
 
   socket.close();  
+  client.close();
 
-  // Interrupt threads immediately canceling them so we can quit.
-  acceptor.interrupt();
-  packet_worker.interrupt();
-  csv_worker.interrupt();
-  csvDispatcher.interrupt();
-  pktDispatcher.interrupt();
-  proactor.interrupt();
-}
 
+  FCLOSE (pktlog);
+}
diff --git a/workbook/cell.c b/workbook/cell.c
index 6dbff41..52147ff 100755
--- a/workbook/cell.c
+++ b/workbook/cell.c
@@ -5,6 +5,7 @@
 static Cell *cell_object_init (void);
 static void cell_object_free (Cell *);
 static void cell_method_set_value (Cell *, const gchar *);
+static void cell_method_set_value_length (Cell *, void *, size_t);
 static void cell_method_set_column (Cell *, gint);
 static void cell_method_set_row (Cell *, gint);
 static void cell_method_set_all (Cell *, gint, gint, const gchar *);
@@ -39,6 +40,7 @@ cell_object_init (void)
   cell->set_attributes = cell_method_set_attributes;
   cell->set_range = cell_method_set_range;
   cell->set_value = cell_method_set_value;
+  cell->set_value_length = cell_method_set_value_length;
   cell->set_column = cell_method_set_column;
   cell->set_row = cell_method_set_row;
   cell->set = cell_method_set_all;
@@ -173,6 +175,14 @@ cell_method_set_value (Cell * cell,
 }
 
 static void
+cell_method_set_value_length (Cell * cell, void * s, size_t length) {
+  ASSERT (cell != NULL);
+
+  g_string_assign (cell->value, "");
+  g_string_append_len (cell->value, (const char *)s, length);
+}
+
+static void
 cell_method_destroy (Cell * cell)
 {
   g_return_if_fail (cell != NULL);
diff --git a/workbook/sheet.c b/workbook/sheet.c
index 308e60c..c60d6d6 100644
--- a/workbook/sheet.c
+++ b/workbook/sheet.c
@@ -105,6 +105,8 @@ sheet_object_init (Workbook * book,
   sheet->notices = 0;
   sheet->has_focus = FALSE;
   sheet->next = sheet->prev = NULL;
+  sheet->max_rows = rows;
+  sheet->max_columns = columns;
 
   /* Methods */
   sheet->destroy = sheet_method_destroy;
diff --git a/workbook/workbook.c b/workbook/workbook.c
index f7a7d9c..15baf6c 100644
--- a/workbook/workbook.c
+++ b/workbook/workbook.c
@@ -90,6 +90,7 @@ workbook_method_get_sheet (Workbook * wb, const gchar * sheet)
     {
       ITERATE_BEGIN (Sheet, wb->sheet_first);
       {
+	if (!sheet) return NULL;
 	if (!strcmp (sheet, it->name))
 	  return it;
       }
@@ -114,7 +115,7 @@ workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
 		 sheet->name, wb->filename);
       return;
     }
-
+  
   ITERATE_BEGIN (Sheet, wb->sheet_first);
   {
     /* Remove the sheet from the GtkNotebook */

commit d6579af0622a639ff3a71c819d35289d935b6fdc
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Thu Apr 16 00:30:53 2009 +0000

    Added more Csv Parsing logic and attempting to work out some problems with Proactor.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@15 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/bin/socketTest.py b/bin/socketTest.py
index d4bf6a8..e4f696c 100644
--- a/bin/socketTest.py
+++ b/bin/socketTest.py
@@ -19,7 +19,7 @@ def main():
     sock.sendall ("^0^1^sheet1^10000^11\n")
     
     while ii < 10000:
-        sock.sendall ("^%d^0^sheet1^0^0^^0\n" %ii)
+        sock.sendall ("^%d^0^sheet1^%d^0^^0\n" %(ii, ii))
         ii = ii + 1
 
     sock.close()
diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
index 545077c..5cf1dde 100644
--- a/src/realtime/CsvParser.cpp
+++ b/src/realtime/CsvParser.cpp
@@ -1,24 +1,65 @@
+/*
+   CsvParser.cpp - CSV Parser Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "CsvParser.hpp"
+#include <workbook/sheet.h>
+#include <workbook/cell.h>
 
 namespace realtime {
 
+  struct csv_column {
+    Sheet * sheet;
+    Cell * cell;
+    long unsigned row;
+    long unsigned field;
+    char * value;
+  };
+
   /* This structure is due to the libcsv parser; it uses function pointers to
      do any work inside of an actual tuple. So the cb1 is called after a field
      is parsed and cb2 is called after a tuple/row is parsed. */
   static void 
   cb1 (void * s, size_t length, void * data) {
-    
+    struct csv_column * column = (struct csv_column *)data;
+    Cell * cell = column->cell;
+    Sheet * sheet = column->sheet;
+
+    cell->set_row (cell, column->row);
+    cell->set_column (cell, ++column->field);
+    cell->set_value (cell, column->value);
+    sheet->apply_cell (sheet, cell);
   }
 
   static void
   cb2 (int c, void * data) {
-    
+    struct csv_column * column = (struct csv_column *)data;
+    column->row++;
+    column->field = 0;
   }
 
   void *
   CsvParser::run (void * null) {
     this->running = true;
     struct csv_parser csv;
+    struct csv_column column = {this->wb->sheet_first,
+			    this->cell, 0, 0, new char[1024]};
     
     if (csv_init (&csv, CSV_STRICT) != 0) {
       std::cerr << "Failed initializing libcsv parser\n";
@@ -36,15 +77,18 @@ namespace realtime {
 			       bytes, 
 			       cb1,
 			       cb2,
-			       this->cell)) != buf.length()) {
+			       &column)) != buf.length()) {
 	  // Something went wrong here. Discard and continue.
 	  if (csv_error (&csv) == CSV_EPARSE) 
 	    std::cerr << "Parsing error on input:\n" << buf;
 	  continue;
 	}
       }
+      Thread::sleep(100);
     }
     csv_free (&csv);
+    delete column.value;
     return NULL;
   }
-}
+
+} // end of namespace
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
index 90a38c3..2293dad 100644
--- a/src/realtime/CsvParser.hpp
+++ b/src/realtime/CsvParser.hpp
@@ -1,3 +1,23 @@
+/*
+   CsvParser.cpp - CSV Parser Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_CSVPARSER
 #define HPP_CSVPARSER
 
@@ -15,11 +35,13 @@ namespace realtime {
     Workbook * wb;
     FILE * pktlog;
     Cell * cell;
+    int verbosity;
   public:
-    CsvParser (Workbook * wb, FILE * pktlog) {
+    CsvParser (Workbook * wb, FILE * pktlog, int verbosity) {
       this->wb = wb;
       this->pktlog = pktlog;
       this->cell = cell_new();
+      this->verbosity = verbosity;
     }
 
     virtual ~CsvParser (void) {
@@ -28,5 +50,7 @@ namespace realtime {
 
     void * run (void * null);
   };
-}
+
+} // end of namespace
+
 #endif
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
index 75cd57b..a164c78 100644
--- a/src/realtime/Network.cpp
+++ b/src/realtime/Network.cpp
@@ -25,43 +25,15 @@
 
 namespace realtime {
   
-  Connection::Connection (int sockfd) {
-    this->sockfd = sockfd;
-  }
-
-  Connection::~Connection (void) {
-  }
-
-  NetworkDispatcher::NetworkDispatcher (proactor::Proactor * pro) {
-    this->pro = pro;
-  }
-  
-  NetworkDispatcher::~NetworkDispatcher (void) {
-  }
-
-  void *
-  NetworkDispatcher::run (void * null) {
-    this->running = true;
-
-    while (this->running == true) {
-      // Dispatch all of the input items on the queue.
-      this->inputQueue.lock();
-
-      while (this->inputQueue.size() > 0) {
-	// For right now all we're doing is pushing up the chain.
-	this->pro->onReadComplete ( this->inputQueue.pop() );
-      }
-
-      this->inputQueue.unlock();
-
-      Thread::sleep(100);
-    }
-  
-    return NULL; 
+  ConnectionThread::ConnectionThread (proactor::InputDispatcher * d, 
+				      int newfd) {
+    this->socket = new network::TcpClientSocket (newfd);
+    this->dispatcher = d;
   }
 
-  ConnectionThread::ConnectionThread (proactor::Dispatcher * d, int newfd) {
-    this->socket = new Connection (newfd);
+  ConnectionThread::ConnectionThread (proactor::InputDispatcher * d,
+				      network::TcpSocket * s) {
+    this->socket = s;
     this->dispatcher = d;
   }
 
@@ -73,43 +45,39 @@ namespace realtime {
   ConnectionThread::run (void * null) {
     this->running = true;
     int size = 0;
-    char buf[MAX_INPUT_SIZE];
-    char * p = NULL, * q = NULL;
+    size_t pos = 0;
+    char * buf = new char[MAX_INPUT_SIZE];
+    std::string packet;
 
     while (this->running == true) {
-      if ((size = this->socket->receive (&buf[0], MAX_INPUT_SIZE)) <= 0) {
-	// 
-	break;
-      }
+      packet.clear();
 
-      buf[size] = 0;
-      
-      q = p = &buf[0];
+      while ((size = this->socket->receive (buf, MAX_INPUT_SIZE)) > 0) {
 
-      while (p && (*p != '\0')) {
-	  if (IS_TERMINAL (p)) {
-	      *p = 0;
+	if (size == -1) {
+	  this->running = false;
+	  break;
+	}
 
-	      if (*(p+1) == '\n')
-		p++;
+	*(buf+size) = 0;
+	packet.append(buf);
 
-	      this->dispatcher->onReadComplete (q);
-	      
-	      q = (++p);
-	      continue;
-	  }
-	  p++;
+	while ((pos = packet.find_first_of('\n')) != std::string::npos) {
+	  this->dispatcher->onReadComplete (packet.substr (0, pos));
+	  packet = packet.substr (pos+1, packet.length());
+	}
       }
-      
+
       Thread::sleep (100);
     }
 
     this->dispatcher->removeWorker (this);
+    delete buf;
     return NULL;
   }
 
-  AcceptThread::AcceptThread (TcpServerSocket::Acceptor * acceptor,
-			      proactor::Dispatcher * dispatcher) {
+  AcceptThread::AcceptThread (network::TcpServerSocket::Acceptor * acceptor,
+			      proactor::InputDispatcher * dispatcher) {
     this->dispatcher = dispatcher;
     this->acceptor = acceptor;
   }
@@ -143,4 +111,5 @@ namespace realtime {
 
     return NULL;
   }
-}
+
+} // end of namespace
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
index f31dfc6..b2240be 100644
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -23,33 +23,37 @@
 
 #include "network/Tcp.hpp"
 #include "proactor/Worker.hpp"
-#include "proactor/Dispatcher.hpp"
 #include "proactor/Proactor.hpp"
 #include <iostream>
 
-#define MAX_INPUT_SIZE 4194304
+#define MAX_INPUT_SIZE 1024
 
 namespace realtime {
 
-  class Connection : public TcpSocket {
+  class NetworkCsvReceiver : public proactor::InputDispatcher {
   public:
-    Connection (int sockfd); 
-    virtual ~Connection (void);
+    NetworkCsvReceiver (int e, proactor::Proactor * pro) {
+      this->pro = pro;
+      setEventId(e);
+    }
+    virtual ~NetworkCsvReceiver (void) { }
   };
 
-  class NetworkDispatcher : public proactor::Dispatcher {
+  class NetworkPktReceiver : public proactor::InputDispatcher {
   public:
-    NetworkDispatcher (proactor::Proactor * pro);
-    virtual ~NetworkDispatcher (void);
-    
-    void * run (void * null);
+    NetworkPktReceiver (int e, proactor::Proactor * pro) {
+      this->pro = pro;
+      setEventId(e);
+    }
+    virtual ~NetworkPktReceiver (void) { }
   };
 
   class ConnectionThread : public proactor::Worker {
   private:
-    Connection * socket;
+    network::TcpSocket * socket;
   public:
-    ConnectionThread (proactor::Dispatcher * dispatcher, int newfd);
+    ConnectionThread (proactor::InputDispatcher * d, int newfd);
+    ConnectionThread (proactor::InputDispatcher * d, network::TcpSocket * s);
     virtual ~ConnectionThread (void);
   
     void * run (void * null);
@@ -57,13 +61,15 @@ namespace realtime {
 
   class AcceptThread : public proactor::Worker {
   private:
-    TcpServerSocket::Acceptor * acceptor;
+    network::TcpServerSocket::Acceptor * acceptor;
   public:
-    AcceptThread (TcpServerSocket::Acceptor * acceptor,
-		  proactor::Dispatcher * dispatcher);
+    AcceptThread (network::TcpServerSocket::Acceptor * acceptor,
+		  proactor::InputDispatcher * dispatcher);
     virtual ~AcceptThread (void);
 
     void * run (void * null);
   };
-}
+
+} // end of namespace
+
 #endif
diff --git a/src/realtime/Packet.hpp b/src/realtime/Packet.hpp
index 012a9d7..a83f3f9 100755
--- a/src/realtime/Packet.hpp
+++ b/src/realtime/Packet.hpp
@@ -69,5 +69,7 @@ namespace realtime {
     }
     inline size_t size (void) const { return this->fields.size(); }
   };
-}
+
+} // end of namespace
+
 #endif
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index 5c63976..7ce4b09 100644
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -249,5 +249,7 @@ namespace realtime {
       return NULL;
     }
   };
-}
+
+} // end of namespace
+
 #endif
diff --git a/src/realtime/concurrent/List.hpp b/src/realtime/concurrent/List.hpp
index 238405e..dd9339c 100755
--- a/src/realtime/concurrent/List.hpp
+++ b/src/realtime/concurrent/List.hpp
@@ -29,6 +29,7 @@ namespace concurrent {
   template <typename T>
   class List : public RecursiveMutex, public std::list<T> {
   };
-}
+
+} // end of namespace
 
 #endif
diff --git a/src/realtime/concurrent/Map.hpp b/src/realtime/concurrent/Map.hpp
index 9218f5c..ae5d1c3 100755
--- a/src/realtime/concurrent/Map.hpp
+++ b/src/realtime/concurrent/Map.hpp
@@ -38,5 +38,7 @@ namespace concurrent {
   public:
     Map (void) : RecursiveMutex() { }
   };
-}
+
+} // end of namespace
+
 #endif
diff --git a/src/realtime/concurrent/Mutex.cpp b/src/realtime/concurrent/Mutex.cpp
index 1708bc2..d188509 100755
--- a/src/realtime/concurrent/Mutex.cpp
+++ b/src/realtime/concurrent/Mutex.cpp
@@ -19,72 +19,73 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "Mutex.hpp"
-using namespace concurrent;
-
-IMutex::IMutex (void) {
-  this->mutex = NULL;
-  this->attrib = NULL;
-}
-
-IMutex::IMutex (const IMutex & m) {
-  this->mutex = m.mutex;
-  this->attrib = m.attrib;
-}
-
-IMutex::~IMutex (void) {
-}
-
-IMutex & 
-IMutex::operator= (const IMutex & m) {
-  this->mutex = m.mutex;
-  this->attrib = m.attrib;
-  return *this;
-}
-
-void
-IMutex::lock (void) {
-  pthread_mutex_lock (this->mutex);
-}
-
-void 
-IMutex::unlock (void) {
-  pthread_mutex_unlock (this->mutex);
-}
-
-bool
-IMutex::trylock (void) {
-  return (pthread_mutex_trylock (this->mutex) == 0) ?
-    true : false;
-}
-		      
-/****************************************************************************/
-
-RecursiveMutex::RecursiveMutex (void) {
-  this->mutex = new pthread_mutex_t;
-  this->attrib = new pthread_mutexattr_t;
-
-  pthread_mutexattr_init (this->attrib);
-  pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+
+namespace concurrent {
+
+  IMutex::IMutex (void) {
+    this->mutex = NULL;
+    this->attrib = NULL;
+  }
+
+  IMutex::IMutex (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+  }
+
+  IMutex::~IMutex (void) {
+  }
+
+  IMutex & 
+  IMutex::operator= (const IMutex & m) {
+    this->mutex = m.mutex;
+    this->attrib = m.attrib;
+    return *this;
+  }
+
+  void
+  IMutex::lock (void) {
+    pthread_mutex_lock (this->mutex);
+  }
+
+  void 
+  IMutex::unlock (void) {
+    pthread_mutex_unlock (this->mutex);
+  }
+
+  bool
+  IMutex::trylock (void) {
+    return (pthread_mutex_trylock (this->mutex) == 0) ?
+      true : false;
+  }
   
-  pthread_mutex_init (this->mutex, attrib);
-}
+  RecursiveMutex::RecursiveMutex (void) {
+    this->mutex = new pthread_mutex_t;
+    this->attrib = new pthread_mutexattr_t;
+
+    pthread_mutexattr_init (this->attrib);
+    pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+    
+    pthread_mutex_init (this->mutex, attrib);
+  }
+
+  RecursiveMutex::~RecursiveMutex (void) {
+    pthread_mutex_destroy (this->mutex);
+    pthread_mutexattr_destroy (this->attrib);
 
-RecursiveMutex::~RecursiveMutex (void) {
-  pthread_mutex_destroy (this->mutex);
-  pthread_mutexattr_destroy (this->attrib);
+    delete this->mutex;
+    delete this->attrib;
+  }
 
-  delete this->mutex;
-  delete this->attrib;
-}
+  Mutex::Mutex (void) {
+    this->mutex = new pthread_mutex_t;
 
-Mutex::Mutex (void) {
-  this->mutex = new pthread_mutex_t;
+    pthread_mutex_init (this->mutex, NULL);
+  }
 
-  pthread_mutex_init (this->mutex, NULL);
-}
+  Mutex::~Mutex (void) {
+    pthread_mutex_destroy (this->mutex);
 
-Mutex::~Mutex (void) {
-  pthread_mutex_destroy (this->mutex);
+    delete this->mutex;
+  }
 
-  delete this->mutex;
-}
+} // end of namespace
diff --git a/src/realtime/concurrent/Semaphore.cpp b/src/realtime/concurrent/Semaphore.cpp
index 668dce1..09f0172 100755
--- a/src/realtime/concurrent/Semaphore.cpp
+++ b/src/realtime/concurrent/Semaphore.cpp
@@ -19,22 +19,26 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "Semaphore.hpp"
-using namespace concurrent;
 
-Semaphore::Semaphore (void) {
-  sem_init (&this->semaphore, 0, 0);
-}
+namespace concurrent {
 
-Semaphore::~Semaphore (void) {
-  sem_destroy (&this->semaphore);
-}
+  Semaphore::Semaphore (void) {
+    sem_init (&this->semaphore, 0, 0);
+  }
 
-void
-Semaphore::acquire (void) {
-  sem_wait (&this->semaphore);
-}
+  Semaphore::~Semaphore (void) {
+    sem_destroy (&this->semaphore);
+  }
+
+  void
+  Semaphore::acquire (void) {
+    sem_wait (&this->semaphore);
+  }
+
+  void
+  Semaphore::release (void) {
+    sem_post (&this->semaphore);
+  }
+
+} // end of namespace
 
-void
-Semaphore::release (void) {
-  sem_post (&this->semaphore);
-}
diff --git a/src/realtime/concurrent/Thread.cpp b/src/realtime/concurrent/Thread.cpp
index 07e5721..2dd4af2 100755
--- a/src/realtime/concurrent/Thread.cpp
+++ b/src/realtime/concurrent/Thread.cpp
@@ -22,117 +22,110 @@
 #include "ThreadGroup.hpp"
 #include <iostream>
 #include <ctime>
-using namespace concurrent;
-
-static void *
-thread_run (void * runner) {
-  void * rvalue = ((IRunnable *)runner)->run (NULL);
-  return rvalue;
-}
-
-Thread::Thread (ThreadGroup * group,
-		IRunnable * runner, 
-		const std::string & name) {
-  this->group = group;
-  this->runner = runner;
-  this->name = name;
-  this->running = false;
-}
-
-Thread::Thread (IRunnable * runner,
-		const std::string & name) {
-  this->group = NULL;
-  this->runner = runner;
-  this->name = name;
-  this->running = false;
-}
-
-Thread::Thread (const std::string & name) {
-  this->group = NULL;
-  this->runner = NULL;
-  this->name = name;
-  this->running = false;
-}
-
-Thread::Thread (void) {
-  this->group = NULL;
-  this->runner = NULL;
-  this->name.clear();
-  this->running = false;
-}
-
-Thread::~Thread (void) {
-  if (this->running == true)
-    this->interrupt();
-}
-
-void
-Thread::interrupt (void) {
-  pthread_cancel (this->thread);
-  pthread_detach (this->thread);
-}
-
-void
-Thread::yield (void) {
-  pthread_yield();
-}
-
-void *
-Thread::stop (void) {
-  this->running = false;
-  return this->join();
-}
-
-int
-Thread::sleep (unsigned long ms) {
-  struct timespec req = {0};
-  time_t sec = (int)(ms/1000);
-  ms = ms - (sec*1000);
-  req.tv_sec = sec;
-  req.tv_nsec = ms*1000000L;
-  while (nanosleep (&req, &req) == -1)
-    continue;
-  return 1;
-}
-
-bool
-Thread::start (void) {
-  if (this->running == true)
-    return false;
-
-  if (this->runner != NULL)
-    {
+
+namespace concurrent {
+
+  static void *
+  thread_run (void * runner) {
+    void * rvalue = ((IRunnable *)runner)->run (NULL);
+    return rvalue;
+  }
+
+  Thread::Thread (ThreadGroup * group,
+		  IRunnable * runner, 
+		  const std::string & name) {
+    this->group = group;
+    this->runner = runner;
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (IRunnable * runner,
+		  const std::string & name) 
+    : group(NULL) {
+    this->runner = runner;
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (const std::string & name) 
+    : group(NULL), runner(NULL) {
+    this->name = name;
+    this->running = false;
+  }
+
+  Thread::Thread (void) : group(NULL), runner(NULL) {
+    this->running = false;
+  }
+
+  Thread::~Thread (void) {
+    if (this->running == true)
+      this->interrupt();
+  }
+
+  void 
+  Thread::interrupt (void) {
+    pthread_cancel (this->thread);
+    pthread_detach (this->thread);
+  }
+
+  void 
+  Thread::yield (void) {
+    pthread_yield();
+  }
+
+  void * 
+  Thread::stop (void) {
+    this->running = false;
+    return this->join();
+  }
+
+  int 
+  Thread::sleep (unsigned long ms) {
+    struct timespec req = {0};
+    time_t sec = (int)(ms/1000);
+    ms = ms - (sec*1000);
+    req.tv_sec = sec;
+    req.tv_nsec = ms*1000000L;
+    while (nanosleep (&req, &req) == -1)
+      continue;
+    return 1;
+  }
+
+  bool 
+  Thread::start (void) {
+    if (this->running == true)
+      return false;
+
+    if (this->runner != NULL) {
       if (pthread_create (&this->thread,
 			  NULL,
 			  thread_run,
 			  this->runner))
-	{
 	  return false;
-	}    
     }
-  else
-    {
+    else {
       if (pthread_create (&this->thread,
 			  NULL,
 			  thread_run,
 			  this))
-	{
-	  return false;
-	}
+	return false;
     }
 
-  this->running = true;
-  return true;
-}
-
-void *
-Thread::join (void) {
-  void * rvalue = NULL;
-  pthread_join (this->thread, &rvalue);
-  return rvalue;
-}
-
-void *
-Thread::run (void *null) {
-  pthread_exit (null);
-}
+    this->running = true;
+    return true;
+  }
+
+  void *
+  Thread::join (void) {
+    void * rvalue = NULL;
+    pthread_join (this->thread, &rvalue);
+    return rvalue;
+  }
+
+  void *
+  Thread::run (void *null) {
+    pthread_exit (null);
+  }
+
+} // end of namespace
diff --git a/src/realtime/concurrent/ThreadPool.cpp b/src/realtime/concurrent/ThreadPool.cpp
index b9ffde2..cebb30f 100755
--- a/src/realtime/concurrent/ThreadPool.cpp
+++ b/src/realtime/concurrent/ThreadPool.cpp
@@ -19,73 +19,72 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "ThreadPool.hpp"
-using namespace concurrent;
 
-ThreadPool::ThreadPool (int nMaxThreads) {
-  this->running = false;
+namespace concurrent {
 
-  for (int ii = 0; ii < nMaxThreads; ii++)
-    {
+  ThreadPool::ThreadPool (int nMaxThreads) {
+    this->running = false;
+
+    for (int ii = 0; ii < nMaxThreads; ii++) {
       std::string name = std::string("Thread ");
       name.push_back (ii);
       Thread * t = new Thread (new Task (this), name);
       this->threads.push_back (t);
     }
-}
+  }
 
-ThreadPool::~ThreadPool (void) {
-  if (this->running == true)
-    this->stop(true);
+  ThreadPool::~ThreadPool (void) {
+    if (this->running == true)
+      this->stop(true);
 
-  std::list<Thread *>::iterator it = this->threads.begin();
-  while (it != this->threads.end())
-    {
+    std::list<Thread *>::iterator it = this->threads.begin();
+    while (it != this->threads.end()) {
       Thread * t = (*it++);
       delete t;
     }
 
-  while (this->runQueue.size() > 0)
-    {
+    while (this->runQueue.size() > 0) {
       IRunnable * r = this->runQueue.pop();
       delete r;
     }
-}
-
-void 
-ThreadPool::start (void) {
-  this->running = true;
+  }
 
+  void 
+  ThreadPool::start (void) {
+    this->running = true;
+    
   std::list<Thread *>::iterator it = this->threads.begin();
   while (it != this->threads.end())
     {
       (*it)->start();
       it++;
     }
-}
+  }
 
-void
-ThreadPool::stop (bool join = false) {
-  this->running = false;
+  void 
+  ThreadPool::stop (bool join = false) {
+    this->running = false;
 
-  /* Waiting to join all of the threads will mean that the thread that the
-     pool is calling the stop() method from will block until all of the 
-     threads inside of the pool have stopped.
+    /* Waiting to join all of the threads will mean that the thread that the
+       pool is calling the stop() method from will block until all of the 
+       threads inside of the pool have stopped.
 
-     There is a PROBLEM here. If you call this, for some reason, from inside
-     of one of the Task threads then you are going to hit a deadlock. Never
-     pass the join parameter if this is being called from inside the Tasks. */
-  if (join == true)
-    {
+       There is a PROBLEM here. If you call this, for some reason, from inside
+       of one of the Task threads then you are going to hit a deadlock. Never
+       pass the join parameter if this is being called from inside the Tasks.*/
+    if (join == true) {
       std::list<Thread *>::iterator it = this->threads.begin();
-      while (it != this->threads.end())
-	{
-	  (*it)->join ();
-	  it++;
-	}
+      while (it != this->threads.end()) {
+	(*it)->join ();
+	it++;
+      }
     }
-}
+  }
+
+  void 
+  ThreadPool::execute (IRunnable * runner) {
+    this->runQueue.push (runner);
+  }
+
+} // end of namespace
 
-void
-ThreadPool::execute (IRunnable * runner) {
-  this->runQueue.push (runner);
-}
diff --git a/src/realtime/concurrent/ThreadPool.hpp b/src/realtime/concurrent/ThreadPool.hpp
index 2e7ddd2..a09dd58 100755
--- a/src/realtime/concurrent/ThreadPool.hpp
+++ b/src/realtime/concurrent/ThreadPool.hpp
@@ -29,63 +29,63 @@
 
 namespace concurrent {
 
-/* @description: This is a ThreadPool object that will keep N concurrent
-   threads running. Runnable objects can be attached to this object and they
-   will be executed immediately as a thread becomes available to run them. 
-   @author: John `jb Bellone (jvb4@njit.edu)
-   @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
-class ThreadPool {
-  /* @description: This object is an individual task that will be spawned at
-     the start of the ThreadPool. Each thread periodically checks the pool
-     object for any available Runnable objects from the queue. If there are
-     such objects it will take them off, run them and delete them. */
-  class Task : public IRunnable {
-  private:
-    ThreadPool * pool;
-  public:
-    Task (ThreadPool * pool) {
-      this->pool = pool;
-    }
+  /* @description: This is a ThreadPool object that will keep N concurrent
+     threads running. Runnable objects can be attached to this object and they
+     will be executed immediately as a thread becomes available to run them. 
+     @author: John `jb Bellone (jvb4@njit.edu)
+     @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
+  class ThreadPool {
+    /* @description: This object is an individual task that will be spawned at
+       the start of the ThreadPool. Each thread periodically checks the pool
+       object for any available Runnable objects from the queue. If there are
+       such objects it will take them off, run them and delete them. */
+    class Task : public IRunnable {
+    private:
+      ThreadPool * pool;
+    public:
+      Task (ThreadPool * pool) {
+	this->pool = pool;
+      }
       
-    void * run (void *) {
-      this->running = true;
+      void * run (void *) {
+	this->running = true;
 
-      while (this->running == true)
-	{
-	  if (pool->isRunning() == false)
-	    break;
+	while (this->running == true)
+	  {
+	    if (pool->isRunning() == false)
+	      break;
 
-	  if (pool->getQueueSize() > 0)
-	    {
-	      IRunnable * runner = pool->removeFromQueue();
-	      runner->run(NULL);
-	      delete runner;
-	    }
-	  ::sleep (1);
-	}
-      return NULL;
-    }
-  };
-private:
-  concurrent::Queue<IRunnable *> runQueue;
-  std::list<Thread *> threads;
-  bool running;
-public:  
-  ThreadPool (int);
-  ~ThreadPool (void);
+	    if (pool->getQueueSize() > 0)
+	      {
+		IRunnable * runner = pool->removeFromQueue();
+		runner->run(NULL);
+		delete runner;
+	      }
+	    ::sleep (1);
+	  }
+	return NULL;
+      }
+    };
+  private:
+    concurrent::Queue<IRunnable *> runQueue;
+    std::list<Thread *> threads;
+    bool running;
+  public:  
+    ThreadPool (int);
+    ~ThreadPool (void);
 
-  /* Thread un-Safe Methods */
-  void start (void);
-  void stop (bool);
+    /* Thread un-Safe Methods */
+    void start (void);
+    void stop (bool);
 
-  /* Thread-Safe Methods */
-  void execute (IRunnable *);
-  inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
-  inline bool isRunning (void) const { return this->running; }
-  inline int getMaxThreads (void) const { return this->threads.size(); }
-  inline size_t getQueueSize (void) { return this->runQueue.size(); }
-};
+    /* Thread-Safe Methods */
+    void execute (IRunnable *);
+    inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
+    inline bool isRunning (void) const { return this->running; }
+    inline int getMaxThreads (void) const { return this->threads.size(); }
+    inline size_t getQueueSize (void) { return this->runQueue.size(); }
+  };
 
-}
+} // end of namespace
 
 #endif
diff --git a/src/realtime/network/Socket.hpp b/src/realtime/network/Socket.hpp
index ee0bf74..3662409 100755
--- a/src/realtime/network/Socket.hpp
+++ b/src/realtime/network/Socket.hpp
@@ -23,15 +23,19 @@
 
 #include <cstring>
 
-class ISocket {
-protected:
-  int sockfd;
-public:
-  virtual ~ISocket (void) { }
-
-  virtual void close (void) = 0;
-  virtual int send (const char * bytes, size_t length) = 0;
-  virtual int receive (char * btyes, size_t size) = 0;
-};
+namespace network {
+
+  class ISocket {
+  protected:
+    int sockfd;
+  public:
+    virtual ~ISocket (void) { }
+
+    virtual void close (void) = 0;
+    virtual int send (const char * bytes, size_t length) = 0;
+    virtual int receive (char * btyes, size_t size) = 0;
+  };
+
+} // end of namesapce
 
 #endif
diff --git a/src/realtime/network/Tcp.cpp b/src/realtime/network/Tcp.cpp
index 0b14e21..18b5b7d 100755
--- a/src/realtime/network/Tcp.cpp
+++ b/src/realtime/network/Tcp.cpp
@@ -25,144 +25,144 @@
 #include <unistd.h>
 #include <netdb.h>
 
-/*****************************************************************************/
+namespace network {
 
-TcpSocket::TcpSocket (void) {
-  this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
-}
+  TcpSocket::TcpSocket (void) {
+    this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+  }
 
-TcpSocket::~TcpSocket (void) {
-  this->close();
-}
+  TcpSocket::~TcpSocket (void) {
+    this->close();
+  }
 
-void
-TcpSocket::close (void) {
-  if (this->sockfd > 0)
-    ::close (this->sockfd);
-}
+  void
+  TcpSocket::close (void) {
+    if (this->sockfd > 0)
+      ::close (this->sockfd);
+  }
 	
-int
-TcpSocket::send (const char * bytes, size_t length) {
-  return ::send (this->sockfd, bytes, length, 0);
-}
-
-int
-TcpSocket::receive (char * bytes, size_t size) {
-  return ::recv (this->sockfd, bytes, size, 0);
-}
-
-/*****************************************************************************/
-
-TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
-  this->port = port;
-
-  memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-  this->sockaddr.sin_family = AF_INET;
-  this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-  this->sockaddr.sin_port = htons (this->port);
-}
-
-TcpServerSocket::~TcpServerSocket (void) {
-  this->close();
-}
-
-bool
-TcpServerSocket::start (int backlog = 5) {
-  int opt = 1;
-
-  // This is to prevent conflicts with major services' ports.
-  if (this->port < 1024)
-    return false;
-
-  if (::setsockopt (this->sockfd, 
-		    SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
-    return false;
-
-  if (::bind (this->sockfd,
-	      (struct sockaddr *)&(this->sockaddr),
-	      sizeof (this->sockaddr)) < 0)
-    return false;
-
-  if (::listen (this->sockfd, backlog) < 0)
-    return false;
-
-  return true;
-}
-
-void
-TcpServerSocket::close (void) {
-  TcpSocket::close();
-}
-
-TcpServerSocket::Acceptor *
-TcpServerSocket::newAcceptor (void) {
-  return new TcpServerSocket::Acceptor (this, this->sockfd);
-}
-
-/*****************************************************************************/
-
-TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
-  this->socket = server;
-  this->sockfd = sockfd;
-}
-
-int
-TcpServerSocket::Acceptor::acceptIncoming (void) {
-  int newfd = -1;
-  static struct sockaddr_in clientaddr;
-  unsigned int x = sizeof (clientaddr);
-
-  if ((newfd = ::accept (this->sockfd, 
-			 (struct sockaddr *)&clientaddr,
-			 &x)) < 0)
-    return -1;
-  return newfd;
-}
-
-/*****************************************************************************/
-
-TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
-  memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
-  this->sockaddr.sin_family = AF_INET;
-  this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
-}
+  int
+  TcpSocket::send (const char * bytes, size_t length) {
+    return ::send (this->sockfd, bytes, length, 0);
+  }
+
+  int
+  TcpSocket::receive (char * bytes, size_t size) {
+    return ::recv (this->sockfd, bytes, size, 0);
+  }
+
+  TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
+    this->port = port;
+
+    memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+    this->sockaddr.sin_family = AF_INET;
+    this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+    this->sockaddr.sin_port = htons (this->port);
+  }
+
+  TcpServerSocket::~TcpServerSocket (void) {
+    this->close();
+  }
+
+  bool
+  TcpServerSocket::start (int backlog = 5) {
+    int opt = 1;
+
+    // This is to prevent conflicts with major services' ports.
+    if (this->port < 1024)
+      return false;
+
+    if (::setsockopt (this->sockfd, 
+		      SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
+      return false;
+
+    if (::bind (this->sockfd,
+		(struct sockaddr *)&(this->sockaddr),
+		sizeof (this->sockaddr)) < 0)
+      return false;
+
+    if (::listen (this->sockfd, backlog) < 0)
+      return false;
+
+    return true;
+  }
+
+  void
+  TcpServerSocket::close (void) {
+    TcpSocket::close();
+  }
+
+  TcpServerSocket::Acceptor *
+  TcpServerSocket::newAcceptor (void) {
+    return new TcpServerSocket::Acceptor (this, this->sockfd);
+  }
+
+  TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
+    this->socket = server;
+    this->sockfd = sockfd;
+  }
+
+  int
+  TcpServerSocket::Acceptor::acceptIncoming (void) {
+    int newfd = -1;
+    static struct sockaddr_in clientaddr;
+    unsigned int x = sizeof (clientaddr);
+
+    if ((newfd = ::accept (this->sockfd, 
+			   (struct sockaddr *)&clientaddr,
+			   &x)) < 0)
+      return -1;
+    return newfd;
+  }
+
+  TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
+    memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+    this->sockaddr.sin_family = AF_INET;
+    this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+  }
+
+  TcpClientSocket::TcpClientSocket (int newfd) {
+    this->sockfd = newfd;
+  }
 				
-TcpClientSocket::~TcpClientSocket (void) {
-}
-
-bool
-TcpClientSocket::connect (const char * host, int port) {
-  struct sockaddr_in servAddr;
-  struct hostent * h;
-
-  if (!host || (*host == '\0'))
-    return false;
-
-  if (this->sockfd < 0)
-    return false;
-
-  if ((h = ::gethostbyname (host)) == NULL)
-    return false;
-
-  servAddr.sin_family = h->h_addrtype;
-  memcpy ((char *)&(servAddr.sin_addr.s_addr),
-	  h->h_addr_list[0],
-	  h->h_length);
-  servAddr.sin_port = htons (port);
-  
-  if (::bind (this->sockfd,
-	      (struct sockaddr *)&(this->sockaddr),
-	      sizeof (this->sockaddr)) < 0)
-    return false;
-
-  if (::connect (this->sockfd,
-		 (struct sockaddr *)&(this->sockaddr),
-		 sizeof (this->sockaddr)) < 0)
-    return false;
-  return true;  
-}
-
-void
-TcpClientSocket::close (void) {
-  TcpSocket::close();
-}
+  TcpClientSocket::~TcpClientSocket (void) {
+  }
+
+  bool
+  TcpClientSocket::connect (const char * host, int port) {
+    struct sockaddr_in servAddr;
+    struct hostent * h;
+
+    if (!host || (*host == '\0'))
+      return false;
+
+    if (this->sockfd < 0)
+      return false;
+    
+    if ((h = ::gethostbyname (host)) == NULL)
+      return false;
+
+    servAddr.sin_family = h->h_addrtype;
+    memcpy ((char *)&(servAddr.sin_addr.s_addr),
+	    h->h_addr_list[0],
+	    h->h_length);
+    servAddr.sin_port = htons (port);
+    
+    if (::bind (this->sockfd,
+		(struct sockaddr *)&(this->sockaddr),
+		sizeof (this->sockaddr)) < 0)
+      return false;
+    
+    if (::connect (this->sockfd,
+		   (struct sockaddr *)&(this->sockaddr),
+		   sizeof (this->sockaddr)) < 0)
+      return false;
+    return true;  
+  }
+
+  void
+  TcpClientSocket::close (void) {
+    TcpSocket::close();
+  }
+
+} // end of namespace
diff --git a/src/realtime/network/Tcp.hpp b/src/realtime/network/Tcp.hpp
index e650c5b..de8c160 100755
--- a/src/realtime/network/Tcp.hpp
+++ b/src/realtime/network/Tcp.hpp
@@ -25,48 +25,52 @@
 #include <arpa/inet.h>
 #include <netinet/in.h>
 
-class TcpSocket : public ISocket {
-public:
-  TcpSocket (void);
-  virtual ~TcpSocket (void);
+namespace network {
 
-  void close (void);
-  int send (const char * bytes, size_t length);
-  int receive (char * bytes, size_t size);
-};
-
-class TcpServerSocket : public TcpSocket {
-private:
-  struct sockaddr_in sockaddr;
-  int port;
-public:
-  class Acceptor {
-  private:
-    TcpServerSocket * socket;
-    int sockfd;
+  class TcpSocket : public ISocket {
+  protected:
+    struct sockaddr_in sockaddr;
   public:
-    Acceptor (TcpServerSocket * server, int sockfd);
+    TcpSocket (void);
+    virtual ~TcpSocket (void);
 
-    int acceptIncoming (void);
+    void close (void);
+    int send (const char * bytes, size_t length);
+    int receive (char * bytes, size_t size);
   };
 
-  TcpServerSocket (int port);
-  virtual ~TcpServerSocket (void);
+  class TcpServerSocket : public TcpSocket {
+  private:
+    int port;
+  public:
+    class Acceptor {
+    private:
+      TcpServerSocket * socket;
+      int sockfd;
+    public:
+      Acceptor (TcpServerSocket * server, int sockfd);
+
+      int acceptIncoming (void);
+    };
 
-  bool start (int backlog);
-  void close (void);
-  Acceptor * newAcceptor (void);
-};
+    TcpServerSocket (int port);
+    virtual ~TcpServerSocket (void);
+    
+    bool start (int backlog);
+    void close (void);
+    Acceptor * newAcceptor (void);
+  };
+  
+  class TcpClientSocket : public TcpSocket {
+  public:
+    TcpClientSocket (void);
+    TcpClientSocket (int newfd);
+    virtual ~TcpClientSocket (void);
 
-class TcpClientSocket : public TcpSocket {
-private:
-  struct sockaddr_in sockaddr;
-public:
-  TcpClientSocket (void);
-  virtual ~TcpClientSocket (void);
+    bool connect (const char * host, int port);
+    void close (void);
+  };
 
-  bool connect (const char * host, int port);
-  void close (void);
-};
+} // end of namespace
 
 #endif
diff --git a/src/realtime/proactor/Dispatcher.cpp b/src/realtime/proactor/Dispatcher.cpp
index 114fae6..a20db5b 100644
--- a/src/realtime/proactor/Dispatcher.cpp
+++ b/src/realtime/proactor/Dispatcher.cpp
@@ -19,27 +19,27 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "Dispatcher.hpp"
-using namespace proactor;
-
-Dispatcher::~Dispatcher (void) {
-  while (this->inputQueue.size() > 0)
-    this->inputQueue.pop();
-}
-
-void
-Dispatcher::addWorker (Worker * w) {
-  this->workers.push_back (w);
-}
-
-bool
-Dispatcher::removeWorker (Worker * w) {
-  WorkerListType::iterator it = std::find (this->workers.begin(),
-					   this->workers.end(),
-					   w);
-
-  if (it == this->workers.end())
-    return false;
+#include "Worker.hpp"
+
+namespace proactor {
+
+  bool
+  Dispatcher::addWorker (Worker * w) {
+    this->workers.push_back (w);
+    return w->start();
+  }
+
+  bool
+  Dispatcher::removeWorker (Worker * w) {
+    WorkerListType::iterator it = std::find (this->workers.begin(),
+					     this->workers.end(),
+					     w);
+
+    if (it == this->workers.end())
+      return false;
   
-  this->workers.erase (it);
-  return true;
-}
+    this->workers.erase (it);
+    return true;
+  }
+
+} // end of namesapce
diff --git a/src/realtime/proactor/Dispatcher.hpp b/src/realtime/proactor/Dispatcher.hpp
index 2a71462..cfc350b 100755
--- a/src/realtime/proactor/Dispatcher.hpp
+++ b/src/realtime/proactor/Dispatcher.hpp
@@ -23,12 +23,9 @@
 
 #include "../concurrent/Thread.hpp"
 #include "../concurrent/List.hpp"
-#include "../concurrent/Queue.hpp"
-#include "Event.hpp"
 
 namespace proactor {
 
-  class Proactor;
   class Worker;
 
   class Dispatcher : public concurrent::Thread {
@@ -36,31 +33,13 @@ namespace proactor {
     typedef concurrent::List<Worker *> WorkerListType;
 
     WorkerListType workers;
-    int eventId;
-  protected:
-    typedef concurrent::Queue<Event> EventQueueType;
-
-    Proactor * pro;
-    EventQueueType inputQueue;
   public:
     virtual ~Dispatcher (void);
 
-    void addWorker (Worker * w);
+    bool addWorker (Worker * w);
     bool removeWorker (Worker * w);
-
-    inline void onReadComplete (const char * buf) {
-      this->inputQueue.push ( Event (this->eventId, std::string(buf)) );
-    }
-
-    inline void setEventId (int e) {
-      this->eventId = e;
-    }
-
-    inline int getEventId (void) {
-      return this->eventId;
-    }
   };
 
-}
+} // end of namespace
 
 #endif
diff --git a/src/realtime/proactor/Event.cpp b/src/realtime/proactor/Event.cpp
index a1cb9df..1d5b755 100755
--- a/src/realtime/proactor/Event.cpp
+++ b/src/realtime/proactor/Event.cpp
@@ -19,16 +19,19 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
 */
 #include "Event.hpp"
-using namespace proactor;
 
-int Event::numEvents = 0;
+namespace proactor {
 
-Event::Event (int e, const std::string & buf) {
-  this->id = e;
-  this->buf = buf;
-}
+  int Event::numEvents = 0;
 
-int
-Event::uniqueEventId (void) {
-  return Event::numEvents++;
-}
+  Event::Event (int e, const std::string & buf) {
+    this->id = e;
+    this->buf = buf;
+  }
+
+  int
+  Event::uniqueEventId (void) {
+    return Event::numEvents++;
+  }
+ 
+} // end of namespace
diff --git a/src/realtime/proactor/Event.hpp b/src/realtime/proactor/Event.hpp
index d856114..2ab3261 100755
--- a/src/realtime/proactor/Event.hpp
+++ b/src/realtime/proactor/Event.hpp
@@ -21,6 +21,7 @@
 #ifndef HPP_PROACTOR_EVENT
 #define HPP_PROACTOR_EVENT
 
+#include "Dispatcher.hpp"
 #include <string>
 
 namespace proactor {
@@ -37,6 +38,21 @@ namespace proactor {
     static int uniqueEventId (void);
   };
 
+  class EventDispatcher : public Dispatcher {
+  private:
+    int eventId;
+  public:
+    virtual ~EventDispatcher (void) { }
+
+    inline void setEventId (int e) { 
+      this->eventId = e;
+    }
+
+    inline int getEventId (void) { 
+      return this->eventId;
+    }
+  };
+
 }
 
 #endif
diff --git a/src/realtime/proactor/InputDispatcher.cpp b/src/realtime/proactor/InputDispatcher.cpp
new file mode 100644
index 0000000..b5a0ea9
--- /dev/null
+++ b/src/realtime/proactor/InputDispatcher.cpp
@@ -0,0 +1,54 @@
+/* 
+   InputDispatcher.cpp - Input Dispatcher Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "InputDispatcher.hpp"
+#include "Proactor.hpp"
+
+namespace proactor {
+
+  InputDispatcher::~InputDispatcher (void) {
+      this->inputQueue.lock();
+      while (this->inputQueue.size() > 0)
+	this->inputQueue.pop();
+      this->inputQueue.unlock();
+  }
+
+  void *
+  InputDispatcher::run (void * null) {
+    this->running = true;
+
+    while (this->running == true) {
+      // Dispatch all of the input items on the queue.
+      this->inputQueue.lock();
+
+      while (this->inputQueue.size() > 0) {
+	// For right now all we're doing is pushing up the chain.
+	this->pro->onReadComplete ( this->inputQueue.pop() );
+      }
+
+      this->inputQueue.unlock();
+
+      Thread::sleep(100);
+    }
+  
+    return NULL; 
+  }
+
+} // end of namespace
diff --git a/src/realtime/proactor/InputDispatcher.hpp b/src/realtime/proactor/InputDispatcher.hpp
new file mode 100644
index 0000000..8f7dc55
--- /dev/null
+++ b/src/realtime/proactor/InputDispatcher.hpp
@@ -0,0 +1,53 @@
+/* 
+   InputDispatcher.hpp - Input Dispatcher Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_INPUTDISPATCHER
+#define HPP_PROACTOR_INPUTDISPATCHER
+
+#include "../concurrent/Queue.hpp"
+#include "Event.hpp"
+
+namespace proactor {
+
+  class Proactor;
+
+  class InputDispatcher : public EventDispatcher {
+  protected:
+    typedef concurrent::Queue<Event> InputQueueType;
+
+    Proactor * pro;
+    InputQueueType inputQueue;
+  public:
+    virtual ~InputDispatcher (void);
+    
+    inline void onReadComplete (const char * buf) {
+      this->inputQueue.push ( Event (getEventId(), std::string(buf)) );
+    }
+
+    inline void onReadComplete (std::string buf) {
+      this->inputQueue.push ( Event (getEventId(), buf) );
+    }
+
+    void * run (void * null);
+  };
+
+} // end of namespace
+
+#endif
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
index f76d13e..3362504 100755
--- a/src/realtime/proactor/Proactor.cpp
+++ b/src/realtime/proactor/Proactor.cpp
@@ -20,130 +20,135 @@
 */
 #include "Proactor.hpp"
 #include <iostream>
-using namespace proactor;
 
-Proactor::Proactor (void) {
-}
+namespace proactor {
 
-Proactor::~Proactor (void) {
-  // Remove all of the lists of event handlers.
-  {
-    EventMapType::iterator it = this->eventsToHandlers.begin();
-    while (it != this->eventsToHandlers.end())
-      {
-	WorkerListType * q = (it->second);
-	delete q;
-	it++;
-      }
+  Proactor::Proactor (void) {
   }
 
-  // Handle the dispatchers that have not been manually removed.
-  {
-    DispatcherList::iterator it = this->dispatchers.begin();
-    while (it != this->dispatchers.end())
-      {
-	Dispatcher * d = (*it);
-	delete d;
-	it++;
-      }
+  Proactor::~Proactor (void) {
+    // Remove all of the lists of event handlers.
+    {
+      EventMapType::iterator it = this->eventsToHandlers.begin();
+      while (it != this->eventsToHandlers.end())
+	{
+	  WorkerListType * q = (it->second);
+	  delete q;
+	  it++;
+	}
+    }
+
+    // Handle the dispatchers that have not been manually removed.
+    {
+      DispatcherList::iterator it = this->dispatchers.begin();
+      while (it != this->dispatchers.end())
+	{
+	  InputDispatcher * d = (*it);
+	  delete d;
+	  it++;
+	}
+    }
   }
-}
 
-void
-Proactor::addWorker (int e, Worker * job) {
-  this->eventsToHandlers.lock();
-  {
-    EventMapType::iterator it = this->eventsToHandlers.find (e);
+  bool
+  Proactor::addWorker (int e, Worker * job) {
+    this->eventsToHandlers.lock();
+    {
+      EventMapType::iterator it = this->eventsToHandlers.find (e);
   
-    if (it == this->eventsToHandlers.end())
-      this->eventsToHandlers[e] = new WorkerListType;  
-    this->eventsToHandlers[e]->push_back (job);
+      if (it == this->eventsToHandlers.end())
+	this->eventsToHandlers[e] = new WorkerListType;  
+      this->eventsToHandlers[e]->push_back (job);
+    }
+    this->eventsToHandlers.unlock();
+
+    return job->start();
   }
-  this->eventsToHandlers.unlock();
-}
-
-void
-Proactor::onReadComplete (Event e) {
-  this->inputQueue.push (e);
-}
-
-void 
-Proactor::onReadComplete (int e, const char * buf) {
-  this->inputQueue.push ( Event (e, std::string (buf)) );   
-}
-
-bool
-Proactor::removeWorker (int e, Worker * job) {
-  bool result = false;
-
-  this->eventsToHandlers.lock();
-  {
-    WorkerListType::iterator it = 
-      std::find (this->eventsToHandlers[e]->begin(),
-		 this->eventsToHandlers[e]->end(),
-		 job);
-    
-    if (it != this->eventsToHandlers[e]->end())
-      {
-	this->eventsToHandlers[e]->erase (it);
-	result = true;
-      }
+
+  void
+  Proactor::onReadComplete (Event e) {
+    this->inputQueue.push (e);
   }
-  this->eventsToHandlers.unlock();
-   
-  return result;
-}
-
-void
-Proactor::addDispatcher (Dispatcher * d) {
-  this->dispatchers.push_back (d);
-}
-
-bool
-Proactor::removeDispatcher (Dispatcher * d) {
-  DispatcherList::iterator it = std::find (this->dispatchers.begin(),
-					   this->dispatchers.end(),
-					   d);
-
-  if (it == this->dispatchers.end())
-    return false;
-  
-  this->dispatchers.erase (it);
-  return true;
-}
 
-void *
-Proactor::run (void * null) {
-  this->running = true;
-  
-  WorkerListType::iterator it;
+  void 
+  Proactor::onReadComplete (int e, const char * buf) {
+    this->inputQueue.push ( Event (e, std::string (buf)) );   
+  }
+
+  bool
+  Proactor::removeWorker (int e, Worker * job) {
+    bool result = false;
 
-  while (this->running == true)
+    this->eventsToHandlers.lock();
     {
-      this->inputQueue.lock();
-      while (this->inputQueue.size() > 0)
+      WorkerListType::iterator it = 
+	std::find (this->eventsToHandlers[e]->begin(),
+		   this->eventsToHandlers[e]->end(),
+		   job);
+    
+      if (it != this->eventsToHandlers[e]->end())
 	{
-	  Event e = this->inputQueue.pop();
+	  this->eventsToHandlers[e]->erase (it);
+	  result = true;
+	}
+    }
+    this->eventsToHandlers.unlock();
+   
+    return result;
+  }
+
+  void
+  Proactor::addDispatcher (InputDispatcher * d) {
+    this->dispatchers.push_back (d);
+  }
+
+  bool
+  Proactor::removeDispatcher (InputDispatcher * d) {
+    DispatcherList::iterator it = std::find (this->dispatchers.begin(),
+					     this->dispatchers.end(),
+					     d);
 
-	  // We are throwing events with no handlers to catch them.
-	  if (this->eventsToHandlers.find (e.id) == 
-	      this->eventsToHandlers.end())
-	    continue;
+    if (it == this->dispatchers.end())
+      return false;
+  
+    this->dispatchers.erase (it);
+    return true;
+  }
+
+  void *
+  Proactor::run (void * null) {
+    this->running = true;
+  
+    WorkerListType::iterator it;
+
+    while (this->running == true)
+      {
+	this->inputQueue.lock();
+	while (this->inputQueue.size() > 0)
+	  {
+	    Event e = this->inputQueue.pop();
+
+	    // We are throwing events with no handlers to catch them.
+	    if (this->eventsToHandlers.find (e.id) == 
+		this->eventsToHandlers.end())
+	      continue;
  
-	  it = this->eventsToHandlers[e.id]->begin();
+	    it = this->eventsToHandlers[e.id]->begin();
 	  
-	  while (it != this->eventsToHandlers[e.id]->end())
-	    {
-	      Worker * j = (*it);
+	    while (it != this->eventsToHandlers[e.id]->end())
+	      {
+		Worker * j = (*it);
 	      
-	      j->pushInputQueue (e.buf);
+		j->pushInputQueue (e.buf);
 		      
-	      it++;
-	    }
-	}
-      this->inputQueue.unlock();
+		it++;
+	      }
+	  }
+	this->inputQueue.unlock();
       
-      Thread::sleep(100);
-    }
-  return NULL;
-}
+	Thread::sleep(100);
+      }
+    return NULL;
+  }
+
+} // end of namespace
diff --git a/src/realtime/proactor/Proactor.hpp b/src/realtime/proactor/Proactor.hpp
index f0beafc..d66465d 100755
--- a/src/realtime/proactor/Proactor.hpp
+++ b/src/realtime/proactor/Proactor.hpp
@@ -28,15 +28,16 @@
 #include "Worker.hpp"
 #include "Event.hpp"
 #include "Dispatcher.hpp"
+#include "InputDispatcher.hpp"
 #include <list>
 #include <queue>
 
 namespace proactor {
 
-  class Proactor : public Dispatcher {
+  class Proactor : public InputDispatcher {
   private:
     typedef std::list<Worker *> WorkerListType;
-    typedef concurrent::List<Dispatcher *> DispatcherList;
+    typedef concurrent::List<InputDispatcher *> DispatcherList;
     typedef concurrent::Map<int, WorkerListType *> EventMapType;
     
     EventMapType eventsToHandlers;
@@ -45,10 +46,10 @@ namespace proactor {
     Proactor (void);
     virtual ~Proactor (void);
 
-    void addWorker (int e, Worker * w);
+    bool addWorker (int e, Worker * w);
     bool removeWorker (int e, Worker * w);
-    void addDispatcher (Dispatcher * d);
-    bool removeDispatcher (Dispatcher * d);
+    void addDispatcher (InputDispatcher * d);
+    bool removeDispatcher (InputDispatcher * d);
     
     void * run (void * null);
  
@@ -60,6 +61,6 @@ namespace proactor {
     }
   };
 
-}
+} // end of namespace
 
 #endif
diff --git a/src/realtime/proactor/Worker.hpp b/src/realtime/proactor/Worker.hpp
index ba076ed..3c22639 100644
--- a/src/realtime/proactor/Worker.hpp
+++ b/src/realtime/proactor/Worker.hpp
@@ -27,13 +27,13 @@
 
 namespace proactor {
 
-  class Dispatcher;
+  class InputDispatcher;
 
   class Worker : public concurrent::Thread {
   protected:
     typedef concurrent::Queue<std::string> InputQueueType;
 
-    Dispatcher * dispatcher;
+    InputDispatcher * dispatcher;
     InputQueueType inputQueue;
   public:
     inline void pushInputQueue (std::string buf) {
@@ -41,6 +41,6 @@ namespace proactor {
     }
   };
 
-}
+} // end of namespace
 
 #endif
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index d6bb0e0..0f53761 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -32,6 +32,7 @@
 #include "proactor/Proactor.hpp"
 #include "proactor/Event.hpp"
 #include "Network.hpp"
+#include "CsvParser.hpp"
 #include "PacketParser.hpp"
 #include "Packet.hpp"
 
@@ -55,16 +56,14 @@ thread_main (ThreadArgs * args) {
   Config * cfg  = (Config *)args->at(1);
 
   ConfigPair * logpath = cfg->get_pair (cfg, "realtime", "log", "path");
-  if (IS_NULL (logpath))
-    {
+  if (IS_NULL (logpath)) {
       g_critical ("Failed loading log->path from configuration file; "
 		  "exiting thread");
       return;
     }
 
   ConfigPair * servport = cfg->get_pair (cfg, "realtime", "tcp", "port");
-  if (IS_NULL (servport))
-    {
+  if (IS_NULL (servport)) {
       g_critical ("Failed loading tcp->port from configuration file; "
 		  "exiting thread");
       return;
@@ -73,16 +72,13 @@ thread_main (ThreadArgs * args) {
   ConfigPair * verbosity = cfg->get_pair (cfg, 
 					  "realtime", "debug", "verbosity");
   if (IS_NULL (verbosity))
-    {
-      g_warning ("Failed loading debug->verbosity from configuration file.");
-    }
-
+    g_warning ("Failed loading debug->verbosity from configuration file.");
+  
   FILE * pktlog = NULL;
   std::string logname = std::string (logpath->value).append("/");
   logname.append (append_pidname("realtime.").append(".log"));
 
-  if ((pktlog = fopen (logname.c_str(), "w")) == NULL)
-    {
+  if ((pktlog = fopen (logname.c_str(), "w")) == NULL) {
       g_critical ("Failed opening file '%s' for packet logging; exiting"
 		  " thread", logname.c_str());
       return;
@@ -91,50 +87,68 @@ thread_main (ThreadArgs * args) {
   /* Start up the Tcp Socket server on the port specified inside of the
      configuration file. This IS NOT a separate thread. */
   int port = atoi(servport->value);
-  TcpServerSocket socket ( port );
-  if (socket.start(5) == false)
-    {
+  network::TcpServerSocket socket ( port );
+  if (socket.start(5) == false) {
       g_critical ("Failed starting TcpServerSocket on port localhost:%d;"
 		  " exiting thread", port);
       return;
     }
+
+  network::TcpClientSocket client;
+  if (client.connect ("127.0.0.1", 50000) == false)
+    {
+      g_critical ("Failed connecting to TcpClientSocket");
+      return;
+    }
   
   // Get a unique event identifier that will be used throughout.
-  int e = proactor::Event::uniqueEventId();
+  int csvEventID = proactor::Event::uniqueEventId();
+  int pktEventID = proactor::Event::uniqueEventId();
 
   proactor::Proactor proactor;
-  if (proactor.start() == false)
-    {
+  NetworkCsvReceiver csvDispatcher (csvEventID, &proactor);
+  NetworkPktReceiver pktDispatcher (pktEventID, &proactor);
+  AcceptThread acceptor (socket.newAcceptor(), &pktDispatcher);
+  ConnectionThread creader (&csvDispatcher, &client);
+  PacketParser packet_worker (wb, pktlog, atoi(verbosity->value));
+  CsvParser csv_worker (wb, pktlog, atoi(verbosity->value));
+
+  if (proactor.addWorker (pktEventID, &packet_worker) == false) {
+      g_critical ("Failed starting packet parser worker; exiting thread.");
+      return;
+    }
+
+  if (proactor.addWorker (csvEventID, &csv_worker) == false) {
+      g_critical ("Failed starting csv parser worker; exiting thread.");
+      return;
+    }
+
+  if (proactor.start() == false) {
       g_critical ("Failed starting Proactor; exiting thread.");
       return;
     }
 
-  NetworkDispatcher network (&proactor);
-  network.setEventId(e);
-  if (network.start() == false)
-    {
+  if (pktDispatcher.start() == false) {
       g_critical ("Failed starting network; exiting thread.");
       return;
     }
 
-  PacketParser handler (wb, pktlog, atoi(verbosity->value));
-  proactor.addWorker (e, &handler);
-  if (handler.start() == false) 
-    {
-      g_critical ("Failed starting PacketParser; exiting thread.");
+  if (csvDispatcher.start() == false) {
+      g_critical ("Failed starting network; exiting thread.");
       return;
     }
-  
-  AcceptThread acceptor ( socket.newAcceptor(), &network );
-  network.addWorker (&acceptor);
-  if (acceptor.start() == false)
-    {
-      g_critical ("Failed starting Acceptor; exiting thread.");
+
+  if (pktDispatcher.addWorker (&acceptor) == false) {
+      g_critical ("Failed starting acceptor; exiting thread.");
       return;
     }
- 
-  while (!IS_NULLSTR (wb->filename)) 
-    {
+
+  if (csvDispatcher.addWorker (&creader) == false) {
+    g_critical ("Failed starting client; exiting thread.");
+    return;
+  }
+  
+  while (!IS_NULLSTR (wb->filename)) {
       // Continually sleep basically until our application terminates.
       ::sleep (1);
     }
@@ -145,7 +159,10 @@ thread_main (ThreadArgs * args) {
 
   // Interrupt threads immediately canceling them so we can quit.
   acceptor.interrupt();
-  handler.interrupt();
-  network.interrupt();
+  packet_worker.interrupt();
+  csv_worker.interrupt();
+  csvDispatcher.interrupt();
+  pktDispatcher.interrupt();
   proactor.interrupt();
 }
+

commit 46f16e0987853ff998cda68784059b038a7c6a2d
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Tue Apr 14 05:09:42 2009 +0000

    Changed some of the programming style standards of C++
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@10 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
index 65a9482..545077c 100644
--- a/src/realtime/CsvParser.cpp
+++ b/src/realtime/CsvParser.cpp
@@ -1,53 +1,50 @@
 #include "CsvParser.hpp"
 
-/* This structure is due to the libcsv parser; it uses function pointers to
-   do any work inside of an actual tuple. So the cb1 is called after a field
-   is parsed and cb2 is called after a tuple/row is parsed. */
-static void 
-cb1 (void * s, size_t length, void * data) {
+namespace realtime {
 
-}
-
-static void
-cb2 (int c, void * data) {
-
-}
+  /* This structure is due to the libcsv parser; it uses function pointers to
+     do any work inside of an actual tuple. So the cb1 is called after a field
+     is parsed and cb2 is called after a tuple/row is parsed. */
+  static void 
+  cb1 (void * s, size_t length, void * data) {
+    
+  }
 
-void *
-CsvParser::run (void * null) {
- this->running = true;
- struct csv_parser csv;
+  static void
+  cb2 (int c, void * data) {
     
- if (csv_init (&csv, CSV_STRICT) != 0)
-   {
-     std::cerr << "Failed initializing libcsv parser\n";
-     return NULL;
-   }
+  }
 
- while (this->running == true)
-   {
-     while (this->inputQueue.size() > 0)
-       {
-	 std::string buf = this->inputQueue.pop();
-	 size_t bytes = buf.length();
+  void *
+  CsvParser::run (void * null) {
+    this->running = true;
+    struct csv_parser csv;
+    
+    if (csv_init (&csv, CSV_STRICT) != 0) {
+      std::cerr << "Failed initializing libcsv parser\n";
+      return NULL;
+    }
+
+    while (this->running == true) {
+      while (this->inputQueue.size() > 0) {
+	std::string buf = this->inputQueue.pop();
+	size_t bytes = buf.length();
 	 
-	 // Parse the CSV input
-	 if ((bytes = csv_parse(&csv, 
-				buf.c_str(), 
-				bytes, 
-				cb1,
-				cb2,
-				this->cell)) != buf.length())
-	   {
-	     // Something went wrong here. Discard and continue.
-	     if (csv_error (&csv) == CSV_EPARSE) 
-	       std::cerr << "Parsing error on input:\n" << buf;
-	     continue;
-	   }
-       }
-
-   }
-
- csv_free (&csv);
- return NULL;
+	// Parse the CSV input
+	if ((bytes = csv_parse(&csv, 
+			       buf.c_str(), 
+			       bytes, 
+			       cb1,
+			       cb2,
+			       this->cell)) != buf.length()) {
+	  // Something went wrong here. Discard and continue.
+	  if (csv_error (&csv) == CSV_EPARSE) 
+	    std::cerr << "Parsing error on input:\n" << buf;
+	  continue;
+	}
+      }
+    }
+    csv_free (&csv);
+    return NULL;
+  }
 }
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
index 8b4bf44..90a38c3 100644
--- a/src/realtime/CsvParser.hpp
+++ b/src/realtime/CsvParser.hpp
@@ -8,23 +8,25 @@
 #include <csv/csv.h>
 #include <iostream>
 
-class CsvParser : public proactor::Worker {
-private:
-  Workbook * wb;
-  FILE * pktlog;
-  Cell * cell;
-public:
-  CsvParser (Workbook * wb, FILE * pktlog) {
-    this->wb = wb;
-    this->pktlog = pktlog;
-    this->cell = cell_new();
-  }
+namespace realtime {
 
-  virtual ~CsvParser (void) {
-    this->cell->destroy (cell);
-  }
+  class CsvParser : public proactor::Worker {
+  private:
+    Workbook * wb;
+    FILE * pktlog;
+    Cell * cell;
+  public:
+    CsvParser (Workbook * wb, FILE * pktlog) {
+      this->wb = wb;
+      this->pktlog = pktlog;
+      this->cell = cell_new();
+    }
 
-  void * run (void * null);
-};
+    virtual ~CsvParser (void) {
+      this->cell->destroy (cell);
+    }
 
+    void * run (void * null);
+  };
+}
 #endif
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
index cf79243..75cd57b 100644
--- a/src/realtime/Network.cpp
+++ b/src/realtime/Network.cpp
@@ -1,4 +1,4 @@
-/* 
+/*
    Connection.cpp - Connection Object Source File
 
    The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
@@ -23,78 +23,71 @@
 
 #define IS_TERMINAL(c) ((*c == '\n') || (*c == '\r'))
 
-Connection::Connection (int sockfd) {
-  this->sockfd = sockfd;
-}
-
-Connection::~Connection (void) {
-}
+namespace realtime {
+  
+  Connection::Connection (int sockfd) {
+    this->sockfd = sockfd;
+  }
 
-/*****************************************************************************/
-NetworkDispatcher::NetworkDispatcher (proactor::Proactor * pro) {
-  this->pro = pro;
-}
+  Connection::~Connection (void) {
+  }
 
-NetworkDispatcher::~NetworkDispatcher (void) {
-}
+  NetworkDispatcher::NetworkDispatcher (proactor::Proactor * pro) {
+    this->pro = pro;
+  }
+  
+  NetworkDispatcher::~NetworkDispatcher (void) {
+  }
 
-void *
-NetworkDispatcher::run (void * null) {
-  this->running = true;
+  void *
+  NetworkDispatcher::run (void * null) {
+    this->running = true;
 
-  while (this->running == true)
-    {
+    while (this->running == true) {
       // Dispatch all of the input items on the queue.
       this->inputQueue.lock();
 
-      while (this->inputQueue.size() > 0)
-	{
-	  // For right now all we're doing is pushing up the chain.
-	  this->pro->onReadComplete ( this->inputQueue.pop() );
-	}
+      while (this->inputQueue.size() > 0) {
+	// For right now all we're doing is pushing up the chain.
+	this->pro->onReadComplete ( this->inputQueue.pop() );
+      }
 
       this->inputQueue.unlock();
 
       Thread::sleep(100);
     }
   
-  return NULL; 
-}
-
-/*****************************************************************************/
-
-ConnectionThread::ConnectionThread (proactor::Dispatcher * d, int newfd) {
-  this->socket = new Connection (newfd);
-  this->dispatcher = d;
-}
-
-ConnectionThread::~ConnectionThread (void) {
-  delete socket;
-}
-
-void *
-ConnectionThread::run (void * null) {
-  this->running = true;
-  int size = 0;
-  char buf[MAX_INPUT_SIZE];
-  char * p = NULL, * q = NULL;
-
-  while (this->running == true) 
-    {
-      if ((size = this->socket->receive (&buf[0], MAX_INPUT_SIZE)) <= 0)
-	{
-	  // 
-	  break;
-	}
+    return NULL; 
+  }
+
+  ConnectionThread::ConnectionThread (proactor::Dispatcher * d, int newfd) {
+    this->socket = new Connection (newfd);
+    this->dispatcher = d;
+  }
+
+  ConnectionThread::~ConnectionThread (void) {
+    delete socket;
+  }
+
+  void *
+  ConnectionThread::run (void * null) {
+    this->running = true;
+    int size = 0;
+    char buf[MAX_INPUT_SIZE];
+    char * p = NULL, * q = NULL;
+
+    while (this->running == true) {
+      if ((size = this->socket->receive (&buf[0], MAX_INPUT_SIZE)) <= 0) {
+	// 
+	break;
+      }
 
       buf[size] = 0;
       
       q = p = &buf[0];
 
-      while (p && (*p != '\0'))
-	{
-	  if (IS_TERMINAL (p))
-	    {
+      while (p && (*p != '\0')) {
+	  if (IS_TERMINAL (p)) {
 	      *p = 0;
 
 	      if (*(p+1) == '\n')
@@ -104,54 +97,50 @@ ConnectionThread::run (void * null) {
 	      
 	      q = (++p);
 	      continue;
-	    }
+	  }
 	  p++;
-	}
+      }
       
       Thread::sleep (100);
     }
 
-  this->dispatcher->removeWorker (this);
-  return NULL;
-}
-
-/*****************************************************************************/
-
-AcceptThread::AcceptThread (TcpServerSocket::Acceptor * acceptor,
-			    proactor::Dispatcher * dispatcher) {
-  this->dispatcher = dispatcher;
-  this->acceptor = acceptor;
-}
-
-AcceptThread::~AcceptThread (void) {
-  delete this->acceptor;
-}
-
-void *
-AcceptThread::run (void * null) {
-  this->running = true;
-  
-  while (this->running == true)
-    {
+    this->dispatcher->removeWorker (this);
+    return NULL;
+  }
+
+  AcceptThread::AcceptThread (TcpServerSocket::Acceptor * acceptor,
+			      proactor::Dispatcher * dispatcher) {
+    this->dispatcher = dispatcher;
+    this->acceptor = acceptor;
+  }
+
+  AcceptThread::~AcceptThread (void) {
+    delete this->acceptor;
+  }
+
+  void *
+  AcceptThread::run (void * null) {
+    this->running = true;
+    
+    while (this->running == true) {
       int newfd = -1;
 	
-      if ((newfd = this->acceptor->acceptIncoming()) < 0)
-	{
-	  this->running = false;
-	  break;
-	}
+      if ((newfd = this->acceptor->acceptIncoming()) < 0) {
+	this->running = false;
+	break;
+      }
 
       ConnectionThread * c = new ConnectionThread (this->dispatcher, newfd);
       
-      if (c->start() == false)
-	{
-	  // Failed for some reason; cut out and quit for now.
-	  break;
-	}
-	
-	this->dispatcher->addWorker ( c );
-	Thread::sleep (100);
+      if (c->start() == false) {
+	// Failed for some reason; cut out and quit for now.
+	break;
       }
+	
+      this->dispatcher->addWorker ( c );
+      Thread::sleep (100);
+    }
 
     return NULL;
+  }
 }
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
index 8ad8d11..f31dfc6 100644
--- a/src/realtime/Network.hpp
+++ b/src/realtime/Network.hpp
@@ -29,39 +29,41 @@
 
 #define MAX_INPUT_SIZE 4194304
 
-class Connection : public TcpSocket {
-public:
-  Connection (int sockfd); 
-  virtual ~Connection (void);
-};
+namespace realtime {
 
-class NetworkDispatcher : public proactor::Dispatcher {
-public:
-  NetworkDispatcher (proactor::Proactor * pro);
-  virtual ~NetworkDispatcher (void);
+  class Connection : public TcpSocket {
+  public:
+    Connection (int sockfd); 
+    virtual ~Connection (void);
+  };
 
-  void * run (void * null);
-};
+  class NetworkDispatcher : public proactor::Dispatcher {
+  public:
+    NetworkDispatcher (proactor::Proactor * pro);
+    virtual ~NetworkDispatcher (void);
+    
+    void * run (void * null);
+  };
 
-class ConnectionThread : public proactor::Worker {
-private:
-  Connection * socket;
-public:
-  ConnectionThread (proactor::Dispatcher * dispatcher, int newfd);
-  virtual ~ConnectionThread (void);
+  class ConnectionThread : public proactor::Worker {
+  private:
+    Connection * socket;
+  public:
+    ConnectionThread (proactor::Dispatcher * dispatcher, int newfd);
+    virtual ~ConnectionThread (void);
   
-  void * run (void * null);
-};
+    void * run (void * null);
+  };
 
-class AcceptThread : public proactor::Worker {
-private:
-  TcpServerSocket::Acceptor * acceptor;
-public:
-  AcceptThread (TcpServerSocket::Acceptor * acceptor,
-		proactor::Dispatcher * dispatcher);
-  virtual ~AcceptThread (void);
-
-  void * run (void * null);
-};
+  class AcceptThread : public proactor::Worker {
+  private:
+    TcpServerSocket::Acceptor * acceptor;
+  public:
+    AcceptThread (TcpServerSocket::Acceptor * acceptor,
+		  proactor::Dispatcher * dispatcher);
+    virtual ~AcceptThread (void);
 
+    void * run (void * null);
+  };
+}
 #endif
diff --git a/src/realtime/Packet.cpp b/src/realtime/Packet.cpp
index ef0bbd8..e1b61c1 100755
--- a/src/realtime/Packet.cpp
+++ b/src/realtime/Packet.cpp
@@ -32,52 +32,49 @@
     }						 \
   }
 
-Packet::Packet (void)
-{
-  this->delimiter = '\0';
-  this->type = -1;
-}
+namespace realtime {
 
-Packet::~Packet (void)
-{
-  this->time.clear();
-  this->fields.clear();
-}
+  Packet::Packet (void) {
+    this->delimiter = '\0';
+    this->type = -1;
+  }
 
-gboolean
-Packet::parse (const gchar * buf)
-{
-  this->fields.clear();
+  Packet::~Packet (void) {
+    this->time.clear();
+    this->fields.clear();
+  }
 
-  if (IS_NULLSTR (buf)) return FALSE;
+  gboolean
+  Packet::parse (const gchar * buf) {
+    this->fields.clear();
 
-  this->delimiter = buf[0];
+    if (IS_NULLSTR (buf)) 
+      return FALSE;
+  
+    this->delimiter = buf[0];
 
-  String line(&buf[1]), value;
+    String line(&buf[1]), value;
 
-  WORD (this->delimiter, line, this->time);
-  WORD (this->delimiter, line, this->type);
+    WORD (this->delimiter, line, this->time);
+    WORD (this->delimiter, line, this->type);
 
-  while (line.length() > 0)
-    {
+    while (line.length() > 0) {
       WORD (this->delimiter, line, value);
       this->fields.push_back (value);
     }
 
-  return TRUE;
-}
+    return TRUE;
+  }
 
-Map<String,String>
-Packet::parseFormatString (const gchar * buf)
-{
-  String fmt(buf);
-  Map<String,String> pairs; pairs.clear();
+  Map<String,String>
+  Packet::parseFormatString (const gchar * buf) {
+    String fmt(buf);
+    Map<String,String> pairs; pairs.clear();
 
-  size_t pos = 0, length = fmt.length(), comma = 0, equal = 0;
-  String key, val;
+    size_t pos = 0, length = fmt.length(), comma = 0, equal = 0;
+    String key, val;
 
-  while (pos < length)
-    {
+    while (pos < length) {
       if ((comma = fmt.find_first_of (',')) == String::npos)
 	comma = length;
       
@@ -95,5 +92,6 @@ Packet::parseFormatString (const gchar * buf)
       fmt = fmt.substr (comma+1, length);
       length = fmt.length();
     }
-  return pairs;
+    return pairs;
+  }
 }
diff --git a/src/realtime/Packet.hpp b/src/realtime/Packet.hpp
index 2e78d75..012a9d7 100755
--- a/src/realtime/Packet.hpp
+++ b/src/realtime/Packet.hpp
@@ -31,17 +31,17 @@
 #define Array  std::vector
 #define Map    std::map
 
-class Packet
-{
-private:
-  /* Members */
-  String time;
-  String type;
-  Array<String> fields;
-  gchar delimiter;
-public:
-  enum 
-    {
+namespace realtime {
+
+  class Packet {
+  private:
+    /* Members */
+    String time;
+    String type;
+    Array<String> fields;
+    gchar delimiter;
+  public:
+    enum {
       TYPE_UPDATECELL = 0,
       TYPE_ADDSHEET,
       TYPE_REMSHEET,
@@ -53,22 +53,21 @@ public:
       MAX_TYPES
     };
   
-  Packet (void);
-  ~Packet (void);
+    Packet (void);
+    ~Packet (void);
   
-  /* Methods */
-  gboolean parse (const gchar *);
-  Map<String,String> parseFormatString (const gchar *);
-
-  inline gchar getDelimiter (void) const { return this->delimiter; }
-  inline gint getType (void) const { return atoi (this->type.c_str()); }
-  inline const gchar * getTime (void) const { return this->time.c_str(); }
-  inline gint getFieldSize (void) const { return this->fields.size(); }
-  inline const gchar * operator[] (gint index) const 
-  {
-    return this->fields.at(index).c_str();
-  }
-  inline size_t size (void) const { return this->fields.size(); }
-};
+    /* Methods */
+    gboolean parse (const gchar *);
+    Map<String,String> parseFormatString (const gchar *);
 
+    inline gchar getDelimiter (void) const { return this->delimiter; }
+    inline gint getType (void) const { return atoi (this->type.c_str()); }
+    inline const gchar * getTime (void) const { return this->time.c_str(); }
+    inline gint getFieldSize (void) const { return this->fields.size(); }
+    inline const gchar * operator[] (gint index) const {
+      return this->fields.at(index).c_str();
+    }
+    inline size_t size (void) const { return this->fields.size(); }
+  };
+}
 #endif
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index c0ebb80..5c63976 100644
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -30,256 +30,224 @@
 #include <queue>
 #include <ctime>
 
-class PacketParser : public proactor::Worker {
-private:
-  Workbook * wb;
-  FILE * pktlog;
-  Cell * cell;
-  int verbosity;
-public:
-  PacketParser (Workbook * wb, FILE * pktlog, int verbosity = 0) { 
-    this->wb = wb;
-    this->pktlog = pktlog;
-    this->cell = cell_new();
-    this->verbosity = verbosity;
-  }
+namespace realtime {
+
+  class PacketParser : public proactor::Worker {
+  private:
+    Workbook * wb;
+    FILE * pktlog;
+    Cell * cell;
+    int verbosity;
+  public:
+    PacketParser (Workbook * wb, FILE * pktlog, int verbosity = 0) { 
+      this->wb = wb;
+      this->pktlog = pktlog;
+      this->cell = cell_new();
+      this->verbosity = verbosity;
+    }
   
-  virtual ~PacketParser (void) {
-    this->cell->destroy (cell);
-  }
-
-  void * run (void * null) {
-    this->running = true;
-    std::queue<std::string> queue;
-    Packet packet;
-    const char * p = NULL;
-
-    while (this->running == true)
-      {
-	if (this->inputQueue.size() > 0)
-	  {
-	    // Lock, copy, clear, unlock. - Free this up.
-	    this->inputQueue.lock();
-	    queue = this->inputQueue.copy();
-	    this->inputQueue.clear();
-	    this->inputQueue.unlock();
-	    	    
-	    while (queue.size() > 0)
-	      {
-		// Never understood why pop() doesn't return the element.
-		std::string buf = queue.front(); queue.pop();
-		p = buf.c_str();
-
-		if (packet.parse (p) == FALSE)
-		  {
-		    g_warning ("Failed parsing packet '%s'", buf.c_str());
-		    Thread::sleep (5);
-		    continue;
-		  }
-
-		switch (packet.getType())
-		  {
-		  default:
-		    g_warning ("Invaild packet line '%s'", buf.c_str());
-		    break;
-		    /* ^time^type^sheet_name^sheet_name^after */
-		  case Packet::TYPE_MOVESHEET:
-		    {
-		      if (packet.size() != 3)
-			{
-			  g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
-				     buf.c_str());
-			  break;
-			}
-
-		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-		      if (IS_NULL (sheet))
-			{
-			  g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
-				     packet[0],
-				     (strcmp(packet[2], "0") == 0) ? "after" : "before",
-				     packet[1]);
-			  break;
-			}
+    virtual ~PacketParser (void) {
+      this->cell->destroy (cell);
+    }
+
+    void * run (void * null) {
+      this->running = true;
+      std::queue<std::string> queue;
+      Packet packet;
+      const char * p = NULL;
+
+      while (this->running == true) {
+	if (this->inputQueue.size() > 0) {
+	  // Lock, copy, clear, unlock. - Free this up.
+	  this->inputQueue.lock();
+	  queue = this->inputQueue.copy();
+	  this->inputQueue.clear();
+	  this->inputQueue.unlock();
+	  
+	  while (queue.size() > 0) {
+	    // Never understood why pop() doesn't return the element.
+	    std::string buf = queue.front(); queue.pop();
+	    p = buf.c_str();
+
+	    if (packet.parse (p) == FALSE) {
+	      g_warning ("Failed parsing packet '%s'", buf.c_str());
+	      Thread::sleep (5);
+	      continue;
+	    }
+
+	    switch (packet.getType()) {
+	    default:
+	      g_warning ("Invaild packet line '%s'", buf.c_str());
+	      break;
+	      /* ^time^type^sheet_name^sheet_name^after */
+	    case Packet::TYPE_MOVESHEET: {
+	      if (packet.size() != 3) {
+		g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
+			   buf.c_str());
+		break;
+	      }
+	      
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet)) {
+		g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
+			   packet[0],
+			   (strcmp(packet[2], "0") == 0) ? "after" : "before",
+			   packet[1]);
+		break;
+	      }
 
-		      if (wb->move_sheet (wb, sheet,
-					  packet[1], 
-					  atoi (packet[2]))
-			  == FALSE)
-			{
-			  g_warning ("Failed moving sheet '%s'", packet[0]);
-			  break;
-			}
-		    }
-		    break;
-		    /* ^time^type^sheet_name^loadpath */
-		  case Packet::TYPE_LOADSHEET:
-		    {
-		      if (packet.size() != 2)
-			{			  
-			  g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
-				     buf.c_str());
-			  break;
-			}
+	      if (wb->move_sheet (wb, sheet, packet[1], atoi (packet[2]))
+		  == FALSE) {
+		g_warning ("Failed moving sheet '%s'", packet[0]);
+		break;
+	      }
+	    }
+	      break;
+	      /* ^time^type^sheet_name^loadpath */
+	    case Packet::TYPE_LOADSHEET: {
+	      if (packet.size() != 2) {			  
+		g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
+			   buf.c_str());
+		break;
+	      }
 
-		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-		      if (IS_NULL (sheet))
-			{
-			  g_warning ("Unable to load geometry file; sheet '%s'"
-				       " does not exist", packet[0]);
-			  break;
-			}
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet)) {
+		g_warning ("Unable to load geometry file; sheet '%s'"
+			   " does not exist", packet[0]);
+		break;
+	      }
 	      
-		      sheet->load (sheet, packet[1]);
-		    }
-		    break;
-		    /* ^time^type^sheet_name^savepath */
-		  case Packet::TYPE_SAVESHEET:
-		    {
-		      if (packet.size() != 2)
-			{
-			  g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
-				     buf.c_str());
-			  break;
-			}
+	      sheet->load (sheet, packet[1]);
+	    }
+	      break;
+	      /* ^time^type^sheet_name^savepath */
+	    case Packet::TYPE_SAVESHEET: {
+	      if (packet.size() != 2) {
+		g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
+			   buf.c_str());
+		break;
+	      }
 		      
-		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-		      if (IS_NULL (sheet))
-			{
-			  g_warning ("Failed saving sheet '%s'; does not exist",
-				     packet[0]);
-			  break;
-			}
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet)) {
+		g_warning ("Failed saving sheet '%s'; does not exist",
+			   packet[0]);
+		break;
+	      }
 	      
-		      if (sheet->save (sheet, packet[1]) == FALSE)
-			{
-			  g_warning ("Unable to save sheet.");
-			  break;
-			}
-		    }
-		    break;
-		    /* ^time^type^sheet_name^position */
-		  case Packet::TYPE_MOVESHEETINDEX:
-		    {
-		      if (packet.size() != 2)
-			{
-			  g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
-				     "format: %s", buf.c_str());
-			  break;
-			}
+	      if (sheet->save (sheet, packet[1]) == FALSE) {
+		g_warning ("Unable to save sheet.");
+		break;
+	      }
+	    }
+	      break;
+	      /* ^time^type^sheet_name^position */
+	    case Packet::TYPE_MOVESHEETINDEX: {
+	      if (packet.size() != 2) {
+		g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
+			   "format: %s", buf.c_str());
+		break;
+	      }
 
-		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-		      if (IS_NULL (sheet))
-			{
-			  g_warning ("Failed moving sheet '%s' to %d:"
-				     " Does not exist", packet[0], atoi(packet[1]));
-			  break;
-			}
-		      
-		      if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) 
-			  == FALSE)
-			{
-			  g_warning ("Failed moving sheet '%s' to %d:"
-				     " Invaild index\n", packet[0], atoi(packet[1]));
-			}
-		    }
-		    break;
-		    /* ^time^type^sheet_name */
-		  case Packet::TYPE_REMSHEET:
-		    {
-		      if (packet.size() != 1)
-			{
-			  g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
-				     buf.c_str());
-			  break;
-			}
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet)) {
+		g_warning ("Failed moving sheet '%s' to %d:"
+			   " Does not exist", packet[0], atoi(packet[1]));
+		break;
+	      }
 		      
-		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-		      if (IS_NULL (sheet))
-			{
-			  g_warning ("Failed removing sheet '%s':"
-				     " Does not exist", packet[0]);
-			  break;
-			}
-		      wb->remove_sheet (wb, sheet);
-		      sheet->destroy (sheet);
-		    }
-		    break;
-		    /* ^time^type^sheet_name^max_row^max_column */
-		  case Packet::TYPE_ADDSHEET:
-		    {
-		      if (packet.size() != 3)
-			{
-			  g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
-				     buf.c_str());
-			  break;
-			}
+	      if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) == FALSE) {
+		g_warning ("Failed moving sheet '%s' to %d:"
+			   " Invaild index\n", packet[0], atoi(packet[1]));
+	      }
+	    }
+	      break;
+	      /* ^time^type^sheet_name */
+	    case Packet::TYPE_REMSHEET: {
+	      if (packet.size() != 1) {
+		g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
+			   buf.c_str());
+		break;
+	      }
 		      
-		      wb->add_new_sheet (wb, 
-					 packet[0],
-					 atoi (packet[1]),
-					 atoi (packet[2]));
-		    }
-		    break;
-		    /* ^time^type^sheet_name^row^column^format^data */
-		  case Packet::TYPE_UPDATECELL:
-		    {
-		      if (packet.size() != 5)
-			{
-			  g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
-				     "format: %s", buf.c_str());
-			  break;
-			}
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet)) {
+		g_warning ("Failed removing sheet '%s':"
+			   " Does not exist", packet[0]);
+		break;
+	      }
+	      wb->remove_sheet (wb, sheet);
+	      sheet->destroy (sheet);
+	    }
+	      break;
+	      /* ^time^type^sheet_name^max_row^max_column */
+	    case Packet::TYPE_ADDSHEET: {
+	      if (packet.size() != 3) {
+		g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
+			   buf.c_str());
+		break;
+	      }
 		      
-		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      wb->add_new_sheet (wb, 
+				 packet[0],
+				 atoi (packet[1]),
+				 atoi (packet[2]));
+	    }
+	      break;
+	      /* ^time^type^sheet_name^row^column^format^data */
+	    case Packet::TYPE_UPDATECELL: {
+	      if (packet.size() != 5) {
+		g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
+			   "format: %s", buf.c_str());
+		break;
+	      }
 		      
-		      if (IS_NULL (sheet))
-			{
-			  g_warning ("Invaild sheet name '%s': Does not exist",
-				     packet[0]);
-			  break;
-			}
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet)) {
+		g_warning ("Invaild sheet name '%s': Does not exist",
+			   packet[0]);
+		break;
+	      }
 	            
-		      cell->set_row (cell, atoi (packet[1]) );
-		      cell->set_column (cell, atoi (packet[2]) );
+	      cell->set_row (cell, atoi (packet[1]) );
+	      cell->set_column (cell, atoi (packet[2]) );
 	      
-		      if (strlen (packet[3]) > 0)
-			{
-			  Map<String,String> fmt = packet.parseFormatString (packet[3]);
-		  
-			  if (fmt["bgcolor"].length() > 0)
-			    cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
-			  if (fmt["fgcolor"].length() > 0)
-			    cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
-			  if (fmt["justification"].length() > 0)
-			    cell->set_justification (cell, 
-						     (GtkJustification)
-						     atoi (fmt["justification"].c_str()));
-			}
-		      
-		      cell->set_value (cell, packet[4]);
-		      
-		      sheet->apply_cell (sheet, cell);
-		      
-		      if (this->verbosity > 0)
-			{
-			  g_message ("Cell (%d,%d) updated", 
-				     cell->row, cell->column);
-			}
-		    }
-		    break;
-		  }
+	      if (strlen (packet[3]) > 0) {
+		Map<String,String> fmt = packet.parseFormatString (packet[3]);
 		
-		fprintf (pktlog, "%s\n", buf.c_str());
-		fflush (pktlog);
-		Thread::sleep(5);
+		if (fmt["bgcolor"].length() > 0)
+		  cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
+		if (fmt["fgcolor"].length() > 0)
+		  cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
+		if (fmt["justification"].length() > 0)
+		  cell->set_justification (cell, 
+					   (GtkJustification)
+					   atoi (fmt["justification"].c_str()));
+	      }
+	      
+	      cell->set_value (cell, packet[4]);
+	      
+	      sheet->apply_cell (sheet, cell);
+		      
+	      if (this->verbosity > 0) {
+		g_message ("Cell (%d,%d) updated", 
+			   cell->row, cell->column);
 	      }
+	    }
+	      break;
+	    }
+		
+	    fprintf (pktlog, "%s\n", buf.c_str());
+	    fflush (pktlog);
+	    Thread::sleep(5);
 	  }
+	}
 	Thread::sleep (100);
       }
 
-    return NULL;
-  }
-};
-
+      return NULL;
+    }
+  };
+}
 #endif
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index b923c80..d6bb0e0 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -35,6 +35,8 @@
 #include "PacketParser.hpp"
 #include "Packet.hpp"
 
+using namespace realtime;
+
 /* @description: This method creates a filename with the prefix supplied and
    uses the pid of the process as its suffix. 
    @pre: The prefix (should be a file path, obviously). */

commit aed6c404e293577dbd9aff235e16937ffe1a9f63
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Sat Apr 11 17:08:50 2009 +0000

    Updated proactor design and added network python test.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@9 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/.gtkworkbook b/.gtkworkbook
index 73223a7..d73595e 100644
--- a/.gtkworkbook
+++ b/.gtkworkbook
@@ -1,5 +1,5 @@
-INSLIBDIR=/home/jbellone/gtkworkbook/lib
-INSBINDIR=/home/jbellone/gtkworkbook/bin
-INSEXTDIR=/home/jbellone/gtkworkbook/lib/gtkcsv
-PROJDIR=/home/jbellone/work/gtkworkbook
-SYSINSPATH=/home/jbellone
+INSLIBDIR=/home/johnb/gtkworkbook/lib
+INSBINDIR=/home/johnb/gtkworkbook/bin
+INSEXTDIR=/home/johnb/gtkworkbook/lib/gtkworkbook
+PROJDIR=/home/johnb/work/gtkworkbook
+SYSINSPATH=/home/johnb
diff --git a/bin/application.cfg b/bin/application.cfg
index 167539a..9c25431 100755
--- a/bin/application.cfg
+++ b/bin/application.cfg
@@ -7,6 +7,7 @@
 	linux :: filename=realtime.so;
 	log :: path=/home/johnb;
 	tcp :: port=8888;
+	debug :: verbosity=0;
 }
 %block basic
 {
diff --git a/bin/socketTest.py b/bin/socketTest.py
new file mode 100644
index 0000000..d4bf6a8
--- /dev/null
+++ b/bin/socketTest.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python
+import sys
+import optparse
+import socket
+
+def main():
+    p = optparse.OptionParser()
+    p.add_option("--port", "-p", default=8888)
+    p.add_option("--input", "-i", default="test.txt")
+    options, arguments = p.parse_args()
+
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    sock.connect(("localhost", options.port))
+    
+    fp = open(options.input, "r")
+
+    ii = 0
+
+    sock.sendall ("^0^1^sheet1^10000^11\n")
+    
+    while ii < 10000:
+        sock.sendall ("^%d^0^sheet1^0^0^^0\n" %ii)
+        ii = ii + 1
+
+    sock.close()
+        
+if __name__ == '__main__':
+    main()
diff --git a/bin/test.txt b/bin/test.txt
index fefa4fd..d676b5b 100755
--- a/bin/test.txt
+++ b/bin/test.txt
@@ -1,11 +1,10 @@
-^1^1^sheet0^100^10
-^2^sheet0^3^2^bgcolor=red,fgcolor=white^First
-^3^sheet0^4^6^bgcolor=blue,fgcolor=white^Second
+^2^0^sheet0^3^2^bgcolor=red,fgcolor=white^First
+^3^0^sheet0^4^6^bgcolor=blue,fgcolor=white^Second
 ^4^1^sheet1^100^10
 ^5^1^sheet2^100^10
 ^6^1^sheet3^100^10
 ^7^0^sheet1^3^2^bgcolor=red,fgcolor=white^First
-^8^sheet1^4^6^bgcolor=blue,fgcolor=white^Second
+^8^0^sheet1^4^6^bgcolor=blue,fgcolor=white^Second
 ^9^0^sheet2^3^2^bgcolor=red,fgcolor=white^First
 ^10^0^sheet2^4^6^bgcolor=blue,fgcolor=white^Second
 ^11^2^sheet1
diff --git a/bin/yahooQuoteServer.py b/bin/yahooQuoteServer.py
index 559883a..69d5a1f 100755
--- a/bin/yahooQuoteServer.py
+++ b/bin/yahooQuoteServer.py
@@ -48,7 +48,7 @@ if __name__ == "__main__":
 # Copyright (C) 2009, John Bellone, Jr. <jvb4@njit.edu>
 #
 # This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as publisehd by
+# it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 2 of the License, or
 # (at your option) any later version.
 #
diff --git a/csv/Makefile b/csv/Makefile
index 94ebcb2..7e22a9c 100644
--- a/csv/Makefile
+++ b/csv/Makefile
@@ -33,7 +33,7 @@ install_static_lib: libcsv.a
 	cp -f $< $(DESTDIR)$(LIBDIR)/$<
 
 libcsv.o: libcsv.c csv.h
-	$(CC) $< -c -o $@
+	$(CC) -fPIC $< -c -o $@
 
 libcsv.so: libcsv.o
 	$(CC) -shared $< -o $@
diff --git a/src/main.c b/src/main.c
index 86362f3..4867f2c 100755
--- a/src/main.c
+++ b/src/main.c
@@ -27,7 +27,7 @@ main(int argc, char *argv[])
 
   app->run (app);
   app->close (app);
-  
+
   return 0; 
 }
 
diff --git a/src/realtime/AcceptThread.hpp b/src/realtime/AcceptThread.hpp
deleted file mode 100755
index bc65d9f..0000000
--- a/src/realtime/AcceptThread.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/* 
-   AcceptThread.hpp - Acceptor Thread Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_ACCEPTTHREAD
-#define HPP_ACCEPTTHREAD
-
-#include "network/Tcp.hpp"
-#include "proactor/Dispatcher.hpp"
-#include "Connection.hpp"
-#include <iostream>
-
-/* @description: This object runs as a separate thread accepting incoming
-   connections from a TcpServerSocket object.
-   @author: John `jb Bellone (jvb4@njit.edu) */
-class AcceptThread : public proactor::Dispatcher {
-private:
-  TcpServerSocket::Acceptor * acceptor;
-public:
-  AcceptThread (TcpServerSocket::Acceptor * acceptor, 
-		proactor::Proactor * pro) {
-    this->pro = pro;
-    this->acceptor = acceptor;
-  }
-
-  virtual ~AcceptThread (void) {
-      delete acceptor;
-  }
-
-  void * run (void * null) {
-    this->running = true;
-  
-    while (this->running == true)
-      {
-	int newfd = -1;
-	
-	if ((newfd = this->acceptor->acceptIncoming()) < 0)
-	  {
-	    this->running = false;
-	    break;
-	  }
-
-	ConnectionThread * c = new ConnectionThread (this->pro, newfd);
-	c->setEventId ( this->getEventId() );
-
-	if (c->start() == false)
-	  {
-	    // Failed for some reason; cut out and quit for now.
-	    break;
-	  }
-	
-	this->pro->addDispatcher ( c );
-	Thread::sleep (100);
-      }
-
-    return NULL;
-  }
-};
-
-#endif
diff --git a/src/realtime/Connection.cpp b/src/realtime/Connection.cpp
deleted file mode 100644
index b430943..0000000
--- a/src/realtime/Connection.cpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/* 
-   Connection.cpp - Connection Object Source File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#include "Connection.hpp"
-#include <iostream>
-
-#define IS_TERMINAL(c) ((*c == '\n') || (*c == '\r'))
-
-Connection::Connection (int sockfd) {
-  this->sockfd = sockfd;
-}
-
-Connection::~Connection (void) {
-}
-
-/*****************************************************************************/
-
-ConnectionThread::ConnectionThread (proactor::Proactor * pro, int newfd) {
-  this->socket = new Connection (newfd);
-  this->pro = pro;
-}
-
-ConnectionThread::~ConnectionThread (void) {
-  delete socket;
-}
-
-void *
-ConnectionThread::run (void * null) {
-  this->running = true;
-  int size = 0;
-  char buf[MAX_INPUT_SIZE];
-  char * p = NULL, * q = NULL;
-
-  while (this->running == true) 
-    {
-      if ((size = this->socket->receive (&buf[0], MAX_INPUT_SIZE)) <= 0)
-	{
-	  this->running = false;
-	  break;
-	}
-
-      buf[size] = 0;
-
-      q = p = &buf[0];
-      while (p && (*p != '\0'))
-	{
-	  if (IS_TERMINAL (p))
-	    {
-	      *p = 0;
-
-	      if (*(p+1) == '\n')
-		p++;
-
-	      this->pro->onReadComplete (this->getEventId(), q);
-	      
-	      q = (++p);
-	      continue;
-	    }
-	  p++;
-	}
-      
-      Thread::sleep (100);
-    }
-
-  this->pro->removeDispatcher (this);
-  return NULL;
-}
diff --git a/src/realtime/Connection.hpp b/src/realtime/Connection.hpp
deleted file mode 100644
index 2273b30..0000000
--- a/src/realtime/Connection.hpp
+++ /dev/null
@@ -1,47 +0,0 @@
-/* 
-   Connection.hpp - Connection Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_CONNECTION
-#define HPP_CONNECTION
-
-#include "network/Tcp.hpp"
-#include "proactor/Dispatcher.hpp"
-#include "proactor/Proactor.hpp"
-#include <iostream>
-
-#define MAX_INPUT_SIZE 4096
-
-class Connection : public TcpSocket {
-public:
-  Connection (int sockfd); 
-  virtual ~Connection (void);
-};
-
-class ConnectionThread : public proactor::Dispatcher {
-private:
-  Connection * socket;
-public:
-  ConnectionThread (proactor::Proactor * pro, int newfd); 
-  virtual ~ConnectionThread (void);
-
-  void * run (void * null);
-};
-
-#endif
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
index f3e9a30..8b4bf44 100644
--- a/src/realtime/CsvParser.hpp
+++ b/src/realtime/CsvParser.hpp
@@ -1,14 +1,14 @@
 #ifndef HPP_CSVPARSER
 #define HPP_CSVPARSER
 
-#include "proactor/Job.hpp"
+#include "proactor/Worker.hpp"
 #include <workbook/workbook.h>
 #include <workbook/sheet.h>
 #include <workbook/cell.h>
 #include <csv/csv.h>
 #include <iostream>
 
-class CsvParser : public proactor::Job {
+class CsvParser : public proactor::Worker {
 private:
   Workbook * wb;
   FILE * pktlog;
diff --git a/src/realtime/Network.cpp b/src/realtime/Network.cpp
new file mode 100644
index 0000000..cf79243
--- /dev/null
+++ b/src/realtime/Network.cpp
@@ -0,0 +1,157 @@
+/* 
+   Connection.cpp - Connection Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Network.hpp"
+#include <iostream>
+
+#define IS_TERMINAL(c) ((*c == '\n') || (*c == '\r'))
+
+Connection::Connection (int sockfd) {
+  this->sockfd = sockfd;
+}
+
+Connection::~Connection (void) {
+}
+
+/*****************************************************************************/
+NetworkDispatcher::NetworkDispatcher (proactor::Proactor * pro) {
+  this->pro = pro;
+}
+
+NetworkDispatcher::~NetworkDispatcher (void) {
+}
+
+void *
+NetworkDispatcher::run (void * null) {
+  this->running = true;
+
+  while (this->running == true)
+    {
+      // Dispatch all of the input items on the queue.
+      this->inputQueue.lock();
+
+      while (this->inputQueue.size() > 0)
+	{
+	  // For right now all we're doing is pushing up the chain.
+	  this->pro->onReadComplete ( this->inputQueue.pop() );
+	}
+
+      this->inputQueue.unlock();
+
+      Thread::sleep(100);
+    }
+  
+  return NULL; 
+}
+
+/*****************************************************************************/
+
+ConnectionThread::ConnectionThread (proactor::Dispatcher * d, int newfd) {
+  this->socket = new Connection (newfd);
+  this->dispatcher = d;
+}
+
+ConnectionThread::~ConnectionThread (void) {
+  delete socket;
+}
+
+void *
+ConnectionThread::run (void * null) {
+  this->running = true;
+  int size = 0;
+  char buf[MAX_INPUT_SIZE];
+  char * p = NULL, * q = NULL;
+
+  while (this->running == true) 
+    {
+      if ((size = this->socket->receive (&buf[0], MAX_INPUT_SIZE)) <= 0)
+	{
+	  // 
+	  break;
+	}
+
+      buf[size] = 0;
+      
+      q = p = &buf[0];
+
+      while (p && (*p != '\0'))
+	{
+	  if (IS_TERMINAL (p))
+	    {
+	      *p = 0;
+
+	      if (*(p+1) == '\n')
+		p++;
+
+	      this->dispatcher->onReadComplete (q);
+	      
+	      q = (++p);
+	      continue;
+	    }
+	  p++;
+	}
+      
+      Thread::sleep (100);
+    }
+
+  this->dispatcher->removeWorker (this);
+  return NULL;
+}
+
+/*****************************************************************************/
+
+AcceptThread::AcceptThread (TcpServerSocket::Acceptor * acceptor,
+			    proactor::Dispatcher * dispatcher) {
+  this->dispatcher = dispatcher;
+  this->acceptor = acceptor;
+}
+
+AcceptThread::~AcceptThread (void) {
+  delete this->acceptor;
+}
+
+void *
+AcceptThread::run (void * null) {
+  this->running = true;
+  
+  while (this->running == true)
+    {
+      int newfd = -1;
+	
+      if ((newfd = this->acceptor->acceptIncoming()) < 0)
+	{
+	  this->running = false;
+	  break;
+	}
+
+      ConnectionThread * c = new ConnectionThread (this->dispatcher, newfd);
+      
+      if (c->start() == false)
+	{
+	  // Failed for some reason; cut out and quit for now.
+	  break;
+	}
+	
+	this->dispatcher->addWorker ( c );
+	Thread::sleep (100);
+      }
+
+    return NULL;
+}
diff --git a/src/realtime/Network.hpp b/src/realtime/Network.hpp
new file mode 100644
index 0000000..8ad8d11
--- /dev/null
+++ b/src/realtime/Network.hpp
@@ -0,0 +1,67 @@
+/* 
+   Connection.hpp - Connection Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_NETWORK
+#define HPP_NETWORK
+
+#include "network/Tcp.hpp"
+#include "proactor/Worker.hpp"
+#include "proactor/Dispatcher.hpp"
+#include "proactor/Proactor.hpp"
+#include <iostream>
+
+#define MAX_INPUT_SIZE 4194304
+
+class Connection : public TcpSocket {
+public:
+  Connection (int sockfd); 
+  virtual ~Connection (void);
+};
+
+class NetworkDispatcher : public proactor::Dispatcher {
+public:
+  NetworkDispatcher (proactor::Proactor * pro);
+  virtual ~NetworkDispatcher (void);
+
+  void * run (void * null);
+};
+
+class ConnectionThread : public proactor::Worker {
+private:
+  Connection * socket;
+public:
+  ConnectionThread (proactor::Dispatcher * dispatcher, int newfd);
+  virtual ~ConnectionThread (void);
+  
+  void * run (void * null);
+};
+
+class AcceptThread : public proactor::Worker {
+private:
+  TcpServerSocket::Acceptor * acceptor;
+public:
+  AcceptThread (TcpServerSocket::Acceptor * acceptor,
+		proactor::Dispatcher * dispatcher);
+  virtual ~AcceptThread (void);
+
+  void * run (void * null);
+};
+
+#endif
diff --git a/src/realtime/Packet.cpp b/src/realtime/Packet.cpp
index 6c23b23..ef0bbd8 100755
--- a/src/realtime/Packet.cpp
+++ b/src/realtime/Packet.cpp
@@ -63,6 +63,7 @@ Packet::parse (const gchar * buf)
       WORD (this->delimiter, line, value);
       this->fields.push_back (value);
     }
+
   return TRUE;
 }
 
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index b16d2fb..c0ebb80 100644
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -21,22 +21,27 @@
 #ifndef HPP_PACKETHANDLER
 #define HPP_PACKETHANDLER
 
-#include "proactor/Job.hpp"
+#include "proactor/Worker.hpp"
 #include "Packet.hpp"
 #include <workbook/cell.h>
 #include <workbook/sheet.h>
 #include <workbook/workbook.h>
+#include <string>
+#include <queue>
+#include <ctime>
 
-class PacketParser : public proactor::Job {
+class PacketParser : public proactor::Worker {
 private:
   Workbook * wb;
   FILE * pktlog;
   Cell * cell;
+  int verbosity;
 public:
-  PacketParser (Workbook * wb, FILE * pktlog) { 
+  PacketParser (Workbook * wb, FILE * pktlog, int verbosity = 0) { 
     this->wb = wb;
     this->pktlog = pktlog;
     this->cell = cell_new();
+    this->verbosity = verbosity;
   }
   
   virtual ~PacketParser (void) {
@@ -45,217 +50,232 @@ public:
 
   void * run (void * null) {
     this->running = true;
+    std::queue<std::string> queue;
     Packet packet;
     const char * p = NULL;
 
     while (this->running == true)
       {
-	while (this->inputQueue.size() > 0)
+	if (this->inputQueue.size() > 0)
 	  {
-	    std::string buf = this->inputQueue.pop();
-	    p = buf.c_str();
-
-	    if (packet.parse (p) == FALSE)
+	    // Lock, copy, clear, unlock. - Free this up.
+	    this->inputQueue.lock();
+	    queue = this->inputQueue.copy();
+	    this->inputQueue.clear();
+	    this->inputQueue.unlock();
+	    	    
+	    while (queue.size() > 0)
 	      {
-		g_warning ("Failed parsing packet '%s'", buf.c_str());
-		::sleep (1);
-		continue;
-	      }
+		// Never understood why pop() doesn't return the element.
+		std::string buf = queue.front(); queue.pop();
+		p = buf.c_str();
 
-	  switch (packet.getType())
-	    {
-	    default:
-	      g_warning ("Invaild packet line '%s'", buf.c_str());
-	      break;
-	    /* ^time^type^sheet_name^sheet_name^after */
-	  case Packet::TYPE_MOVESHEET:
-	    {
-	      if (packet.size() != 3)
-		{
-		  g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
+		if (packet.parse (p) == FALSE)
+		  {
+		    g_warning ("Failed parsing packet '%s'", buf.c_str());
+		    Thread::sleep (5);
+		    continue;
+		  }
 
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
-			 packet[0],
-			 (strcmp(packet[2], "0") == 0) ? "after" : "before",
-			 packet[1]);
-		  break;
-		}
+		switch (packet.getType())
+		  {
+		  default:
+		    g_warning ("Invaild packet line '%s'", buf.c_str());
+		    break;
+		    /* ^time^type^sheet_name^sheet_name^after */
+		  case Packet::TYPE_MOVESHEET:
+		    {
+		      if (packet.size() != 3)
+			{
+			  g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
+				     buf.c_str());
+			  break;
+			}
 
-	      if (wb->move_sheet (wb, sheet,
-				  packet[1], 
-				  atoi (packet[2]))
-		  == FALSE)
-		{
-		  g_warning ("Failed moving sheet '%s'", packet[0]);
-		  break;
-		}
-	    }
-	    break;
-	    /* ^time^type^sheet_name^loadpath */
-	  case Packet::TYPE_LOADSHEET:
-	    {
-	      if (packet.size() != 2)
-		{
-		  g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
+		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+		      if (IS_NULL (sheet))
+			{
+			  g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
+				     packet[0],
+				     (strcmp(packet[2], "0") == 0) ? "after" : "before",
+				     packet[1]);
+			  break;
+			}
 
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Unable to load geometry file; sheet '%s'"
-			     " does not exist", packet[0]);
-		  break;
-		}
-	      
-	      sheet->load (sheet, packet[1]);
-	    }
-	    break;
-	    /* ^time^type^sheet_name^savepath */
-	  case Packet::TYPE_SAVESHEET:
-	    {
-	      if (packet.size() != 2)
-		{
-		  g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
+		      if (wb->move_sheet (wb, sheet,
+					  packet[1], 
+					  atoi (packet[2]))
+			  == FALSE)
+			{
+			  g_warning ("Failed moving sheet '%s'", packet[0]);
+			  break;
+			}
+		    }
+		    break;
+		    /* ^time^type^sheet_name^loadpath */
+		  case Packet::TYPE_LOADSHEET:
+		    {
+		      if (packet.size() != 2)
+			{			  
+			  g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
+				     buf.c_str());
+			  break;
+			}
 
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Failed saving sheet '%s'; does not exist",
-			     packet[0]);
-		  break;
-		}
+		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+		      if (IS_NULL (sheet))
+			{
+			  g_warning ("Unable to load geometry file; sheet '%s'"
+				       " does not exist", packet[0]);
+			  break;
+			}
 	      
-	      if (sheet->save (sheet, packet[1]) == FALSE)
-		{
-		  g_warning ("Unable to save sheet.");
-		  break;
-		}
-	    }
-	    break;
-	    /* ^time^type^sheet_name^position */
-	  case Packet::TYPE_MOVESHEETINDEX:
-	    {
-	      if (packet.size() != 2)
-		{
-		  g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
-			     "format: %s", buf.c_str());
-		  break;
-		}
-
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Failed moving sheet '%s' to %d:"
-			     " Does not exist", packet[0], atoi(packet[1]));
-		  break;
-		}
+		      sheet->load (sheet, packet[1]);
+		    }
+		    break;
+		    /* ^time^type^sheet_name^savepath */
+		  case Packet::TYPE_SAVESHEET:
+		    {
+		      if (packet.size() != 2)
+			{
+			  g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
+				     buf.c_str());
+			  break;
+			}
+		      
+		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+		      if (IS_NULL (sheet))
+			{
+			  g_warning ("Failed saving sheet '%s'; does not exist",
+				     packet[0]);
+			  break;
+			}
 	      
-	      if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) 
-		  == FALSE)
-		{
-		  g_warning ("Failed moving sheet '%s' to %d:"
-			     " Invaild index\n", packet[0], atoi(packet[1]));
-		}
-	    }
-	    break;
-	    /* ^time^type^sheet_name */
-	  case Packet::TYPE_REMSHEET:
-	    {
-	      if (packet.size() != 1)
-		{
-		  g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
-
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Failed removing sheet '%s':"
-			     " Does not exist", packet[0]);
-		  break;
-		}
-	      wb->remove_sheet (wb, sheet);
-	      sheet->destroy (sheet);
-	    }
-	    break;
-	    /* ^time^type^sheet_name^max_row^max_column */
-	  case Packet::TYPE_ADDSHEET:
-	    {
-	      if (packet.size() != 3)
-		{
-		  g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
-
-	      wb->add_new_sheet (wb, 
-				 packet[0],
-				 atoi (packet[1]),
-				 atoi (packet[2]));
-	    }
-	    break;
-	    /* ^time^type^sheet_name^row^column^format^data */
-	  case Packet::TYPE_UPDATECELL:
-	    {
-	      if (packet.size() != 5)
-		{
-		  g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
-			     "format: %s", buf.c_str());
-		  break;
-		}
+		      if (sheet->save (sheet, packet[1]) == FALSE)
+			{
+			  g_warning ("Unable to save sheet.");
+			  break;
+			}
+		    }
+		    break;
+		    /* ^time^type^sheet_name^position */
+		  case Packet::TYPE_MOVESHEETINDEX:
+		    {
+		      if (packet.size() != 2)
+			{
+			  g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
+				     "format: %s", buf.c_str());
+			  break;
+			}
 
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Invaild sheet name '%s': Does not exist",
-			     packet[0]);
-		  break;
-		}
+		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+		      if (IS_NULL (sheet))
+			{
+			  g_warning ("Failed moving sheet '%s' to %d:"
+				     " Does not exist", packet[0], atoi(packet[1]));
+			  break;
+			}
+		      
+		      if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) 
+			  == FALSE)
+			{
+			  g_warning ("Failed moving sheet '%s' to %d:"
+				     " Invaild index\n", packet[0], atoi(packet[1]));
+			}
+		    }
+		    break;
+		    /* ^time^type^sheet_name */
+		  case Packet::TYPE_REMSHEET:
+		    {
+		      if (packet.size() != 1)
+			{
+			  g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
+				     buf.c_str());
+			  break;
+			}
+		      
+		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+		      if (IS_NULL (sheet))
+			{
+			  g_warning ("Failed removing sheet '%s':"
+				     " Does not exist", packet[0]);
+			  break;
+			}
+		      wb->remove_sheet (wb, sheet);
+		      sheet->destroy (sheet);
+		    }
+		    break;
+		    /* ^time^type^sheet_name^max_row^max_column */
+		  case Packet::TYPE_ADDSHEET:
+		    {
+		      if (packet.size() != 3)
+			{
+			  g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
+				     buf.c_str());
+			  break;
+			}
+		      
+		      wb->add_new_sheet (wb, 
+					 packet[0],
+					 atoi (packet[1]),
+					 atoi (packet[2]));
+		    }
+		    break;
+		    /* ^time^type^sheet_name^row^column^format^data */
+		  case Packet::TYPE_UPDATECELL:
+		    {
+		      if (packet.size() != 5)
+			{
+			  g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
+				     "format: %s", buf.c_str());
+			  break;
+			}
+		      
+		      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+		      
+		      if (IS_NULL (sheet))
+			{
+			  g_warning ("Invaild sheet name '%s': Does not exist",
+				     packet[0]);
+			  break;
+			}
 	            
-	      cell->set_row (cell, atoi (packet[1]) );
-	      cell->set_column (cell, atoi (packet[2]) );
+		      cell->set_row (cell, atoi (packet[1]) );
+		      cell->set_column (cell, atoi (packet[2]) );
 	      
-	      if (strlen (packet[3]) > 0)
-		{
-		  Map<String,String> fmt = packet.parseFormatString (packet[3]);
+		      if (strlen (packet[3]) > 0)
+			{
+			  Map<String,String> fmt = packet.parseFormatString (packet[3]);
 		  
-		  if (fmt["bgcolor"].length() > 0)
-		    cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
-		  if (fmt["fgcolor"].length() > 0)
-		    cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
-		  if (fmt["justification"].length() > 0)
-		    cell->set_justification (cell, 
-					     (GtkJustification)
-					     atoi (fmt["justification"].c_str()));
-		}
-	      
-	      cell->set_value (cell, packet[4]);
-	      
-	      sheet->apply_cell (sheet, cell);
-	      
-	      g_message ("Cell (%d,%d) updated", cell->row, cell->column);
-	    }
-	    break;
-	  }
-	
-	  fprintf (pktlog, "%s\n", buf.c_str());
-	  fflush (pktlog);
-	  ::sleep (1);
+			  if (fmt["bgcolor"].length() > 0)
+			    cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
+			  if (fmt["fgcolor"].length() > 0)
+			    cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
+			  if (fmt["justification"].length() > 0)
+			    cell->set_justification (cell, 
+						     (GtkJustification)
+						     atoi (fmt["justification"].c_str()));
+			}
+		      
+		      cell->set_value (cell, packet[4]);
+		      
+		      sheet->apply_cell (sheet, cell);
+		      
+		      if (this->verbosity > 0)
+			{
+			  g_message ("Cell (%d,%d) updated", 
+				     cell->row, cell->column);
+			}
+		    }
+		    break;
+		  }
+		
+		fprintf (pktlog, "%s\n", buf.c_str());
+		fflush (pktlog);
+		Thread::sleep(5);
+	      }
 	  }
-	::sleep (1);
+	Thread::sleep (100);
       }
 
     return NULL;
diff --git a/src/realtime/concurrent/Queue.hpp b/src/realtime/concurrent/Queue.hpp
index 6922f4f..58b7631 100755
--- a/src/realtime/concurrent/Queue.hpp
+++ b/src/realtime/concurrent/Queue.hpp
@@ -39,6 +39,17 @@ namespace concurrent {
     Queue (void) { }
     virtual ~Queue (void) { }
 
+    inline void clear (void) {
+      this->lock();
+      while (this->the_queue.size() > 0)
+	this->the_queue.pop();
+      this->unlock();
+    }
+
+    inline std::queue<T> copy (void) {
+      return this->the_queue;
+    }
+
     inline const T & back (void) {
       this->lock();
       T & elem = this->the_queue.back();
diff --git a/src/realtime/network/Tcp.cpp b/src/realtime/network/Tcp.cpp
index 46ad9bd..0b14e21 100755
--- a/src/realtime/network/Tcp.cpp
+++ b/src/realtime/network/Tcp.cpp
@@ -68,8 +68,14 @@ TcpServerSocket::~TcpServerSocket (void) {
 
 bool
 TcpServerSocket::start (int backlog = 5) {
+  int opt = 1;
+
   // This is to prevent conflicts with major services' ports.
-  if (this->port < 50)
+  if (this->port < 1024)
+    return false;
+
+  if (::setsockopt (this->sockfd, 
+		    SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
     return false;
 
   if (::bind (this->sockfd,
diff --git a/src/realtime/proactor/Dispatcher.cpp b/src/realtime/proactor/Dispatcher.cpp
new file mode 100644
index 0000000..114fae6
--- /dev/null
+++ b/src/realtime/proactor/Dispatcher.cpp
@@ -0,0 +1,45 @@
+/* 
+   Dispatcher.hpp - Dispatcher Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#include "Dispatcher.hpp"
+using namespace proactor;
+
+Dispatcher::~Dispatcher (void) {
+  while (this->inputQueue.size() > 0)
+    this->inputQueue.pop();
+}
+
+void
+Dispatcher::addWorker (Worker * w) {
+  this->workers.push_back (w);
+}
+
+bool
+Dispatcher::removeWorker (Worker * w) {
+  WorkerListType::iterator it = std::find (this->workers.begin(),
+					   this->workers.end(),
+					   w);
+
+  if (it == this->workers.end())
+    return false;
+  
+  this->workers.erase (it);
+  return true;
+}
diff --git a/src/realtime/proactor/Dispatcher.hpp b/src/realtime/proactor/Dispatcher.hpp
index 39af130..2a71462 100755
--- a/src/realtime/proactor/Dispatcher.hpp
+++ b/src/realtime/proactor/Dispatcher.hpp
@@ -22,25 +22,42 @@
 #define HPP_PROACTOR_DISPATCHER
 
 #include "../concurrent/Thread.hpp"
+#include "../concurrent/List.hpp"
+#include "../concurrent/Queue.hpp"
+#include "Event.hpp"
 
 namespace proactor {
 
   class Proactor;
+  class Worker;
 
   class Dispatcher : public concurrent::Thread {
   private:
-    int eid;
+    typedef concurrent::List<Worker *> WorkerListType;
+
+    WorkerListType workers;
+    int eventId;
   protected:
+    typedef concurrent::Queue<Event> EventQueueType;
+
     Proactor * pro;
+    EventQueueType inputQueue;
   public:
-    virtual ~Dispatcher (void) { }
+    virtual ~Dispatcher (void);
+
+    void addWorker (Worker * w);
+    bool removeWorker (Worker * w);
+
+    inline void onReadComplete (const char * buf) {
+      this->inputQueue.push ( Event (this->eventId, std::string(buf)) );
+    }
 
     inline void setEventId (int e) {
-      this->eid = e;
+      this->eventId = e;
     }
 
     inline int getEventId (void) {
-      return this->eid;
+      return this->eventId;
     }
   };
 
diff --git a/src/realtime/proactor/Job.hpp b/src/realtime/proactor/Job.hpp
deleted file mode 100755
index 189cb6a..0000000
--- a/src/realtime/proactor/Job.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/* 
-   Job.hpp - Job Object Header File
-
-   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
-   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the library; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
-*/
-#ifndef HPP_PROACTOR_JOB
-#define HPP_PROACTOR_JOB
-
-#include "../concurrent/Queue.hpp"
-#include "../concurrent/Thread.hpp"
-#include <string>
-
-namespace proactor {
-
-  class Job : public concurrent::Thread {
-  protected:
-    concurrent::Queue<std::string> inputQueue;
-  public:
-    inline void pushInputQueue (std::string buf) {
-      this->inputQueue.push (buf);
-    }
-  };
-
-}
-
-#endif
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
index 12dc34d..f76d13e 100755
--- a/src/realtime/proactor/Proactor.cpp
+++ b/src/realtime/proactor/Proactor.cpp
@@ -31,7 +31,7 @@ Proactor::~Proactor (void) {
     EventMapType::iterator it = this->eventsToHandlers.begin();
     while (it != this->eventsToHandlers.end())
       {
-	EventHandlers * q = (it->second);
+	WorkerListType * q = (it->second);
 	delete q;
 	it++;
       }
@@ -50,30 +50,35 @@ Proactor::~Proactor (void) {
 }
 
 void
-Proactor::registerHandler (int e, Job * job) {
+Proactor::addWorker (int e, Worker * job) {
   this->eventsToHandlers.lock();
   {
     EventMapType::iterator it = this->eventsToHandlers.find (e);
   
     if (it == this->eventsToHandlers.end())
-      this->eventsToHandlers[e] = new EventHandlers;  
+      this->eventsToHandlers[e] = new WorkerListType;  
     this->eventsToHandlers[e]->push_back (job);
   }
   this->eventsToHandlers.unlock();
 }
 
+void
+Proactor::onReadComplete (Event e) {
+  this->inputQueue.push (e);
+}
+
 void 
 Proactor::onReadComplete (int e, const char * buf) {
   this->inputQueue.push ( Event (e, std::string (buf)) );   
 }
 
 bool
-Proactor::unregisterHandler (int e, Job * job) {
+Proactor::removeWorker (int e, Worker * job) {
   bool result = false;
 
   this->eventsToHandlers.lock();
   {
-    EventHandlers::iterator it = 
+    WorkerListType::iterator it = 
       std::find (this->eventsToHandlers[e]->begin(),
 		 this->eventsToHandlers[e]->end(),
 		 job);
@@ -111,7 +116,7 @@ void *
 Proactor::run (void * null) {
   this->running = true;
   
-  EventHandlers::iterator it;
+  WorkerListType::iterator it;
 
   while (this->running == true)
     {
@@ -129,7 +134,7 @@ Proactor::run (void * null) {
 	  
 	  while (it != this->eventsToHandlers[e.id]->end())
 	    {
-	      Job * j = (*it);
+	      Worker * j = (*it);
 	      
 	      j->pushInputQueue (e.buf);
 		      
diff --git a/src/realtime/proactor/Proactor.hpp b/src/realtime/proactor/Proactor.hpp
index 0039971..f0beafc 100755
--- a/src/realtime/proactor/Proactor.hpp
+++ b/src/realtime/proactor/Proactor.hpp
@@ -25,7 +25,7 @@
 #include "../concurrent/Map.hpp"
 #include "../concurrent/Queue.hpp"
 #include "../concurrent/List.hpp"
-#include "Job.hpp"
+#include "Worker.hpp"
 #include "Event.hpp"
 #include "Dispatcher.hpp"
 #include <list>
@@ -33,29 +33,26 @@
 
 namespace proactor {
 
-  class Dispatcher;
-
-  class Proactor : public concurrent::Thread {
+  class Proactor : public Dispatcher {
   private:
-    typedef std::list<Job *> EventHandlers;
+    typedef std::list<Worker *> WorkerListType;
     typedef concurrent::List<Dispatcher *> DispatcherList;
-    typedef concurrent::Map<int, EventHandlers *> EventMapType;
-    typedef concurrent::Queue<Event> EventQueueType;
+    typedef concurrent::Map<int, WorkerListType *> EventMapType;
     
     EventMapType eventsToHandlers;
     DispatcherList dispatchers;
-    EventQueueType inputQueue;
   public:
     Proactor (void);
     virtual ~Proactor (void);
 
-    void registerHandler (int e, Job * job);
-    bool unregisterHandler (int e, Job * job);
+    void addWorker (int e, Worker * w);
+    bool removeWorker (int e, Worker * w);
     void addDispatcher (Dispatcher * d);
     bool removeDispatcher (Dispatcher * d);
     
     void * run (void * null);
  
+    void onReadComplete (Event e);
     void onReadComplete (int e, const char * buf);
 
     inline const std::string & peekInputQueue (void) {
diff --git a/src/realtime/proactor/Worker.hpp b/src/realtime/proactor/Worker.hpp
new file mode 100644
index 0000000..ba076ed
--- /dev/null
+++ b/src/realtime/proactor/Worker.hpp
@@ -0,0 +1,46 @@
+/* 
+   Worker.hpp - Worker Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PROACTOR_WORKER
+#define HPP_PROACTOR_WORKER
+
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/Thread.hpp"
+#include <string>
+
+namespace proactor {
+
+  class Dispatcher;
+
+  class Worker : public concurrent::Thread {
+  protected:
+    typedef concurrent::Queue<std::string> InputQueueType;
+
+    Dispatcher * dispatcher;
+    InputQueueType inputQueue;
+  public:
+    inline void pushInputQueue (std::string buf) {
+      this->inputQueue.push (buf);
+    }
+  };
+
+}
+
+#endif
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index e0ea03d..b923c80 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -31,7 +31,7 @@
 #include "concurrent/ThreadArgs.hpp"
 #include "proactor/Proactor.hpp"
 #include "proactor/Event.hpp"
-#include "AcceptThread.hpp"
+#include "Network.hpp"
 #include "PacketParser.hpp"
 #include "Packet.hpp"
 
@@ -49,8 +49,6 @@ append_pidname (const gchar * pre) {
    @wb: The Workbook that the thread will be changing. */
 void
 thread_main (ThreadArgs * args) {
-  g_usleep (5000000); /* 5 seconds - initial startup delay */
-
   Workbook * wb = (Workbook *)args->at(0);
   Config * cfg  = (Config *)args->at(1);
 
@@ -70,6 +68,13 @@ thread_main (ThreadArgs * args) {
       return;
     }
 
+  ConfigPair * verbosity = cfg->get_pair (cfg, 
+					  "realtime", "debug", "verbosity");
+  if (IS_NULL (verbosity))
+    {
+      g_warning ("Failed loading debug->verbosity from configuration file.");
+    }
+
   FILE * pktlog = NULL;
   std::string logname = std::string (logpath->value).append("/");
   logname.append (append_pidname("realtime.").append(".log"));
@@ -102,16 +107,24 @@ thread_main (ThreadArgs * args) {
       return;
     }
 
-  PacketParser handler (wb, pktlog);
-  proactor.registerHandler (e, &handler);
+  NetworkDispatcher network (&proactor);
+  network.setEventId(e);
+  if (network.start() == false)
+    {
+      g_critical ("Failed starting network; exiting thread.");
+      return;
+    }
+
+  PacketParser handler (wb, pktlog, atoi(verbosity->value));
+  proactor.addWorker (e, &handler);
   if (handler.start() == false) 
     {
       g_critical ("Failed starting PacketParser; exiting thread.");
       return;
     }
   
-  AcceptThread acceptor ( socket.newAcceptor(), &proactor );
-  acceptor.setEventId (e);
+  AcceptThread acceptor ( socket.newAcceptor(), &network );
+  network.addWorker (&acceptor);
   if (acceptor.start() == false)
     {
       g_critical ("Failed starting Acceptor; exiting thread.");
@@ -126,10 +139,11 @@ thread_main (ThreadArgs * args) {
 
   FCLOSE (pktlog);
 
+  socket.close();  
+
   // Interrupt threads immediately canceling them so we can quit.
   acceptor.interrupt();
   handler.interrupt();
+  network.interrupt();
   proactor.interrupt();
-
-  socket.close();  
 }

commit 39c74f6870f5e8dd458feeae85b12ee6b4740a53
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Wed Apr 8 21:58:07 2009 +0000

    Added CsvParser files.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@8 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/src/realtime/CsvParser.cpp b/src/realtime/CsvParser.cpp
new file mode 100644
index 0000000..65a9482
--- /dev/null
+++ b/src/realtime/CsvParser.cpp
@@ -0,0 +1,53 @@
+#include "CsvParser.hpp"
+
+/* This structure is due to the libcsv parser; it uses function pointers to
+   do any work inside of an actual tuple. So the cb1 is called after a field
+   is parsed and cb2 is called after a tuple/row is parsed. */
+static void 
+cb1 (void * s, size_t length, void * data) {
+
+}
+
+static void
+cb2 (int c, void * data) {
+
+}
+
+void *
+CsvParser::run (void * null) {
+ this->running = true;
+ struct csv_parser csv;
+    
+ if (csv_init (&csv, CSV_STRICT) != 0)
+   {
+     std::cerr << "Failed initializing libcsv parser\n";
+     return NULL;
+   }
+
+ while (this->running == true)
+   {
+     while (this->inputQueue.size() > 0)
+       {
+	 std::string buf = this->inputQueue.pop();
+	 size_t bytes = buf.length();
+	 
+	 // Parse the CSV input
+	 if ((bytes = csv_parse(&csv, 
+				buf.c_str(), 
+				bytes, 
+				cb1,
+				cb2,
+				this->cell)) != buf.length())
+	   {
+	     // Something went wrong here. Discard and continue.
+	     if (csv_error (&csv) == CSV_EPARSE) 
+	       std::cerr << "Parsing error on input:\n" << buf;
+	     continue;
+	   }
+       }
+
+   }
+
+ csv_free (&csv);
+ return NULL;
+}
diff --git a/src/realtime/CsvParser.hpp b/src/realtime/CsvParser.hpp
new file mode 100644
index 0000000..f3e9a30
--- /dev/null
+++ b/src/realtime/CsvParser.hpp
@@ -0,0 +1,30 @@
+#ifndef HPP_CSVPARSER
+#define HPP_CSVPARSER
+
+#include "proactor/Job.hpp"
+#include <workbook/workbook.h>
+#include <workbook/sheet.h>
+#include <workbook/cell.h>
+#include <csv/csv.h>
+#include <iostream>
+
+class CsvParser : public proactor::Job {
+private:
+  Workbook * wb;
+  FILE * pktlog;
+  Cell * cell;
+public:
+  CsvParser (Workbook * wb, FILE * pktlog) {
+    this->wb = wb;
+    this->pktlog = pktlog;
+    this->cell = cell_new();
+  }
+
+  virtual ~CsvParser (void) {
+    this->cell->destroy (cell);
+  }
+
+  void * run (void * null);
+};
+
+#endif

commit bd1c5586efa89a45f449531d1345937a1733eb26
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Wed Apr 8 21:56:22 2009 +0000

    Updated Makefile to include libcsv support, added beginnings of CsvParser into realtime example.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@7 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/Makefile b/Makefile
index 9fc2f02..9828841 100755
--- a/Makefile
+++ b/Makefile
@@ -2,7 +2,11 @@ MD=mkdir -p
 MAKE=-make -C
 PWD=`pwd`
 
-all:	libconfig libworkbook gtkcsv
+all:	libconfig libworkbook libcsv gtkworkbook
+
+libcsv:
+	${MD} OBJS/libcsv
+	${MAKE} csv/ all
 
 libconfig:
 	${MD} OBJS/libconfig
@@ -12,16 +16,18 @@ libworkbook:
 	${MD} OBJS/libworkbook
 	${MAKE} workbook/ all
 
-gtkcsv:
+gtkworkbook:
 	${MD} OBJS/realtime
 	$(MAKE) src/ all
 
 clean:
 	$(MAKE) config/ clean
 	${MAKE} workbook/ clean
+	${MAKE} csv/ clean
 	$(MAKE) src/ clean
 
 install: all
 	$(MAKE) config/ install
 	${MAKE} workbook/ install
+	${MAKE} csv/ install
 	${MAKE} src/ install
diff --git a/bin/yahooQuoteServer.py b/bin/yahooQuoteServer.py
new file mode 100755
index 0000000..559883a
--- /dev/null
+++ b/bin/yahooQuoteServer.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python
+import sys
+import os
+import time
+import optparse
+import logging
+import socket
+import thread
+import urllib
+
+def acceptor(serversock, descriptors):
+    while 1:
+        # Waiting for connection...
+        clientsock,addr = serversock.accept()
+        descriptors.append((clientsock,addr))
+        time.sleep(1/100)
+        
+def main():
+    HOST = ''
+    PORT = 50000
+    MAXPENDING = 5
+    URI = "http://finance.yahoo.com/d/quotes.csv?s=JAVA+C+AAPL+MSFT&f=snl1c6ahg"
+    
+    serversock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
+    serversock.bind((HOST,PORT));
+    serversock.listen(MAXPENDING);
+    
+    descriptors = []
+
+    thread.start_new_thread(acceptor, (serversock, descriptors))
+    
+    running = 1
+
+    while running:
+        csv = urllib.urlopen(URI)
+        blob = csv.read()
+        
+        # Iterate through the clients and print, print, print!
+        for client in descriptors:
+            client[0].send(blob)
+
+        time.sleep(2)
+
+# Execute the main method of the script.
+if __name__ == "__main__":
+    main()
+
+# Copyright (C) 2009, John Bellone, Jr. <jvb4@njit.edu>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as publisehd by
+# the Free Software Foundation, either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy olf the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
diff --git a/csv/Makefile b/csv/Makefile
index 2e3dc0c..94ebcb2 100644
--- a/csv/Makefile
+++ b/csv/Makefile
@@ -1,5 +1,6 @@
 CC=gcc
 AR=ar
+CP=cp
 
 VERSION=3.0.0
 DESTDIR=
@@ -7,7 +8,7 @@ LIBDIR=/usr/lib
 INCDIR=/usr/include
 MANDIR=/usr/share/man/man3
 
-.PHONY: all install install_headers install_man install_shared install_static clean test
+.PHONnY: all install install_headers install_man install_shared install_static clean test
 
 all: libcsv.so libcsv.a
 
@@ -36,6 +37,8 @@ libcsv.o: libcsv.c csv.h
 
 libcsv.so: libcsv.o
 	$(CC) -shared $< -o $@
+	$(CP) $@ ../lib/$@
+	$(CP) ../lib/$@ ../lib/$@.1
 
 libcsv.a: libcsv.o
 	$(AR) -rc $@ $^
@@ -43,6 +46,7 @@ libcsv.a: libcsv.o
 
 clean:
 	rm libcsv.o libcsv.so libcsv.a
+	rm ../lib/libcsv.*
 
 test: libcsv.o
 	$(CC) test_csv.c $< -o $@
diff --git a/include/csv/csv.h b/include/csv/csv.h
new file mode 100644
index 0000000..8fd706b
--- /dev/null
+++ b/include/csv/csv.h
@@ -0,0 +1,86 @@
+#ifndef LIBCSV_H__
+#define LIBCSV_H__
+#include <stdlib.h>
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CSV_MAJOR 3
+#define CSV_MINOR 0
+#define CSV_RELEASE 0
+
+/* Error Codes */
+#define CSV_SUCCESS 0
+#define CSV_EPARSE 1   /* Parse error in strict mode */
+#define CSV_ENOMEM 2   /* Out of memory while increasing buffer size */
+#define CSV_ETOOBIG 3  /* Buffer larger than SIZE_MAX needed */
+#define CSV_EINVALID 4 /* Invalid code,should never be received from csv_error*/
+
+
+/* parser options */
+#define CSV_STRICT 1    /* enable strict mode */
+#define CSV_REPALL_NL 2 /* report all unquoted carriage returns and linefeeds */
+#define CSV_STRICT_FINI 4 /* causes csv_fini to return CSV_EPARSE if last
+                             field is quoted and doesn't containg ending 
+                             quote */
+#define CSV_APPEND_NULL 8 /* Ensure that all fields are null-ternimated */
+
+
+/* Character values */
+#define CSV_TAB    0x09
+#define CSV_SPACE  0x20
+#define CSV_CR     0x0d
+#define CSV_LF     0x0a
+#define CSV_COMMA  0x2c
+#define CSV_QUOTE  0x22
+
+struct csv_parser {
+  int pstate;         /* Parser state */
+  int quoted;         /* Is the current field a quoted field? */
+  size_t spaces;      /* Number of continious spaces after quote or in a non-quoted field */
+  unsigned char * entry_buf;   /* Entry buffer */
+  size_t entry_pos;   /* Current position in entry_buf (and current size of entry) */
+  size_t entry_size;  /* Size of entry buffer */
+  int status;         /* Operation status */
+  unsigned char options;
+  unsigned char quote_char;
+  unsigned char delim_char;
+  int (*is_space)(unsigned char);
+  int (*is_term)(unsigned char);
+  size_t blk_size;
+  void *(*malloc_func)(size_t);
+  void *(*realloc_func)(void *, size_t);
+  void (*free_func)(void *);
+};
+
+/* Function Prototypes */
+int csv_init(struct csv_parser *p, unsigned char options);
+int csv_fini(struct csv_parser *p, void (*cb1)(void *, size_t, void *), void (*cb2)(int, void *), void *data);
+void csv_free(struct csv_parser *p);
+int csv_error(struct csv_parser *p);
+char * csv_strerror(int error);
+size_t csv_parse(struct csv_parser *p, const void *s, size_t len, void (*cb1)(void *, size_t, void *), void (*cb2)(int, void *), void *data);
+size_t csv_write(void *dest, size_t dest_size, const void *src, size_t src_size);
+int csv_fwrite(FILE *fp, const void *src, size_t src_size);
+size_t csv_write2(void *dest, size_t dest_size, const void *src, size_t src_size, unsigned char quote);
+int csv_fwrite2(FILE *fp, const void *src, size_t src_size, unsigned char quote);
+int csv_get_opts(struct csv_parser *p);
+int csv_set_opts(struct csv_parser *p, unsigned char options);
+void csv_set_delim(struct csv_parser *p, unsigned char c);
+void csv_set_quote(struct csv_parser *p, unsigned char c);
+unsigned char csv_get_delim(struct csv_parser *p);
+unsigned char csv_get_quote(struct csv_parser *p);
+void csv_set_space_func(struct csv_parser *p, int (*f)(unsigned char));
+void csv_set_term_func(struct csv_parser *p, int (*f)(unsigned char));
+void csv_set_realloc_func(struct csv_parser *p, void *(*)(void *, size_t));
+void csv_set_free_func(struct csv_parser *p, void (*)(void *));
+void csv_set_blk_size(struct csv_parser *p, size_t);
+size_t csv_get_buffer_size(struct csv_parser *p);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
index c70f4b0..b16d2fb 100644
--- a/src/realtime/PacketParser.hpp
+++ b/src/realtime/PacketParser.hpp
@@ -40,7 +40,7 @@ public:
   }
   
   virtual ~PacketParser (void) {
-    cell->destroy (cell);
+    this->cell->destroy (cell);
   }
 
   void * run (void * null) {

commit 8f60cb6d3d5ce6c745ae3634fbca864fec04be2a
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Wed Apr 8 18:36:38 2009 +0000

    Fixed minor bug in Proactor.cpp; little too early for THAT change.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@6 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
index f2b4d79..12dc34d 100755
--- a/src/realtime/proactor/Proactor.cpp
+++ b/src/realtime/proactor/Proactor.cpp
@@ -115,11 +115,6 @@ Proactor::run (void * null) {
 
   while (this->running == true)
     {
-      
-    }
-
-  while (this->running == true)
-    {
       this->inputQueue.lock();
       while (this->inputQueue.size() > 0)
 	{

commit c3bff338af1300456d781408aea64e92a31e1937
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Wed Apr 8 18:33:24 2009 +0000

    Updated with documentation and libcsv release that will be used for future examples.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@5 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/INSTALL b/INSTALL
new file mode 100644
index 0000000..20dcd38
--- /dev/null
+++ b/INSTALL
@@ -0,0 +1,43 @@
+GTKWorkbook Installation
+------------------------
+
+0.	Testing Systems
+
+	CentOS 5.2 (Redhat)
+	GCC 4.1.2
+	Python 2.4.3
+
+1. 	Requirements
+
+	A. GtkExtra
+
+	The libworkbook library wraps the GTK+ calls to the GtkSheet widget
+	which is included inside of the GtkExtra library available on
+	sourceforge.net. Due to the age of the gtkextra2 release I would
+	highly suggest downloading directly from the CVS repository.
+
+	http://gtkextra.cvs.sourceforge.net/viewvc/gtkextra/gtkextra-2/
+
+	B. Pixman
+
+	The GtkExtra library requires this to be installed with the version
+	of GTK that ships with CentOS 5.2. I believe that it is available with
+	newer versions of GTK, but here is the location of the repository if
+	you need to find it. Grab the newest release, compile and install.
+
+	http://cairographics.org/releases/
+		
+2.	Installation
+
+	Once all of the dependencies (above) have been installed you can
+	finally get on to the fun stuff. The compliation of the project is
+	rather easy (and quick).
+
+	Inside of the root directory of the project, type:
+
+	make clean all
+
+	If you wish to install:
+
+	make clean install
+
diff --git a/LICENSE b/LICENSE
index 4dc08b4..8c177f8 100644
--- a/LICENSE
+++ b/LICENSE
@@ -267,7 +267,7 @@ Library will still fall under Section 6.)
 distribute the object code for the work under the terms of Section 6.
 Any executables containing that work also fall under Section 6,
 whether or not they are linked directly with the Library itself.
-
+
   6. As an exception to the Sections above, you may also combine or
 link a "work that uses the Library" with the Library to produce a
 work containing portions of the Library, and distribute that work
@@ -456,48 +456,3 @@ SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 DAMAGES.
 
 		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
diff --git a/README b/README
new file mode 100644
index 0000000..e6a8ec8
--- /dev/null
+++ b/README
@@ -0,0 +1,47 @@
+GTKWorkbook README
+------------------
+
+0. Project Website
+
+	The project has moved to sourceforge.net:
+
+	http://gtkworkbook.sourceforge.net/
+
+	The subversion repository has moved there as well:
+
+	https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook
+	
+1. Installation
+	
+	Please see the INSTALL file in the root directory of the project for
+	more details on how to properly install this project.
+
+2. License
+	
+	There should be a file entitled LICENSE in the root directory of the
+	project. All of the code, unless otherwise specified, is licensed
+	under the GNU Lesser General Public License 2.1. There may be
+	individual scripts or files that are licensed under the GNU General
+	Public License 2, but those should be far and few between.
+
+	The <libcsv> library included is licensed under the LGPL 2.1 and all
+	the documentation information is included in the library's directory.
+
+3. Documentation
+	
+	Most of the library code is commented pretty well, but much of the
+	example application code has not been documented yet. Any specific
+	questions should be directly asked on the project's forum on the
+	sourceforge.net website.
+
+	In the future there will be an API PDF. 
+
+4. Contact
+	
+	The best means of contact would be through the sourceforge.net project
+	website (information at the top of this document) but if it is urgent
+	then you may contact me directly via email.
+
+	John Bellone, Jr.
+	<https://blogs.njit.edu/jvb4>
+	<jvb4@njit.edu>
\ No newline at end of file
diff --git a/csv/Changelog b/csv/Changelog
new file mode 100644
index 0000000..92c9806
--- /dev/null
+++ b/csv/Changelog
@@ -0,0 +1,66 @@
+Fri Oct 13 08:40:13 EDT 2006
+libcsv version 0.9.0 released - initial public release
+
+Tue Oct 24 08:22:56 EDT 2006
+libcsv version 0.9.1 released
+  * Fixed LICENSE file to include LGPL text instead of GPL text, thanks to Alejandro Mery <amery@opensde.org> for pointing this out
+  * Included a Makefile for platforms supporting make, thanks to Alejandro Mery for creating the initial Makefile
+  * Updated INSTALL file to include Makefile directions
+
+
+Thu Mar  1 10:27:30 EST 2007
+libcsv version 0.9.5 released
+  * Fixed a bug in which the closing quote of a quoted field, along with any
+  trailing spaces, would be included as part of the field data for the last field when csv_fini was called if the last record did not end with a newline sequence.  This was discovered while testing the Text-CSV-LibCSV Perl wrapper for libcsv created by Jiro Nishiguchi <jiro@cpan.org>
+  * Fixed incorrect prototype for csv_fini in the README file, thanks to Edd Edmondson <edward.edmondson@port.ac.uk> for pointing this out
+  * Minor modifications to clean up pedantic compiler warnings
+  * Added "Interfaces for other languages" to the README file
+
+Sun Mar  4 14:25:07 EST 2007
+libcsv version 1.0.0 released
+  * Changed the interface to allow arbitrary user data to be passed between the parser function and the callback functions via a void pointer eliminating the need for file-scope variables in cases where data needs to be shared and making it considerably easier to create interfaces to the library in other languages.  This change makes this version of the library incompatible with previous versions. Thanks to Jiro Nishiguchi for suggesting this change
+  * man page is now included which obsoletes the old README, pdf version also included
+  * Updated examples to use new interface
+  * Updated documentation to reflect interface changes
+  * Cleaned up INSTALL file
+  * Included license statement in example programs
+
+Sun May 20 11:44:09 EDT 2007
+libcsv version 1.0.1 released
+  * Added CSV_STRICT_FINI option which can be used to cause csv_fini() to return an error when the quoted data being parsed doesn't contain a terminating quote character
+  * Added a test program to test the parsing and writer functions
+
+Fri Jun  1 11:18:28 EDT 2007
+libcsv version 2.0.0 released
+  * This major release contains features that break binary compatibility with earlier libcsv versions.  The interface is backwards compatible with 1.x so existing programs only need to be recompiled to work with the new version, no source code modifications need to be made.
+  * Added csv_set_delim()/csv_get_delim() and csv_set_quote()/csv_get_quote() functions to set and get the field delimeter and quote characters respectively.  Thanks to Martin Ugarte <ugarte.m@gmail.com> for his input
+  * Added csv_set_space_func() and csv_set_term_func() functions that allow a user provided function to specify which characters should be considered spaces and line terminators respectively
+  * Updated documentation to include new functions
+  * Included FAQ document to answer common questions about using libcsv to solve specific problems
+  * Updated test program to include ability to test new features
+  * Updated csvinfo to show the use of some of the new functions
+  * Added csv_write2 and csv_fwrite2 which allow the quote character to be specified
+
+Thu Jun  7 14:44:23 EDT 2007
+libcsv version 2.0.1 released
+  * Fixed bug in Makefile causing library to be installed as libcsv.so.0 instead of libcsv.so.2
+  * Fixed bug in csvvalid example program where location of malformed bytes past byte 1023 were misreported
+
+Fri Jul 25 22:17:35 EDT 2008
+libcsv version 3.0.0 released
+  * This release contains interface changes that are not compatible with
+  previous versions.  Callback functions now use void * parameters
+  instead of char *, this eliminates the need to cast data read into a buffer
+  of unsigned char which is the proper way to read binary data, data is also
+  treated as an array of unsigned char internally.  The cb2 callback function
+  now uses int instead of char, char has changed to unsigned char in several
+  places, csv_opts has been replaced with csv_get_opts and csv_set_opts, and
+  csv_fini returns -1 instead of 0 when no newline if present at the end of
+  the last record.  New features also make this version binary-incompatible
+  with previous versions.
+  * Added CSV_APPEND_NULL option which will null-terminate all collected
+  fields making it easier to treat data as C strings when desired.
+  * Added C++ wrapper in csv.h to make it easier to call functions from C++.
+  * Added functions to change the memory allocation functions used, get the
+  size of the internal buffer, and get and set the size of the amount of
+  memory requested when the internal buffer gets too large.
diff --git a/csv/FAQ b/csv/FAQ
new file mode 100644
index 0000000..75e6f1f
--- /dev/null
+++ b/csv/FAQ
@@ -0,0 +1,149 @@
+My data contains unescaped quotes within quoted fields or quote
+characters in unquoted field.
+
+libcsv handles such malformed data by default, no special configuration
+is required.  There are cases where such malformed data is ambigous and
+might not be parsed the way you would like, see the man page for libcsv
+for details.  The csvfix and csvtest programs in the example directory
+may be useful when trying to determine how libcsv will parse your data.
+The csvvalid program can also be used to check for malformed data files.
+
+
+
+My csv file contains comments that should not be parsed as csv data,
+how can I handle this?
+
+Although there is no direct support for comment handling in libcsv you
+can preprocess the data before sending it to libcsv.  For example, say
+that you wish to ignore all lines whose first non-space, non-tab
+character is a hash (#), you could use the following piece of code to
+accomplish that:
+
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include "csv.h"
+
+int in_comment, in_record;
+
+void cb1(void *d, char *s, size_t size) { /* Data processing here */ }
+void cb2(void *d, char c) { in_record = 0; /* Record handling here */ }
+
+int main (void) {
+  int c;
+  char ch;
+  struct csv_parser *p;
+  if (csv_init(&p, 0))
+    return EXIT_FAILURE;
+
+  while ((c = getchar()) != EOF) {
+    ch = c;
+    if (in_comment) {
+      if (ch == '\012' || ch == '\015') {
+        in_comment = 0;
+      }
+    } else if (!in_record) {
+      if (ch == ' ' || ch == '\t') {
+        ;
+      } else if (ch == '#') {
+        in_comment = 1;
+      } else {
+        in_record = 1;
+        csv_parse(p, &ch, 1, cb1, cb2);
+      }
+    } else {
+      csv_parse(p, &ch, 1, cb1, cb2);
+    }
+  }
+  csv_fini(p, ...);
+  return 0;
+}
+
+If you determine that calling csv_parse for each character takes too
+much overhead (do some tests before making this decision, it usually
+doesn't) you can optimize this by processing a larger number of
+characters and calling csv_parse on a larger resulting buffer.  
+If you know that your data is text-only, you can simplify this by
+reading one line at a time, checking the first non-space character,
+skipping the line if it is a comment character and calling csv_parse
+if it isn't.
+
+
+
+My data uses a semicolon as a delimiter instead of comma but otherwise
+follows CSV conventions, how can I use libcsv to read my data?
+
+Use the csv_set_delim function introduced in libcsv 2.0.0:
+struct csv_parser *p;
+csv_init(&p);
+csv_set_delim(p, ';');
+...
+
+You can use csv_set_delim to set the delimiter to any character.  Any
+field that contains the delimiter must be quoted when using strict
+mode.  Be careful not to set the delimiter to the same character used
+as the quote character, a space character or a line terminator
+character though as libcsv won't be able to determine if the character 
+is a field delimiter or a quote, etc.
+
+
+
+My data uses a single quotes instead of double quotes for quoted
+fields, how can I accomidate this?
+
+Use the csv_set_quote function introduced in libcsv 2.0.0:
+struct csv_parser *p;
+csv_init(&p);
+csv_set_quote(p, '\'');
+...
+
+As with csv_set_delim you can set the quote character to any character
+but fields containing the quote character must still be quoted and are
+expected to be escaped by an instance of itself.  For example, if you 
+use csv_set_quote to change the quote character to a single quote, 
+instances of a single quote in field data should be escaped by a 
+preceding single quote.
+
+
+
+How can I preserve leading and trailing whitespace from non-quoted 
+fields?
+
+By default libcsv ignores leading and trailing spaces and tabs from 
+non-quoted fields as this is the most common practice and expected by 
+many applications.  The csv_set_space_func function introduced in 
+libcsv 2.0.0 allows you to specify a function that will return 1 if 
+the provided character should be considered a space character and 0 
+otherwise.  This allows you to change the characters that libcsv 
+ignores around unquoted fields.  If you create a function that always 
+returns 0 then no character will be recognized as a space character 
+and all characters will be preserved:
+
+int my_space(char c) { return 0;}
+
+struct csv_parser *p;
+csv_init(&p);
+csv_set_space_func(p, my_space);
+...
+
+
+How can I remove leading and trailing whitespace from quoted fields?
+
+By default libcsv removes surrounding space and tab characters from 
+unquoted fields but not from quoted fields.  The easiest way to remove 
+unwanted characters from a quoted field is inside the field callback 
+function, simply take the data provided to the callback function and 
+perform any manipulations directly on it.
+
+
+
+I want to be able to do things like extract or search on specific 
+fields from a CSV file, sort a CSV file, etc. but the common UNIX 
+utilities (cut, grep, sort, etc.) don't work on CSV data that contains 
+fields with embedded commas or newlines, etc.  Are there any tools 
+like this for managing CSV files?
+
+Take a look at csvutils at http://sourceforge.net/projects/csvutils.
+This package uses libcsv to provide a number of useful CSV utilities 
+including csvcut, csvgrep, and others with option syntax resembling 
+their non-CSV counterparts.
diff --git a/csv/INSTALL b/csv/INSTALL
new file mode 100644
index 0000000..5bdd63b
--- /dev/null
+++ b/csv/INSTALL
@@ -0,0 +1,49 @@
+[Installing on systems with make(1)]
+
+On systems with make, the installation process consists of:
+
+    make
+    make test
+    make install
+
+You may need to run ldconfig or a similiar command before dynamically
+linking your program to libcsv.
+
+This will install the csv.h header, libcsv shared and static libraries,
+and the csv(3) manual page.  You can use one of the following targets to
+fine-tune the things that are installed:
+
+    make install_man - install only the man page
+    make install_headers - install only the header
+    make install_static_lib - install only the static version of the library
+    make install_shared_lib - install only the dynamic version of the library
+    make install_static - same as install_static_lib plus install_headers
+    mnake install_shared - same as install_shared_lib plus install_headers
+
+[Installing on systems without make]
+
+libcsv is written in pure ANSI C89 and does not have any prerequisites aside
+from a compiler and the Standard C library, it should compile on any
+conforming implementation.  Below are examples of how to compile this on gcc,
+see your compiler's documentation for other compilers.
+
+libcsv can be installed as a shared library on systems that support it:
+  gcc -shared libcsv.c -o libcsv.so
+
+or simply compiled into object code an linked into your program:
+  gcc libcsv.c -c -o libcsv.o
+  gcc myproject.c libcsv.o -o myproject
+
+you can also compile libcsv as a static library:
+  gcc libcsv.c -c -o libcsv.o
+  ar -rc libcsv.a libcsv.o
+  ar -s libcsv.a
+
+
+The examples can be compiled with gcc like this:
+  gcc csvinfo.c libcsv.o -o csvinfo
+
+or using a shared library like this:
+  gcc csvinfo.c -lcsv -o csvinfo
+
+
diff --git a/csv/LICENSE b/csv/LICENSE
new file mode 100644
index 0000000..8c177f8
--- /dev/null
+++ b/csv/LICENSE
@@ -0,0 +1,458 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
diff --git a/csv/Makefile b/csv/Makefile
new file mode 100644
index 0000000..2e3dc0c
--- /dev/null
+++ b/csv/Makefile
@@ -0,0 +1,51 @@
+CC=gcc
+AR=ar
+
+VERSION=3.0.0
+DESTDIR=
+LIBDIR=/usr/lib
+INCDIR=/usr/include
+MANDIR=/usr/share/man/man3
+
+.PHONY: all install install_headers install_man install_shared install_static clean test
+
+all: libcsv.so libcsv.a
+
+install: install_headers install_shared_lib install_static_lib install_man
+
+install_shared: install_headers install_shared_lib
+install_static: install_headers install_static_lib
+
+install_man: csv.3.gz
+	cp -f $^ $(DESTDIR)$(MANDIR)/
+
+install_headers: csv.h
+	mkdir -p $(DESTDIR)$(INCDIR)/libcsv/
+	cp -f $^ $(DESTDIR)$(INCDIR)/libcsv/
+
+install_shared_lib: libcsv.so
+	cp -f $< $(DESTDIR)$(LIBDIR)/$<.$(VERSION)
+	ln -sf $<.$(VERSION) $(DESTDIR)$(LIBDIR)/$<.3
+	ln -sf $<.3 $(DESTDIR)$(LIBDIR)/$<
+
+install_static_lib: libcsv.a
+	cp -f $< $(DESTDIR)$(LIBDIR)/$<
+
+libcsv.o: libcsv.c csv.h
+	$(CC) $< -c -o $@
+
+libcsv.so: libcsv.o
+	$(CC) -shared $< -o $@
+
+libcsv.a: libcsv.o
+	$(AR) -rc $@ $^
+	$(AR) -s $@
+
+clean:
+	rm libcsv.o libcsv.so libcsv.a
+
+test: libcsv.o
+	$(CC) test_csv.c $< -o $@
+	./test
+	rm ./test
+
diff --git a/csv/README b/csv/README
new file mode 100644
index 0000000..186e971
--- /dev/null
+++ b/csv/README
@@ -0,0 +1,27 @@
+Installation
+------------
+installation usually consists of:
+make && make test && make install
+
+see the INSTALL file for details and instructions on other systems
+
+
+License
+-------
+The libcsv library is licensed under the LGPL, see the LICENSE file for details
+The example programs are licensed under the GPL, see the LICENSE file in the
+examples directory for details
+
+
+Documentation
+-------------
+See the accompanying man pages or pdf documentation
+
+
+libcsv interfaces for other programming languages
+-------------------------------------------------
+Perl - Text-CSV-LibCSV by Jiro Nishiguchi
+       http://search.cpan.org/dist/Text-CSV-LibCSV/
+
+Ruby - SimpleCSV by Ken Date
+       http://rubyforge.org/projects/simplecsv/
diff --git a/csv/csv.3.gz b/csv/csv.3.gz
new file mode 100644
index 0000000..5a76348
Binary files /dev/null and b/csv/csv.3.gz differ
diff --git a/csv/csv.h b/csv/csv.h
new file mode 100644
index 0000000..8fd706b
--- /dev/null
+++ b/csv/csv.h
@@ -0,0 +1,86 @@
+#ifndef LIBCSV_H__
+#define LIBCSV_H__
+#include <stdlib.h>
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CSV_MAJOR 3
+#define CSV_MINOR 0
+#define CSV_RELEASE 0
+
+/* Error Codes */
+#define CSV_SUCCESS 0
+#define CSV_EPARSE 1   /* Parse error in strict mode */
+#define CSV_ENOMEM 2   /* Out of memory while increasing buffer size */
+#define CSV_ETOOBIG 3  /* Buffer larger than SIZE_MAX needed */
+#define CSV_EINVALID 4 /* Invalid code,should never be received from csv_error*/
+
+
+/* parser options */
+#define CSV_STRICT 1    /* enable strict mode */
+#define CSV_REPALL_NL 2 /* report all unquoted carriage returns and linefeeds */
+#define CSV_STRICT_FINI 4 /* causes csv_fini to return CSV_EPARSE if last
+                             field is quoted and doesn't containg ending 
+                             quote */
+#define CSV_APPEND_NULL 8 /* Ensure that all fields are null-ternimated */
+
+
+/* Character values */
+#define CSV_TAB    0x09
+#define CSV_SPACE  0x20
+#define CSV_CR     0x0d
+#define CSV_LF     0x0a
+#define CSV_COMMA  0x2c
+#define CSV_QUOTE  0x22
+
+struct csv_parser {
+  int pstate;         /* Parser state */
+  int quoted;         /* Is the current field a quoted field? */
+  size_t spaces;      /* Number of continious spaces after quote or in a non-quoted field */
+  unsigned char * entry_buf;   /* Entry buffer */
+  size_t entry_pos;   /* Current position in entry_buf (and current size of entry) */
+  size_t entry_size;  /* Size of entry buffer */
+  int status;         /* Operation status */
+  unsigned char options;
+  unsigned char quote_char;
+  unsigned char delim_char;
+  int (*is_space)(unsigned char);
+  int (*is_term)(unsigned char);
+  size_t blk_size;
+  void *(*malloc_func)(size_t);
+  void *(*realloc_func)(void *, size_t);
+  void (*free_func)(void *);
+};
+
+/* Function Prototypes */
+int csv_init(struct csv_parser *p, unsigned char options);
+int csv_fini(struct csv_parser *p, void (*cb1)(void *, size_t, void *), void (*cb2)(int, void *), void *data);
+void csv_free(struct csv_parser *p);
+int csv_error(struct csv_parser *p);
+char * csv_strerror(int error);
+size_t csv_parse(struct csv_parser *p, const void *s, size_t len, void (*cb1)(void *, size_t, void *), void (*cb2)(int, void *), void *data);
+size_t csv_write(void *dest, size_t dest_size, const void *src, size_t src_size);
+int csv_fwrite(FILE *fp, const void *src, size_t src_size);
+size_t csv_write2(void *dest, size_t dest_size, const void *src, size_t src_size, unsigned char quote);
+int csv_fwrite2(FILE *fp, const void *src, size_t src_size, unsigned char quote);
+int csv_get_opts(struct csv_parser *p);
+int csv_set_opts(struct csv_parser *p, unsigned char options);
+void csv_set_delim(struct csv_parser *p, unsigned char c);
+void csv_set_quote(struct csv_parser *p, unsigned char c);
+unsigned char csv_get_delim(struct csv_parser *p);
+unsigned char csv_get_quote(struct csv_parser *p);
+void csv_set_space_func(struct csv_parser *p, int (*f)(unsigned char));
+void csv_set_term_func(struct csv_parser *p, int (*f)(unsigned char));
+void csv_set_realloc_func(struct csv_parser *p, void *(*)(void *, size_t));
+void csv_set_free_func(struct csv_parser *p, void (*)(void *));
+void csv_set_blk_size(struct csv_parser *p, size_t);
+size_t csv_get_buffer_size(struct csv_parser *p);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/csv/csv.pdf b/csv/csv.pdf
new file mode 100644
index 0000000..24e35e3
Binary files /dev/null and b/csv/csv.pdf differ
diff --git a/csv/examples/LICENSE b/csv/examples/LICENSE
new file mode 100644
index 0000000..e501bab
--- /dev/null
+++ b/csv/examples/LICENSE
@@ -0,0 +1,280 @@
+  GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
diff --git a/csv/examples/csvfix.c b/csv/examples/csvfix.c
new file mode 100644
index 0000000..44335f1
--- /dev/null
+++ b/csv/examples/csvfix.c
@@ -0,0 +1,93 @@
+/*
+csvfix - reads (possibly malformed) CSV data from input file
+         and writes properly formed CSV to output file
+
+Copyright (C) 2007  Robert Gamble
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "libcsv/csv.h"
+
+void cb1 (void *s, size_t i, void *outfile) {
+  csv_fwrite((FILE *)outfile, s, i);
+  fputc(',',(FILE *)outfile);
+}
+
+void cb2 (int c, void *outfile) {
+  fseek((FILE *)outfile, -1, SEEK_CUR);
+  fputc('\n', (FILE *)outfile);
+}
+
+int main (int argc, char *argv[]) {
+  char buf[1024];
+  size_t i;
+  struct csv_parser p;
+  FILE *infile, *outfile;
+  csv_init(&p, 0);
+
+  if (argc != 3) {
+    fprintf(stderr, "Usage: csv_fix infile outfile\n");
+    return EXIT_FAILURE;
+  }
+
+  if (!strcmp(argv[1], argv[2])) {
+    fprintf(stderr, "Input file and output file must not be the same!\n");
+    exit(EXIT_FAILURE);
+  }
+
+  infile = fopen(argv[1], "rb");
+  if (infile == NULL) {
+    fprintf(stderr, "Failed to open file %s: %s\n", argv[1], strerror(errno));
+    exit(EXIT_FAILURE);
+  }
+
+  outfile = fopen(argv[2], "wb");
+  if (outfile == NULL) {
+    fprintf(stderr, "Failed to open file %s: %s\n", argv[2], strerror(errno));
+    fclose(infile);
+    exit(EXIT_FAILURE);
+  }
+
+  while ((i=fread(buf, 1, 1024, infile)) > 0) {
+    if (csv_parse(&p, buf, i, cb1, cb2, outfile) != i) {
+      fprintf(stderr, "Error parsing file: %s\n", csv_strerror(csv_error(&p)));
+      fclose(infile);
+      fclose(outfile);
+      remove(argv[2]);
+      exit(EXIT_FAILURE);
+    }
+  }
+
+  csv_fini(&p, cb1, cb2, outfile);
+  csv_free(&p);
+
+  if (ferror(infile)) {
+    fprintf(stderr, "Error reading from input file");
+    fclose(infile);
+    fclose(outfile);
+    remove(argv[2]);
+    exit(EXIT_FAILURE);
+  }
+
+  fclose(infile);
+  fclose(outfile);
+  return EXIT_SUCCESS;
+}
+
diff --git a/csv/examples/csvinfo.c b/csv/examples/csvinfo.c
new file mode 100644
index 0000000..7f11a66
--- /dev/null
+++ b/csv/examples/csvinfo.c
@@ -0,0 +1,104 @@
+/*
+csvinfo - reads CSV data from input file(s) and reports the number
+          of fields and rows encountered in each file
+
+Copyright (C) 2007  Robert Gamble
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "libcsv/csv.h"
+
+struct counts {
+  long unsigned fields;
+  long unsigned rows;
+};
+
+void cb1 (void *s, size_t len, void *data) { ((struct counts *)data)->fields++; }
+void cb2 (int c, void *data) { ((struct counts *)data)->rows++; }
+
+static int is_space(unsigned char c) {
+  if (c == CSV_SPACE || c == CSV_TAB) return 1;
+  return 0;
+}
+
+static int is_term(unsigned char c) {
+  if (c == CSV_CR || c == CSV_LF) return 1;
+  return 0;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+  FILE *fp;
+  struct csv_parser p;
+  char buf[1024];
+  size_t bytes_read;
+  unsigned char options = 0;
+  struct counts c = {0, 0};
+
+  if (argc < 2) {
+    fprintf(stderr, "Usage: csvinfo [-s] files\n");
+    exit(EXIT_FAILURE);
+  }
+
+  if (csv_init(&p, options) != 0) {
+    fprintf(stderr, "Failed to initialize csv parser\n");
+    exit(EXIT_FAILURE);
+  }
+
+  csv_set_space_func(&p, is_space);
+  csv_set_term_func(&p, is_term);
+
+  while (*(++argv)) {
+    if (strcmp(*argv, "-s") == 0) {
+      options = CSV_STRICT;
+      csv_set_opts(&p, options);
+      continue;
+    }
+
+    fp = fopen(*argv, "rb");
+    if (!fp) {
+      fprintf(stderr, "Failed to open %s: %s\n", *argv, strerror(errno));
+      continue;
+    }
+
+    while ((bytes_read=fread(buf, 1, 1024, fp)) > 0) {
+      if (csv_parse(&p, buf, bytes_read, cb1, cb2, &c) != bytes_read) {
+        fprintf(stderr, "Error while parsing file: %s\n", csv_strerror(csv_error(&p)));
+      }
+    }
+
+    csv_fini(&p, cb1, cb2, &c);
+
+    if (ferror(fp)) {
+      fprintf(stderr, "Error while reading file %s\n", *argv);
+      fclose(fp);
+      continue;
+    }
+
+    fclose(fp);
+    printf("%s: %lu fields, %lu rows\n", *argv, c.fields, c.rows);
+  }
+
+  csv_free(&p);
+  exit(EXIT_SUCCESS);
+}
+ 
diff --git a/csv/examples/csvtest.c b/csv/examples/csvtest.c
new file mode 100644
index 0000000..c17a444
--- /dev/null
+++ b/csv/examples/csvtest.c
@@ -0,0 +1,63 @@
+/*
+csvtest - reads CSV data from stdin and output properly formed equivalent
+          useful for testing the library
+
+Copyright (C) 2007  Robert Gamble
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "libcsv/csv.h"
+
+static int put_comma;
+
+void cb1 (void *s, size_t i, void *p) {
+  if (put_comma)
+    putc(',', stdout);
+  csv_fwrite(stdout, s, i);
+  put_comma = 1;
+}
+
+void cb2 (int c, void *p) {
+  put_comma = 0;
+  putc('\n', stdout);
+}
+
+int main (void) {
+  struct csv_parser p;
+  int i;
+  char c;
+
+  csv_init(&p, 0);
+
+  while ((i=getc(stdin)) != EOF) {
+    c = i;
+    if (csv_parse(&p, &c, 1, cb1, cb2, NULL) != 1) {
+      fprintf(stderr, "Error: %s\n", csv_strerror(csv_error(&p)));
+      exit(EXIT_FAILURE);
+    }
+  }
+
+  csv_fini(&p, cb1, cb2, NULL);
+  csv_free(&p);
+
+  return EXIT_SUCCESS;
+}
+
diff --git a/csv/examples/csvvalid.c b/csv/examples/csvvalid.c
new file mode 100644
index 0000000..1581521
--- /dev/null
+++ b/csv/examples/csvvalid.c
@@ -0,0 +1,78 @@
+/*
+csvvalid - determine if files are properly formed CSV files and display
+           position of first offending byte if not
+
+Copyright (C) 2007  Robert Gamble
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "libcsv/csv.h"
+
+int
+main (int argc, char *argv[])
+{
+  FILE *fp;
+  int i;
+  struct csv_parser p;
+  char buf[1024];
+  size_t bytes_read;
+  size_t pos;
+  size_t retval;
+
+  if (argc < 2) {
+    fprintf(stderr, "Usage: csvvalid files\n");
+    exit(EXIT_FAILURE);
+  }
+
+  if (csv_init(&p, CSV_STRICT) != 0) {
+    fprintf(stderr, "Failed to initialize csv parser\n");
+    exit(EXIT_FAILURE);
+  }
+
+  for (i = 1; i < argc; i++) {
+    pos = 0;
+    fp = fopen(argv[i], "rb");
+    if (!fp) {
+      fprintf(stderr, "Failed to open %s: %s, skipping\n", argv[i], strerror(errno));
+      continue;
+    }
+    while ((bytes_read=fread(buf, 1, 1024, fp)) > 0) {
+      if ((retval = csv_parse(&p, buf, bytes_read, NULL, NULL, NULL)) != bytes_read) {
+        if (csv_error(&p) == CSV_EPARSE) {
+          printf("%s: malformed at byte %lu\n", argv[i], (unsigned long)pos + retval + 1);
+          goto end;
+        } else {
+          printf("Error while processing %s: %s\n", argv[i], csv_strerror(csv_error(&p)));
+          goto end;
+        }
+      }
+      pos += bytes_read;
+    }
+    printf("%s well-formed\n", argv[i]);
+
+    end:
+    fclose(fp);
+    csv_fini(&p, NULL, NULL, NULL);
+    pos = 0;
+  }
+
+  csv_free(&p);
+  return EXIT_SUCCESS;
+}
diff --git a/csv/libcsv.c b/csv/libcsv.c
new file mode 100644
index 0000000..6c2f6cd
--- /dev/null
+++ b/csv/libcsv.c
@@ -0,0 +1,579 @@
+/*
+libcsv - parse and write csv data
+Copyright (C) 2008  Robert Gamble
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#if ___STDC_VERSION__ >= 199901L
+#  include <stdint.h>
+#else
+#  define SIZE_MAX ((size_t)-1) /* C89 doesn't have stdint.h or SIZE_MAX */
+#endif
+
+#include "csv.h"
+
+#define VERSION "3.0.0"
+
+#define ROW_NOT_BEGUN           0
+#define FIELD_NOT_BEGUN         1
+#define FIELD_BEGUN             2
+#define FIELD_MIGHT_HAVE_ENDED  3
+
+/*
+  Explanation of states
+  ROW_NOT_BEGUN    There have not been any fields encountered for this row
+  FIELD_NOT_BEGUN  There have been fields but we are currently not in one
+  FIELD_BEGUN      We are in a field
+  FIELD_MIGHT_HAVE_ENDED
+                   We encountered a double quote inside a quoted field, the
+                   field is either ended or the quote is literal
+*/
+
+#define MEM_BLK_SIZE 128
+
+#define SUBMIT_FIELD(p) \
+  do { \
+   if (!quoted) \
+     entry_pos -= spaces; \
+   if (p->options & CSV_APPEND_NULL) \
+     ((p)->entry_buf[entry_pos+1]) = '\0'; \
+   if (cb1) \
+     cb1(p->entry_buf, entry_pos, data); \
+   pstate = FIELD_NOT_BEGUN; \
+   entry_pos = quoted = spaces = 0; \
+ } while (0)
+
+#define SUBMIT_ROW(p, c) \
+  do { \
+    if (cb2) \
+      cb2(c, data); \
+    pstate = ROW_NOT_BEGUN; \
+    entry_pos = quoted = spaces = 0; \
+  } while (0)
+
+#define SUBMIT_CHAR(p, c) ((p)->entry_buf[entry_pos++] = (c))
+
+static char *csv_errors[] = {"success",
+                             "error parsing data while strict checking enabled",
+                             "memory exhausted while increasing buffer size",
+                             "data size too large",
+                             "invalid status code"};
+
+int
+csv_error(struct csv_parser *p)
+{
+  /* Return the current status of the parser */
+  return p->status;
+}
+
+char *
+csv_strerror(int status)
+{
+  /* Return a textual description of status */
+  if (status >= CSV_EINVALID || status < 0)
+    return csv_errors[CSV_EINVALID];
+  else
+    return csv_errors[status];
+}
+
+int
+csv_get_opts(struct csv_parser *p)
+{
+  /* Return the currently set options of parser */
+  if (p == NULL)
+    return -1;
+
+  return p->options;
+}
+
+int
+csv_set_opts(struct csv_parser *p, unsigned char options)
+{
+  /* Set the options */
+  if (p == NULL)
+    return -1;
+
+  p->options = options;
+  return 0;
+}
+
+int
+csv_init(struct csv_parser *p, unsigned char options)
+{
+  /* Initialize a csv_parser object returns 0 on success, -1 on error */
+  if (p == NULL)
+    return -1;
+
+  p->entry_buf = NULL;
+  p->pstate = ROW_NOT_BEGUN;
+  p->quoted = 0;
+  p->spaces = 0;
+  p->entry_pos = 0;
+  p->entry_size = 0;
+  p->status = 0;
+  p->options = options;
+  p->quote_char = CSV_QUOTE;
+  p->delim_char = CSV_COMMA;
+  p->is_space = NULL;
+  p->is_term = NULL;
+  p->blk_size = MEM_BLK_SIZE;
+  p->malloc_func = NULL;
+  p->realloc_func = realloc;
+  p->free_func = free;
+
+  return 0;
+}
+
+void
+csv_free(struct csv_parser *p)
+{
+  /* Free the entry_buffer of csv_parser object */
+  if (p == NULL)
+    return;
+
+  if (p->entry_buf)
+    p->free_func(p->entry_buf);
+
+  p->entry_buf = NULL;
+  p->entry_size = 0;
+
+  return;
+}
+
+int
+csv_fini(struct csv_parser *p, void (*cb1)(void *, size_t, void *), void (*cb2)(int c, void *), void *data)
+{
+  /* Finalize parsing.  Needed, for example, when file does not end in a newline */
+  int quoted = p->quoted;
+  int pstate = p->pstate;
+  size_t spaces = p->spaces;
+  size_t entry_pos = p->entry_pos;
+
+  if (p == NULL)
+    return -1;
+
+
+  if (p->pstate == FIELD_BEGUN && p->quoted && p->options & CSV_STRICT && p->options & CSV_STRICT_FINI) {
+    /* Current field is quoted, no end-quote was seen, and CSV_STRICT_FINI is set */
+    p->status = CSV_EPARSE;
+    return -1;
+  }
+
+  switch (p->pstate) {
+    case FIELD_MIGHT_HAVE_ENDED:
+      p->entry_pos -= p->spaces + 1;  /* get rid of spaces and original quote */
+      /* Fall-through */
+    case FIELD_NOT_BEGUN:
+    case FIELD_BEGUN:
+      quoted = p->quoted, pstate = p->pstate;
+      spaces = p->spaces, entry_pos = p->entry_pos;
+      SUBMIT_FIELD(p);
+      SUBMIT_ROW(p, -1);
+    case ROW_NOT_BEGUN: /* Already ended properly */
+      ;
+  }
+
+  /* Reset parser */
+  p->spaces = p->quoted = p->entry_pos = p->status = 0;
+  p->pstate = ROW_NOT_BEGUN;
+
+  return 0;
+}
+
+void
+csv_set_delim(struct csv_parser *p, unsigned char c)
+{
+  /* Set the delimiter */
+  if (p) p->delim_char = c;
+}
+
+void
+csv_set_quote(struct csv_parser *p, unsigned char c)
+{
+  /* Set the quote character */
+  if (p) p->quote_char = c;
+}
+
+unsigned char
+csv_get_delim(struct csv_parser *p)
+{
+  /* Get the delimiter */
+  return p->delim_char;
+}
+
+unsigned char
+csv_get_quote(struct csv_parser *p)
+{
+  /* Get the quote character */
+  return p->quote_char;
+}
+
+void
+csv_set_space_func(struct csv_parser *p, int (*f)(unsigned char))
+{
+  /* Set the space function */
+  if (p) p->is_space = f;
+}
+ 
+void
+csv_set_term_func(struct csv_parser *p, int (*f)(unsigned char))
+{
+  /* Set the term function */
+  if (p) p->is_term = f;
+}
+
+void
+csv_set_realloc_func(struct csv_parser *p, void *(*f)(void *, size_t))
+{
+  /* Set the realloc function used to increase buffer size */
+  if (p && f) p->realloc_func = f;
+}
+ 
+void
+csv_set_free_func(struct csv_parser *p, void (*f)(void *))
+{
+  /* Set the free function used to free the buffer */
+  if (p && f) p->free_func = f;
+}
+
+void
+csv_set_blk_size(struct csv_parser *p, size_t size)
+{
+  /* Set the block size used to increment buffer size */
+  if (p) p->blk_size = size;
+}
+
+size_t
+csv_get_buffer_size(struct csv_parser *p)
+{
+  /* Get the size of the entry buffer */
+  if (p)
+    return p->entry_size;
+  return 0;
+}
+ 
+static int
+csv_increase_buffer(struct csv_parser *p)
+{
+  /* Increase the size of the entry buffer.  Attempt to increase size by 
+   * p->blk_size, if this is larger than SIZE_MAX try to increase current
+   * buffer size to SIZE_MAX.  If allocation fails, try to allocate halve 
+   * the size and try again until successful or increment size is zero.
+   */
+
+  size_t to_add = p->blk_size;
+  void *vp;
+
+  if ( p->entry_size >= SIZE_MAX - to_add )
+    to_add = SIZE_MAX - p->entry_size;
+
+  if (!to_add) {
+    p->status = CSV_ETOOBIG;
+    return -1;
+  }
+
+  while ((vp = p->realloc_func(p->entry_buf, p->entry_size + to_add)) == NULL) {
+    to_add /= 2;
+    if (!to_add) {
+      p->status = CSV_ENOMEM;
+      return -1;
+    }
+  }
+
+  /* Update entry buffer pointer and entry_size if successful */
+  p->entry_buf = vp;
+  p->entry_size += to_add;
+  return 0;
+}
+ 
+size_t
+csv_parse(struct csv_parser *p, const void *s, size_t len, void (*cb1)(void *, size_t, void *), void (*cb2)(int c, void *), void *data)
+{
+  unsigned const char *us = s;  /* Access input data as array of unsigned char */
+  unsigned char c;              /* The character we are currently processing */
+  size_t pos = 0;               /* The number of characters we have processed in this call */
+
+  /* Store key fields into local variables for performance */
+  unsigned char delim = p->delim_char;
+  unsigned char quote = p->quote_char;
+  int (*is_space)(unsigned char) = p->is_space;
+  int (*is_term)(unsigned char) = p->is_term;
+  int quoted = p->quoted;
+  int pstate = p->pstate;
+  size_t spaces = p->spaces;
+  size_t entry_pos = p->entry_pos;
+
+
+  if (!p->entry_buf && pos < len) {
+    /* Buffer hasn't been allocated yet and len > 0 */
+    if (csv_increase_buffer(p) != 0) { 
+      p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
+      return pos;
+    }
+  }
+
+  while (pos < len) {
+    /* Check memory usage, increase buffer if neccessary */
+    if (entry_pos == ((p->options & CSV_APPEND_NULL) ? p->entry_size - 1 : p->entry_size) ) {
+      if (csv_increase_buffer(p) != 0) {
+        p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
+        return pos;
+      }
+    }
+
+    c = us[pos++];
+
+    switch (pstate) {
+      case ROW_NOT_BEGUN:
+      case FIELD_NOT_BEGUN:
+        if (is_space ? is_space(c) : c == CSV_SPACE || c == CSV_TAB) { /* Space or Tab */
+          continue;
+        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) { /* Carriage Return or Line Feed */
+          if (pstate == FIELD_NOT_BEGUN) {
+            SUBMIT_FIELD(p);
+            SUBMIT_ROW(p, (unsigned char)c); 
+          } else {  /* ROW_NOT_BEGUN */
+            /* Don't submit empty rows by default */
+            if (p->options & CSV_REPALL_NL) {
+              SUBMIT_ROW(p, (unsigned char)c);
+            }
+          }
+          continue;
+        } else if (c == delim) { /* Comma */
+          SUBMIT_FIELD(p);
+          break;
+        } else if (c == quote) { /* Quote */
+          pstate = FIELD_BEGUN;
+          quoted = 1;
+        } else {               /* Anything else */
+          pstate = FIELD_BEGUN;
+          quoted = 0;
+          SUBMIT_CHAR(p, c);
+        }
+        break;
+      case FIELD_BEGUN:
+        if (c == quote) {         /* Quote */
+          if (quoted) {
+            SUBMIT_CHAR(p, c);
+            pstate = FIELD_MIGHT_HAVE_ENDED;
+          } else {
+            /* STRICT ERROR - double quote inside non-quoted field */
+            if (p->options & CSV_STRICT) {
+              p->status = CSV_EPARSE;
+              p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
+              return pos-1;
+            }
+            SUBMIT_CHAR(p, c);
+            spaces = 0;
+          }
+        } else if (c == delim) {  /* Comma */
+          if (quoted) {
+            SUBMIT_CHAR(p, c);
+          } else {
+            SUBMIT_FIELD(p);
+          }
+        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) {  /* Carriage Return or Line Feed */
+          if (!quoted) {
+            SUBMIT_FIELD(p);
+            SUBMIT_ROW(p, (unsigned char)c);
+          } else {
+            SUBMIT_CHAR(p, c);
+          }
+        } else if (!quoted && (is_space? is_space(c) : c == CSV_SPACE || c == CSV_TAB)) { /* Tab or space for non-quoted field */
+            SUBMIT_CHAR(p, c);
+            spaces++;
+        } else {  /* Anything else */
+          SUBMIT_CHAR(p, c);
+          spaces = 0;
+        }
+        break;
+      case FIELD_MIGHT_HAVE_ENDED:
+        /* This only happens when a quote character is encountered in a quoted field */
+        if (c == delim) {  /* Comma */
+          entry_pos -= spaces + 1;  /* get rid of spaces and original quote */
+          SUBMIT_FIELD(p);
+        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) {  /* Carriage Return or Line Feed */
+          entry_pos -= spaces + 1;  /* get rid of spaces and original quote */
+          SUBMIT_FIELD(p);
+          SUBMIT_ROW(p, (unsigned char)c);
+        } else if (is_space ? is_space(c) : c == CSV_SPACE || c == CSV_TAB) {  /* Space or Tab */
+          SUBMIT_CHAR(p, c);
+          spaces++;
+        } else if (c == quote) {  /* Quote */
+          if (spaces) {
+            /* STRICT ERROR - unescaped double quote */
+            if (p->options & CSV_STRICT) {
+              p->status = CSV_EPARSE;
+              p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
+              return pos-1;
+            }
+            spaces = 0;
+            SUBMIT_CHAR(p, c);
+          } else {
+            /* Two quotes in a row */
+            pstate = FIELD_BEGUN;
+          }
+        } else {  /* Anything else */
+          /* STRICT ERROR - unescaped double quote */
+          if (p->options & CSV_STRICT) {
+            p->status = CSV_EPARSE;
+            p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
+            return pos-1;
+          }
+          pstate = FIELD_BEGUN;
+          spaces = 0;
+          SUBMIT_CHAR(p, c);
+        }
+        break;
+     default:
+       break;
+    }
+  }
+  p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;
+  return pos;
+}
+
+size_t
+csv_write (void *dest, size_t dest_size, const void *src, size_t src_size)
+{
+  unsigned char *cdest = dest;
+  const unsigned char *csrc = src;
+  size_t chars = 0;
+
+  if (src == NULL)
+    return 0;
+
+  if (cdest == NULL)
+    dest_size = 0;
+
+  if (dest_size > 0)
+    *cdest++ = '"';
+  chars++;
+
+  while (src_size) {
+    if (*csrc == '"') {
+      if (dest_size > chars)
+        *cdest++ = '"';
+      if (chars < SIZE_MAX) chars++;
+    }
+    if (dest_size > chars)
+      *cdest++ = *csrc;
+    if (chars < SIZE_MAX) chars++;
+    src_size--;
+    csrc++;
+  }
+
+  if (dest_size > chars)
+    *cdest = '"';
+  if (chars < SIZE_MAX) chars++;
+
+  return chars;
+}
+
+int
+csv_fwrite (FILE *fp, const void *src, size_t src_size)
+{
+  const unsigned char *csrc = src;
+
+  if (fp == NULL || src == NULL)
+    return 0;
+
+  if (fputc('"', fp) == EOF)
+    return EOF;
+
+  while (src_size) {
+    if (*csrc == '"') {
+      if (fputc('"', fp) == EOF)
+        return EOF;
+    }
+    if (fputc(*csrc, fp) == EOF)
+      return EOF;
+    src_size--;
+    csrc++;
+  }
+
+  if (fputc('"', fp) == EOF) {
+    return EOF;
+  }
+
+  return 0;
+}
+
+size_t
+csv_write2 (void *dest, size_t dest_size, const void *src, size_t src_size, unsigned char quote)
+{
+  unsigned char *cdest = dest;
+  const unsigned char *csrc = src;
+  size_t chars = 0;
+
+  if (src == NULL)
+    return 0;
+
+  if (dest == NULL)
+    dest_size = 0;
+
+  if (dest_size > 0)
+    *cdest++ = quote;
+  chars++;
+
+  while (src_size) {
+    if (*csrc == quote) {
+      if (dest_size > chars)
+        *cdest++ = quote;
+      if (chars < SIZE_MAX) chars++;
+    }
+    if (dest_size > chars)
+      *cdest++ = *csrc;
+    if (chars < SIZE_MAX) chars++;
+    src_size--;
+    csrc++;
+  }
+
+  if (dest_size > chars)
+    *cdest = quote;
+  if (chars < SIZE_MAX) chars++;
+
+  return chars;
+}
+
+int
+csv_fwrite2 (FILE *fp, const void *src, size_t src_size, unsigned char quote)
+{
+  const unsigned char *csrc = src;
+
+  if (fp == NULL || src == NULL)
+    return 0;
+
+  if (fputc(quote, fp) == EOF)
+    return EOF;
+
+  while (src_size) {
+    if (*csrc == quote) {
+      if (fputc(quote, fp) == EOF)
+        return EOF;
+    }
+    if (fputc(*csrc, fp) == EOF)
+      return EOF;
+    src_size--;
+    csrc++;
+  }
+
+  if (fputc(quote, fp) == EOF) {
+    return EOF;
+  }
+
+  return 0;
+}
diff --git a/csv/test_csv.c b/csv/test_csv.c
new file mode 100644
index 0000000..450bed4
--- /dev/null
+++ b/csv/test_csv.c
@@ -0,0 +1,463 @@
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <stdlib.h>
+#include "./csv.h"
+
+#define CSV_END 0
+#define CSV_COL 1
+#define CSV_ROW 2
+#define CSV_ERR 3
+
+#define DO_TEST(name, options) test_parser("test" #name, options, test ## name ## _data, \
+        sizeof(test ## name ## _data) - 1, test ## name ## _results, \
+        CSV_COMMA, CSV_QUOTE, NULL, NULL)
+
+#define DO_TEST_CUSTOM(name, options, d, q, s, t) test_parser("custom" #name, options, custom ## name ## _data, \
+        sizeof(custom ## name ## _data) - 1, custom ## name ## _results, d, q, s, t)
+
+struct event {
+  int event_type; 
+  int retval;
+  size_t size;  /* Number of bytes in this event or return value from csv_fini */
+  char *data;   /* Data for this event */
+};
+
+struct event *event_ptr;
+int event_idx;
+size_t row, col;
+
+void
+fail_parser (char * test_name, char * message)
+{
+  fprintf(stderr, "Parser test %s failed on event %d: %s\n", test_name, event_idx, message);
+  exit(EXIT_FAILURE);
+}
+
+void
+fail_writer (char * test_name, char * message)
+{
+  fprintf(stderr, "Writer test %s failed: %s\n", test_name, message);
+  exit(EXIT_FAILURE);
+}
+
+void
+cb1 (void *data, size_t len, void *t)
+{
+  char * test_name = t;
+
+  /* Make sure we were expecting a column */
+  if (event_ptr->event_type != CSV_COL)
+    fail_parser(test_name, "didn't expect a column");
+
+  /* Check the actual size against the expected size */
+  if (event_ptr->size != len)
+    fail_parser(test_name, "actual data length doesn't match expected data length");
+
+  /* Check the actual data against the expected data */
+  if (memcmp(event_ptr->data, data, len) != 0)
+    fail_parser(test_name, "actual data doesn't match expected data");
+
+  event_idx++;
+  event_ptr++;
+  col++;
+}
+
+void
+cb2 (int c, void *t)
+{
+  char * test_name = t;
+
+  /* Make sure we were expecting an the end of a row */
+  if (event_ptr->event_type != CSV_ROW)
+    fail_parser(test_name, "didn't expect end of row");
+
+  /* Check that the row ended with the character we expected */
+  if (event_ptr->retval != c)
+    fail_parser(test_name, "row ended with unexpected character");
+
+  event_idx++;
+  event_ptr++;
+  col = 1;
+  row++;
+}
+
+void
+test_parser (char *test_name, unsigned char options, void *input, size_t len, struct event expected[],
+             char delimiter, char quote, int (*space_func)(unsigned char), int (*term_func)(unsigned char))
+{
+  int result = 0;
+  size_t retval;
+  struct csv_parser p;
+  size_t size;
+
+  for (size = 1; size <= len; size++) {
+    size_t bytes_processed = 0;
+    csv_init(&p, options);
+    csv_set_delim(&p, delimiter);
+    csv_set_quote(&p, quote);
+    csv_set_space_func(&p, space_func);
+    csv_set_term_func(&p, term_func);
+
+    row = col = 1;
+    event_ptr = &expected[0];
+    event_idx = 1;
+
+    do {
+      size_t bytes = size < len - bytes_processed ? size : len - bytes_processed;
+      retval = csv_parse(&p, input + bytes_processed, bytes, cb1, cb2, test_name);
+      if (retval != bytes) {
+        if (event_ptr->event_type != CSV_ERR) {
+          fail_parser(test_name, "unexpected parse error occured");
+        } else {
+          csv_free(&p);
+          return;
+        }
+      }
+      bytes_processed += bytes;
+    } while (bytes_processed < len);
+
+    result = csv_fini(&p, cb1, cb2, test_name);
+
+    if (result != 0) {
+      if (event_ptr->event_type != CSV_ERR) {
+        fail_parser(test_name, "unexpected parse error occured");
+      } else {
+        csv_free(&p);
+        return;
+      }
+    }
+
+    csv_free(&p);
+
+    if (event_ptr->event_type != CSV_END)
+      fail_parser(test_name, "unexpected end of input");
+  }
+}
+
+void
+test_writer (char * test_name, char *input, size_t input_len, char *expected, size_t expected_len)
+{
+  size_t actual_len;
+  char *temp = malloc(input_len*2 + 2);
+  if (!temp) {
+    fprintf(stderr, "Failed to allocate memory in test_writer!\n");
+    exit(EXIT_FAILURE);
+  }
+
+  actual_len = csv_write(temp, input_len*2 + 2, input, input_len);
+  if (actual_len != expected_len)
+    fail_writer(test_name, "actual length doesn't match expected length");
+  if (memcmp(temp, expected, actual_len) != 0)
+    fail_writer(test_name, "actual data doesn't match expected data");
+}
+
+void
+test_writer2 (char * test_name, char *input, size_t input_len, char *expected, size_t expected_len, char quote)
+{
+  size_t actual_len;
+  char *temp = malloc(input_len*2 + 2);
+  if (!temp) {
+    fprintf(stderr, "Failed to allocate memory in test_writer!\n");
+    exit(EXIT_FAILURE);
+  }
+
+  actual_len = csv_write2(temp, input_len*2 + 2, input, input_len, quote);
+  if (actual_len != expected_len)
+    fail_writer(test_name, "actual length doesn't match expected length");
+  if (memcmp(temp, expected, actual_len) != 0)
+    fail_writer(test_name, "actual data doesn't match expected data");
+}
+
+
+int main (void) {
+
+  /* Parser Tests */
+
+  /* Parser tests presented here consist of two parts:
+     1. the raw data to be parsed as an array of char
+     2. the behavior expected from attempting to parse the data
+  
+     The latter is encapsulated into an array of struct event, each event
+     described the type of event that was expected at that point and details
+     of the event.  There are four event types:
+     1. CSV_END - signifies the successful end of parsing, no events should
+                  follow in this test
+     2. CSV_COL - signifies that a column or CSV element is expected to be
+                  submitted to the appropriate callback function
+     3. CSV_ROW - specifies the end of a row has been reached
+     4. CSV_ERR - signifies that an error is expected at this point, no
+                  further events should follow in this test
+
+     In addition to the event type, an event is also characterized by a size
+     and a data member in the event structure.  The meaning of these fields
+     depends on the event type.
+
+     The size member for CSV_COL is the size of the expected data column,
+     for CSV_ROW is it the size of the terminating character which should
+     always be 1.  The size for CSV_END should always be zero, for CSV_ERR
+     the size is not used.
+
+     The data member represents the actual data after parsing for a CSV_COL,
+     the terminating character for CSV_ROW (the first character of the provided
+     char array is the one used), and is not used for CSV_END or CSV_ERR, it
+     should be NULL in these cases.
+  */
+
+
+  char test01_data[] = " 1,2 ,  3         ,4,5\x0d\x0a";
+  char test02_data[] = ",,,,,\x0a";
+  char test03_data[] = "\",\",\",\",\"\"";
+  char test04_data[] = "\"I call our world Flatland,\x0a"
+                       "not because we call it so,\x0a"
+                       "but to make its nature clearer\x0a"
+                       "to you, my happy readers,\x0a"
+                       "who are privileged to live in Space.\"";
+  char test05_data[] = "\"\"\"a,b\"\"\",,\" \"\"\"\" \",\"\"\"\"\" \",\" \"\"\"\"\",\"\"\"\"\"\"";
+  char test06_data[] = "\" a, b ,c \", a b  c,";
+  char test07_data[] = "\" \"\" \" \" \"\" \"";
+  char test07b_data[] = "\" \"\" \" \" \"\" \"";
+  char test08_data[] = "\" abc\"                                             "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                          \", \"123\"";
+  char test09_data[] = "";
+  char test10_data[] = "a\x0a";
+  char test11_data[] = "1,2 ,3,4\x0a";
+  char test12_data[] = "\x0a\x0a\x0a\x0a";
+  char test12b_data[] = "\x0a\x0a\x0a\x0a";
+  char test13_data[] = "\"abc\"";
+  char test14_data[] = "1, 2, 3,\x0a\x0d\x0a  \"4\", \x0d,";
+  char test15_data[] = "1, 2, 3,\x0a\x0d\x0a  \"4\", \x0d\"\"";
+  char test16_data[] = "\"1\",\"2\",\" 3 ";
+  char test16b_data[] = "\"1\",\"2\",\" 3 ";
+  char test17_data[] = " a\0b\0c ";
+  char test18_data[] = "12345678901234567890123456789012";
+
+  /* Custom tests */
+  char custom01_data[] = "'''a;b''';;' '''' ';''''' ';' ''''';''''''";
+
+  /* |1|2|3|4|5| */
+  struct event test01_results[] =
+    { {CSV_COL, 0, 1, "1"},
+      {CSV_COL, 0, 1, "2"},
+      {CSV_COL, 0, 1, "3"},
+      {CSV_COL, 0, 1, "4"},
+      {CSV_COL, 0, 1, "5"},
+      {CSV_ROW, '\x0d', 1, NULL}, {CSV_END, 0, 0, NULL} };
+    
+  /* ||||||| */
+  struct event test02_results[] =
+    { {CSV_COL, 0, 0, ""},
+      {CSV_COL, 0, 0, ""},
+      {CSV_COL, 0, 0, ""},
+      {CSV_COL, 0, 0, ""},
+      {CSV_COL, 0, 0, ""},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, '\x0a', 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* |,|,|| */
+  struct event test03_results[] = 
+    { {CSV_COL, 0, 1, ","},
+      {CSV_COL, 0, 1, ","},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  struct event test04_results[] = 
+    { {CSV_COL, 0, 147, "I call our world Flatland,\x0a"
+                     "not because we call it so,\x0a"
+                     "but to make its nature clearer\x0a"
+                     "to you, my happy readers,\x0a"
+                     "who are privileged to live in Space."},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* |"a,b"|| "" |"" | ""|""| */
+  struct event test05_results[] = 
+    { {CSV_COL, 0, 5, "\"a,b\""},
+      {CSV_COL, 0, 0, ""},
+      {CSV_COL, 0, 4, " \"\" "},
+      {CSV_COL, 0, 3, "\"\" "},
+      {CSV_COL, 0, 3, " \"\""},
+      {CSV_COL, 0, 2, "\"\""},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* | a, b ,c |a b  c|| */
+  struct event test06_results[] = 
+    { {CSV_COL, 0, 9, " a, b ,c "},
+      {CSV_COL, 0, 6, "a b  c"},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* | " " " " | */
+  struct event test07_results[] = 
+    { {CSV_COL, 0, 9, " \" \" \" \" "},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* Will cause error with CSV_STRICT set */
+  struct event test07b_results[] = 
+    { {CSV_ERR, 0, 0, NULL} };
+
+  struct event test08_results[] = 
+    { {CSV_COL, 0, 463,   " abc\"                                               "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                                     "
+                       "                                        "},
+      {CSV_COL, 0, 3, "123"},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+                     
+  /* empty */
+  struct event test09_results[] = 
+    { {CSV_END, 0, 0, NULL} };
+
+  /* |a| */
+  struct event test10_results[] = 
+    { {CSV_COL, 0, 1, "a"},
+      {CSV_ROW, '\x0a', 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* |1|2|3|4| */
+  struct event test11_results[] = 
+    { {CSV_COL, 0, 1, "1"},
+      {CSV_COL, 0, 1, "2"},
+      {CSV_COL, 0, 1, "3"}, 
+      {CSV_COL, 0, 1, "4"},
+      {CSV_ROW, '\x0a', 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* empty */
+  struct event test12_results[] = 
+    { {CSV_END, 0, 0, NULL} };
+
+  /* Test CSV_REPALL_NL */
+  struct event test12b_results[] = 
+    { {CSV_ROW, '\x0a', 1, NULL},
+      {CSV_ROW, '\x0a', 1, NULL},
+      {CSV_ROW, '\x0a', 1, NULL},
+      {CSV_ROW, '\x0a', 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* |abc| */
+  struct event test13_results[] =
+    { {CSV_COL, 0, 3, "abc"},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* |1|2|3||
+     |4||
+     |||       */
+  struct event test14_results[] =
+    { {CSV_COL, 0, 1, "1"},
+      {CSV_COL, 0, 1, "2"},
+      {CSV_COL, 0, 1, "3"},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, '\x0a', 1, NULL},
+      {CSV_COL, 0, 1, "4"},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, '\x0d', 1, NULL},
+      {CSV_COL, 0, 0, ""},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, -1, 0, NULL}, {CSV_END, 0, 0, NULL} }; 
+      
+  /* |1|2|3||
+     |4||
+     ||       */
+  struct event test15_results[] =
+    { {CSV_COL, 0, 1, "1"},
+      {CSV_COL, 0, 1, "2"},
+      {CSV_COL, 0, 1, "3"},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, '\x0a', 1, NULL},
+      {CSV_COL, 0, 1, "4"},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, '\x0d', 1, NULL},
+      {CSV_COL, 0, 0, ""},
+      {CSV_ROW, -1, 0, NULL}, {CSV_END, 0, 0, NULL} };
+
+
+  /* |1|2| 3 | */
+  struct event test16_results[] = 
+    { {CSV_COL, 0, 1, "1"},
+      {CSV_COL, 0, 1, "2"},
+      {CSV_COL, 0, 3, " 3 "},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* Will cause an error with CSV_STRICT_FINI set */
+  struct event test16b_results[] = 
+    { {CSV_COL, 0, 1, "1"},
+      {CSV_COL, 0, 1, "2"},
+      {CSV_ERR, 0, 0, NULL} };
+
+  /* |a\0b\0c| */
+  struct event test17_results[] = 
+    { {CSV_COL, 0, 5, "a\0b\0c"},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  /* |'a;b'|| '' |'' | ''|''| */
+  struct event custom01_results[] = 
+    { {CSV_COL, 0, 5, "'a;b'"},
+      {CSV_COL, 0, 0, ""},
+      {CSV_COL, 0, 4, " '' "},
+      {CSV_COL, 0, 3, "'' "},
+      {CSV_COL, 0, 3, " ''"},
+      {CSV_COL, 0, 2, "''"},
+      {CSV_ROW, -1, 1, NULL}, {CSV_END, 0, 0, NULL} };
+
+  DO_TEST(01, 0);
+  DO_TEST(01, CSV_STRICT);
+  DO_TEST(02, 0);
+  DO_TEST(02, CSV_STRICT);
+  DO_TEST(03, 0);
+  DO_TEST(03, CSV_STRICT);
+  DO_TEST(04, 0);
+  DO_TEST(04, CSV_STRICT);
+  DO_TEST(05, 0);
+  DO_TEST(05, CSV_STRICT);
+  DO_TEST(05, CSV_STRICT | CSV_STRICT_FINI);
+  DO_TEST(06, 0);
+  DO_TEST(06, CSV_STRICT);
+  DO_TEST(07, 0);
+  DO_TEST(07b, CSV_STRICT);
+  DO_TEST(08, 0);
+  DO_TEST(09, 0);
+  DO_TEST(10, 0);
+  DO_TEST(11, 0);
+  DO_TEST(12, 0);
+  DO_TEST(12b, CSV_REPALL_NL);
+  DO_TEST(13, 0);
+  DO_TEST(14, 0);
+  DO_TEST(14, CSV_STRICT);
+  DO_TEST(15, 0);
+  DO_TEST(15, CSV_STRICT);
+  DO_TEST(16, 0);
+  DO_TEST(16, CSV_STRICT);
+  DO_TEST(16b, CSV_STRICT | CSV_STRICT_FINI);
+  DO_TEST(16, 0);
+  DO_TEST(16, CSV_STRICT);
+  DO_TEST(17, 0);
+  DO_TEST(17, CSV_STRICT);
+
+  DO_TEST_CUSTOM(01, 0, ';', '\'', NULL, NULL);
+
+  /* Writer Tests */
+
+  /* The writer tests are simpler, the test_writer function is used to
+     test the csv_write function and takes five arguments: the name of
+     the test, the data to convert, the length of that data, the expected
+     resulting CSV data, and the expected length of the result.
+  */
+
+  test_writer("1", "abc", 3, "\"abc\"", 5);
+  test_writer("2", "\"\"\"\"\"\"\"\"", 8, "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"", 18);
+
+  test_writer2("1", "abc", 3, "'abc'", 5, '\'');
+  test_writer2("2", "''''''''", 8, "''''''''''''''''''", 18, '\'');
+
+  puts("All tests passed");
+  return 0;
+}
diff --git a/csv/tests/test_01.csv b/csv/tests/test_01.csv
new file mode 100644
index 0000000..dc95b75
--- /dev/null
+++ b/csv/tests/test_01.csv
@@ -0,0 +1 @@
+ 1,2 , 	3	  ,4,5
diff --git a/csv/tests/test_02.csv b/csv/tests/test_02.csv
new file mode 100644
index 0000000..d36a458
--- /dev/null
+++ b/csv/tests/test_02.csv
@@ -0,0 +1 @@
+,,,,,
diff --git a/csv/tests/test_03.csv b/csv/tests/test_03.csv
new file mode 100644
index 0000000..235090b
--- /dev/null
+++ b/csv/tests/test_03.csv
@@ -0,0 +1 @@
+",",",",""
diff --git a/csv/tests/test_04.csv b/csv/tests/test_04.csv
new file mode 100644
index 0000000..bdd2fa2
--- /dev/null
+++ b/csv/tests/test_04.csv
@@ -0,0 +1,5 @@
+"I call our world Flatland,
+ not because we call it so, 
+ but to make its nature clearer
+ to you, my happy readers,
+ who are privileged to live in Space."
diff --git a/csv/tests/test_05.csv b/csv/tests/test_05.csv
new file mode 100644
index 0000000..92ca7c6
--- /dev/null
+++ b/csv/tests/test_05.csv
@@ -0,0 +1 @@
+"""a,b""",," """" ",""""" "," """"",""""""
diff --git a/csv/tests/test_06.csv b/csv/tests/test_06.csv
new file mode 100644
index 0000000..b124e7e
--- /dev/null
+++ b/csv/tests/test_06.csv
@@ -0,0 +1 @@
+" a, b ,c ", a b  c,
diff --git a/csv/tests/test_07.csv b/csv/tests/test_07.csv
new file mode 100644
index 0000000..0f54a76
--- /dev/null
+++ b/csv/tests/test_07.csv
@@ -0,0 +1 @@
+" "" " " "" "
diff --git a/csv/tests/test_08.csv b/csv/tests/test_08.csv
new file mode 100644
index 0000000..4a17b9f
--- /dev/null
+++ b/csv/tests/test_08.csv
@@ -0,0 +1 @@
+" abc"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ", "123" 
diff --git a/csv/tests/test_09.csv b/csv/tests/test_09.csv
new file mode 100644
index 0000000..e69de29
diff --git a/csv/tests/test_10.csv b/csv/tests/test_10.csv
new file mode 100644
index 0000000..7898192
--- /dev/null
+++ b/csv/tests/test_10.csv
@@ -0,0 +1 @@
+a
diff --git a/csv/tests/test_11.csv b/csv/tests/test_11.csv
new file mode 100644
index 0000000..4eb154e
--- /dev/null
+++ b/csv/tests/test_11.csv
@@ -0,0 +1 @@
+1,2 ,3,4
diff --git a/csv/tests/test_12.csv b/csv/tests/test_12.csv
new file mode 100644
index 0000000..fd40910
--- /dev/null
+++ b/csv/tests/test_12.csv
@@ -0,0 +1,4 @@
+
+
+
+
diff --git a/csv/tests/test_13.csv b/csv/tests/test_13.csv
new file mode 100644
index 0000000..4f44a21
--- /dev/null
+++ b/csv/tests/test_13.csv
@@ -0,0 +1 @@
+"abc"
\ No newline at end of file
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
index 12dc34d..f2b4d79 100755
--- a/src/realtime/proactor/Proactor.cpp
+++ b/src/realtime/proactor/Proactor.cpp
@@ -115,6 +115,11 @@ Proactor::run (void * null) {
 
   while (this->running == true)
     {
+      
+    }
+
+  while (this->running == true)
+    {
       this->inputQueue.lock();
       while (this->inputQueue.size() > 0)
 	{

commit 8f4cf8664eef8bce63fc351bc6e445a7dc384645
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Thu Apr 2 04:31:59 2009 +0000

    Added LICENSE and terms to all files.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@4 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..4dc08b4
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,503 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
diff --git a/config/INIFile.c b/config/INIFile.c
index 5580e3a..7cdbbbe 100644
--- a/config/INIFile.c
+++ b/config/INIFile.c
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   INIFile.c - INI File Object/Parser
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "parse.h"
 #include <config/INIFile.h>
 #include <string.h>
diff --git a/config/config.c b/config/config.c
index 48b5b06..98adcbf 100755
--- a/config/config.c
+++ b/config/config.c
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/*
+  config.c - Configuration File Object/Parser
+
+  The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+  Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with the library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include <config/config.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/config/parse.c b/config/parse.c
index 1181950..d575700 100644
--- a/config/parse.c
+++ b/config/parse.c
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   parse.c - Generic Parsing Code
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "parse.h"
 #include <string.h>
 #include <stdlib.h>
diff --git a/config/parse.h b/config/parse.h
index 0866e4d..7c4dd3b 100644
--- a/config/parse.h
+++ b/config/parse.h
@@ -1,3 +1,23 @@
+/* 
+   parse.h - Generic Parse Code Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_PARSE
 #define H_PARSE
 
diff --git a/include/config/INIFile.h b/include/config/INIFile.h
index 3c24dd6..ae8f722 100644
--- a/include/config/INIFile.h
+++ b/include/config/INIFile.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   INIFile.h - INI File Object/Parser Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_INIFILE
 #define H_INIFILE
 #ifdef __cplusplus
diff --git a/include/config/config.h b/include/config/config.h
index d1414c4..2113fff 100755
--- a/include/config/config.h
+++ b/include/config/config.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   config.h - Config Object/Parser Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_CONFIG
 #define H_CONFIG
 #ifdef __cplusplus
diff --git a/include/shared.h b/include/shared.h
index 09b81f3..659306f 100755
--- a/include/shared.h
+++ b/include/shared.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   shared.h - Shared Macro Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_SHARED
 #define H_SHARED
 
diff --git a/include/workbook/cell.h b/include/workbook/cell.h
index bc63237..5ad0ec9 100644
--- a/include/workbook/cell.h
+++ b/include/workbook/cell.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   cell.h - Cell Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_CELL
 #define H_CELL
 
diff --git a/include/workbook/sheet.h b/include/workbook/sheet.h
index 09d54e4..e9d093a 100644
--- a/include/workbook/sheet.h
+++ b/include/workbook/sheet.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   sheet.h - Sheet Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_SHEET
 #define H_SHEET
 
diff --git a/include/workbook/workbook.h b/include/workbook/workbook.h
index df23774..5fdb31c 100644
--- a/include/workbook/workbook.h
+++ b/include/workbook/workbook.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   workbook.h - Workbook Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_WORKBOOK
 #define H_WORKBOOK
 
diff --git a/src/Makefile b/src/Makefile
index 4120977..77e4c45 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -5,24 +5,24 @@ OBJS=$(patsubst %.c,${OBJDIR}/%.o,${SRCS})
 
 LFLAGS=-lworkbook -lconfig -lgtkextra-x11-2.0 -lgthread-2.0
 
-all: 	gtkcsv
+all: 	gtkworkbook
 	make -C realtime/ all
 #	make -C basic/ all
 #	make -C csv/ all
 
-gtkcsv: ${OBJS}
-	${CC} -o ${PROJDIR}/bin/gtkcsv ${OBJS} ${LIBS} ${LFLAGS}
+gtkworkbook: ${OBJS}
+	${CC} -o ${PROJDIR}/bin/gtkworkbook ${OBJS} ${LIBS} ${LFLAGS}
 
 clean:		
 	${MD} ${OBJDIR}	
-	${RM} ${OBJS} ${INSBINDIR}/gtkcsv
+	${RM} ${OBJS} ${INSBINDIR}/gtkworkbook
 	make -C realtime/ clean
 #	make -C basic/ clean
 #	make -C csv/ clean
 
 install: all
 	${MD} ${INSBINDIR}
-	${CP} ${PROJDIR}/bin/gtkcsv ${INSBINDIR}/gtkcsv
+	${CP} ${PROJDIR}/bin/gtkworkbook ${INSBINDIR}/gtkworkbook
 	make -C realtime/ install
 #	make -C basic/ install
 #	make -C csv/ install
diff --git a/src/application.c b/src/application.c
index da44dfc..5da5e86 100644
--- a/src/application.c
+++ b/src/application.c
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   application.c - Application Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "application.h"
 #include "plugin.h"
 #include <stdio.h>
diff --git a/src/application.h b/src/application.h
index 57baaf2..8cd0e5d 100644
--- a/src/application.h
+++ b/src/application.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   application.h - Application Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_APPLICATION
 #define H_APPLICATION
 
diff --git a/src/include.h b/src/include.h
index d7083a5..c7799ed 100644
--- a/src/include.h
+++ b/src/include.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   include.h - Include Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_INCLUDE
 #define H_INCLUDE
 
diff --git a/src/main.c b/src/main.c
index a9b759e..86362f3 100755
--- a/src/main.c
+++ b/src/main.c
@@ -1,3 +1,23 @@
+/* 
+   main.c - main() Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "application.h"
 
 int 
diff --git a/src/plugin.c b/src/plugin.c
index a872ee5..23b0493 100755
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   plugin.c - Plugin Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "plugin.h"
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/src/plugin.h b/src/plugin.h
index 14fad72..598275d 100755
--- a/src/plugin.h
+++ b/src/plugin.h
@@ -1,4 +1,23 @@
-/* @author: John `jb Bellone <jvb4@njit.edu> */
+/* 
+   plugin.h - Plugin Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef H_PLUGIN
 #define H_PLUGIN
 
diff --git a/src/realtime/AcceptThread.hpp b/src/realtime/AcceptThread.hpp
index e199358..bc65d9f 100755
--- a/src/realtime/AcceptThread.hpp
+++ b/src/realtime/AcceptThread.hpp
@@ -1,3 +1,23 @@
+/* 
+   AcceptThread.hpp - Acceptor Thread Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_ACCEPTTHREAD
 #define HPP_ACCEPTTHREAD
 
diff --git a/src/realtime/Connection.cpp b/src/realtime/Connection.cpp
index 28cc905..b430943 100644
--- a/src/realtime/Connection.cpp
+++ b/src/realtime/Connection.cpp
@@ -1,3 +1,23 @@
+/* 
+   Connection.cpp - Connection Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Connection.hpp"
 #include <iostream>
 
diff --git a/src/realtime/Connection.hpp b/src/realtime/Connection.hpp
index 4cebcce..2273b30 100644
--- a/src/realtime/Connection.hpp
+++ b/src/realtime/Connection.hpp
@@ -1,3 +1,23 @@
+/* 
+   Connection.hpp - Connection Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_CONNECTION
 #define HPP_CONNECTION
 
diff --git a/src/realtime/Packet.cpp b/src/realtime/Packet.cpp
index 02c0acc..6c23b23 100755
--- a/src/realtime/Packet.cpp
+++ b/src/realtime/Packet.cpp
@@ -1,3 +1,23 @@
+/* 
+   Packet.cpp - Packet Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Packet.hpp"
 
 #define WORD(d,buf,word) if (buf.length() > 0) { \
diff --git a/src/realtime/Packet.hpp b/src/realtime/Packet.hpp
index 31d1398..2e78d75 100755
--- a/src/realtime/Packet.hpp
+++ b/src/realtime/Packet.hpp
@@ -1,3 +1,23 @@
+/* 
+   Packet.hpp - Packet Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_PACKET
 #define HPP_PACKET
 
diff --git a/src/realtime/PacketHandler.hpp b/src/realtime/PacketHandler.hpp
deleted file mode 100755
index 03e99c9..0000000
--- a/src/realtime/PacketHandler.hpp
+++ /dev/null
@@ -1,245 +0,0 @@
-#ifndef HPP_PACKETHANDLER
-#define HPP_PACKETHANDLER
-
-#include "proactor/Job.hpp"
-#include "Packet.hpp"
-#include <workbook/cell.h>
-#include <workbook/sheet.h>
-#include <workbook/workbook.h>
-
-class PacketHandler : public proactor::Job {
-private:
-  Workbook * wb;
-  FILE * pktlog;
-  Cell * cell;
-public:
-  PacketHandler (Workbook * wb, FILE * pktlog) { 
-    this->wb = wb;
-    this->pktlog = pktlog;
-    this->cell = cell_new();
-  }
-  
-  virtual ~PacketHandler (void) {
-    cell->destroy (cell);
-  }
-
-  void * run (void * null) {
-    this->running = true;
-    Packet packet;
-    const char * p = NULL;
-
-    while (this->running == true)
-      {
-	while (this->inputQueue.size() > 0)
-	  {
-	    std::string buf = this->inputQueue.pop();
-	    p = buf.c_str();
-
-	    if (packet.parse (p) == FALSE)
-	      {
-		g_warning ("Failed parsing packet '%s'", buf.c_str());
-		::sleep (1);
-		continue;
-	      }
-
-	  switch (packet.getType())
-	    {
-	    default:
-	      g_warning ("Invaild packet line '%s'", buf.c_str());
-	      break;
-	    /* ^time^type^sheet_name^sheet_name^after */
-	  case Packet::TYPE_MOVESHEET:
-	    {
-	      if (packet.size() != 3)
-		{
-		  g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
-
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
-			 packet[0],
-			 (strcmp(packet[2], "0") == 0) ? "after" : "before",
-			 packet[1]);
-		  break;
-		}
-
-	      if (wb->move_sheet (wb, sheet,
-				  packet[1], 
-				  atoi (packet[2]))
-		  == FALSE)
-		{
-		  g_warning ("Failed moving sheet '%s'", packet[0]);
-		  break;
-		}
-	    }
-	    break;
-	    /* ^time^type^sheet_name^loadpath */
-	  case Packet::TYPE_LOADSHEET:
-	    {
-	      if (packet.size() != 2)
-		{
-		  g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
-
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Unable to load geometry file; sheet '%s'"
-			     " does not exist", packet[0]);
-		  break;
-		}
-	      
-	      sheet->load (sheet, packet[1]);
-	    }
-	    break;
-	    /* ^time^type^sheet_name^savepath */
-	  case Packet::TYPE_SAVESHEET:
-	    {
-	      if (packet.size() != 2)
-		{
-		  g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
-
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Failed saving sheet '%s'; does not exist",
-			     packet[0]);
-		  break;
-		}
-	      
-	      if (sheet->save (sheet, packet[1]) == FALSE)
-		{
-		  g_warning ("Unable to save sheet.");
-		  break;
-		}
-	    }
-	    break;
-	    /* ^time^type^sheet_name^position */
-	  case Packet::TYPE_MOVESHEETINDEX:
-	    {
-	      if (packet.size() != 2)
-		{
-		  g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
-			     "format: %s", buf.c_str());
-		  break;
-		}
-
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Failed moving sheet '%s' to %d:"
-			     " Does not exist", packet[0], atoi(packet[1]));
-		  break;
-		}
-	      
-	      if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) 
-		  == FALSE)
-		{
-		  g_warning ("Failed moving sheet '%s' to %d:"
-			     " Invaild index\n", packet[0], atoi(packet[1]));
-		}
-	    }
-	    break;
-	    /* ^time^type^sheet_name */
-	  case Packet::TYPE_REMSHEET:
-	    {
-	      if (packet.size() != 1)
-		{
-		  g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
-
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Failed removing sheet '%s':"
-			     " Does not exist", packet[0]);
-		  break;
-		}
-	      wb->remove_sheet (wb, sheet);
-	      sheet->destroy (sheet);
-	    }
-	    break;
-	    /* ^time^type^sheet_name^max_row^max_column */
-	  case Packet::TYPE_ADDSHEET:
-	    {
-	      if (packet.size() != 3)
-		{
-		  g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
-			     buf.c_str());
-		  break;
-		}
-
-	      wb->add_new_sheet (wb, 
-				 packet[0],
-				 atoi (packet[1]),
-				 atoi (packet[2]));
-	    }
-	    break;
-	    /* ^time^type^sheet_name^row^column^format^data */
-	  case Packet::TYPE_UPDATECELL:
-	    {
-	      if (packet.size() != 5)
-		{
-		  g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
-			     "format: %s", buf.c_str());
-		  break;
-		}
-
-	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
-
-	      if (IS_NULL (sheet))
-		{
-		  g_warning ("Invaild sheet name '%s': Does not exist",
-			     packet[0]);
-		  break;
-		}
-	            
-	      cell->set_row (cell, atoi (packet[1]) );
-	      cell->set_column (cell, atoi (packet[2]) );
-	      
-	      if (strlen (packet[3]) > 0)
-		{
-		  Map<String,String> fmt = packet.parseFormatString (packet[3]);
-		  
-		  if (fmt["bgcolor"].length() > 0)
-		    cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
-		  if (fmt["fgcolor"].length() > 0)
-		    cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
-		  if (fmt["justification"].length() > 0)
-		    cell->set_justification (cell, 
-					     (GtkJustification)
-					     atoi (fmt["justification"].c_str()));
-		}
-	      
-	      cell->set_value (cell, packet[4]);
-	      
-	      sheet->apply_cell (sheet, cell);
-	      
-	      g_message ("Cell (%d,%d) updated", cell->row, cell->column);
-	    }
-	    break;
-	  }
-	
-	  fprintf (pktlog, "%s\n", buf.c_str());
-	  fflush (pktlog);
-	  ::sleep (1);
-	  }
-	::sleep (1);
-      }
-
-    return NULL;
-  }
-};
-
-#endif
diff --git a/src/realtime/PacketParser.hpp b/src/realtime/PacketParser.hpp
new file mode 100644
index 0000000..c70f4b0
--- /dev/null
+++ b/src/realtime/PacketParser.hpp
@@ -0,0 +1,265 @@
+/* 
+   PacketParser.cpp - PacketParser Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
+#ifndef HPP_PACKETHANDLER
+#define HPP_PACKETHANDLER
+
+#include "proactor/Job.hpp"
+#include "Packet.hpp"
+#include <workbook/cell.h>
+#include <workbook/sheet.h>
+#include <workbook/workbook.h>
+
+class PacketParser : public proactor::Job {
+private:
+  Workbook * wb;
+  FILE * pktlog;
+  Cell * cell;
+public:
+  PacketParser (Workbook * wb, FILE * pktlog) { 
+    this->wb = wb;
+    this->pktlog = pktlog;
+    this->cell = cell_new();
+  }
+  
+  virtual ~PacketParser (void) {
+    cell->destroy (cell);
+  }
+
+  void * run (void * null) {
+    this->running = true;
+    Packet packet;
+    const char * p = NULL;
+
+    while (this->running == true)
+      {
+	while (this->inputQueue.size() > 0)
+	  {
+	    std::string buf = this->inputQueue.pop();
+	    p = buf.c_str();
+
+	    if (packet.parse (p) == FALSE)
+	      {
+		g_warning ("Failed parsing packet '%s'", buf.c_str());
+		::sleep (1);
+		continue;
+	      }
+
+	  switch (packet.getType())
+	    {
+	    default:
+	      g_warning ("Invaild packet line '%s'", buf.c_str());
+	      break;
+	    /* ^time^type^sheet_name^sheet_name^after */
+	  case Packet::TYPE_MOVESHEET:
+	    {
+	      if (packet.size() != 3)
+		{
+		  g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
+			 packet[0],
+			 (strcmp(packet[2], "0") == 0) ? "after" : "before",
+			 packet[1]);
+		  break;
+		}
+
+	      if (wb->move_sheet (wb, sheet,
+				  packet[1], 
+				  atoi (packet[2]))
+		  == FALSE)
+		{
+		  g_warning ("Failed moving sheet '%s'", packet[0]);
+		  break;
+		}
+	    }
+	    break;
+	    /* ^time^type^sheet_name^loadpath */
+	  case Packet::TYPE_LOADSHEET:
+	    {
+	      if (packet.size() != 2)
+		{
+		  g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Unable to load geometry file; sheet '%s'"
+			     " does not exist", packet[0]);
+		  break;
+		}
+	      
+	      sheet->load (sheet, packet[1]);
+	    }
+	    break;
+	    /* ^time^type^sheet_name^savepath */
+	  case Packet::TYPE_SAVESHEET:
+	    {
+	      if (packet.size() != 2)
+		{
+		  g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Failed saving sheet '%s'; does not exist",
+			     packet[0]);
+		  break;
+		}
+	      
+	      if (sheet->save (sheet, packet[1]) == FALSE)
+		{
+		  g_warning ("Unable to save sheet.");
+		  break;
+		}
+	    }
+	    break;
+	    /* ^time^type^sheet_name^position */
+	  case Packet::TYPE_MOVESHEETINDEX:
+	    {
+	      if (packet.size() != 2)
+		{
+		  g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
+			     "format: %s", buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Failed moving sheet '%s' to %d:"
+			     " Does not exist", packet[0], atoi(packet[1]));
+		  break;
+		}
+	      
+	      if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) 
+		  == FALSE)
+		{
+		  g_warning ("Failed moving sheet '%s' to %d:"
+			     " Invaild index\n", packet[0], atoi(packet[1]));
+		}
+	    }
+	    break;
+	    /* ^time^type^sheet_name */
+	  case Packet::TYPE_REMSHEET:
+	    {
+	      if (packet.size() != 1)
+		{
+		  g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Failed removing sheet '%s':"
+			     " Does not exist", packet[0]);
+		  break;
+		}
+	      wb->remove_sheet (wb, sheet);
+	      sheet->destroy (sheet);
+	    }
+	    break;
+	    /* ^time^type^sheet_name^max_row^max_column */
+	  case Packet::TYPE_ADDSHEET:
+	    {
+	      if (packet.size() != 3)
+		{
+		  g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      wb->add_new_sheet (wb, 
+				 packet[0],
+				 atoi (packet[1]),
+				 atoi (packet[2]));
+	    }
+	    break;
+	    /* ^time^type^sheet_name^row^column^format^data */
+	  case Packet::TYPE_UPDATECELL:
+	    {
+	      if (packet.size() != 5)
+		{
+		  g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
+			     "format: %s", buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Invaild sheet name '%s': Does not exist",
+			     packet[0]);
+		  break;
+		}
+	            
+	      cell->set_row (cell, atoi (packet[1]) );
+	      cell->set_column (cell, atoi (packet[2]) );
+	      
+	      if (strlen (packet[3]) > 0)
+		{
+		  Map<String,String> fmt = packet.parseFormatString (packet[3]);
+		  
+		  if (fmt["bgcolor"].length() > 0)
+		    cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
+		  if (fmt["fgcolor"].length() > 0)
+		    cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
+		  if (fmt["justification"].length() > 0)
+		    cell->set_justification (cell, 
+					     (GtkJustification)
+					     atoi (fmt["justification"].c_str()));
+		}
+	      
+	      cell->set_value (cell, packet[4]);
+	      
+	      sheet->apply_cell (sheet, cell);
+	      
+	      g_message ("Cell (%d,%d) updated", cell->row, cell->column);
+	    }
+	    break;
+	  }
+	
+	  fprintf (pktlog, "%s\n", buf.c_str());
+	  fflush (pktlog);
+	  ::sleep (1);
+	  }
+	::sleep (1);
+      }
+
+    return NULL;
+  }
+};
+
+#endif
diff --git a/src/realtime/concurrent/List.hpp b/src/realtime/concurrent/List.hpp
index 787e213..238405e 100755
--- a/src/realtime/concurrent/List.hpp
+++ b/src/realtime/concurrent/List.hpp
@@ -1,3 +1,23 @@
+/* 
+   List.hpp - Mutex List Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_CONCURRENT_LIST
 #define HPP_CONCURRENT_LIST
 
diff --git a/src/realtime/concurrent/Lockable.hpp b/src/realtime/concurrent/Lockable.hpp
index f67b796..f3226c0 100755
--- a/src/realtime/concurrent/Lockable.hpp
+++ b/src/realtime/concurrent/Lockable.hpp
@@ -1,3 +1,23 @@
+/* 
+   Lockable.hpp - Lockable Interface Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_LOCKABLE
 #define HPP_THREAD_LOCKABLE
 
diff --git a/src/realtime/concurrent/Map.hpp b/src/realtime/concurrent/Map.hpp
index 1aafb1e..9218f5c 100755
--- a/src/realtime/concurrent/Map.hpp
+++ b/src/realtime/concurrent/Map.hpp
@@ -1,3 +1,23 @@
+/* 
+   Map.hpp - Mutex Map Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_MAP
 #define HPP_THREAD_MAP
 
diff --git a/src/realtime/concurrent/Mutex.cpp b/src/realtime/concurrent/Mutex.cpp
index 90a4632..1708bc2 100755
--- a/src/realtime/concurrent/Mutex.cpp
+++ b/src/realtime/concurrent/Mutex.cpp
@@ -1,3 +1,23 @@
+/* 
+   Mutex.cpp - Mutex Object(s) Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Mutex.hpp"
 using namespace concurrent;
 
diff --git a/src/realtime/concurrent/Mutex.hpp b/src/realtime/concurrent/Mutex.hpp
index 1677359..4a30cda 100755
--- a/src/realtime/concurrent/Mutex.hpp
+++ b/src/realtime/concurrent/Mutex.hpp
@@ -1,3 +1,23 @@
+/* 
+   Mutex.hpp - Mutex Object(s) Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_MUTEX
 #define HPP_THREAD_MUTEX
 
diff --git a/src/realtime/concurrent/Queue.hpp b/src/realtime/concurrent/Queue.hpp
index 00eb11c..6922f4f 100755
--- a/src/realtime/concurrent/Queue.hpp
+++ b/src/realtime/concurrent/Queue.hpp
@@ -1,3 +1,23 @@
+/* 
+   Queue.hpp - Mutex Queue Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_QUEUE
 #define HPP_THREAD_QUEUE
 
diff --git a/src/realtime/concurrent/Runnable.hpp b/src/realtime/concurrent/Runnable.hpp
index 5c001c2..740a859 100755
--- a/src/realtime/concurrent/Runnable.hpp
+++ b/src/realtime/concurrent/Runnable.hpp
@@ -1,3 +1,23 @@
+/* 
+   Runnable.hpp - Runnable Interface Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_RUNNABLE
 #define HPP_THREAD_RUNNABLE
 
diff --git a/src/realtime/concurrent/Semaphore.cpp b/src/realtime/concurrent/Semaphore.cpp
index 49c7199..668dce1 100755
--- a/src/realtime/concurrent/Semaphore.cpp
+++ b/src/realtime/concurrent/Semaphore.cpp
@@ -1,3 +1,23 @@
+/* 
+   Semaphore.cpp - Semaphore Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Semaphore.hpp"
 using namespace concurrent;
 
diff --git a/src/realtime/concurrent/Semaphore.hpp b/src/realtime/concurrent/Semaphore.hpp
index 6c6b40b..e3504cf 100755
--- a/src/realtime/concurrent/Semaphore.hpp
+++ b/src/realtime/concurrent/Semaphore.hpp
@@ -1,3 +1,23 @@
+/* 
+   Semaphore.hpp - Semaphore Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_SEMAPHORE
 #define HPP_THREAD_SEMAPHORE
 
diff --git a/src/realtime/concurrent/Thread.cpp b/src/realtime/concurrent/Thread.cpp
index 5a6ee95..07e5721 100755
--- a/src/realtime/concurrent/Thread.cpp
+++ b/src/realtime/concurrent/Thread.cpp
@@ -1,3 +1,23 @@
+/* 
+   Thread.cpp - Thread Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Thread.hpp"
 #include "ThreadGroup.hpp"
 #include <iostream>
diff --git a/src/realtime/concurrent/Thread.hpp b/src/realtime/concurrent/Thread.hpp
index 4cfc510..bcc4b1b 100755
--- a/src/realtime/concurrent/Thread.hpp
+++ b/src/realtime/concurrent/Thread.hpp
@@ -1,3 +1,23 @@
+/* 
+   Thread.hpp - Thread Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_THREAD
 #define HPP_THREAD_THREAD
 
diff --git a/src/realtime/concurrent/ThreadGroup.hpp b/src/realtime/concurrent/ThreadGroup.hpp
index 5ac7df6..c42755f 100755
--- a/src/realtime/concurrent/ThreadGroup.hpp
+++ b/src/realtime/concurrent/ThreadGroup.hpp
@@ -1,3 +1,23 @@
+/* 
+   ThreadGroup.hpp - ThreadGroup Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_THREADGROUP
 #define HPP_THREAD_THREADGROUP
 
diff --git a/src/realtime/concurrent/ThreadPool.cpp b/src/realtime/concurrent/ThreadPool.cpp
index b4a0dcb..b9ffde2 100755
--- a/src/realtime/concurrent/ThreadPool.cpp
+++ b/src/realtime/concurrent/ThreadPool.cpp
@@ -1,3 +1,23 @@
+/* 
+   ThreadPool.cpp - ThreadPool Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "ThreadPool.hpp"
 using namespace concurrent;
 
diff --git a/src/realtime/concurrent/ThreadPool.hpp b/src/realtime/concurrent/ThreadPool.hpp
index 9930080..2e7ddd2 100755
--- a/src/realtime/concurrent/ThreadPool.hpp
+++ b/src/realtime/concurrent/ThreadPool.hpp
@@ -1,3 +1,23 @@
+/* 
+   ThreadPool.hpp - ThreadPool Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_THREAD_THREADPOOL
 #define HPP_THREAD_THREADPOOL
 
diff --git a/src/realtime/network/Socket.hpp b/src/realtime/network/Socket.hpp
index 7ef0fa3..ee0bf74 100755
--- a/src/realtime/network/Socket.hpp
+++ b/src/realtime/network/Socket.hpp
@@ -1,3 +1,23 @@
+/* 
+   Socket.hpp - Socket Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_NETWORK_SOCKET
 #define HPP_NETWORK_SOCKET
 
diff --git a/src/realtime/network/Tcp.cpp b/src/realtime/network/Tcp.cpp
index cd3c9b4..46ad9bd 100755
--- a/src/realtime/network/Tcp.cpp
+++ b/src/realtime/network/Tcp.cpp
@@ -1,3 +1,23 @@
+/* 
+   Tcp.hpp - Tcp Implementation Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Tcp.hpp"
 #include <iostream>
 #include <sys/types.h>
diff --git a/src/realtime/network/Tcp.hpp b/src/realtime/network/Tcp.hpp
index fade7df..e650c5b 100755
--- a/src/realtime/network/Tcp.hpp
+++ b/src/realtime/network/Tcp.hpp
@@ -1,3 +1,23 @@
+/* 
+   Tcp.hpp - Tcp Implementation Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_NETWORK_TCP
 #define HPP_NETWORK_TCP
 
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
index 4e958e0..4dff5c2 100755
--- a/src/realtime/plugin_main.cpp
+++ b/src/realtime/plugin_main.cpp
@@ -1,3 +1,23 @@
+/* 
+   plugin_main.cpp - Plugin DLL Entry Point
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include <iostream>
 #include <glib/gthread.h>
 #include <workbook/workbook.h>
diff --git a/src/realtime/proactor/Dispatcher.hpp b/src/realtime/proactor/Dispatcher.hpp
index 34604ac..39af130 100755
--- a/src/realtime/proactor/Dispatcher.hpp
+++ b/src/realtime/proactor/Dispatcher.hpp
@@ -1,3 +1,23 @@
+/* 
+   Dispatcher.hpp - Dispatcher Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_PROACTOR_DISPATCHER
 #define HPP_PROACTOR_DISPATCHER
 
diff --git a/src/realtime/proactor/Event.cpp b/src/realtime/proactor/Event.cpp
index d21d35b..a1cb9df 100755
--- a/src/realtime/proactor/Event.cpp
+++ b/src/realtime/proactor/Event.cpp
@@ -1,3 +1,23 @@
+/* 
+   Event.cpp - Event Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Event.hpp"
 using namespace proactor;
 
diff --git a/src/realtime/proactor/Event.hpp b/src/realtime/proactor/Event.hpp
index 2680276..d856114 100755
--- a/src/realtime/proactor/Event.hpp
+++ b/src/realtime/proactor/Event.hpp
@@ -1,3 +1,23 @@
+/* 
+   Event.hpp - Event Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_PROACTOR_EVENT
 #define HPP_PROACTOR_EVENT
 
diff --git a/src/realtime/proactor/Job.hpp b/src/realtime/proactor/Job.hpp
index adaf5b0..189cb6a 100755
--- a/src/realtime/proactor/Job.hpp
+++ b/src/realtime/proactor/Job.hpp
@@ -1,3 +1,23 @@
+/* 
+   Job.hpp - Job Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_PROACTOR_JOB
 #define HPP_PROACTOR_JOB
 
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
index 1d30f58..12dc34d 100755
--- a/src/realtime/proactor/Proactor.cpp
+++ b/src/realtime/proactor/Proactor.cpp
@@ -1,3 +1,23 @@
+/* 
+   Proactor.cpp - Proactor Object Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include "Proactor.hpp"
 #include <iostream>
 using namespace proactor;
diff --git a/src/realtime/proactor/Proactor.hpp b/src/realtime/proactor/Proactor.hpp
index d47e8ca..0039971 100755
--- a/src/realtime/proactor/Proactor.hpp
+++ b/src/realtime/proactor/Proactor.hpp
@@ -1,3 +1,23 @@
+/* 
+   Proactor.hpp - Proactor Object Header File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #ifndef HPP_PROACTOR_PROACTOR
 #define HPP_PROACTOR_PROACTOR
 
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
index 4d4df9f..e0ea03d 100755
--- a/src/realtime/thread_main.cpp
+++ b/src/realtime/thread_main.cpp
@@ -1,3 +1,23 @@
+/* 
+   thread_main.cpp - Plugin Main Thread Source File
+
+   The GTKWorkbook Project <http://gtkworkbook.sourceforge.net/>
+   Copyright (C) 2008, 2009 John Bellone, Jr. <jvb4@njit.edu>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PRACTICAL PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the library; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+*/
 #include <workbook/workbook.h>
 #include <config/config.h>
 #include <sys/stat.h>
@@ -12,7 +32,7 @@
 #include "proactor/Proactor.hpp"
 #include "proactor/Event.hpp"
 #include "AcceptThread.hpp"
-#include "PacketHandler.hpp"
+#include "PacketParser.hpp"
 #include "Packet.hpp"
 
 /* @description: This method creates a filename with the prefix supplied and
@@ -82,11 +102,11 @@ thread_main (ThreadArgs * args) {
       return;
     }
 
-  PacketHandler handler (wb, pktlog);
+  PacketParser handler (wb, pktlog);
   proactor.registerHandler (e, &handler);
   if (handler.start() == false) 
     {
-      g_critical ("Failed starting PacketHandler; exiting thread.");
+      g_critical ("Failed starting PacketParser; exiting thread.");
       return;
     }
   

commit 2157ff40e8f1052481114c256beeceae011fd956
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Thu Apr 2 02:14:23 2009 +0000

    Added directories for build and .gtkworkbook
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@3 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/.gtkworkbook b/.gtkworkbook
new file mode 100644
index 0000000..73223a7
--- /dev/null
+++ b/.gtkworkbook
@@ -0,0 +1,5 @@
+INSLIBDIR=/home/jbellone/gtkworkbook/lib
+INSBINDIR=/home/jbellone/gtkworkbook/bin
+INSEXTDIR=/home/jbellone/gtkworkbook/lib/gtkcsv
+PROJDIR=/home/jbellone/work/gtkworkbook
+SYSINSPATH=/home/jbellone
diff --git a/Makefile.base b/Makefile.base
index 7c44f17..5316eb5 100755
--- a/Makefile.base
+++ b/Makefile.base
@@ -8,13 +8,13 @@ CP=-cp
 
 # These directories below are changed based upon where you want
 # to INSTALL the files to. They are only copied to on `make install` 
-INSLIBDIR=${shell /bin/sed -n '/^INSLIBDIR/s/.*=//p' ~/.gtkcsv}
-INSBINDIR=${shell /bin/sed -n '/^INSBINDIR/s/.*=//p' ~/.gtkcsv}
-INSEXTDIR=${shell /bin/sed -n '/^INSEXTDIR/s/.*=//p' ~/.gtkcsv}
+INSLIBDIR=${shell /bin/sed -n '/^INSLIBDIR/s/.*=//p' ~/.gtkworkbook}
+INSBINDIR=${shell /bin/sed -n '/^INSBINDIR/s/.*=//p' ~/.gtkworkbook}
+INSEXTDIR=${shell /bin/sed -n '/^INSEXTDIR/s/.*=//p' ~/.gtkworkbook}
 
 # These are the project directories and dependency directories.
-PROJDIR=${shell /bin/sed -n '/^PROJDIR/s/.*=//p' ~/.gtkcsv}
-SYSINSPATH=${shell /bin/sed -n '/^SYSINSPATH/s/.*=//p' ~/.gtkcsv}
+PROJDIR=${shell /bin/sed -n '/^PROJDIR/s/.*=//p' ~/.gtkworkbook}
+SYSINSPATH=${shell /bin/sed -n '/^SYSINSPATH/s/.*=//p' ~/.gtkworkbook}
 LIBDIR=${SYSINSPATH}/lib
 INCDIR=${SYSINSPATH}/include
 OBJDIR=${PROJDIR}/OBJS

commit 88e12df3ebe8e53971ae6132ca3b10f108f60e18
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Thu Apr 2 02:06:27 2009 +0000

    Added Makefile for <src> directory.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@2 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/src/Makefile b/src/Makefile
new file mode 100755
index 0000000..4120977
--- /dev/null
+++ b/src/Makefile
@@ -0,0 +1,34 @@
+include ../Makefile.base
+
+SRCS=$(wildcard *.c)
+OBJS=$(patsubst %.c,${OBJDIR}/%.o,${SRCS})
+
+LFLAGS=-lworkbook -lconfig -lgtkextra-x11-2.0 -lgthread-2.0
+
+all: 	gtkcsv
+	make -C realtime/ all
+#	make -C basic/ all
+#	make -C csv/ all
+
+gtkcsv: ${OBJS}
+	${CC} -o ${PROJDIR}/bin/gtkcsv ${OBJS} ${LIBS} ${LFLAGS}
+
+clean:		
+	${MD} ${OBJDIR}	
+	${RM} ${OBJS} ${INSBINDIR}/gtkcsv
+	make -C realtime/ clean
+#	make -C basic/ clean
+#	make -C csv/ clean
+
+install: all
+	${MD} ${INSBINDIR}
+	${CP} ${PROJDIR}/bin/gtkcsv ${INSBINDIR}/gtkcsv
+	make -C realtime/ install
+#	make -C basic/ install
+#	make -C csv/ install
+
+${OBJDIR}/%.o: %.c
+	${CC} ${INCS} -c ${CCFLAGS} $< -o $@
+
+.c.o:
+	${CC} ${INCS} -c ${CCFLAGS} $<

commit 73fe2ae7d05638c15688c041aa7cc2a52bdfec5d
Author: j_bellone <j_bellone@2d834452-db39-49f7-84f1-2edcd6a33ad8>
Date:   Thu Apr 2 00:56:43 2009 +0000

    Added initial code setup to repository.
    
    git-svn-id: https://gtkworkbook.svn.sourceforge.net/svnroot/gtkworkbook/trunk@1 2d834452-db39-49f7-84f1-2edcd6a33ad8

diff --git a/Makefile b/Makefile
new file mode 100755
index 0000000..9fc2f02
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,27 @@
+MD=mkdir -p
+MAKE=-make -C
+PWD=`pwd`
+
+all:	libconfig libworkbook gtkcsv
+
+libconfig:
+	${MD} OBJS/libconfig
+	${MAKE} config/ all
+
+libworkbook:
+	${MD} OBJS/libworkbook
+	${MAKE} workbook/ all
+
+gtkcsv:
+	${MD} OBJS/realtime
+	$(MAKE) src/ all
+
+clean:
+	$(MAKE) config/ clean
+	${MAKE} workbook/ clean
+	$(MAKE) src/ clean
+
+install: all
+	$(MAKE) config/ install
+	${MAKE} workbook/ install
+	${MAKE} src/ install
diff --git a/Makefile.base b/Makefile.base
new file mode 100755
index 0000000..7c44f17
--- /dev/null
+++ b/Makefile.base
@@ -0,0 +1,37 @@
+CC=gcc
+CX=g++
+RM=-rm -f
+MD=-mkdir -p
+LN=-ln
+AR=-ar
+CP=-cp
+
+# These directories below are changed based upon where you want
+# to INSTALL the files to. They are only copied to on `make install` 
+INSLIBDIR=${shell /bin/sed -n '/^INSLIBDIR/s/.*=//p' ~/.gtkcsv}
+INSBINDIR=${shell /bin/sed -n '/^INSBINDIR/s/.*=//p' ~/.gtkcsv}
+INSEXTDIR=${shell /bin/sed -n '/^INSEXTDIR/s/.*=//p' ~/.gtkcsv}
+
+# These are the project directories and dependency directories.
+PROJDIR=${shell /bin/sed -n '/^PROJDIR/s/.*=//p' ~/.gtkcsv}
+SYSINSPATH=${shell /bin/sed -n '/^SYSINSPATH/s/.*=//p' ~/.gtkcsv}
+LIBDIR=${SYSINSPATH}/lib
+INCDIR=${SYSINSPATH}/include
+OBJDIR=${PROJDIR}/OBJS
+
+LD_LIBRARY_PATH=${PROJDIR}/lib:${LIBDIR}
+export LD_LIBRARY_PATH
+
+INCS = -I${INCDIR}/gtkextra-2.0
+INCS += -I${PROJDIR}/include
+INCS += `pkg-config gtk+-2.0 glib-2.0 --cflags`
+
+LIBS = -lpixman-1
+LIBS += -L${PROJDIR}/lib
+LIBS += -Wl,-rpath ${PROJDIR}/lib
+LIBS += -L${LIBDIR}
+LIBS += -Wl,-rpath ${LIBDIR}
+LIBS += `pkg-config gtk+-2.0 glib-2.0 --libs`
+
+CCFLAGS=-g -O0 -std=c99 -Wall -pthread
+CXFLAGS=-g -O0 -Wall
\ No newline at end of file
diff --git a/bin/application.cfg b/bin/application.cfg
new file mode 100755
index 0000000..167539a
--- /dev/null
+++ b/bin/application.cfg
@@ -0,0 +1,20 @@
+%block application {
+	load :: extensions=realtime,basic,csv;
+}
+%block realtime
+{
+	onLoad :: run=1;
+	linux :: filename=realtime.so;
+	log :: path=/home/johnb;
+	tcp :: port=8888;
+}
+%block basic
+{
+	onLoad :: run=0;
+	linux :: filename=basic.so;
+}
+%block csv
+{
+	onLoad :: run=0;
+	linux :: filename=csv.so;
+}
\ No newline at end of file
diff --git a/bin/config.cfg b/bin/config.cfg
new file mode 100755
index 0000000..848374b
--- /dev/null
+++ b/bin/config.cfg
@@ -0,0 +1,13 @@
+%block param {
+	row :: key = value;
+}
+%block param
+{
+	glb :: batch = 1; iterations = 4; opt=1;msglatency=1;
+	GLB1 :: somevec = a,b,c;
+}
+
+%block config {
+	row :: vector = 1,2,3; key=value;
+	row :: key=value; key=value2;
+}
\ No newline at end of file
diff --git a/bin/test.txt b/bin/test.txt
new file mode 100755
index 0000000..fefa4fd
--- /dev/null
+++ b/bin/test.txt
@@ -0,0 +1,12 @@
+^1^1^sheet0^100^10
+^2^sheet0^3^2^bgcolor=red,fgcolor=white^First
+^3^sheet0^4^6^bgcolor=blue,fgcolor=white^Second
+^4^1^sheet1^100^10
+^5^1^sheet2^100^10
+^6^1^sheet3^100^10
+^7^0^sheet1^3^2^bgcolor=red,fgcolor=white^First
+^8^sheet1^4^6^bgcolor=blue,fgcolor=white^Second
+^9^0^sheet2^3^2^bgcolor=red,fgcolor=white^First
+^10^0^sheet2^4^6^bgcolor=blue,fgcolor=white^Second
+^11^2^sheet1
+^12^3^sheet3^0
diff --git a/config/INIFile.c b/config/INIFile.c
new file mode 100644
index 0000000..5580e3a
--- /dev/null
+++ b/config/INIFile.c
@@ -0,0 +1,409 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#include "parse.h"
+#include <config/INIFile.h>
+#include <string.h>
+
+/* INIFile.c (static) */
+static INIFile *inifile_object_init (const gchar *);
+static INISection *inisection_object_init (INIFile *, const gchar *);
+static INIPair *inipair_object_init (INISection *,
+				     const gchar *,
+				     const gchar *,
+				     gint);
+static void inifile_object_free (INIFile *);
+static void inisection_object_free (INISection *);
+static void inipair_object_free (INIPair *);
+static gboolean inifile_method_open (INIFile *);
+static gboolean inifile_method_save (INIFile *, const gchar *);
+static gboolean inifile_method_load (INIFile *, FILE *);
+static void inifile_method_destroy (INIFile *);
+static INISection *inifile_method_get_section (INIFile *, const gchar *);
+static INIPair *inifile_method_get_pair (INIFile *, 
+					 const gchar *, 
+					 const gchar *);
+static const gchar *inifile_method_get_value (INIFile *,
+					      const gchar *,
+					      const gchar *);
+static const gchar *inisection_method_get_value (INISection *,
+						 const gchar *);
+static INIPair *inisection_method_get_pair (INISection *, const gchar *);
+static void inisection_method_destroy (INISection *);
+static void inisection_method_add_pair (INISection *,
+					gint, 
+					const gchar *,
+					const gchar *);
+static void inipair_method_destroy (INIPair *);
+
+INIFile *inifile_new (const gchar * filename)
+{
+  return inifile_object_init (filename);
+}
+
+INISection *inisection_new (INIFile * ini, const gchar * section)
+{
+  return inisection_object_init (ini, section);
+}
+
+INIPair *inipair_new (INISection * section, 
+		      const gchar * key, 
+		      const gchar * value,
+		      gint line)
+{
+  return inipair_object_init (section, key, value, line);
+}
+
+static INIFile *
+inifile_object_init (const gchar * filename)
+{
+  if (!IS_NULLSTR (filename))
+    return NULL;
+
+  INIFile * ini = NEW (INIFile);
+
+  /* Members */
+  ini->filename = g_strdup (filename);
+
+  /* Methods */
+  ini->open = inifile_method_open;
+  ini->save = inifile_method_save;
+  ini->load = inifile_method_load;
+  ini->destroy = inifile_method_destroy;
+  ini->getSection = inifile_method_get_section;
+  ini->getPair = inifile_method_get_pair;
+  ini->getValue = inifile_method_get_value;
+
+  return ini;
+}
+
+static void
+inifile_object_free (INIFile *ini)
+{
+  ASSERT (ini != NULL);
+
+  FREE (ini);
+}
+
+static void
+inifile_method_destroy (INIFile *ini)
+{
+  ASSERT (ini != NULL);
+
+  inifile_object_free (ini);
+}
+
+static gboolean
+inifile_method_save (INIFile * ini, const gchar * filename)
+{
+  ASSERT (ini != NULL);
+
+  if (IS_NULLSTR (filename))
+    return FALSE;
+
+  return TRUE; 
+}
+
+static gboolean
+inifile_method_open (INIFile * ini)
+{
+  ASSERT (ini != NULL);
+
+  if (IS_NULLSTR (ini->filename))
+    return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (ini->filename, "r")) == NULL)
+    {
+      fprintf (stderr, "Failed opening INIFile '%s'\n", ini->filename);
+      fflush (stderr);
+      return FALSE;
+    }
+
+  if (ini->load (ini, fp) == FALSE)
+    {
+      fprintf (stderr, "Failed loading INIFile '%s'\n", ini->filename);
+      fflush (stderr);
+      FCLOSE (fp);
+      return FALSE;
+    }
+  FCLOSE (fp);
+  return TRUE;
+}
+
+static gboolean
+inifile_method_load (INIFile * ini, FILE * fp)
+{
+  ASSERT (ini != NULL);
+
+  if (IS_NULL (fp))
+    return FALSE;
+
+  gint line = 0;
+  INISection *section = NULL;
+  gchar buf[4096], key[1024], value[1024];
+  gchar * p = NULL;
+
+  do
+    {
+      p = buf;
+
+      if (IS_NULLSTR (p) || feof (fp))
+	break;
+      /* As per the INI file format a semicolon is considered a line block
+	 comment. This continues until there is a newline character. */
+      else if (*p == ';')
+	{
+	  p = munch (p);
+	  continue;
+	}
+      /* [section] */
+      else if (*p == '[') 
+	{
+	  if ((p = parse (p+1, &buf[0], 1024, ']')) == NULL)
+	    {
+	      fprintf (stderr, "Error parsing block '%s'\n", p);
+	      fflush (stderr);
+	      return FALSE;
+	    }
+
+	  section = inisection_new (ini, key);
+	}
+      /* We do not care about these characters at all. Move on to the next. */
+      else if ((*p == ']') || (*p == '\t') || (*p == '\r'))
+	{
+	  p++;					
+	  continue;
+	}
+      else if (*p == '\n')
+	{
+	  line++;
+	  p++;
+	  continue;
+	}
+
+      /* We do not suppor any type of "global" key->value pairs. There must
+	 a section associated with a pair. */
+      if (IS_NULL (section))
+	{
+	  fprintf (stderr, "Error parsing file on line %d; please check"
+		   " file integrity\n", line);
+	  fflush (stderr);
+	  return FALSE;
+	}
+
+      /* Key = Value\n */
+      if ((p = parse (p, &key[0], 1024, '=')) == NULL)
+	{
+	  fprintf (stderr, "Error parsing section %s: key->value at line %d\n",
+		   section->title, line);
+	  fflush (stderr);
+	  return FALSE;
+	}
+
+      if ((p = parse (p+1, &value[0], 1024, '\n')) == NULL)
+	{
+	  fprintf (stderr, "Error parsing section %s: %s->value at line %d\n",
+		   section->title, key, line);
+	  fflush (stderr);
+	  return FALSE;
+	}
+      
+      section->addPair (section, line, key, value);
+
+      line++;
+    } while (fgets (buf, 4096, fp) != NULL);
+  return TRUE;
+}
+
+static INISection *
+inifile_method_get_section (INIFile * ini, const gchar * section)
+{
+  ASSERT (ini != NULL);
+
+  if (!IS_NULLSTR (section))
+    {
+      ITERATE_BEGIN (INISection, ini->section_head);
+      {
+	if (strcmp (section, it->title) == 0)
+	  return it;
+      }
+      ITERATE_END();
+    }
+  return NULL;
+}
+
+static INIPair *
+inifile_method_get_pair (INIFile * ini, 
+			 const gchar * section,
+			 const gchar * key)
+{
+  ASSERT (ini != NULL);
+
+  if (!IS_NULLSTR (section) && !IS_NULLSTR (key))
+    {
+      INISection * s = ini->getSection (ini, section);
+      if (s == NULL)
+	return NULL;
+
+      return s->getPair (s, key);
+
+    }
+  return NULL;
+}
+
+static const gchar *
+inifile_method_get_value (INIFile * ini,
+			  const gchar * section,
+			  const gchar * key)
+{
+  ASSERT (ini != NULL);
+
+  if (!IS_NULLSTR (section) && !IS_NULLSTR (key))
+    {
+      INISection * s = ini->getSection (ini, section);
+      if (s == NULL)
+	return NULL;
+
+      return s->getValue (s, key);
+    }
+  return NULL;
+}
+
+static void
+inisection_object_free (INISection * section)
+{
+  ASSERT (section != NULL);
+
+  DESTROY (INIPair, section->pair_head);
+
+  FREE (section->title);
+  FREE (section);
+}
+
+static INISection *
+inisection_object_init (INIFile * ini, const gchar * section)
+{
+  ASSERT (ini != NULL);
+
+  if (IS_NULLSTR (section))
+    return NULL;
+
+  INISection * s = ini->getSection (ini, section);
+  if (IS_NULL (s))
+    {
+      s = NEW (INISection);
+      
+      /* Members */
+      s->ini = ini;
+      s->next = NULL;
+      s->pair_head = NULL;
+      s->pair_count = 0;
+      s->title = g_strdup ("");
+      
+      /* Methods */
+      s->addPair = inisection_method_add_pair;
+      s->getValue = inisection_method_get_value;
+      s->getPair = inisection_method_get_pair;
+      s->destroy = inisection_method_destroy;
+    }
+  return s;
+}
+
+static const gchar *
+inisection_method_get_value (INISection * section, const gchar * key)
+{
+  ASSERT (section != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ITERATE_BEGIN (INIPair, section->pair_head);
+      {
+	if (strcmp (key, it->key) == 0)
+	  return it->value;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static INIPair *
+inisection_method_get_pair (INISection * section, const gchar * key)
+{
+  ASSERT (section != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ITERATE_BEGIN (INIPair, section->pair_head);
+      {
+	if (strcmp (key, it->key) == 0)
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static void
+inisection_method_add_pair (INISection * section,
+			    gint line,
+			    const gchar * key,
+			    const gchar * value)
+{
+  ASSERT (section != NULL);
+  
+  if (!IS_NULLSTR (key) && !IS_NULLSTR (value))
+    {
+      INIPair * pair = inipair_new (section, key, value, line);
+      SINGLE_LINK (INIPair, section->pair_head, section->pair_tail, pair);
+    }
+}
+
+static void
+inisection_method_destroy (INISection * section)
+{
+  ASSERT (section != NULL);
+
+  DESTROY (INIPair, section->pair_head);
+  
+  inisection_object_free (section);
+}
+
+static INIPair *
+inipair_object_init (INISection * section, 
+		     const gchar * key,
+		     const gchar * value,
+		     gint line)
+{
+  ASSERT (section != NULL);
+
+  if (IS_NULLSTR (key) || IS_NULLSTR (value))
+    return NULL;
+
+  INIPair * pair = section->getPair (section, key);
+  if (IS_NULL (pair))
+    {
+      pair = NEW (INIPair);
+      
+      /* Members */
+      pair->section = section;
+      pair->next = NULL;
+      pair->key = g_strdup (key);
+      pair->value = g_strdup (value);
+      pair->line = line;
+
+      /* Methods */
+      pair->destroy = inipair_method_destroy;
+    }
+  return pair;
+}
+
+static void
+inipair_method_destroy (INIPair * pair)
+{
+  inipair_object_free (pair);
+}
+
+static void
+inipair_object_free (INIPair * pair)
+{
+  ASSERT (pair != NULL);
+}
diff --git a/config/Makefile b/config/Makefile
new file mode 100755
index 0000000..bb46529
--- /dev/null
+++ b/config/Makefile
@@ -0,0 +1,32 @@
+include ../Makefile.base
+
+SRCS=$(wildcard *.c)
+OBJS=$(patsubst %.c,${OBJDIR}/libconfig/%.o,${SRCS})
+
+LFLAGS = -lgobject-2.0 -ldl
+
+all: 	libconfig
+
+install:
+	${RM} ${INSLIBDIR}/libconfig.a ${INSLIBDIR}/libconfig.so \
+	${INSLIBDIR}/libconfig.so.1
+	${CP} ${PROJDIR}/lib/libconfig.so ${INSLIBDIR}/libconfig.so.1
+	${LN} ${INSLIBDIR}/libconfig.so.1 ${INSLIBDIR}/libconfig.a
+	${LN} ${INSLIBDIR}/libconfig.a ${INSLIBDIR}/libconfig.so
+#	chcon -t textrel_shlib_t ${INSLIBDIR}/libconfig.so.1	
+
+libconfig: ${OBJS}
+	${RM} ${PROJDIR}/lib/libconfig.so.1
+	${CC} -shared -Wl,-soname,libconfig.so.1 \
+	-o ${PROJDIR}/lib/libconfig.so ${OBJS} ${LIBS} ${LFLAGS}
+	${LN} ${PROJDIR}/lib/libconfig.so ${PROJDIR}/lib/libconfig.so.1
+
+clean:		
+	${MD} ${OBJDIR}/libconfig	
+	${RM} ${OBJS} ${PROJDIR}/lib/libconfig.so.1
+
+${OBJDIR}/libconfig/%.o: %.c
+	${CC} ${INCS} -c -fPIC ${CCFLAGS} $< -o $@
+
+.c.o:
+	${CC} ${INCS} -c -fPIC ${CCFLAGS} $<
diff --git a/config/config.c b/config/config.c
new file mode 100755
index 0000000..48b5b06
--- /dev/null
+++ b/config/config.c
@@ -0,0 +1,739 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#include <config/config.h>
+#include <stdlib.h>
+#include <string.h>
+#include "parse.h"
+
+/* config.c (static) */
+
+static Config *config_object_init (const gchar *);
+static ConfigPair *configpair_object_init (ConfigRow *, 
+					   const gchar *,
+					   const gchar *);
+static ConfigRow *configrow_object_init (ConfigBlock *, const gchar *);
+static ConfigBlock *configblock_object_init (Config *, const gchar *);
+static ConfigVector *configvector_object_init (ConfigRow *,const gchar *);
+static void configrow_object_free (ConfigRow *);
+static void configblock_object_free (ConfigBlock *);
+static void configpair_object_free (ConfigPair *);
+static void config_object_free (Config *);
+static void configvector_object_free (ConfigVector *);
+static ConfigVector *config_method_get_vector (Config *,
+					       const gchar *,
+					       const gchar *,
+					       const gchar *);
+static ConfigPair *config_method_get_pair (Config *,
+					   const gchar *,
+					   const gchar *,
+					   const gchar *);
+static ConfigBlock *config_method_get_block (Config *, const gchar *);
+static ConfigPair *configblock_method_get_pair (ConfigBlock *, 
+						const gchar *,
+						const gchar *);
+static ConfigRow *config_method_get_row (Config *,
+					 const gchar *, 
+					 const gchar *);
+static ConfigRow *configblock_method_get_row (ConfigBlock *, const gchar *);
+static gchar *configrow_method_parse (ConfigRow *, gchar *);
+static void configrow_method_destroy (ConfigRow *);
+static ConfigPair *configrow_method_get_pair (ConfigRow *, const gchar *);
+static ConfigVector *configrow_method_get_vector (ConfigRow *, const gchar *);
+static void configpair_method_destroy (ConfigPair *);
+static void configblock_method_destroy (ConfigBlock *);
+static void configvector_method_destroy (ConfigVector *);
+static gint configvector_method_get_int (ConfigVector *, gint);
+static gchar *configvector_method_get (ConfigVector *, gint);
+static void configvector_method_add (ConfigVector *, const gchar *);
+static gchar *configblock_method_parse (ConfigBlock *, gchar *, FILE *);
+static void config_method_destroy (Config *);
+static gint config_method_open (Config *);
+static gint config_method_save (Config *, const gchar *);
+static gint config_method_load (Config *, FILE *);
+
+ConfigBlock *
+configblock_new (Config * c, const gchar * tag)
+{
+  /* No NULL tags. */
+  if (IS_NULLSTR (tag)) return NULL;
+  return configblock_object_init (c, tag);
+}
+
+static gchar *
+configblock_method_parse (ConfigBlock * block, gchar * p, FILE * fp)
+{
+  ASSERT (block != NULL);
+  ASSERT (p != NULL);
+
+  if (!fp || feof (fp)) return FALSE;
+
+  gchar buf[1024], word[1024];
+  gchar * q = NULL;
+  g_stpcpy (buf, p);
+
+  /* This block of code makes sure that we indeed have an opening brace
+    to continue with parsing of the configuration file. */
+  do
+    {
+      p = buf;
+      
+      if (EXPECT (p, q, '{'))
+	{
+	  g_stpcpy (buf, q+1);
+	  break;
+	} 
+
+      if (*q == '\0')
+	continue;
+      return NULL;
+    } while (fgets (buf, 1024, fp) != NULL);
+
+  /* Start actually parsing rows now. */
+  do 
+    {
+      p = buf;
+      do
+	{
+	  if (*p == '}')
+	    return p;
+	  else if (*p == '\n')
+	    {
+	      p++;
+	      continue;
+	    }
+	  else 
+	    {
+	      if ((q = parse (p, &word[0], 1024, ':')) != NULL)
+		{
+		  if (*(q+1) == ':')
+		    {
+		      ConfigRow * row 
+			= block->get_row (block, trim (&word[0]));
+		      
+		      if (row)
+			{
+			  fprintf (stderr, "**CONFIG**: row '%s' already"
+				   " defined in block '%s'; replacing\n",
+				   row->tag, block->tag);
+			  fflush (stderr);
+
+			  row->destroy (row);
+			}
+
+		      row = configrow_new (block, trim (&word[0]));
+		    
+		      if ((p = row->parse (row, q+2)) == NULL)
+			{
+			  fprintf (stderr, "Error parsing line: %s", buf);
+			  fflush (stderr);
+			  return NULL;
+			}
+		      break;
+		    }
+		}
+	    }
+	  fprintf (stderr, "Error in formatting on line: %s\n", buf);
+	  fflush (stderr);
+	  return NULL;
+	} while (*p != '\0');
+     } while (fgets (buf, 1024, fp) != NULL);
+  return NULL;
+}
+
+static void
+configblock_method_destroy (ConfigBlock * block)
+{
+  ASSERT (block != NULL);
+
+  DESTROY (ConfigRow, block->row_head);
+  SINGLE_UNLINK (ConfigBlock, block->cfg->block_head, 
+		 block->cfg->block_tail, block);
+  
+  configblock_object_free (block);
+}
+
+static ConfigRow *
+configblock_method_get_row (ConfigBlock * block, const gchar * row)
+{
+  ASSERT (block != NULL);
+
+  if (!IS_NULLSTR (row))
+    {
+      ITERATE_BEGIN (ConfigRow, block->row_head);
+      {
+	if (!strcmp (it->tag, row))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static ConfigPair *
+configblock_method_get_pair (ConfigBlock * block, 
+			     const gchar * row,
+			     const gchar * key)
+{
+  ASSERT (block != NULL);
+
+  if (!IS_NULLSTR (row))
+    {
+      ITERATE_BEGIN (ConfigRow, block->row_head);
+      {
+	if (!strcmp (it->tag, row))
+	  return it->get_pair (it, key);
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static void
+configblock_object_free (ConfigBlock * block)
+{
+  ASSERT (block != NULL);
+
+  FREE (block->tag);
+  
+  FREE (block);
+  block = NULL;
+}
+
+static ConfigBlock *
+configblock_object_init (Config * c, const gchar * tag)
+{
+  ASSERT (c != NULL);
+
+  ConfigBlock * b = NEW (ConfigBlock);
+
+  /* Members */
+  b->cfg = c;
+  b->tag = g_strdup (tag);
+  b->next = NULL; 
+  b->row_head = b->row_tail = NULL;
+  
+  /* Methods */
+  b->parse = configblock_method_parse;
+  b->destroy = configblock_method_destroy;
+  b->get_row = configblock_method_get_row;
+  b->get_pair = configblock_method_get_pair;
+
+  SINGLE_LINK (ConfigBlock, c->block_head, c->block_tail, b);
+  return b;
+}
+
+Config *
+config_new (const gchar * filename)
+{
+  return config_object_init (filename);
+}
+
+static void
+config_method_destroy (Config * c)
+{
+  ASSERT (c != NULL);
+
+  DESTROY (ConfigBlock, c->block_head);
+  
+  config_object_free (c);
+}
+
+static ConfigRow *
+config_method_get_row (Config * cfg, const gchar * block, const gchar * row)
+{
+  ASSERT (cfg != NULL);
+ 
+  ConfigBlock * b = cfg->get_block (cfg, block);
+  if (b == NULL)
+    return NULL;
+  return b->get_row (b, row);
+}
+
+static ConfigBlock *
+config_method_get_block (Config * cfg, const gchar * block)
+{
+  ASSERT (cfg != NULL);
+
+  if (!IS_NULLSTR (block))
+    {
+      ITERATE_BEGIN (ConfigBlock, cfg->block_head);
+      {
+	if (!strcmp (it->tag, block))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+  return NULL;
+}
+
+static ConfigPair *
+config_method_get_pair (Config * cfg, 
+			const gchar * block, 
+			const gchar * row,
+			const gchar * pair)
+{
+  ASSERT (cfg != NULL);
+
+  ConfigRow * r = cfg->get_row (cfg, block, row);
+  if (r == NULL)
+    return NULL;
+  return r->get_pair (r, pair);
+}
+
+static ConfigVector *
+config_method_get_vector (Config * cfg,
+			  const gchar * block,
+			  const gchar * row,
+			  const gchar * vector)
+{
+  ASSERT (cfg != NULL);
+  
+  ConfigRow * r = cfg->get_row (cfg, block, row);
+  if (r == NULL)
+    return NULL;
+  return r->get_vector (r, vector);
+}
+
+static void
+config_object_free (Config * c)
+{
+  ASSERT (c != NULL);
+
+  FREE (c->filename);
+
+  FREE (c);
+  c = NULL;
+}
+
+static Config *
+config_object_init (const gchar * filename)
+{
+  Config * c = NEW (Config);
+
+  /* Members */
+  c->filename = (!IS_NULLSTR (filename)) ? g_strdup (filename) : g_strdup ("");
+  c->block_head = c->block_tail = NULL;
+
+  /* Methods */
+  c->open = config_method_open;
+  c->save = config_method_save;
+  c->load = config_method_load;
+  c->close = config_method_destroy;
+  c->get_vector = config_method_get_vector;
+  c->get_row = config_method_get_row;
+  c->get_block = config_method_get_block;
+  c->get_pair = config_method_get_pair;
+
+  return c;
+}
+
+static gint
+config_method_load (Config * c, FILE * fp)
+{
+  ASSERT (c != NULL);
+  
+  if (!fp || feof(fp))
+    {
+      /* STUB: log me? */
+      return FALSE;
+    }
+
+  gchar buf[1024], word[1024];
+  gchar * p = NULL, * q = NULL;
+
+  while (fgets (buf, 1024, fp) != NULL)
+    {
+      p = buf;
+
+      while ((*p != '\0') && (*p != '\n'))
+	{
+	  if (*p == '%')
+	    {
+	      if ((q = parse (p+1, &word[0], 1024, ' ')) == NULL)
+		{
+		  /* STUB: exit parsing with a failure. */
+		  return FALSE;
+		}
+
+	      if (strcmp (word, "block") == 0)
+		{
+		  if ((q = parse (q+1, &word[0], 1024, ' ')) == NULL)
+		    {
+		      return FALSE;
+		    }
+		  
+		  /* Replace the block if it already exists. Throw error. */
+		  ConfigBlock * b = c->get_block (c, trim (&word[0]));
+		  if (b)
+		    {
+		      fprintf (stderr, "**CONFIG**: block '%s' already"
+			       "exists. Destroying and replacing.\n", b->tag);
+		      fflush (stderr);
+		      b->destroy (b);
+		    }
+
+		  b = configblock_new (c, trim (&word[0]));
+
+		  if ((p = b->parse (b, q, fp)) == NULL)
+		    {
+		      return FALSE;
+		    }
+		}
+	      else if (strcmp (word, "include") == 0)
+		{
+		  if ((p = parse (q+1, &word[0], 1024, ' ')) == NULL)
+		    {
+		      return FALSE;
+		    }
+
+		  /* Include the file; we're going to load up this file
+		     first and then proceed with parsing. */
+		  FILE * ifp = NULL;
+		 
+		  if ((ifp = fopen (trim (&word[0]), "r")) == NULL)
+		    {
+		      fprintf (stderr, "**CONFIG**: include '%s' does not"
+			       " seem to exist or unable to read.\n",
+			       word);
+		      fflush (stderr);
+		      continue;
+		    }
+
+		  c->load (c, ifp);
+		}
+	      else
+		return FALSE;
+	    }
+	  /* BUGFIX: Need to check for tabs. */
+	  else if ((*p != ' ') && (*p != '\t'))
+	    {
+	      /* STUB: error out */
+	      return FALSE;
+	    }
+
+	  if (*p == '\0')
+	    break;
+	  p++;
+	}
+    }
+  return TRUE;
+}
+
+static gint
+config_method_save (Config * c, const gchar * filename)
+{
+  ASSERT (c != NULL);
+
+  if (IS_NULLSTR (filename)) return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (filename, "w")) == NULL)
+    {
+      /* STUB: log me? */
+      return FALSE;
+    }
+  
+  FCLOSE (fp);
+  return TRUE;
+}
+
+static gint
+config_method_open (Config * c)
+{
+  ASSERT (c != NULL);
+
+  if (IS_NULLSTR (c->filename)) return FALSE;
+
+  FILE * fp = NULL;
+  if ((fp = fopen (c->filename, "r")) == NULL)
+    {
+      /* STUB: log this? */
+      return FALSE;
+    }
+
+  gint result = c->load (c, fp);
+  if (result == FALSE)
+    {
+      /* STUB: log me? */
+    }
+
+  FCLOSE (fp);
+  return result;
+}
+
+ConfigPair *
+configpair_new (ConfigRow * row, const gchar * key, const gchar * value)
+{
+  return configpair_object_init (row, key, value);
+}
+
+static ConfigPair *
+configpair_object_init (ConfigRow * row, 
+			const gchar * key,
+			const gchar * value)
+{
+  ASSERT (row != NULL);
+  ASSERT (!IS_NULLSTR (key));
+  
+  ConfigPair * pair = NEW (ConfigPair);
+
+  /* Members */
+  pair->row = row;
+  pair->key = g_strdup (key);
+  pair->next = NULL;
+  pair->value = (!IS_NULLSTR (value)) ? g_strdup (value) : g_strdup ("");
+ 
+  /* Methods */
+  pair->destroy = configpair_method_destroy;
+  
+  DOUBLE_LINK (row->pair_head, row->pair_tail, pair);
+  return pair;
+}
+
+static void
+configpair_method_destroy (ConfigPair * pair)
+{
+  ASSERT (pair != NULL);
+
+  DOUBLE_UNLINK (pair);
+
+  configpair_object_free (pair);
+}
+
+static void
+configpair_object_free (ConfigPair * pair)
+{
+  ASSERT (pair != NULL);
+
+  FREE (pair->key);
+  FREE (pair->value);
+  FREE (pair);
+}
+
+ConfigRow *
+configrow_new (ConfigBlock * block, const gchar * tag)
+{
+  return configrow_object_init (block, tag);
+}
+
+static ConfigRow *
+configrow_object_init (ConfigBlock * block, const gchar * tag)
+{
+  if (IS_NULLSTR (tag)) return NULL;
+
+  ConfigRow * row = NEW (ConfigRow);
+  
+  /* Members */
+  row->block = block;
+  row->tag = g_strdup (tag);
+  row->next = NULL;
+  row->vector_head = row->vector_tail = NULL;
+  row->pair_head = row->pair_tail = NULL;
+
+  /* Methods */
+  row->parse = configrow_method_parse;
+  row->destroy = configrow_method_destroy;
+  row->get_pair = configrow_method_get_pair;
+  row->get_vector = configrow_method_get_vector;
+
+  SINGLE_LINK (ConfigRow, block->row_head, block->row_tail, row);
+  return row;
+}
+
+static void
+configrow_object_free (ConfigRow *row)
+{
+  ASSERT (row != NULL);
+  
+  FREE (row->tag);
+
+  DESTROY (ConfigPair, row->pair_head);
+  DESTROY (ConfigVector, row->vector_head);
+
+  FREE (row);
+}
+
+static ConfigPair *
+configrow_method_get_pair (ConfigRow * row, const gchar * key)
+{
+  ASSERT (row != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ITERATE_BEGIN (ConfigPair, row->pair_head);
+      {
+	if (!strcmp (it->key, key))
+	  return it;
+      }
+      ITERATE_END();
+    }
+  return NULL;
+}
+
+static ConfigVector *
+configrow_method_get_vector (ConfigRow * row, const gchar * key)
+{
+  ASSERT (row != NULL);
+
+  if (!IS_NULLSTR (key))
+    {
+      ConfigPair * pair = row->get_pair (row, key);
+      if (IS_NULL (pair))
+	return NULL;
+
+      /* If we have already parsed it there is no reason to do it 
+	 a second time. Check existing linked list and return the
+	 pointer if we have already allocated it. */
+      ITERATE_BEGIN (ConfigVector, row->vector_head);
+      {
+	if (!strcmp (it->tag, key))
+	  return it;
+      }
+      ITERATE_END();
+
+      ConfigVector * vec = configvector_new (row, pair->key);
+      gchar buf[1024];
+      gchar * p = parse (pair->value, &buf[0], 1024, ','); 
+      gchar * q = pair->value + strlen (pair->value);
+    
+      do
+	{
+	  vec->add (vec, trim (&buf[0]));
+	} while ((p = parse (p+1, &buf[0], 1024, ',')) < q);
+
+      return vec;
+    }
+  return NULL;
+}
+
+static gchar *
+configrow_method_parse (ConfigRow * row, gchar * p)
+{
+  ASSERT (row != NULL);
+  ASSERT (p != NULL);
+
+  gchar key[1024], value[1024];
+  gchar * q = NULL, * s = NULL;
+
+  do
+    {
+      if ((q = parse (p, &key[0], 1024, '=')) == NULL)
+	{
+	  break;
+	}      
+
+      if ((s = parse (q+1, &value[0], 1024, ';')) != NULL)
+	{
+	  ConfigPair * pair = row->get_pair (row, trim (&key[0]));
+	  if (pair)
+	    {
+	      fprintf (stderr, "**CONFIG**: pair '%s:%s' already defined in"
+		       " row '%s' block '%s'; replacing\n",
+		       pair->key, pair->value, row->tag, row->block->tag);
+	      fflush (stderr);
+	      pair->destroy (pair);
+	    }
+
+	  pair = configpair_new (row, trim (&key[0]), trim (&value[0]));
+	}
+      p = s + 1;
+    } while (*p != '\n' && *p != '}' && *p != '\0');
+  return p;
+}
+
+static void 
+configrow_method_destroy (ConfigRow * row)
+{
+   ASSERT (row != NULL);
+
+   SINGLE_UNLINK (ConfigRow, row->block->row_head, row->block->row_tail, row);
+
+  configrow_object_free (row);
+}
+
+ConfigVector *
+configvector_new (ConfigRow * row, const gchar * tag)
+{
+  ASSERT (row != NULL);
+
+  /* No NULL Tags. */
+  if (IS_NULLSTR (tag)) return NULL;
+  return configvector_object_init (row, tag);
+}
+
+static ConfigVector *
+configvector_object_init (ConfigRow * row, const gchar * tag)
+{
+  ASSERT (row != NULL);
+
+  ConfigVector * vec = NEW (ConfigVector);
+
+  /* Members */
+  vec->row = row;
+  vec->tag = g_strdup (tag);
+  vec->next = vec->prev = NULL;
+  vec->array = g_ptr_array_sized_new (7);
+
+  /* Methods */
+  vec->destroy = configvector_method_destroy;
+  vec->get_int = configvector_method_get_int;
+  vec->get = configvector_method_get;
+  vec->add = configvector_method_add;
+
+  DOUBLE_LINK (row->vector_head, row->vector_tail, vec);
+  return vec;
+}
+
+static void 
+configvector_object_free (ConfigVector * vec)
+{
+  ASSERT (vec != NULL);
+
+  FREE (vec->tag);
+
+  if (vec->array != NULL)
+    g_ptr_array_free (vec->array, TRUE);
+
+  FREE (vec);
+}
+
+static void
+configvector_method_destroy (ConfigVector * vec)
+{
+  ASSERT (vec != NULL);
+
+  DOUBLE_UNLINK (vec);
+
+  configvector_object_free (vec);
+}
+
+static gchar *
+configvector_method_get (ConfigVector * vec, gint index)
+{
+  ASSERT (vec != NULL);
+
+  if (index >= vec->array->len) return NULL;
+
+  gchar * rvalue = g_ptr_array_index (vec->array, index);
+  return rvalue;
+}
+
+static gint
+configvector_method_get_int (ConfigVector * vec, gint index)
+{
+  ASSERT (vec != NULL);
+
+  if (index >= vec->array->len) return -1;
+
+  gchar * rvalue = g_ptr_array_index (vec->array, index);
+  return atoi (rvalue);
+}
+
+static void
+configvector_method_add (ConfigVector * vec, const gchar * value)
+{
+  ASSERT (vec != NULL);
+  ASSERT (value != NULL);
+
+  gchar * ptr = g_strdup (value);
+  g_ptr_array_add (vec->array, ptr);
+}
diff --git a/config/parse.c b/config/parse.c
new file mode 100644
index 0000000..1181950
--- /dev/null
+++ b/config/parse.c
@@ -0,0 +1,59 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#include "parse.h"
+#include <string.h>
+#include <stdlib.h>
+
+gchar *
+munch (gchar *p)
+{
+  ASSERT (p != NULL);
+  
+  /* Munch whitespace and ignore newlines, tabs. */
+  while (p && (*p == ' ' || *p == '\n' || *p == '\t')) { p++; } 
+  return p;
+}
+
+gchar *
+parse (gchar *p, gchar *word, gint n, const gchar delim)
+{
+  const gchar *q = p;
+  gint length = 0, ii = 0;
+
+  do 
+    {
+      if (*p == delim)
+	break;
+      p++;
+    } while (p && (*p != '\0') && (*p != '\n'));
+
+  length = (gint)(p - q);
+
+  if (n < length)    return NULL;
+
+  for (ii = 0; ii < length; ii++)
+    word[ii] = q[ii];
+  word[ii] = '\0';
+
+  return p;
+}
+
+gchar *
+trim (gchar *p)
+{
+  ASSERT (p != NULL);
+
+  gchar *q = NULL;
+
+  /* Eliminate tabs and spaces from beginning. */
+  while (p && (*p == ' ' || *p == '\t')) p++;
+
+  q = p;
+
+  /* Eliminate newlines, returns and whitespaces from end. */
+  while (*q != '\0') { q++; }
+  q--;
+  while (*q == ' ' || *q == '\n' || *q == '\r') { q--; }
+  *(q+1) = '\0';
+
+  return p;
+}
diff --git a/config/parse.h b/config/parse.h
new file mode 100644
index 0000000..0866e4d
--- /dev/null
+++ b/config/parse.h
@@ -0,0 +1,14 @@
+#ifndef H_PARSE
+#define H_PARSE
+
+#include <glib.h>
+#include <shared.h>
+
+#define EXPECT(p,q,d) (*(q = munch (p)) == d)
+
+/* parse.c */
+extern gchar *munch (gchar *p);
+extern gchar *parse (gchar *p, gchar *word, gint n, const gchar delim);
+extern gchar *trim (gchar *p);
+
+#endif
diff --git a/include/config/INIFile.h b/include/config/INIFile.h
new file mode 100644
index 0000000..3c24dd6
--- /dev/null
+++ b/include/config/INIFile.h
@@ -0,0 +1,76 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_INIFILE
+#define H_INIFILE
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _INIFile INIFile;
+typedef struct _INISection INISection;
+typedef struct _INIPair INIPair;
+
+#include <shared.h>
+
+struct _INIPair
+{
+  /* Members */
+  INISection *section;
+  INIPair *next;
+  gchar *key;
+  gchar *value;
+  gint line;
+
+  /* Methods */
+  void (*destroy) (INIPair *pair);
+};
+
+struct _INISection
+{
+  /* Members */
+  INIFile *ini;
+  INISection *next;
+  INIPair *pair_head;
+  INIPair *pair_tail;
+  gint pair_count;
+  gchar *title;
+  
+  /* Methods */
+  const gchar *(*getValue) (INISection *section, const gchar *key);
+  INIPair *(*getPair) (INISection *section, const gchar *key);
+  void (*destroy) (INISection *section);
+  void (*addPair) (INISection *section, 
+		   gint line, 
+		   const gchar *key,
+		   const gchar *value);
+};
+
+struct _INIFile
+{
+  /* Members */
+  INISection *section_head;
+  INISection *section_tail;
+  gchar *filename;
+
+  /* Methods */
+  gboolean (*open) (INIFile *);
+  gboolean (*save) (INIFile *, const gchar *);
+  gboolean (*load) (INIFile *, FILE *);
+  void (*destroy) (INIFile *);
+  INISection *(*getSection) (INIFile *ini, const gchar *section);
+  INIPair *(*getPair) (INIFile *ini, const gchar *section, const gchar *key);
+  const gchar *(*getValue) (INIFile *ini, 
+			   const gchar *section, 
+			   const gchar *key); 
+};
+
+/* INIFile.c */
+INIFile *inifile_new (const gchar *filename);
+INISection *inisection_new (INIFile *ini, const gchar *section);
+INIPair *inipair_new (INISection *section, 
+		      const gchar *key, 
+		      const gchar *value,
+		      gint line);
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_INIFILE*/
diff --git a/include/config/config.h b/include/config/config.h
new file mode 100755
index 0000000..d1414c4
--- /dev/null
+++ b/include/config/config.h
@@ -0,0 +1,115 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_CONFIG
+#define H_CONFIG
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _Config Config;
+typedef struct _ConfigBlock ConfigBlock;
+typedef struct _ConfigRow ConfigRow;
+typedef struct _ConfigPair ConfigPair;
+typedef struct _ConfigVector ConfigVector;
+
+#include <shared.h>
+#include <stdlib.h>
+
+struct _ConfigPair
+{
+  /* Members */
+  ConfigRow * row;
+  ConfigPair * next;
+  ConfigPair * prev;
+  gchar * key;
+  gchar * value;
+
+  /* Methods */
+  void (*destroy) (ConfigPair *);
+};
+
+struct _ConfigVector
+{
+  /* Members */
+  ConfigRow * row;
+  ConfigVector * next;
+  ConfigVector * prev;
+  GPtrArray * array;
+  gchar * tag;
+
+  /* Methods */
+  void (*add) (ConfigVector *, const gchar *);
+  gint (*get_int) (ConfigVector *, gint);
+  gchar *(*get) (ConfigVector *, gint);
+  void (*destroy) (ConfigVector *);
+};
+
+struct _ConfigRow
+{
+  /* Members */
+  ConfigBlock * block;
+  ConfigRow * next;
+  ConfigVector * vector_head;
+  ConfigVector * vector_tail;
+  ConfigPair * pair_head;
+  ConfigPair * pair_tail;
+  gchar * tag;
+
+  /* Methods */
+  ConfigPair *(*get_pair) (ConfigRow *, const gchar *);
+  ConfigVector *(*get_vector) (ConfigRow *, const gchar *);
+  gchar *(*parse) (ConfigRow *, gchar *);
+  void (*destroy) (ConfigRow *);
+};
+
+struct _ConfigBlock
+{
+  /* Members */
+  ConfigBlock * next;
+  Config * cfg;
+  ConfigRow * row_head;
+  ConfigRow * row_tail;
+  gchar * tag;
+
+  /* Methods */
+  gchar *(*parse) (ConfigBlock *, gchar *, FILE *);
+  void (*destroy) (ConfigBlock *);
+  ConfigRow *(*get_row) (ConfigBlock *, const gchar *);
+  ConfigPair *(*get_pair) (ConfigBlock *, const gchar *, const gchar *);
+};
+
+struct _Config
+{
+  /* Members */
+  gchar * filename;
+  ConfigBlock * block_head;
+  ConfigBlock * block_tail;
+
+  /* Methods */
+  gint (*open) (Config *);
+  gint (*save) (Config *, const gchar *);
+  gint (*load) (Config *, FILE *);
+  void (*close) (Config *);
+  ConfigVector *(*get_vector) (Config *,
+			       const gchar *,
+			       const gchar *,
+			       const gchar *);
+  ConfigPair *(*get_pair) (Config *, 
+			   const gchar *, 
+			   const gchar *, 
+			   const gchar *);
+  ConfigBlock *(*get_block) (Config *, 
+			     const gchar *);
+  ConfigRow *(*get_row) (Config *, const gchar *, const gchar *);
+};
+
+/* config.c */
+ConfigBlock *configblock_new (Config *, const gchar *);
+Config *config_new (const gchar *);
+ConfigRow *configrow_new (ConfigBlock *, const gchar *);
+ConfigPair *configpair_new (ConfigRow *, const gchar *, const gchar *);
+ConfigVector *configvector_new (ConfigRow *, const gchar *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_CONFIG*/
diff --git a/include/shared.h b/include/shared.h
new file mode 100755
index 0000000..09b81f3
--- /dev/null
+++ b/include/shared.h
@@ -0,0 +1,94 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_SHARED
+#define H_SHARED
+
+#include <glib.h> 
+#include <stdio.h>
+
+#define ASSERT(c) g_assert(c)
+#define FREE(p) { if (p) { g_free (p); p = NULL; } }
+#define NEW(T) g_malloc (sizeof (T))
+#define NEW_ARRAY(T,n) g_malloc (sizeof(T)*n))
+
+#define IS_NULLSTR(s) (!s || (*s == '\0'))
+#define IS_NULL(p) (p == NULL)
+
+#define FCLOSE(fp) { if (fp != NULL) { fflush(fp); fclose(fp); fp = NULL; } }
+#define PCLOSE(fp) { if (fp != NULL) { pclose(fp); fp = NULL; } }
+
+#define ITERATE_BEGIN(TYPE, head) if (head) {		\
+    TYPE *it = NULL, *next = head;			\
+    do { it = next; next = it->next;	
+
+#define ITERATE_END() } while (next); }
+
+#define DESTROY(TYPE, head) if (head) {		   \
+    TYPE *next = head, *item = NULL;		   \
+    do { item = next; next = item->next;	   \
+      item->destroy (item); item = NULL;	   \
+    } while (next);				   \
+  }
+
+#define SINGLE_LINK(TYPE, head, tail, item) if (tail) {		\
+    tail->next = item; tail = item;				\
+  } else if (head) {						\
+    TYPE *next = head, *prev = NULL;				\
+    do { prev = next; next = prev->next; } while (next);	\
+    prev->next = item; tail = item;				\
+  } else { head = item; }
+
+#define SINGLE_UNLINK(TYPE, head, tail, item) if (item == head) { \
+    head = item->next;						  \
+  } else { TYPE *next = head->next, *prev = NULL;		  \
+    while (next) { prev = next; next = prev->next;		  \
+      if (next == item) break; }				  \
+    prev->next = item->next; }
+
+#define UNLINK_OBJECT(current) if (current && current->next && current->prev) \
+    {									\
+      current->prev->next = current->next;				\
+      current->next->prev = current->prev;				\
+      current->next = NULL;						\
+      current->prev = NULL;						\
+    }									\
+  else if (current && current->next)					\
+    {									\
+      current->next->prev = NULL;					\
+      current->next = NULL;						\
+    }									\
+  else if (current && current->prev)					\
+    {									\
+      current->prev->next = NULL;					\
+      current->prev = NULL;						\
+    }
+
+#define LINK_OBJECT(first, last, current) if (!first)	\
+    {							\
+      first = current;					\
+      last = NULL;					\
+      current->next = NULL;				\
+      current->prev = NULL;				\
+    }							\
+  else							\
+    {							\
+      if (!last)					\
+        {						\
+          last = current;				\
+          current->next = NULL;				\
+          current->prev = first;			\
+          first->next = current;			\
+          first->prev = NULL;				\
+        }						\
+      else						\
+        {						\
+          current->prev = last;				\
+	  current->next = NULL;				\
+	  last->next = current;				\
+          last = current;				\
+        }						\
+    }
+
+#define DOUBLE_LINK(head, tail, item) LINK_OBJECT(head, tail, item)
+#define DOUBLE_UNLINK(item) UNLINK_OBJECT(item)
+
+#endif /*H_SHARED*/
diff --git a/include/workbook/cell.h b/include/workbook/cell.h
new file mode 100644
index 0000000..bc63237
--- /dev/null
+++ b/include/workbook/cell.h
@@ -0,0 +1,75 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_CELL
+#define H_CELL
+
+#include <shared.h>
+#include <gtkextra/gtkextra.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  typedef struct _Cell Cell;
+  typedef struct _CellAttributes CellAttributes;
+
+  #include "sheet.h"
+
+  /*
+    @description: These objects will evolve as more uses are found for it. 
+    Right now it provides as an intermediate abstraction for the cell 
+    information of a GtkSheetEntry. It works in conjunction with the Sheet 
+    object (the Sheet object performs all the gtk_sheet_* functions). 
+
+    If you decide to manually set any of the members be sure:
+    a. For single cell changes row and column ranges must equal each other
+       because GtkSheet does not provide interfaces for all operations to
+       be done on single cell.
+    b. Keep in mind that this object was built with the ability to dump a whole
+       array of changes into a Sheet with a single call. This was built for 
+       simple brute forcing of cell additions (and changes).
+    c. If you find yourself adding a lot of code to this object then it may
+       be time to add a new object to libworkbook. It was meant to be simple.
+
+    If you decide to use gtk_sheet_* calls:
+    a. Do not add them to any methods inside of this object. This object does
+       not (and should not) contain any locking procedures. All the locking for
+       threading should be done in the Sheet object (where all gtk+ calls 
+       should be performed). 
+  */
+  struct _CellAttributes
+  {
+    GString * bgcolor;
+    GString * fgcolor;
+    GtkJustification justification;
+  };
+
+  struct _Cell
+  {
+    /* Members */
+    Sheet * sheet;
+    Cell * next;
+    GString * value;
+    CellAttributes attributes;
+    GtkSheetRange range;
+    gint row, column;
+    
+    /* Methods */
+    void (*set) (Cell * cell, gint row, gint column, const gchar * value);
+    void (*set_value) (Cell * cell, const gchar * value);  
+    void (*set_column) (Cell * cell, gint column);
+    void (*set_row) (Cell * cell, gint row);
+    void (*set_range) (Cell * cell, const GtkSheetRange * range);
+    void (*set_justification) (Cell * cell, GtkJustification justification);
+    void (*set_fgcolor) (Cell * cell, const gchar * color);
+    void (*set_bgcolor) (Cell * cell, const gchar * color);
+    void (*set_attributes) (Cell * cell, const CellAttributes * attrib);
+    void (*destroy) (Cell * cell);
+  };
+
+  /* cell.c */
+  Cell *cell_new (void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_CELL*/
diff --git a/include/workbook/sheet.h b/include/workbook/sheet.h
new file mode 100644
index 0000000..09d54e4
--- /dev/null
+++ b/include/workbook/sheet.h
@@ -0,0 +1,73 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_SHEET
+#define H_SHEET
+
+#include <shared.h>
+#include <gtk/gtk.h>
+#include <gtkextra/gtksheet.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define GEOMETRY_FILE_VERSION 0x000001
+
+typedef struct _Sheet Sheet;
+
+#include "workbook.h"
+#include "cell.h"
+
+  /*
+    @description: This object abstracts away all of the calls to the native
+    GtkSheet methods. It is meant to be used with the Cell object(s).
+    
+    Please keep the following in mind:
+    a. All calls to gtk_* methods should be performed in here and not inside of
+       a cell object. 
+    b. All calls to gtk_* methods should be performed inside of a lock, e.g. 
+       you should always use gdk_threads_enter and gtk_threads_exit. Any calls
+       outside of the window (main) thread will usually result in problems if
+       you do not get a mutex. 
+  */
+  struct _Sheet
+  {
+    /* Members */
+    Sheet * next;
+    Sheet * prev;
+    gchar * name;
+    Workbook * workbook;
+    GtkWidget * gtk_label;
+    GtkWidget * gtk_sheet;
+    GtkWidget * gtk_box;
+    gint page;
+    gint attention;
+    gint notices;
+    gboolean has_focus;
+
+    /* Methods */
+    void (*destroy) (Sheet *);
+    void (*set_attention) (Sheet *, gint);
+    void (*apply_range) (Sheet *, 
+			 const GtkSheetRange *, 
+			 const CellAttributes *);
+    void (*apply_array) (Sheet *, const Cell **, gint);
+    void (*apply_cell) (Sheet *, const Cell *);
+
+    void (*set_cell) (Sheet *, gint, gint, const gchar *);  
+    void (*range_set_background) (Sheet *, 
+				  const GtkSheetRange *, 
+				  const gchar *);
+    void (*range_set_foreground) (Sheet *, 
+				  const GtkSheetRange *,
+				  const gchar *);
+    gboolean (*save) (Sheet *, const gchar *);
+    gboolean (*load) (Sheet *, const gchar *);
+  };
+
+  /* sheet.c */
+  Sheet *sheet_new (Workbook *, const gchar *, gint, gint);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_SHEET*/
diff --git a/include/workbook/workbook.h b/include/workbook/workbook.h
new file mode 100644
index 0000000..df23774
--- /dev/null
+++ b/include/workbook/workbook.h
@@ -0,0 +1,52 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_WORKBOOK
+#define H_WORKBOOK
+
+#include <shared.h>
+#include <gtk/gtk.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  enum
+    {
+      SIG_WORKBOOK_CHANGED = 0,
+      /**/
+      MAX_WORKBOOK_SIGNALS
+    };
+
+  typedef struct _Workbook Workbook;
+
+#include "sheet.h"
+
+  struct _Workbook
+  {
+    /* Members */
+    GSourceFunc signals[MAX_WORKBOOK_SIGNALS];
+    Sheet * sheet_first;
+    Sheet * sheet_last;
+    Sheet * focus_sheet;
+    Workbook * next;
+    Workbook * prev;  
+    GtkWidget * gtk_notebook;
+    GtkWidget * gtk_window;
+    GtkWidget * gtk_box;
+    gchar * filename;
+
+    /* Methods */
+    void (*destroy) (Workbook *);
+    Sheet *(*add_new_sheet) (Workbook *, const gchar *, gint, gint);
+    Sheet *(*get_sheet) (Workbook *, const gchar *);
+    void (*remove_sheet) (Workbook *, Sheet *);
+    gboolean (*move_sheet_index) (Workbook *, Sheet *, gint);
+    gboolean (*move_sheet) (Workbook *, Sheet *, const gchar *, gboolean); 
+  };
+
+  /* workbook.c */
+  Workbook *workbook_open (GtkWidget *, const gchar *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*H_WORKBOOK*/
diff --git a/src/application.c b/src/application.c
new file mode 100644
index 0000000..da44dfc
--- /dev/null
+++ b/src/application.c
@@ -0,0 +1,489 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#include "application.h"
+#include "plugin.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <string.h>
+#include <glib/gthread.h>
+
+/* application.c (static) */
+static int application_method_run (ApplicationState *);
+static guint application_signal_delete_event (GtkWindow *,
+					      GdkEvent *, 
+					      gpointer);
+static guint application_signal_destroy_event (GtkWidget *, gpointer);
+static void application_method_close (ApplicationState *);
+static ApplicationState* application_object_free (ApplicationState *);
+static ApplicationState* application_object_init (void);
+static Plugin* application_method_loadplugin (ApplicationState *, 
+					      const gchar *);
+static void application_method_openextension (ApplicationState *,
+					      const gchar *,
+					      gboolean);
+static guint application_signal_gtknotebook_switchpage (GtkNotebook *,
+							GtkNotebookPage *,
+							gint,
+							Workbook *);
+static guint application_signal_gtknotebook_removed (GtkNotebook *,
+						     GtkNotebookPage *,
+						     gint,
+						     Workbook *);
+static guint application_signal_gtknotebook_reordered (GtkNotebook *,
+						       GtkNotebookPage *,
+						       gint,
+						       Workbook *);
+static guint application_signal_gtksheet_changed (GtkWidget *,
+						  gint, gint,
+						  Sheet *);
+
+/* @description: This method takes the argument and clears the string of
+   everything except for the directories. Therefore the return value would
+   be a string sans anything before the last directory delimiter '/'. */
+static gchar *
+munchpath (gchar * path_)
+{
+  gchar * path = g_strdup(path_);
+  path = g_strreverse (path);
+  gchar * p = path;
+
+  while (p && (*p != '\0')) { if (*p == '/') break; p++; }
+
+  gchar * str = g_strdup (p);
+  str = g_strreverse (str);
+  FREE (path);
+  return str;
+}
+
+/* @description: This method creates and returns a new initialized 
+   ApplicationState object. This should only be performed once.
+   @argc: The argument count (passed in from commandline).
+   @argv: The argument pointer to string array. */
+ApplicationState *
+application_init (int * argc, char *** argv)
+{
+  if (!g_thread_supported ())
+    {
+      g_thread_init (NULL);
+      gdk_threads_init ();
+    }
+
+  ApplicationState * appstate = application_object_init ();
+  int c;
+
+  appstate->absolute_path = munchpath (*argv[0]);
+
+  /* This block parses the commandline for options. A better example on how
+     this code works can be found on the GNU website at the following URI:
+     http://gnu.org/software/libtool/manual/libc/Using-Getopt.html */
+  while ((c = getopt (*argc, *argv, "c:")) != -1)
+    {
+      switch (c)
+	{
+	case 'c':
+	  {
+	    Config * cfg = config_new (optarg);
+	    if (!cfg)
+	      {
+		g_critical ("Failed loading configuration file '%s';" 
+			    " which was specified with -c argument\n", optarg);
+		exit (0);
+		break;
+	      }
+	    appstate->cfg = cfg;
+	  }
+	  break;
+
+	case '?':
+	  {
+	    if (optopt == 'c')
+	      {
+		g_warning ("Option -c requires an argument in order to load"
+			   " a configuration file\n");
+	      }
+	  }
+	  break;
+	}
+    }
+
+  gdk_threads_enter ();
+  gtk_init (argc, argv);
+
+  /* Create the window and connect two callback to the signals. */
+  appstate->gtk_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
+		      "destroy",
+		      G_CALLBACK (appstate->signals[SIG_DESTROY_EVENT]),
+		      NULL);
+  gtk_signal_connect (GTK_OBJECT (appstate->gtk_window),
+		      "delete_event",
+		      G_CALLBACK (appstate->signals[SIG_DELETE_EVENT]),
+		      NULL);
+  
+  /* Set the initial size of the application; we could load this
+     from a configuration file eventually. */
+  gtk_widget_set_usize (appstate->gtk_window, 1024, 768);
+  
+  /* Attach the window box to the window and present to the screen. */
+  GtkWidget * window_box = gtk_vbox_new (FALSE, 1);
+  gtk_container_add (GTK_CONTAINER (appstate->gtk_window), window_box);
+  appstate->gtk_window_vbox = window_box;
+  
+  gtk_widget_show_all (appstate->gtk_window);
+ 
+  gdk_threads_leave ();
+  return appstate;
+}
+
+/* @description: This method destroys the application state object.
+   @appstate: The pointer to the object to destroy. */
+static void
+application_method_close (ApplicationState *appstate)
+{
+  ASSERT (appstate != NULL);
+
+  DESTROY (Workbook, appstate->workbook_first);
+
+  /* This has to be set so that we have a sentinel variable in separate threads
+     if there is a better way to do this than it should be changed inside of
+     the plugins that use these pointers to check if the object is still
+     allocated. */
+  appstate->workbook_first = appstate->workbook_last = NULL;
+
+  /* Because of a change to the Plugin architecture it will now yield until
+     all threads that were instatiated are closed properly. We use the 
+     appstate->workbook_first variable in order to test for NULL. */
+  DESTROY (Plugin, appstate->plugin_first);
+
+  appstate->plugin_first = appstate->plugin_last = NULL;
+  
+  application_object_free (appstate);
+}
+
+static guint
+application_signal_gtknotebook_removed (GtkNotebook * notebook,
+					GtkNotebookPage * page,
+					gint page_num,
+					Workbook * wb)
+{
+  ASSERT (wb != NULL);
+
+  return TRUE;
+}
+
+static guint
+application_signal_gtknotebook_reordered (GtkNotebook * notebook,
+					  GtkNotebookPage * page,
+					  gint page_num,
+					  Workbook * wb)
+{
+  ASSERT (wb != NULL);
+
+  return TRUE;
+}
+
+/* @description: This is the callback for the GtkNotebook 'switch-page' 
+   signal. It is called every single time a user *clicks* on different
+   tab. This method is called *before* the drawing takes place.
+
+   This method iterates through the Sheets and updates where neccesary.
+
+   @notebook: This is a pointer to the notebook object. The object is
+   equal to the Workbook->gtk_notebook pointer.
+   @page:
+   @page_num: The number of the *new* page.
+   @book: The Workbook object associated with the GtkNotebook.*/
+static guint
+application_signal_gtknotebook_switchpage (GtkNotebook * notebook,
+					   GtkNotebookPage * page,
+					   gint page_num,
+					   Workbook * book)
+{
+  ASSERT (book != NULL);
+
+  /* Perform the "unfocus" on the old notebook tab. */
+  if (!IS_NULL (book->focus_sheet))
+    {
+      book->focus_sheet->has_focus = FALSE;
+      book->focus_sheet->notices = 0;
+    }
+
+  GtkWidget * widget = gtk_notebook_get_nth_page (notebook, page_num);
+
+  ITERATE_BEGIN (Sheet, book->sheet_first);
+  {
+    /* Once we find the right Sheet object we can perform what we need
+       to in order to change the "focus." Finally, set book pointer. */
+    if (it->gtk_box == widget)
+      {
+	it->page = page_num;
+	it->has_focus = TRUE;
+	it->notices = 0;
+	
+	/* Reset the label on the notebook tab to the object's name. */
+	gtk_notebook_set_tab_label_text (notebook,
+					 it->gtk_box,
+					 it->name);
+	book->focus_sheet = it;
+	break;
+      }
+  }
+  ITERATE_END ();
+  return TRUE;
+}
+
+static guint
+application_signal_gtksheet_changed (GtkWidget * gtksheet,
+				     gint row, gint column,
+				     Sheet * sheet)
+{
+  ASSERT (sheet != NULL);
+  ASSERT (sheet->workbook != NULL);
+
+  Workbook * wb = sheet->workbook;
+
+  if (sheet->notices > 0)
+    {
+      gchar * label 
+	= g_strdup_printf ("%s (%d)", sheet->name, sheet->notices);
+      gtk_notebook_set_tab_label_text (GTK_NOTEBOOK (wb->gtk_notebook),
+				       sheet->gtk_box,
+				       label);
+      FREE (label);
+    }
+  return FALSE;
+}
+
+/* @description: This method frees teh application state object.   
+   @appstate: The application state object to free. */
+static ApplicationState *
+application_object_free (ApplicationState *appstate)
+{
+  ASSERT (appstate != NULL);
+
+  FREE (appstate->absolute_path);
+  FREE (appstate);
+  return appstate;
+}
+
+/* @description: This initializes a new application state object. This
+   should only be called once. */
+static ApplicationState *
+application_object_init (void)
+{
+  ApplicationState * app = NEW (ApplicationState);
+
+  /* Members */
+  app->cfg = NULL;
+  app->workbook_first = app->workbook_last = NULL;
+  app->plugin_first = app->plugin_last = NULL;
+  app->gtk_window = NULL;
+  app->gtk_menu = NULL;
+  app->gtk_window_vbox = NULL;
+
+  /* Set up the signals. */
+  app->signals[SIG_NOTEBOOK_SWITCHED]
+    = (GSourceFunc)application_signal_gtknotebook_switchpage;
+  app->signals[SIG_NOTEBOOK_REORDERED]
+    = (GSourceFunc)application_signal_gtknotebook_reordered;
+  app->signals[SIG_NOTEBOOK_REMOVED]
+    = (GSourceFunc)application_signal_gtknotebook_removed;
+  app->signals[SIG_DESTROY_EVENT]
+    = (GSourceFunc)application_signal_destroy_event;
+  app->signals[SIG_DELETE_EVENT]
+    = (GSourceFunc)application_signal_delete_event;
+  app->signals[SIG_SHEET_CHANGED]
+    = (GSourceFunc)application_signal_gtksheet_changed;
+
+  /* Methods */
+  app->run = application_method_run;
+  app->close = application_method_close;
+  app->load_plugin = application_method_loadplugin;
+  app->open_extension = application_method_openextension;
+
+  return app;
+}
+
+/* @description: This is called from main() when we want to start the
+   application.It loads up the configuration file (if present) and starts
+   gtk_main.
+   @appstate: A pointer to the application state object. */
+static int
+application_method_run (ApplicationState *appstate)
+{
+  if (appstate->cfg)
+    {
+      Config * cfg = appstate->cfg;
+      cfg->open (cfg);
+     
+      /* Load extensions */
+      ConfigRow * load = cfg->get_row (cfg, "application", "load");
+
+      /* Did a little bit of fixing here. We needed something to specify that
+	 certain extensions will start automatically when the application is
+	 started. */
+      if (!IS_NULL (load))
+	{
+	  ConfigVector * ext = load->get_vector (load, "extensions");
+	  gchar * block = NULL;
+	  gint ii = 0;
+
+	  if (IS_NULL (ext))
+	    {
+	      g_critical ("Config 'extensions' vector is NULL");
+	      return -1;
+	    }
+      
+	  while ((block = ext->get(ext, ii)) != NULL)
+	    {
+	      ConfigPair * run = cfg->get_pair (cfg, block, "onLoad", "run");
+	      
+	      if (run && (strcmp (run->value, "1") == 0))
+		{
+		  ConfigPair * filename 
+		    = cfg->get_pair (cfg, block, "linux", "filename");
+
+		  if (!IS_NULL (filename) && !IS_NULLSTR (filename->value))
+		    {
+		      gboolean RelativePath 
+			= (filename->value[0] == '/') ? FALSE : TRUE;
+
+		      appstate->open_extension (appstate, 
+						filename->value, 
+						RelativePath);
+		    }
+		}
+	      ii++;
+	    }
+	}
+    }
+
+  /* Start the GTK+ main loop; make sure it is surrounded in the 
+     thread calls. GTK+ "releases" the current lock after every loop
+     interation. This allows us to call gdk_threads_enter/leave inside
+     of another thread. */
+  gdk_threads_enter ();
+  gtk_main ();
+  gdk_threads_leave ();
+  return 0;
+}
+
+/* @description: This method loads a shared library (plugin) from disk.
+   @appstate: A pointer to the application state object.
+   @filename: The string to the file that we're looking to load.*/
+static Plugin *
+application_method_loadplugin (ApplicationState * appstate, 
+			       const gchar * filename)
+{
+  ASSERT (appstate != NULL);
+  
+  Plugin * plugin = plugin_open (filename);
+  
+  if (plugin == NULL)
+    return NULL;
+
+  LINK_OBJECT (appstate->plugin_first, 
+	       appstate->plugin_last, 
+	       plugin);
+
+  return plugin;
+}
+
+/* @description: This is the callback to GtkMain's "delete" event. This is
+   called when we attempt to close the application safely. 
+   @window: A pointer to the GtkWindow object.
+   @event: A pointer to the associated GdkEvent information.
+   @p: NULL */
+static guint
+application_signal_delete_event (GtkWindow * window, 
+				 GdkEvent * event,
+				 gpointer p)
+{
+  GtkWidget * dialog 
+    = gtk_message_dialog_new (window, GTK_DIALOG_MODAL,
+			      GTK_MESSAGE_QUESTION,
+			      GTK_BUTTONS_YES_NO,
+			      "Are you sure that you want to quit?");
+  gtk_window_set_title (GTK_WINDOW (dialog), "Close Application");
+
+  gint result = gtk_dialog_run (GTK_DIALOG (dialog));
+  
+  gtk_widget_destroy (dialog);
+
+  return (result == GTK_RESPONSE_YES) ? FALSE : TRUE;
+}
+
+/* @description: This is the callback to the "destroy" signal that is
+   emitted from GtkMain. Any cleanup should be done here.
+   @window: A pointer to the GtkWindow object.
+   @data: NULL */
+static guint
+application_signal_destroy_event (GtkWidget *window, gpointer data)
+{
+  gtk_main_quit ();
+  return FALSE;
+}
+
+/* @description: This method loads an extension from the filename
+   provided. It also registers the plugin's method and calls it.
+   @app: A pointer to the application state object.
+   @filename: The string that we should load the library from.
+   @absolute_path: Is the string an absolute or relative path? */
+static void
+application_method_openextension (ApplicationState * app, 
+				  const gchar * filename,
+				  gboolean absolute_path)
+{
+  ASSERT (app != NULL);
+  gchar * fname = NULL;
+  
+  if (absolute_path)
+    {
+      fname = g_strconcat (app->absolute_path, 
+			   filename,
+			   NULL);
+    }
+  else
+    {
+      fname = g_strdup (filename);
+    }
+
+  Plugin * plugin = NULL;
+  if ((plugin = app->load_plugin (app, fname)) != NULL)
+    {
+      typedef Workbook * (*Plugin_Main) (ApplicationState *, Plugin *);
+      Plugin_Main plugin_main;
+	  
+      if ((plugin_main 
+	   = plugin->method_register (plugin, "plugin_main")) == NULL)
+	{
+	  g_critical ("Unable to register method with symbol 'plugin_main'");
+	  exit (1);
+	}
+
+      Workbook * wb = plugin_main (app, plugin);
+      if (wb == NULL)
+	{
+	  g_critical ("Plugin returned a NULL pointer instead of allocated"
+		      " workbook.");
+	  exit (1);
+	}
+      else
+	{
+	  gtk_box_pack_end (GTK_BOX (app->gtk_window_vbox),
+			    wb->gtk_box, 1,1,1);
+
+	  /* Attach all of the signals for the Workbook object. */
+	  gtk_signal_connect (GTK_OBJECT (wb->gtk_notebook),
+			      "switch-page",
+			   (GtkSignalFunc)app->signals[SIG_NOTEBOOK_SWITCHED], 
+			      (gpointer)wb);
+	  
+	  LINK_OBJECT (app->workbook_first, app->workbook_last, wb);
+	}
+    }
+
+  if (absolute_path)
+    FREE (fname);
+}
+
diff --git a/src/application.h b/src/application.h
new file mode 100644
index 0000000..57baaf2
--- /dev/null
+++ b/src/application.h
@@ -0,0 +1,47 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_APPLICATION
+#define H_APPLICATION
+
+typedef struct _ApplicationState ApplicationState;
+
+#include <gtk/gtk.h>
+#include <workbook/workbook.h>
+#include <config/config.h>
+#include <shared.h>
+#include "plugin.h"
+
+enum
+  {
+    SIG_DESTROY_EVENT = 0,
+    SIG_DELETE_EVENT,
+    SIG_NOTEBOOK_SWITCHED,
+    SIG_NOTEBOOK_REMOVED,
+    SIG_NOTEBOOK_REORDERED,
+    SIG_SHEET_CHANGED,
+    /**/
+    MAX_SIGNALS
+  };
+
+struct _ApplicationState
+{
+  /* Members */
+  GSourceFunc signals[MAX_SIGNALS];
+  Config * cfg;
+  Workbook * workbook_first, * workbook_last;
+  Plugin * plugin_first, * plugin_last;
+  GtkWidget * gtk_window;
+  GtkWidget * gtk_menu;
+  GtkWidget * gtk_window_vbox;
+  gchar * absolute_path;
+
+  /* Methods */
+  int (*run) (ApplicationState *);
+  void (*close) (ApplicationState *);
+  void (*open_extension) (ApplicationState *, const gchar *, gboolean);
+  Plugin *(*load_plugin) (ApplicationState *, const gchar *);
+};
+
+/* application.c */
+ApplicationState * application_init (int * argc, char *** argv);
+
+#endif
diff --git a/src/include.h b/src/include.h
new file mode 100644
index 0000000..d7083a5
--- /dev/null
+++ b/src/include.h
@@ -0,0 +1,59 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_INCLUDE
+#define H_INCLUDE
+
+#include <glib.h> 
+#include <csv/csv.h>
+
+#define FCLOSE(fp) { if (fp != NULL) { fflush(fp); fclose(fp); fp = NULL; } }
+#define PCLOSE(fp) { if (fp != NULL) { pclose(fp); fp = NULL; } }
+
+#define UNLINK_OBJECT(current) if (current && current->next && current->prev) \
+    { \
+      current->prev->next = current->next; \
+      current->next->prev = current->prev; \
+      current->next = NULL; \
+      current->prev = NULL; \
+    } \
+  else if (current && current->next) \
+    { \
+      current->next->prev = NULL; \
+      current->next = NULL; \
+    } \
+  else if (current && current->prev) \
+    { \
+      current->prev->next = NULL; \
+      current->prev = NULL; \
+    }
+
+#define LINK_OBJECT(first, last, current) if (!first) \
+    { \
+      first = current; \
+      last = NULL; \
+      current->next = NULL; \
+      current->prev = NULL; \
+    } \
+  else \
+    { \
+      if (!last) \
+        { \
+          last = current; \
+          current->next = NULL; \
+          current->prev = first; \
+          first->next = current; \
+          first->prev = NULL; \
+        } \
+      else \
+        { \
+          current->prev = last; \
+	  current->next = NULL; \
+	  last->next = current;	\
+          last = current; \
+        } \
+    }
+
+#define gmalloc(size) g_malloc(size)
+#define gfree(pointer) { g_free(pointer); pointer = NULL; }
+#define gassert(condition) g_assert(condition)
+
+#endif
diff --git a/src/main.c b/src/main.c
new file mode 100755
index 0000000..a9b759e
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,14 @@
+#include "application.h"
+
+int 
+main(int argc, char *argv[])
+{
+  ApplicationState *app = application_init (&argc, &argv);
+
+  app->run (app);
+  app->close (app);
+  
+  return 0; 
+}
+
+
diff --git a/src/plugin.c b/src/plugin.c
new file mode 100755
index 0000000..a872ee5
--- /dev/null
+++ b/src/plugin.c
@@ -0,0 +1,181 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#include "plugin.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+/* plugin.c (static) */
+static Plugin *plugin_object_init (void);
+static void plugin_method_destroy (Plugin *);
+static void *plugin_method_symbol_register (Plugin *, gchar *);
+static void plugin_method_symbol_deregister (Plugin *, PluginMethod *);
+static Plugin *plugin_object_free (Plugin *);
+static PluginMethod *pluginmethod_object_init (Plugin *);
+static PluginMethod *pluginmethod_object_free (PluginMethod *);
+static void pluginmethod_method_deregister (PluginMethod *, Plugin *);
+static GThread *plugin_method_create_thread (Plugin *,
+					     GThreadFunc,
+					     gpointer);
+
+Plugin *
+plugin_open (const gchar * filename)
+{
+  if (!filename || (*filename == '\0'))
+    return NULL;
+
+  Plugin * plug = plugin_object_init ();
+
+  if ((plug->pfnhandle = LIBRARY_OPEN(filename)) == NULL)
+    {
+      fprintf (stderr, "%s\n", LIBRARY_ERROR());
+      exit (1);
+    }
+  return plug;
+}
+
+static Plugin *
+plugin_object_init (void)
+{
+  Plugin * plug = NEW (Plugin);
+  
+  /* Members */
+  plug->pfnhandle = NULL;
+  plug->next = NULL;
+  plug->prev = NULL;
+  plug->first = NULL;
+  plug->last = NULL;
+  plug->threads = g_ptr_array_new ();
+
+  /* Methods */
+  plug->destroy = plugin_method_destroy;
+  plug->method_register = plugin_method_symbol_register;
+  plug->method_deregister = plugin_method_symbol_deregister;
+  plug->create_thread = plugin_method_create_thread;
+
+  return plug;
+}
+
+static GThread *
+plugin_method_create_thread (Plugin * plugin,
+			     GThreadFunc thread_function,
+			     gpointer data)
+{
+  ASSERT (plugin != NULL);
+
+  GThread * runnable = NULL;
+  GError * err = NULL;
+
+  if ((runnable = g_thread_create (thread_function, data,
+				   TRUE, &err)) == NULL)
+    {
+      g_warning ("Failed creating thread; ERROR %s", err->message);
+      g_error_free (err);
+      return NULL;
+    }
+  g_ptr_array_add (plugin->threads, (gpointer)runnable);
+  return runnable;
+} 
+
+static Plugin *
+plugin_object_free (Plugin * plugin)
+{
+  if (!plugin)
+    return NULL;
+
+  plugin->first = plugin->last = NULL;
+
+  g_ptr_array_free (plugin->threads, TRUE);
+
+  FREE (plugin);
+  return plugin;
+}
+
+static void
+plugin_method_destroy (Plugin * plugin)
+{
+  if (!plugin)
+    return;
+
+  PluginMethod * current = plugin->first, * next = NULL;
+  while (current)
+    {
+      next = current->next;
+      current->deregister (current, plugin);
+      current = next;
+    }
+
+  for (guint ii = 0; ii < plugin->threads->len; ii++)
+    {
+      GThread * thread 
+	= (GThread *)g_ptr_array_remove_index_fast (plugin->threads, ii);
+      g_thread_join (thread);
+    }
+
+  UNLINK_OBJECT (plugin);
+  LIBRARY_CLOSE (plugin->pfnhandle);
+  plugin_object_free (plugin);
+}
+
+static void
+plugin_method_symbol_deregister (Plugin * plugin, PluginMethod * method)
+{
+  if (!plugin || !method)
+    return;
+
+  method->deregister (method, plugin);
+}
+
+static void *
+plugin_method_symbol_register (Plugin * plugin, gchar * symbol)
+{
+  if (IS_NULLSTR (symbol))
+    return NULL;
+
+  PluginMethod * plugm = pluginmethod_object_init (plugin);
+
+  if ((plugm->pfnmethod 
+       = LIBRARY_SYM(plugin->pfnhandle, symbol)) == NULL)
+    {
+      fprintf (stderr, "%s\n", LIBRARY_ERROR());
+      exit (1);
+    }
+
+  LINK_OBJECT (plugin->first, plugin->last, plugm); 
+  return plugm->pfnmethod;
+}
+
+static PluginMethod *
+pluginmethod_object_init (Plugin * plugin)
+{
+  PluginMethod * plugm = NEW (PluginMethod);
+
+  /* Members */
+  plugm->pfnmethod = NULL;
+  plugm->plugin = plugin;
+
+  /* Methods */
+  plugm->deregister = pluginmethod_method_deregister;
+
+  plugm->next = NULL;
+  plugm->prev = NULL;
+  return plugm;
+}
+
+static PluginMethod *
+pluginmethod_object_free (PluginMethod * method)
+{
+  if (!method)
+    return NULL;
+
+  FREE (method);
+  return method;
+}
+
+static void
+pluginmethod_method_deregister (PluginMethod * method, Plugin * plugin)
+{
+  if (!method)
+    return;
+
+  UNLINK_OBJECT (method);
+  pluginmethod_object_free (method);
+}
diff --git a/src/plugin.h b/src/plugin.h
new file mode 100755
index 0000000..14fad72
--- /dev/null
+++ b/src/plugin.h
@@ -0,0 +1,56 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#ifndef H_PLUGIN
+#define H_PLUGIN
+
+typedef struct _PluginMethod PluginMethod;
+typedef struct _Plugin Plugin;
+
+#ifdef WIN32
+#include <windows.h>
+typedef HINSTANCE LibraryHandle;
+#define LIBRARY_CLOSE(handle) FreeLibrary(handle)
+#define LIBRARY_OPEN(filename) LoadLibrary(filename)
+#define LIBRARY_SYM(handle, symbol) GetProcAddress(handle, symbol)
+#define LIBRARY_ERROR() GetLastError()
+#else
+typedef void * LibraryHandle;
+#define LIBRARY_CLOSE(handle) dlclose(handle)
+#define LIBRARY_OPEN(filename) dlopen(filename, RTLD_LAZY)
+#define LIBRARY_SYM(handle, symbol) dlsym(handle, symbol)
+#define LIBRARY_ERROR() dlerror()
+#endif
+
+#include <shared.h>
+#include <dlfcn.h>
+#include <glib/gthread.h>
+
+struct _Plugin
+{
+  /* Members */
+  LibraryHandle pfnhandle;
+  PluginMethod * first, * last;
+  Plugin * next, * prev;
+  GPtrArray * threads;
+
+  /* Methods */
+  void *(*method_register) (Plugin *, gchar *);
+  void (*method_deregister) (Plugin *, PluginMethod *);
+  void (*destroy) (Plugin *);
+  GThread *(*create_thread) (Plugin *, GThreadFunc, gpointer);
+};
+
+struct _PluginMethod
+{
+  /* Members */
+  void * pfnmethod;
+  PluginMethod * next, * prev;
+  Plugin * plugin;
+
+  /* Methods */
+  void (*deregister) (PluginMethod *method, Plugin *plugin);
+};
+
+/* plugin.c */
+Plugin * plugin_open (const gchar * filename);
+
+#endif
diff --git a/src/realtime/AcceptThread.hpp b/src/realtime/AcceptThread.hpp
new file mode 100755
index 0000000..e199358
--- /dev/null
+++ b/src/realtime/AcceptThread.hpp
@@ -0,0 +1,56 @@
+#ifndef HPP_ACCEPTTHREAD
+#define HPP_ACCEPTTHREAD
+
+#include "network/Tcp.hpp"
+#include "proactor/Dispatcher.hpp"
+#include "Connection.hpp"
+#include <iostream>
+
+/* @description: This object runs as a separate thread accepting incoming
+   connections from a TcpServerSocket object.
+   @author: John `jb Bellone (jvb4@njit.edu) */
+class AcceptThread : public proactor::Dispatcher {
+private:
+  TcpServerSocket::Acceptor * acceptor;
+public:
+  AcceptThread (TcpServerSocket::Acceptor * acceptor, 
+		proactor::Proactor * pro) {
+    this->pro = pro;
+    this->acceptor = acceptor;
+  }
+
+  virtual ~AcceptThread (void) {
+      delete acceptor;
+  }
+
+  void * run (void * null) {
+    this->running = true;
+  
+    while (this->running == true)
+      {
+	int newfd = -1;
+	
+	if ((newfd = this->acceptor->acceptIncoming()) < 0)
+	  {
+	    this->running = false;
+	    break;
+	  }
+
+	ConnectionThread * c = new ConnectionThread (this->pro, newfd);
+	c->setEventId ( this->getEventId() );
+
+	if (c->start() == false)
+	  {
+	    // Failed for some reason; cut out and quit for now.
+	    break;
+	  }
+	
+	this->pro->addDispatcher ( c );
+	Thread::sleep (100);
+      }
+
+    return NULL;
+  }
+};
+
+#endif
diff --git a/src/realtime/Connection.cpp b/src/realtime/Connection.cpp
new file mode 100644
index 0000000..28cc905
--- /dev/null
+++ b/src/realtime/Connection.cpp
@@ -0,0 +1,64 @@
+#include "Connection.hpp"
+#include <iostream>
+
+#define IS_TERMINAL(c) ((*c == '\n') || (*c == '\r'))
+
+Connection::Connection (int sockfd) {
+  this->sockfd = sockfd;
+}
+
+Connection::~Connection (void) {
+}
+
+/*****************************************************************************/
+
+ConnectionThread::ConnectionThread (proactor::Proactor * pro, int newfd) {
+  this->socket = new Connection (newfd);
+  this->pro = pro;
+}
+
+ConnectionThread::~ConnectionThread (void) {
+  delete socket;
+}
+
+void *
+ConnectionThread::run (void * null) {
+  this->running = true;
+  int size = 0;
+  char buf[MAX_INPUT_SIZE];
+  char * p = NULL, * q = NULL;
+
+  while (this->running == true) 
+    {
+      if ((size = this->socket->receive (&buf[0], MAX_INPUT_SIZE)) <= 0)
+	{
+	  this->running = false;
+	  break;
+	}
+
+      buf[size] = 0;
+
+      q = p = &buf[0];
+      while (p && (*p != '\0'))
+	{
+	  if (IS_TERMINAL (p))
+	    {
+	      *p = 0;
+
+	      if (*(p+1) == '\n')
+		p++;
+
+	      this->pro->onReadComplete (this->getEventId(), q);
+	      
+	      q = (++p);
+	      continue;
+	    }
+	  p++;
+	}
+      
+      Thread::sleep (100);
+    }
+
+  this->pro->removeDispatcher (this);
+  return NULL;
+}
diff --git a/src/realtime/Connection.hpp b/src/realtime/Connection.hpp
new file mode 100644
index 0000000..4cebcce
--- /dev/null
+++ b/src/realtime/Connection.hpp
@@ -0,0 +1,27 @@
+#ifndef HPP_CONNECTION
+#define HPP_CONNECTION
+
+#include "network/Tcp.hpp"
+#include "proactor/Dispatcher.hpp"
+#include "proactor/Proactor.hpp"
+#include <iostream>
+
+#define MAX_INPUT_SIZE 4096
+
+class Connection : public TcpSocket {
+public:
+  Connection (int sockfd); 
+  virtual ~Connection (void);
+};
+
+class ConnectionThread : public proactor::Dispatcher {
+private:
+  Connection * socket;
+public:
+  ConnectionThread (proactor::Proactor * pro, int newfd); 
+  virtual ~ConnectionThread (void);
+
+  void * run (void * null);
+};
+
+#endif
diff --git a/src/realtime/Makefile b/src/realtime/Makefile
new file mode 100755
index 0000000..5a3ef51
--- /dev/null
+++ b/src/realtime/Makefile
@@ -0,0 +1,26 @@
+include ../../Makefile.base
+
+SRCS=$(wildcard *.cpp) $(wildcard concurrent/*.cpp) $(wildcard network/*.cpp) \
+	$(wildcard proactor/*.cpp)
+OBJS=$(patsubst %.cpp,${OBJDIR}/realtime/%.o,${SRCS})
+
+all: 	realtime
+
+realtime: ${OBJS}
+	${CX} -shared -Wl -o ${PROJDIR}/bin/realtime.so ${OBJS} ${LIBS} \
+	-lgthread-2.0 -lpthread
+
+clean:		
+	${MD} ${OBJDIR}/realtime/concurrent ${OBJDIR}/realtime/network \
+	${OBJDIR}/realtime/proactor
+	${RM} ${OBJS} ${PROJDIR}/bin/realtime.so
+
+install: all
+	${MD} ${INSEXTDIR}
+	${CP} ${PROJDIR}/bin/realtime.so ${INSEXTDIR}/realtime.so
+
+${OBJDIR}/realtime/%.o: %.cpp
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $< -o $@
+
+.cpp.o:
+	${CX} ${INCS} -c -fPIC ${CXFLAGS} $<ls
\ No newline at end of file
diff --git a/src/realtime/Packet.cpp b/src/realtime/Packet.cpp
new file mode 100755
index 0000000..02c0acc
--- /dev/null
+++ b/src/realtime/Packet.cpp
@@ -0,0 +1,78 @@
+#include "Packet.hpp"
+
+#define WORD(d,buf,word) if (buf.length() > 0) { \
+    size_t index = buf.find_first_of (d, 0);	 \
+    if (index == std::string::npos) {		 \
+      word = buf;				 \
+      buf.clear();				 \
+    }						 \
+    else {					 \
+      word = buf.substr (0, index);		 \
+      buf = buf.substr (index+1, buf.length());	 \
+    }						 \
+  }
+
+Packet::Packet (void)
+{
+  this->delimiter = '\0';
+  this->type = -1;
+}
+
+Packet::~Packet (void)
+{
+  this->time.clear();
+  this->fields.clear();
+}
+
+gboolean
+Packet::parse (const gchar * buf)
+{
+  this->fields.clear();
+
+  if (IS_NULLSTR (buf)) return FALSE;
+
+  this->delimiter = buf[0];
+
+  String line(&buf[1]), value;
+
+  WORD (this->delimiter, line, this->time);
+  WORD (this->delimiter, line, this->type);
+
+  while (line.length() > 0)
+    {
+      WORD (this->delimiter, line, value);
+      this->fields.push_back (value);
+    }
+  return TRUE;
+}
+
+Map<String,String>
+Packet::parseFormatString (const gchar * buf)
+{
+  String fmt(buf);
+  Map<String,String> pairs; pairs.clear();
+
+  size_t pos = 0, length = fmt.length(), comma = 0, equal = 0;
+  String key, val;
+
+  while (pos < length)
+    {
+      if ((comma = fmt.find_first_of (',')) == String::npos)
+	comma = length;
+      
+      if ((equal = fmt.find_first_of ('=')) == String::npos)
+	break;
+
+      key = fmt.substr (0, equal);
+      val = fmt.substr (equal+1, comma-equal-1);
+
+      pairs[key] = val;
+
+      if (comma == length)
+	break;
+
+      fmt = fmt.substr (comma+1, length);
+      length = fmt.length();
+    }
+  return pairs;
+}
diff --git a/src/realtime/Packet.hpp b/src/realtime/Packet.hpp
new file mode 100755
index 0000000..31d1398
--- /dev/null
+++ b/src/realtime/Packet.hpp
@@ -0,0 +1,54 @@
+#ifndef HPP_PACKET
+#define HPP_PACKET
+
+#include <workbook/cell.h>
+#include <glib.h>
+#include <string>
+#include <vector>
+#include <map>
+
+#define String std::string
+#define Array  std::vector
+#define Map    std::map
+
+class Packet
+{
+private:
+  /* Members */
+  String time;
+  String type;
+  Array<String> fields;
+  gchar delimiter;
+public:
+  enum 
+    {
+      TYPE_UPDATECELL = 0,
+      TYPE_ADDSHEET,
+      TYPE_REMSHEET,
+      TYPE_MOVESHEETINDEX,
+      TYPE_MOVESHEET,
+      TYPE_SAVESHEET,
+      TYPE_LOADSHEET,
+      /**/
+      MAX_TYPES
+    };
+  
+  Packet (void);
+  ~Packet (void);
+  
+  /* Methods */
+  gboolean parse (const gchar *);
+  Map<String,String> parseFormatString (const gchar *);
+
+  inline gchar getDelimiter (void) const { return this->delimiter; }
+  inline gint getType (void) const { return atoi (this->type.c_str()); }
+  inline const gchar * getTime (void) const { return this->time.c_str(); }
+  inline gint getFieldSize (void) const { return this->fields.size(); }
+  inline const gchar * operator[] (gint index) const 
+  {
+    return this->fields.at(index).c_str();
+  }
+  inline size_t size (void) const { return this->fields.size(); }
+};
+
+#endif
diff --git a/src/realtime/PacketHandler.hpp b/src/realtime/PacketHandler.hpp
new file mode 100755
index 0000000..03e99c9
--- /dev/null
+++ b/src/realtime/PacketHandler.hpp
@@ -0,0 +1,245 @@
+#ifndef HPP_PACKETHANDLER
+#define HPP_PACKETHANDLER
+
+#include "proactor/Job.hpp"
+#include "Packet.hpp"
+#include <workbook/cell.h>
+#include <workbook/sheet.h>
+#include <workbook/workbook.h>
+
+class PacketHandler : public proactor::Job {
+private:
+  Workbook * wb;
+  FILE * pktlog;
+  Cell * cell;
+public:
+  PacketHandler (Workbook * wb, FILE * pktlog) { 
+    this->wb = wb;
+    this->pktlog = pktlog;
+    this->cell = cell_new();
+  }
+  
+  virtual ~PacketHandler (void) {
+    cell->destroy (cell);
+  }
+
+  void * run (void * null) {
+    this->running = true;
+    Packet packet;
+    const char * p = NULL;
+
+    while (this->running == true)
+      {
+	while (this->inputQueue.size() > 0)
+	  {
+	    std::string buf = this->inputQueue.pop();
+	    p = buf.c_str();
+
+	    if (packet.parse (p) == FALSE)
+	      {
+		g_warning ("Failed parsing packet '%s'", buf.c_str());
+		::sleep (1);
+		continue;
+	      }
+
+	  switch (packet.getType())
+	    {
+	    default:
+	      g_warning ("Invaild packet line '%s'", buf.c_str());
+	      break;
+	    /* ^time^type^sheet_name^sheet_name^after */
+	  case Packet::TYPE_MOVESHEET:
+	    {
+	      if (packet.size() != 3)
+		{
+		  g_warning ("Packet::TYPE_MOVESHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Failed moving sheet '%s' to %s sheet '%s'",
+			 packet[0],
+			 (strcmp(packet[2], "0") == 0) ? "after" : "before",
+			 packet[1]);
+		  break;
+		}
+
+	      if (wb->move_sheet (wb, sheet,
+				  packet[1], 
+				  atoi (packet[2]))
+		  == FALSE)
+		{
+		  g_warning ("Failed moving sheet '%s'", packet[0]);
+		  break;
+		}
+	    }
+	    break;
+	    /* ^time^type^sheet_name^loadpath */
+	  case Packet::TYPE_LOADSHEET:
+	    {
+	      if (packet.size() != 2)
+		{
+		  g_warning ("Packet::TYPE_LOADSHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Unable to load geometry file; sheet '%s'"
+			     " does not exist", packet[0]);
+		  break;
+		}
+	      
+	      sheet->load (sheet, packet[1]);
+	    }
+	    break;
+	    /* ^time^type^sheet_name^savepath */
+	  case Packet::TYPE_SAVESHEET:
+	    {
+	      if (packet.size() != 2)
+		{
+		  g_warning ("Packet::TYPE_SAVESHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Failed saving sheet '%s'; does not exist",
+			     packet[0]);
+		  break;
+		}
+	      
+	      if (sheet->save (sheet, packet[1]) == FALSE)
+		{
+		  g_warning ("Unable to save sheet.");
+		  break;
+		}
+	    }
+	    break;
+	    /* ^time^type^sheet_name^position */
+	  case Packet::TYPE_MOVESHEETINDEX:
+	    {
+	      if (packet.size() != 2)
+		{
+		  g_warning ("Packet::TYPE_MOVESHEETINDEX: Wrong packet "
+			     "format: %s", buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Failed moving sheet '%s' to %d:"
+			     " Does not exist", packet[0], atoi(packet[1]));
+		  break;
+		}
+	      
+	      if (wb->move_sheet_index (wb, sheet, atoi(packet[1])) 
+		  == FALSE)
+		{
+		  g_warning ("Failed moving sheet '%s' to %d:"
+			     " Invaild index\n", packet[0], atoi(packet[1]));
+		}
+	    }
+	    break;
+	    /* ^time^type^sheet_name */
+	  case Packet::TYPE_REMSHEET:
+	    {
+	      if (packet.size() != 1)
+		{
+		  g_warning ("Packet::TYPE_REMSHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Failed removing sheet '%s':"
+			     " Does not exist", packet[0]);
+		  break;
+		}
+	      wb->remove_sheet (wb, sheet);
+	      sheet->destroy (sheet);
+	    }
+	    break;
+	    /* ^time^type^sheet_name^max_row^max_column */
+	  case Packet::TYPE_ADDSHEET:
+	    {
+	      if (packet.size() != 3)
+		{
+		  g_warning ("Packet::TYPE_ADDSHEET: Wrong packet format: %s",
+			     buf.c_str());
+		  break;
+		}
+
+	      wb->add_new_sheet (wb, 
+				 packet[0],
+				 atoi (packet[1]),
+				 atoi (packet[2]));
+	    }
+	    break;
+	    /* ^time^type^sheet_name^row^column^format^data */
+	  case Packet::TYPE_UPDATECELL:
+	    {
+	      if (packet.size() != 5)
+		{
+		  g_warning ("Packet::TYPE_UPDATESHEET: Wrong packet "
+			     "format: %s", buf.c_str());
+		  break;
+		}
+
+	      Sheet * sheet = wb->get_sheet (wb, packet[0]);
+
+	      if (IS_NULL (sheet))
+		{
+		  g_warning ("Invaild sheet name '%s': Does not exist",
+			     packet[0]);
+		  break;
+		}
+	            
+	      cell->set_row (cell, atoi (packet[1]) );
+	      cell->set_column (cell, atoi (packet[2]) );
+	      
+	      if (strlen (packet[3]) > 0)
+		{
+		  Map<String,String> fmt = packet.parseFormatString (packet[3]);
+		  
+		  if (fmt["bgcolor"].length() > 0)
+		    cell->set_bgcolor (cell, fmt["bgcolor"].c_str());
+		  if (fmt["fgcolor"].length() > 0)
+		    cell->set_fgcolor (cell, fmt["fgcolor"].c_str());
+		  if (fmt["justification"].length() > 0)
+		    cell->set_justification (cell, 
+					     (GtkJustification)
+					     atoi (fmt["justification"].c_str()));
+		}
+	      
+	      cell->set_value (cell, packet[4]);
+	      
+	      sheet->apply_cell (sheet, cell);
+	      
+	      g_message ("Cell (%d,%d) updated", cell->row, cell->column);
+	    }
+	    break;
+	  }
+	
+	  fprintf (pktlog, "%s\n", buf.c_str());
+	  fflush (pktlog);
+	  ::sleep (1);
+	  }
+	::sleep (1);
+      }
+
+    return NULL;
+  }
+};
+
+#endif
diff --git a/src/realtime/concurrent/List.hpp b/src/realtime/concurrent/List.hpp
new file mode 100755
index 0000000..787e213
--- /dev/null
+++ b/src/realtime/concurrent/List.hpp
@@ -0,0 +1,14 @@
+#ifndef HPP_CONCURRENT_LIST
+#define HPP_CONCURRENT_LIST
+
+#include <list>
+#include "Mutex.hpp"
+
+namespace concurrent {
+
+  template <typename T>
+  class List : public RecursiveMutex, public std::list<T> {
+  };
+}
+
+#endif
diff --git a/src/realtime/concurrent/Lockable.hpp b/src/realtime/concurrent/Lockable.hpp
new file mode 100755
index 0000000..f67b796
--- /dev/null
+++ b/src/realtime/concurrent/Lockable.hpp
@@ -0,0 +1,13 @@
+#ifndef HPP_THREAD_LOCKABLE
+#define HPP_THREAD_LOCKABLE
+
+class ILockable {
+public:
+  virtual ~ILockable (void) { }
+
+  virtual void lock (void) = 0;
+  virtual void unlock (void) = 0;
+  virtual bool trylock (void) = 0;
+};
+
+#endif
diff --git a/src/realtime/concurrent/Map.hpp b/src/realtime/concurrent/Map.hpp
new file mode 100755
index 0000000..1aafb1e
--- /dev/null
+++ b/src/realtime/concurrent/Map.hpp
@@ -0,0 +1,22 @@
+#ifndef HPP_THREAD_MAP
+#define HPP_THREAD_MAP
+
+#include <iterator>
+#include <map>
+#include "Mutex.hpp"
+
+namespace concurrent {
+ 
+  /* @description: This object uses the standard std::map and wraps all of
+     the calls that are exposed with a Mutex object. This object uses a
+     single lock and may cause performance issues if several threads are
+     attempting to use it. 
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template<typename K, typename V>
+  class Map : public RecursiveMutex, public std::map<K,V> {
+  private:
+  public:
+    Map (void) : RecursiveMutex() { }
+  };
+}
+#endif
diff --git a/src/realtime/concurrent/Mutex.cpp b/src/realtime/concurrent/Mutex.cpp
new file mode 100755
index 0000000..90a4632
--- /dev/null
+++ b/src/realtime/concurrent/Mutex.cpp
@@ -0,0 +1,70 @@
+#include "Mutex.hpp"
+using namespace concurrent;
+
+IMutex::IMutex (void) {
+  this->mutex = NULL;
+  this->attrib = NULL;
+}
+
+IMutex::IMutex (const IMutex & m) {
+  this->mutex = m.mutex;
+  this->attrib = m.attrib;
+}
+
+IMutex::~IMutex (void) {
+}
+
+IMutex & 
+IMutex::operator= (const IMutex & m) {
+  this->mutex = m.mutex;
+  this->attrib = m.attrib;
+  return *this;
+}
+
+void
+IMutex::lock (void) {
+  pthread_mutex_lock (this->mutex);
+}
+
+void 
+IMutex::unlock (void) {
+  pthread_mutex_unlock (this->mutex);
+}
+
+bool
+IMutex::trylock (void) {
+  return (pthread_mutex_trylock (this->mutex) == 0) ?
+    true : false;
+}
+		      
+/****************************************************************************/
+
+RecursiveMutex::RecursiveMutex (void) {
+  this->mutex = new pthread_mutex_t;
+  this->attrib = new pthread_mutexattr_t;
+
+  pthread_mutexattr_init (this->attrib);
+  pthread_mutexattr_settype (this->attrib, PTHREAD_MUTEX_RECURSIVE);
+  
+  pthread_mutex_init (this->mutex, attrib);
+}
+
+RecursiveMutex::~RecursiveMutex (void) {
+  pthread_mutex_destroy (this->mutex);
+  pthread_mutexattr_destroy (this->attrib);
+
+  delete this->mutex;
+  delete this->attrib;
+}
+
+Mutex::Mutex (void) {
+  this->mutex = new pthread_mutex_t;
+
+  pthread_mutex_init (this->mutex, NULL);
+}
+
+Mutex::~Mutex (void) {
+  pthread_mutex_destroy (this->mutex);
+
+  delete this->mutex;
+}
diff --git a/src/realtime/concurrent/Mutex.hpp b/src/realtime/concurrent/Mutex.hpp
new file mode 100755
index 0000000..1677359
--- /dev/null
+++ b/src/realtime/concurrent/Mutex.hpp
@@ -0,0 +1,38 @@
+#ifndef HPP_THREAD_MUTEX
+#define HPP_THREAD_MUTEX
+
+#include <pthread.h>
+#include "Lockable.hpp"
+
+namespace concurrent {
+
+  class IMutex : public ILockable {
+  protected:
+    pthread_mutex_t * mutex;
+    pthread_mutexattr_t * attrib;
+  public:
+    IMutex (void);
+    IMutex (const IMutex & m);
+    virtual ~IMutex (void);
+
+    void lock (void);
+    void unlock (void);
+    bool trylock (void);
+
+    IMutex & operator= (const IMutex & m);
+  };
+
+  class Mutex : public IMutex {
+  public:
+    Mutex (void);
+    virtual ~Mutex (void);
+  };
+
+  class RecursiveMutex : public IMutex {
+  public:
+    RecursiveMutex (void);
+    virtual ~RecursiveMutex (void);
+  };
+}
+
+#endif
diff --git a/src/realtime/concurrent/Queue.hpp b/src/realtime/concurrent/Queue.hpp
new file mode 100755
index 0000000..00eb11c
--- /dev/null
+++ b/src/realtime/concurrent/Queue.hpp
@@ -0,0 +1,65 @@
+#ifndef HPP_THREAD_QUEUE
+#define HPP_THREAD_QUEUE
+
+#include "Mutex.hpp"
+#include <queue>
+
+namespace concurrent {
+  
+  /* @description: This object wraps the existing std::queue container with
+     the custom Mutex object from the concurrent namespace. The single lock
+     may be placed in the future with a read/write lock in order to gain a
+     speed advantage.
+     @author: John `jb Bellone <jvb4@njit.edu> */
+  template <typename T>
+  class Queue : public RecursiveMutex {
+  private:
+    std::queue<T> the_queue;
+  public:
+    Queue (void) { }
+    virtual ~Queue (void) { }
+
+    inline const T & back (void) {
+      this->lock();
+      T & elem = this->the_queue.back();
+      this->unlock();
+      return elem;
+    }
+
+    inline const T & front (void) {
+      this->lock();
+      T & elem = this->the_queue.front();
+      this->unlock();
+      return elem;
+    }
+
+    inline void push (const T & x) {
+      this->lock();
+      this->the_queue.push (x);
+      this->unlock();
+    }
+
+    inline T pop (void) {
+      this->lock();
+      T elem = this->the_queue.front();
+      this->the_queue.pop();
+      this->unlock();
+      return elem;
+    }
+    
+    inline size_t size (void) {
+      this->lock();
+      size_t size = this->the_queue.size();
+      this->unlock();
+      return size;
+    }
+
+    inline bool empty (void) {
+      this->lock();
+      bool result = this->the_queue.empty();
+      this->unlock();
+      return result;
+    }
+  };
+}
+#endif
diff --git a/src/realtime/concurrent/Runnable.hpp b/src/realtime/concurrent/Runnable.hpp
new file mode 100755
index 0000000..5c001c2
--- /dev/null
+++ b/src/realtime/concurrent/Runnable.hpp
@@ -0,0 +1,16 @@
+#ifndef HPP_THREAD_RUNNABLE
+#define HPP_THREAD_RUNNABLE
+
+class IRunnable {
+protected:
+  bool running;
+public:
+  IRunnable (void) { this->running = false; }
+  virtual ~IRunnable (void) { }
+
+  virtual void * run (void *) = 0;
+  
+  inline bool isRunning (void) const { return this->running; }
+};
+
+#endif
diff --git a/src/realtime/concurrent/Semaphore.cpp b/src/realtime/concurrent/Semaphore.cpp
new file mode 100755
index 0000000..49c7199
--- /dev/null
+++ b/src/realtime/concurrent/Semaphore.cpp
@@ -0,0 +1,20 @@
+#include "Semaphore.hpp"
+using namespace concurrent;
+
+Semaphore::Semaphore (void) {
+  sem_init (&this->semaphore, 0, 0);
+}
+
+Semaphore::~Semaphore (void) {
+  sem_destroy (&this->semaphore);
+}
+
+void
+Semaphore::acquire (void) {
+  sem_wait (&this->semaphore);
+}
+
+void
+Semaphore::release (void) {
+  sem_post (&this->semaphore);
+}
diff --git a/src/realtime/concurrent/Semaphore.hpp b/src/realtime/concurrent/Semaphore.hpp
new file mode 100755
index 0000000..6c6b40b
--- /dev/null
+++ b/src/realtime/concurrent/Semaphore.hpp
@@ -0,0 +1,21 @@
+#ifndef HPP_THREAD_SEMAPHORE
+#define HPP_THREAD_SEMAPHORE
+
+#include <semaphore.h>
+
+namespace concurrent {
+
+class Semaphore {
+private:
+  sem_t semaphore;
+public:
+  Semaphore (void);
+  virtual ~Semaphore (void);
+
+  void acquire (void);
+  void release (void);
+};
+
+}
+
+#endif
diff --git a/src/realtime/concurrent/Thread.cpp b/src/realtime/concurrent/Thread.cpp
new file mode 100755
index 0000000..5a6ee95
--- /dev/null
+++ b/src/realtime/concurrent/Thread.cpp
@@ -0,0 +1,118 @@
+#include "Thread.hpp"
+#include "ThreadGroup.hpp"
+#include <iostream>
+#include <ctime>
+using namespace concurrent;
+
+static void *
+thread_run (void * runner) {
+  void * rvalue = ((IRunnable *)runner)->run (NULL);
+  return rvalue;
+}
+
+Thread::Thread (ThreadGroup * group,
+		IRunnable * runner, 
+		const std::string & name) {
+  this->group = group;
+  this->runner = runner;
+  this->name = name;
+  this->running = false;
+}
+
+Thread::Thread (IRunnable * runner,
+		const std::string & name) {
+  this->group = NULL;
+  this->runner = runner;
+  this->name = name;
+  this->running = false;
+}
+
+Thread::Thread (const std::string & name) {
+  this->group = NULL;
+  this->runner = NULL;
+  this->name = name;
+  this->running = false;
+}
+
+Thread::Thread (void) {
+  this->group = NULL;
+  this->runner = NULL;
+  this->name.clear();
+  this->running = false;
+}
+
+Thread::~Thread (void) {
+  if (this->running == true)
+    this->interrupt();
+}
+
+void
+Thread::interrupt (void) {
+  pthread_cancel (this->thread);
+  pthread_detach (this->thread);
+}
+
+void
+Thread::yield (void) {
+  pthread_yield();
+}
+
+void *
+Thread::stop (void) {
+  this->running = false;
+  return this->join();
+}
+
+int
+Thread::sleep (unsigned long ms) {
+  struct timespec req = {0};
+  time_t sec = (int)(ms/1000);
+  ms = ms - (sec*1000);
+  req.tv_sec = sec;
+  req.tv_nsec = ms*1000000L;
+  while (nanosleep (&req, &req) == -1)
+    continue;
+  return 1;
+}
+
+bool
+Thread::start (void) {
+  if (this->running == true)
+    return false;
+
+  if (this->runner != NULL)
+    {
+      if (pthread_create (&this->thread,
+			  NULL,
+			  thread_run,
+			  this->runner))
+	{
+	  return false;
+	}    
+    }
+  else
+    {
+      if (pthread_create (&this->thread,
+			  NULL,
+			  thread_run,
+			  this))
+	{
+	  return false;
+	}
+    }
+
+  this->running = true;
+  return true;
+}
+
+void *
+Thread::join (void) {
+  void * rvalue = NULL;
+  pthread_join (this->thread, &rvalue);
+  return rvalue;
+}
+
+void *
+Thread::run (void *null) {
+  pthread_exit (null);
+}
diff --git a/src/realtime/concurrent/Thread.hpp b/src/realtime/concurrent/Thread.hpp
new file mode 100755
index 0000000..4cfc510
--- /dev/null
+++ b/src/realtime/concurrent/Thread.hpp
@@ -0,0 +1,52 @@
+#ifndef HPP_THREAD_THREAD
+#define HPP_THREAD_THREAD
+
+#include <shared.h>
+#include <string>
+#include <pthread.h>
+#include <map>
+#include "Runnable.hpp"
+
+namespace concurrent {
+
+class ThreadGroup;
+
+class Thread : public IRunnable {
+private:
+  ThreadGroup * group;
+  std::string name;
+  IRunnable * runner;
+  pthread_t thread;
+  bool joinable;
+  int priority;
+public:
+  Thread (ThreadGroup * group, 
+	  IRunnable * runner, 
+	  const std::string & name);
+  Thread (IRunnable * runner,
+	  const std::string & name);
+  Thread (const std::string & name);
+  Thread (void);
+  virtual ~Thread (void);
+
+  bool start (void);
+  void * stop (void);
+  void * join (void);
+  void interrupt (void);
+  void yield (void);
+  
+  virtual void * run (void *);
+
+  inline const std::string & getName (void) const { return this->name; }
+  inline int getPriority (void) const { return this->priority; }
+  inline void setPriority (int priority) { this->priority = priority; }
+  inline const ThreadGroup * getThreadGroup (void) const { 
+    return this->group; 
+  }
+
+  static int sleep (unsigned long ms);
+};  
+
+}
+
+#endif
diff --git a/src/realtime/concurrent/ThreadArgs.hpp b/src/realtime/concurrent/ThreadArgs.hpp
new file mode 100755
index 0000000..f44742c
--- /dev/null
+++ b/src/realtime/concurrent/ThreadArgs.hpp
@@ -0,0 +1,8 @@
+#ifndef H_THREAD_THREADARGS
+#define H_THREAD_THREADARGS
+
+#include <vector>
+
+typedef std::vector<void *> ThreadArgs;
+
+#endif
diff --git a/src/realtime/concurrent/ThreadGroup.hpp b/src/realtime/concurrent/ThreadGroup.hpp
new file mode 100755
index 0000000..5ac7df6
--- /dev/null
+++ b/src/realtime/concurrent/ThreadGroup.hpp
@@ -0,0 +1,42 @@
+#ifndef HPP_THREAD_THREADGROUP
+#define HPP_THREAD_THREADGROUP
+
+#include <string>
+#include <list>
+#include "Thread.hpp"
+
+namespace concurrent {
+
+class ThreadGroup {
+  friend class Thread;
+  typedef std::list<Thread *> ThreadList;
+private:
+  int maxPriority;
+  ThreadGroup * parent;
+  std::string name;
+  ThreadList threads;
+  bool daemon; 
+
+  void addThreadToGroup (Thread *);
+  void removeThreadFromGroup (Thread *);
+public:
+  ThreadGroup (const std::string &);
+  ThreadGroup (ThreadGroup *, const std::string &);
+  ~ThreadGroup (void);
+
+  bool parentOf (ThreadGroup *);
+  bool checkAccess (void);
+
+  inline bool isDaemon (void) const { return this->daemon; }
+  
+  inline const ThreadGroup * getParent (void) const { return this->parent; }
+  inline const std::string & getName (void) const { return this->name; }
+  inline int getMaxPriority (void) const { return this->maxPriority; }
+
+  inline void setMaxPriority (int priority) { this->maxPriority = priority; }
+  inline void setDaemon (bool daemon) { this->daemon = daemon; }
+};
+
+}
+
+#endif
diff --git a/src/realtime/concurrent/ThreadPool.cpp b/src/realtime/concurrent/ThreadPool.cpp
new file mode 100755
index 0000000..b4a0dcb
--- /dev/null
+++ b/src/realtime/concurrent/ThreadPool.cpp
@@ -0,0 +1,71 @@
+#include "ThreadPool.hpp"
+using namespace concurrent;
+
+ThreadPool::ThreadPool (int nMaxThreads) {
+  this->running = false;
+
+  for (int ii = 0; ii < nMaxThreads; ii++)
+    {
+      std::string name = std::string("Thread ");
+      name.push_back (ii);
+      Thread * t = new Thread (new Task (this), name);
+      this->threads.push_back (t);
+    }
+}
+
+ThreadPool::~ThreadPool (void) {
+  if (this->running == true)
+    this->stop(true);
+
+  std::list<Thread *>::iterator it = this->threads.begin();
+  while (it != this->threads.end())
+    {
+      Thread * t = (*it++);
+      delete t;
+    }
+
+  while (this->runQueue.size() > 0)
+    {
+      IRunnable * r = this->runQueue.pop();
+      delete r;
+    }
+}
+
+void 
+ThreadPool::start (void) {
+  this->running = true;
+
+  std::list<Thread *>::iterator it = this->threads.begin();
+  while (it != this->threads.end())
+    {
+      (*it)->start();
+      it++;
+    }
+}
+
+void
+ThreadPool::stop (bool join = false) {
+  this->running = false;
+
+  /* Waiting to join all of the threads will mean that the thread that the
+     pool is calling the stop() method from will block until all of the 
+     threads inside of the pool have stopped.
+
+     There is a PROBLEM here. If you call this, for some reason, from inside
+     of one of the Task threads then you are going to hit a deadlock. Never
+     pass the join parameter if this is being called from inside the Tasks. */
+  if (join == true)
+    {
+      std::list<Thread *>::iterator it = this->threads.begin();
+      while (it != this->threads.end())
+	{
+	  (*it)->join ();
+	  it++;
+	}
+    }
+}
+
+void
+ThreadPool::execute (IRunnable * runner) {
+  this->runQueue.push (runner);
+}
diff --git a/src/realtime/concurrent/ThreadPool.hpp b/src/realtime/concurrent/ThreadPool.hpp
new file mode 100755
index 0000000..9930080
--- /dev/null
+++ b/src/realtime/concurrent/ThreadPool.hpp
@@ -0,0 +1,71 @@
+#ifndef HPP_THREAD_THREADPOOL
+#define HPP_THREAD_THREADPOOL
+
+#include "Mutex.hpp"
+#include "Thread.hpp"
+#include "Queue.hpp"
+#include <queue>
+#include <list>
+
+namespace concurrent {
+
+/* @description: This is a ThreadPool object that will keep N concurrent
+   threads running. Runnable objects can be attached to this object and they
+   will be executed immediately as a thread becomes available to run them. 
+   @author: John `jb Bellone (jvb4@njit.edu)
+   @basis: http://ibm.com/developerworks/java/library/j-jtp0730.html */
+class ThreadPool {
+  /* @description: This object is an individual task that will be spawned at
+     the start of the ThreadPool. Each thread periodically checks the pool
+     object for any available Runnable objects from the queue. If there are
+     such objects it will take them off, run them and delete them. */
+  class Task : public IRunnable {
+  private:
+    ThreadPool * pool;
+  public:
+    Task (ThreadPool * pool) {
+      this->pool = pool;
+    }
+      
+    void * run (void *) {
+      this->running = true;
+
+      while (this->running == true)
+	{
+	  if (pool->isRunning() == false)
+	    break;
+
+	  if (pool->getQueueSize() > 0)
+	    {
+	      IRunnable * runner = pool->removeFromQueue();
+	      runner->run(NULL);
+	      delete runner;
+	    }
+	  ::sleep (1);
+	}
+      return NULL;
+    }
+  };
+private:
+  concurrent::Queue<IRunnable *> runQueue;
+  std::list<Thread *> threads;
+  bool running;
+public:  
+  ThreadPool (int);
+  ~ThreadPool (void);
+
+  /* Thread un-Safe Methods */
+  void start (void);
+  void stop (bool);
+
+  /* Thread-Safe Methods */
+  void execute (IRunnable *);
+  inline IRunnable * removeFromQueue (void) { return this->runQueue.pop(); }
+  inline bool isRunning (void) const { return this->running; }
+  inline int getMaxThreads (void) const { return this->threads.size(); }
+  inline size_t getQueueSize (void) { return this->runQueue.size(); }
+};
+
+}
+
+#endif
diff --git a/src/realtime/network/Socket.hpp b/src/realtime/network/Socket.hpp
new file mode 100755
index 0000000..7ef0fa3
--- /dev/null
+++ b/src/realtime/network/Socket.hpp
@@ -0,0 +1,17 @@
+#ifndef HPP_NETWORK_SOCKET
+#define HPP_NETWORK_SOCKET
+
+#include <cstring>
+
+class ISocket {
+protected:
+  int sockfd;
+public:
+  virtual ~ISocket (void) { }
+
+  virtual void close (void) = 0;
+  virtual int send (const char * bytes, size_t length) = 0;
+  virtual int receive (char * btyes, size_t size) = 0;
+};
+
+#endif
diff --git a/src/realtime/network/Tcp.cpp b/src/realtime/network/Tcp.cpp
new file mode 100755
index 0000000..cd3c9b4
--- /dev/null
+++ b/src/realtime/network/Tcp.cpp
@@ -0,0 +1,142 @@
+#include "Tcp.hpp"
+#include <iostream>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <netdb.h>
+
+/*****************************************************************************/
+
+TcpSocket::TcpSocket (void) {
+  this->sockfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+}
+
+TcpSocket::~TcpSocket (void) {
+  this->close();
+}
+
+void
+TcpSocket::close (void) {
+  if (this->sockfd > 0)
+    ::close (this->sockfd);
+}
+	
+int
+TcpSocket::send (const char * bytes, size_t length) {
+  return ::send (this->sockfd, bytes, length, 0);
+}
+
+int
+TcpSocket::receive (char * bytes, size_t size) {
+  return ::recv (this->sockfd, bytes, size, 0);
+}
+
+/*****************************************************************************/
+
+TcpServerSocket::TcpServerSocket (int port) : TcpSocket() {
+  this->port = port;
+
+  memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+  this->sockaddr.sin_family = AF_INET;
+  this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+  this->sockaddr.sin_port = htons (this->port);
+}
+
+TcpServerSocket::~TcpServerSocket (void) {
+  this->close();
+}
+
+bool
+TcpServerSocket::start (int backlog = 5) {
+  // This is to prevent conflicts with major services' ports.
+  if (this->port < 50)
+    return false;
+
+  if (::bind (this->sockfd,
+	      (struct sockaddr *)&(this->sockaddr),
+	      sizeof (this->sockaddr)) < 0)
+    return false;
+
+  if (::listen (this->sockfd, backlog) < 0)
+    return false;
+
+  return true;
+}
+
+void
+TcpServerSocket::close (void) {
+  TcpSocket::close();
+}
+
+TcpServerSocket::Acceptor *
+TcpServerSocket::newAcceptor (void) {
+  return new TcpServerSocket::Acceptor (this, this->sockfd);
+}
+
+/*****************************************************************************/
+
+TcpServerSocket::Acceptor::Acceptor (TcpServerSocket * server, int sockfd) {
+  this->socket = server;
+  this->sockfd = sockfd;
+}
+
+int
+TcpServerSocket::Acceptor::acceptIncoming (void) {
+  int newfd = -1;
+  static struct sockaddr_in clientaddr;
+  unsigned int x = sizeof (clientaddr);
+
+  if ((newfd = ::accept (this->sockfd, 
+			 (struct sockaddr *)&clientaddr,
+			 &x)) < 0)
+    return -1;
+  return newfd;
+}
+
+/*****************************************************************************/
+
+TcpClientSocket::TcpClientSocket (void) : TcpSocket() {
+  memset (&(this->sockaddr), 0, sizeof (this->sockaddr));
+  this->sockaddr.sin_family = AF_INET;
+  this->sockaddr.sin_addr.s_addr = htonl (INADDR_ANY);
+}
+				
+TcpClientSocket::~TcpClientSocket (void) {
+}
+
+bool
+TcpClientSocket::connect (const char * host, int port) {
+  struct sockaddr_in servAddr;
+  struct hostent * h;
+
+  if (!host || (*host == '\0'))
+    return false;
+
+  if (this->sockfd < 0)
+    return false;
+
+  if ((h = ::gethostbyname (host)) == NULL)
+    return false;
+
+  servAddr.sin_family = h->h_addrtype;
+  memcpy ((char *)&(servAddr.sin_addr.s_addr),
+	  h->h_addr_list[0],
+	  h->h_length);
+  servAddr.sin_port = htons (port);
+  
+  if (::bind (this->sockfd,
+	      (struct sockaddr *)&(this->sockaddr),
+	      sizeof (this->sockaddr)) < 0)
+    return false;
+
+  if (::connect (this->sockfd,
+		 (struct sockaddr *)&(this->sockaddr),
+		 sizeof (this->sockaddr)) < 0)
+    return false;
+  return true;  
+}
+
+void
+TcpClientSocket::close (void) {
+  TcpSocket::close();
+}
diff --git a/src/realtime/network/Tcp.hpp b/src/realtime/network/Tcp.hpp
new file mode 100755
index 0000000..fade7df
--- /dev/null
+++ b/src/realtime/network/Tcp.hpp
@@ -0,0 +1,52 @@
+#ifndef HPP_NETWORK_TCP
+#define HPP_NETWORK_TCP
+
+#include "Socket.hpp"
+#include <arpa/inet.h>
+#include <netinet/in.h>
+
+class TcpSocket : public ISocket {
+public:
+  TcpSocket (void);
+  virtual ~TcpSocket (void);
+
+  void close (void);
+  int send (const char * bytes, size_t length);
+  int receive (char * bytes, size_t size);
+};
+
+class TcpServerSocket : public TcpSocket {
+private:
+  struct sockaddr_in sockaddr;
+  int port;
+public:
+  class Acceptor {
+  private:
+    TcpServerSocket * socket;
+    int sockfd;
+  public:
+    Acceptor (TcpServerSocket * server, int sockfd);
+
+    int acceptIncoming (void);
+  };
+
+  TcpServerSocket (int port);
+  virtual ~TcpServerSocket (void);
+
+  bool start (int backlog);
+  void close (void);
+  Acceptor * newAcceptor (void);
+};
+
+class TcpClientSocket : public TcpSocket {
+private:
+  struct sockaddr_in sockaddr;
+public:
+  TcpClientSocket (void);
+  virtual ~TcpClientSocket (void);
+
+  bool connect (const char * host, int port);
+  void close (void);
+};
+
+#endif
diff --git a/src/realtime/plugin_main.cpp b/src/realtime/plugin_main.cpp
new file mode 100755
index 0000000..4e958e0
--- /dev/null
+++ b/src/realtime/plugin_main.cpp
@@ -0,0 +1,52 @@
+#include <iostream>
+#include <glib/gthread.h>
+#include <workbook/workbook.h>
+#include "concurrent/ThreadArgs.hpp"
+#include "../application.h"
+#include "../plugin.h"
+
+/* Prototypes */
+extern void thread_main (ThreadArgs *);
+
+extern "C"
+{
+  Workbook *
+  plugin_main (ApplicationState * app, Plugin * plugin)
+  {
+    ASSERT (app != NULL);
+    ASSERT (plugin != NULL);
+
+    Workbook * wb = NULL;
+    GtkWidget * hbox = gtk_handle_box_new ();
+    
+    if ((wb = workbook_open (app->gtk_window, "realtime")) == NULL)
+      {
+	g_critical ("Failed opening workbook; exiting plugin");
+	return NULL;
+      }
+
+    wb->signals[SIG_WORKBOOK_CHANGED] = app->signals[SIG_SHEET_CHANGED];
+
+    gtk_container_add (GTK_CONTAINER (hbox), wb->gtk_notebook);
+ 
+    wb->gtk_box = hbox;
+    
+    wb->add_new_sheet (wb, "sheet0", 100, 11);
+
+    ThreadArgs args;
+    args.push_back( (void *)wb );
+    args.push_back( (void *)app->cfg );
+
+    if (plugin->create_thread (plugin, 
+			       (GThreadFunc)thread_main,
+			       (gpointer)new ThreadArgs (args)
+			       ) == NULL)
+      {
+	g_critical ("Failed creating thread; exiting plugin");
+	return NULL;
+      }
+   
+    gtk_widget_show (hbox);
+    return wb;
+  }
+}
diff --git a/src/realtime/proactor/Dispatcher.hpp b/src/realtime/proactor/Dispatcher.hpp
new file mode 100755
index 0000000..34604ac
--- /dev/null
+++ b/src/realtime/proactor/Dispatcher.hpp
@@ -0,0 +1,29 @@
+#ifndef HPP_PROACTOR_DISPATCHER
+#define HPP_PROACTOR_DISPATCHER
+
+#include "../concurrent/Thread.hpp"
+
+namespace proactor {
+
+  class Proactor;
+
+  class Dispatcher : public concurrent::Thread {
+  private:
+    int eid;
+  protected:
+    Proactor * pro;
+  public:
+    virtual ~Dispatcher (void) { }
+
+    inline void setEventId (int e) {
+      this->eid = e;
+    }
+
+    inline int getEventId (void) {
+      return this->eid;
+    }
+  };
+
+}
+
+#endif
diff --git a/src/realtime/proactor/Event.cpp b/src/realtime/proactor/Event.cpp
new file mode 100755
index 0000000..d21d35b
--- /dev/null
+++ b/src/realtime/proactor/Event.cpp
@@ -0,0 +1,14 @@
+#include "Event.hpp"
+using namespace proactor;
+
+int Event::numEvents = 0;
+
+Event::Event (int e, const std::string & buf) {
+  this->id = e;
+  this->buf = buf;
+}
+
+int
+Event::uniqueEventId (void) {
+  return Event::numEvents++;
+}
diff --git a/src/realtime/proactor/Event.hpp b/src/realtime/proactor/Event.hpp
new file mode 100755
index 0000000..2680276
--- /dev/null
+++ b/src/realtime/proactor/Event.hpp
@@ -0,0 +1,22 @@
+#ifndef HPP_PROACTOR_EVENT
+#define HPP_PROACTOR_EVENT
+
+#include <string>
+
+namespace proactor {
+
+  class Event {
+  private:
+    static int numEvents;
+  public:
+    int id;
+    std::string buf;
+
+    Event (int id, const std::string & buf);
+
+    static int uniqueEventId (void);
+  };
+
+}
+
+#endif
diff --git a/src/realtime/proactor/Job.hpp b/src/realtime/proactor/Job.hpp
new file mode 100755
index 0000000..adaf5b0
--- /dev/null
+++ b/src/realtime/proactor/Job.hpp
@@ -0,0 +1,21 @@
+#ifndef HPP_PROACTOR_JOB
+#define HPP_PROACTOR_JOB
+
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/Thread.hpp"
+#include <string>
+
+namespace proactor {
+
+  class Job : public concurrent::Thread {
+  protected:
+    concurrent::Queue<std::string> inputQueue;
+  public:
+    inline void pushInputQueue (std::string buf) {
+      this->inputQueue.push (buf);
+    }
+  };
+
+}
+
+#endif
diff --git a/src/realtime/proactor/Proactor.cpp b/src/realtime/proactor/Proactor.cpp
new file mode 100755
index 0000000..1d30f58
--- /dev/null
+++ b/src/realtime/proactor/Proactor.cpp
@@ -0,0 +1,124 @@
+#include "Proactor.hpp"
+#include <iostream>
+using namespace proactor;
+
+Proactor::Proactor (void) {
+}
+
+Proactor::~Proactor (void) {
+  // Remove all of the lists of event handlers.
+  {
+    EventMapType::iterator it = this->eventsToHandlers.begin();
+    while (it != this->eventsToHandlers.end())
+      {
+	EventHandlers * q = (it->second);
+	delete q;
+	it++;
+      }
+  }
+
+  // Handle the dispatchers that have not been manually removed.
+  {
+    DispatcherList::iterator it = this->dispatchers.begin();
+    while (it != this->dispatchers.end())
+      {
+	Dispatcher * d = (*it);
+	delete d;
+	it++;
+      }
+  }
+}
+
+void
+Proactor::registerHandler (int e, Job * job) {
+  this->eventsToHandlers.lock();
+  {
+    EventMapType::iterator it = this->eventsToHandlers.find (e);
+  
+    if (it == this->eventsToHandlers.end())
+      this->eventsToHandlers[e] = new EventHandlers;  
+    this->eventsToHandlers[e]->push_back (job);
+  }
+  this->eventsToHandlers.unlock();
+}
+
+void 
+Proactor::onReadComplete (int e, const char * buf) {
+  this->inputQueue.push ( Event (e, std::string (buf)) );   
+}
+
+bool
+Proactor::unregisterHandler (int e, Job * job) {
+  bool result = false;
+
+  this->eventsToHandlers.lock();
+  {
+    EventHandlers::iterator it = 
+      std::find (this->eventsToHandlers[e]->begin(),
+		 this->eventsToHandlers[e]->end(),
+		 job);
+    
+    if (it != this->eventsToHandlers[e]->end())
+      {
+	this->eventsToHandlers[e]->erase (it);
+	result = true;
+      }
+  }
+  this->eventsToHandlers.unlock();
+   
+  return result;
+}
+
+void
+Proactor::addDispatcher (Dispatcher * d) {
+  this->dispatchers.push_back (d);
+}
+
+bool
+Proactor::removeDispatcher (Dispatcher * d) {
+  DispatcherList::iterator it = std::find (this->dispatchers.begin(),
+					   this->dispatchers.end(),
+					   d);
+
+  if (it == this->dispatchers.end())
+    return false;
+  
+  this->dispatchers.erase (it);
+  return true;
+}
+
+void *
+Proactor::run (void * null) {
+  this->running = true;
+  
+  EventHandlers::iterator it;
+
+  while (this->running == true)
+    {
+      this->inputQueue.lock();
+      while (this->inputQueue.size() > 0)
+	{
+	  Event e = this->inputQueue.pop();
+
+	  // We are throwing events with no handlers to catch them.
+	  if (this->eventsToHandlers.find (e.id) == 
+	      this->eventsToHandlers.end())
+	    continue;
+ 
+	  it = this->eventsToHandlers[e.id]->begin();
+	  
+	  while (it != this->eventsToHandlers[e.id]->end())
+	    {
+	      Job * j = (*it);
+	      
+	      j->pushInputQueue (e.buf);
+		      
+	      it++;
+	    }
+	}
+      this->inputQueue.unlock();
+      
+      Thread::sleep(100);
+    }
+  return NULL;
+}
diff --git a/src/realtime/proactor/Proactor.hpp b/src/realtime/proactor/Proactor.hpp
new file mode 100755
index 0000000..d47e8ca
--- /dev/null
+++ b/src/realtime/proactor/Proactor.hpp
@@ -0,0 +1,48 @@
+#ifndef HPP_PROACTOR_PROACTOR
+#define HPP_PROACTOR_PROACTOR
+
+#include "../concurrent/Thread.hpp"
+#include "../concurrent/Map.hpp"
+#include "../concurrent/Queue.hpp"
+#include "../concurrent/List.hpp"
+#include "Job.hpp"
+#include "Event.hpp"
+#include "Dispatcher.hpp"
+#include <list>
+#include <queue>
+
+namespace proactor {
+
+  class Dispatcher;
+
+  class Proactor : public concurrent::Thread {
+  private:
+    typedef std::list<Job *> EventHandlers;
+    typedef concurrent::List<Dispatcher *> DispatcherList;
+    typedef concurrent::Map<int, EventHandlers *> EventMapType;
+    typedef concurrent::Queue<Event> EventQueueType;
+    
+    EventMapType eventsToHandlers;
+    DispatcherList dispatchers;
+    EventQueueType inputQueue;
+  public:
+    Proactor (void);
+    virtual ~Proactor (void);
+
+    void registerHandler (int e, Job * job);
+    bool unregisterHandler (int e, Job * job);
+    void addDispatcher (Dispatcher * d);
+    bool removeDispatcher (Dispatcher * d);
+    
+    void * run (void * null);
+ 
+    void onReadComplete (int e, const char * buf);
+
+    inline const std::string & peekInputQueue (void) {
+      return (this->inputQueue.front()).buf;
+    }
+  };
+
+}
+
+#endif
diff --git a/src/realtime/thread_main.cpp b/src/realtime/thread_main.cpp
new file mode 100755
index 0000000..4d4df9f
--- /dev/null
+++ b/src/realtime/thread_main.cpp
@@ -0,0 +1,115 @@
+#include <workbook/workbook.h>
+#include <config/config.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <cstdlib>
+#include <signal.h>
+#include <iostream>
+#include <sstream>
+#include <string>
+#include "concurrent/ThreadArgs.hpp"
+#include "proactor/Proactor.hpp"
+#include "proactor/Event.hpp"
+#include "AcceptThread.hpp"
+#include "PacketHandler.hpp"
+#include "Packet.hpp"
+
+/* @description: This method creates a filename with the prefix supplied and
+   uses the pid of the process as its suffix. 
+   @pre: The prefix (should be a file path, obviously). */
+static std::string
+append_pidname (const gchar * pre) {
+  std::stringstream s;
+  s << pre << getppid();
+  return s.str();
+}
+
+/* @description: This is the main execution function for the thread.
+   @wb: The Workbook that the thread will be changing. */
+void
+thread_main (ThreadArgs * args) {
+  g_usleep (5000000); /* 5 seconds - initial startup delay */
+
+  Workbook * wb = (Workbook *)args->at(0);
+  Config * cfg  = (Config *)args->at(1);
+
+  ConfigPair * logpath = cfg->get_pair (cfg, "realtime", "log", "path");
+  if (IS_NULL (logpath))
+    {
+      g_critical ("Failed loading log->path from configuration file; "
+		  "exiting thread");
+      return;
+    }
+
+  ConfigPair * servport = cfg->get_pair (cfg, "realtime", "tcp", "port");
+  if (IS_NULL (servport))
+    {
+      g_critical ("Failed loading tcp->port from configuration file; "
+		  "exiting thread");
+      return;
+    }
+
+  FILE * pktlog = NULL;
+  std::string logname = std::string (logpath->value).append("/");
+  logname.append (append_pidname("realtime.").append(".log"));
+
+  if ((pktlog = fopen (logname.c_str(), "w")) == NULL)
+    {
+      g_critical ("Failed opening file '%s' for packet logging; exiting"
+		  " thread", logname.c_str());
+      return;
+    }
+
+  /* Start up the Tcp Socket server on the port specified inside of the
+     configuration file. This IS NOT a separate thread. */
+  int port = atoi(servport->value);
+  TcpServerSocket socket ( port );
+  if (socket.start(5) == false)
+    {
+      g_critical ("Failed starting TcpServerSocket on port localhost:%d;"
+		  " exiting thread", port);
+      return;
+    }
+  
+  // Get a unique event identifier that will be used throughout.
+  int e = proactor::Event::uniqueEventId();
+
+  proactor::Proactor proactor;
+  if (proactor.start() == false)
+    {
+      g_critical ("Failed starting Proactor; exiting thread.");
+      return;
+    }
+
+  PacketHandler handler (wb, pktlog);
+  proactor.registerHandler (e, &handler);
+  if (handler.start() == false) 
+    {
+      g_critical ("Failed starting PacketHandler; exiting thread.");
+      return;
+    }
+  
+  AcceptThread acceptor ( socket.newAcceptor(), &proactor );
+  acceptor.setEventId (e);
+  if (acceptor.start() == false)
+    {
+      g_critical ("Failed starting Acceptor; exiting thread.");
+      return;
+    }
+ 
+  while (!IS_NULLSTR (wb->filename)) 
+    {
+      // Continually sleep basically until our application terminates.
+      ::sleep (1);
+    }
+
+  FCLOSE (pktlog);
+
+  // Interrupt threads immediately canceling them so we can quit.
+  acceptor.interrupt();
+  handler.interrupt();
+  proactor.interrupt();
+
+  socket.close();  
+}
diff --git a/workbook/Makefile b/workbook/Makefile
new file mode 100755
index 0000000..ccf9b7d
--- /dev/null
+++ b/workbook/Makefile
@@ -0,0 +1,30 @@
+include ../Makefile.base
+
+SRCS=$(wildcard *.c)
+OBJS=$(patsubst %.c,${OBJDIR}/libworkbook/%.o,${SRCS})
+
+all: 	libworkbook
+
+install:
+	${RM} ${INSLIBDIR}/libworkbook.a ${INSLIBDIR}/libworkbook.so.1 \
+	${INSLIBDIR}/libworkbook.so.1
+	${CP} ${PROJDIR}/lib/libworkbook.so ${INSLIBDIR}/libworkbook.so.1
+	${LN} ${INSLIBDIR}/libworkbook.so.1 ${INSLIBDIR}/libworkbook.a
+	${LN} ${INSLIBDIR}/libworkbook.a ${INSLIBDIR}/libworkbook.so
+#	chcon -t textrel_shlib_t ${INSLIBDIR}/libworkbook.so.1
+
+libworkbook: ${OBJS}
+	${RM} ${PROJDIR}/lib/libworkbook.so.1 ${PROJDIR}/lib/libworkbook.so
+	${CC} -shared -Wl,-soname,libworkbook.so.1 \
+	-o ${PROJDIR}/lib/libworkbook.so ${OBJS} ${LIBS} \
+	-lgtkextra-x11-2.0 -ldl -gthread-2.0
+	${LN} ${PROJDIR}/lib/libworkbook.so ${PROJDIR}/lib/libworkbook.so.1
+clean:		
+	${MD} ${OBJDIR}/libworkbook	
+	${RM} ${OBJS} ${PROJDIR}/lib/libworkbook.so.1
+
+${OBJDIR}/libworkbook/%.o: %.c
+	${CC} ${INCS} -c -fPIC ${CCFLAGS} $< -o $@
+
+.c.o:
+	${CC} ${INCS} -c -fPIC ${CCFLAGS} $<
diff --git a/workbook/cell.c b/workbook/cell.c
new file mode 100755
index 0000000..6dbff41
--- /dev/null
+++ b/workbook/cell.c
@@ -0,0 +1,181 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#include <workbook/cell.h>
+
+/* cell.c (static) */
+static Cell *cell_object_init (void);
+static void cell_object_free (Cell *);
+static void cell_method_set_value (Cell *, const gchar *);
+static void cell_method_set_column (Cell *, gint);
+static void cell_method_set_row (Cell *, gint);
+static void cell_method_set_all (Cell *, gint, gint, const gchar *);
+static void cell_method_set_justification (Cell *, GtkJustification);
+static void cell_method_destroy (Cell *);
+static void cell_method_set_bgcolor (Cell *, const gchar *);
+static void cell_method_set_fgcolor (Cell *, const gchar *);
+static void cell_method_set_attributes (Cell *, const CellAttributes *);
+static void cell_method_set_range (Cell *, const GtkSheetRange *);
+
+/* @description: The function returns a pointer to a Cell object. */
+Cell *
+cell_new (void)
+{
+  Cell * cell = cell_object_init ();
+  return cell;
+}
+
+/* @description: This function is the Cell object's constructor. */
+static Cell *
+cell_object_init (void)
+{
+  Cell * cell = NEW (Cell);
+
+  cell->attributes.bgcolor = g_string_new_len ("", 4096);
+  cell->attributes.fgcolor = g_string_new_len ("", 4096);
+  cell->value = g_string_new_len ("", 4096);
+
+  /* Methods */
+  cell->set_fgcolor = cell_method_set_fgcolor;
+  cell->set_bgcolor = cell_method_set_bgcolor;
+  cell->set_attributes = cell_method_set_attributes;
+  cell->set_range = cell_method_set_range;
+  cell->set_value = cell_method_set_value;
+  cell->set_column = cell_method_set_column;
+  cell->set_row = cell_method_set_row;
+  cell->set = cell_method_set_all;
+  cell->set_justification = cell_method_set_justification;
+  cell->destroy = cell_method_destroy;
+
+  return cell;
+}
+
+/* @description: This object frees the memory created by the Cell object.
+   @cell: The pointer to the object to free. */
+static void
+cell_object_free (Cell * cell)
+{
+  ASSERT (cell != NULL);
+
+  g_string_free (cell->value, TRUE);
+  g_string_free (cell->attributes.fgcolor, TRUE);
+  g_string_free (cell->attributes.bgcolor, TRUE);
+  FREE (cell);
+}
+
+/* @description: This method sets a cell in the GtkSheet with the attributes
+   of a Cell object.
+   @row: An integer value of the row to set.
+   @column: An integer value fo the column to set.
+   @value: A string value to what should be set in the Cell. */
+static void
+cell_method_set_all (Cell * cell, 
+		     gint row, gint column, 
+		     const gchar * value)
+{
+  ASSERT (cell != NULL);
+
+  g_string_assign (cell->value, value);
+  cell->row = row;
+  cell->column = column;  
+}
+
+/* @description: This method sets the justification of the specified Cell
+   object.
+   @justification: The GtkJustification value for the cell. */
+static void
+cell_method_set_justification (Cell * cell, 
+			       GtkJustification justification)
+{
+  ASSERT (cell != NULL);
+  cell->attributes.justification = justification;
+}
+
+/* @description: The method sets the row of the Cell object.
+   @row: Integer value of the row. */
+static void
+cell_method_set_row (Cell * cell, 
+		     gint row)
+{
+  ASSERT (cell != NULL);
+  cell->row = row;
+  cell->range.row0 = cell->range.rowi = row;
+}
+
+/* @description: The method sets the column of the Cell object.
+   @column: Integer value fo the column. */
+static void
+cell_method_set_column (Cell * cell, 
+			gint column)
+{
+  ASSERT (cell != NULL);
+  cell->column = column;
+  cell->range.col0 = cell->range.coli = column;
+}
+
+/* @description: This method sets the bgcolor of the Cell object.
+   @color: String value of the color, e.g. white, blue, red. */
+static void
+cell_method_set_bgcolor (Cell * cell, 
+			 const gchar * color)
+{
+  ASSERT (cell != NULL);
+
+  g_string_assign (cell->attributes.bgcolor, color);
+}
+
+/* @description: This method sets the fgcolor of the Cell object.
+   @color: String value of the color, e.g. white, blue, red. */
+static void 
+cell_method_set_fgcolor (Cell * cell, 
+			 const gchar *color)
+{
+  ASSERT (cell != NULL);
+  
+  g_string_assign (cell->attributes.fgcolor, color);
+}
+
+/* @description: This method sets the range of the Cell object.
+   @range: A pointer to a GtkSheetRange object. */
+static void
+cell_method_set_range (Cell * cell, 
+		       const GtkSheetRange * range)
+{
+  ASSERT (cell != NULL); ASSERT (range != NULL);
+  
+  cell->range.row0 = range->row0;
+  cell->range.col0 = range->col0;
+  cell->range.rowi = range->rowi;
+  cell->range.coli = range->coli;
+}
+
+/* @description: This method sets the attributes of the Cell object.
+   @attrib: A pointer to the Cell Attributes object. */
+static void
+cell_method_set_attributes (Cell * cell, 
+			    const CellAttributes * attrib)
+{
+  ASSERT (cell != NULL); ASSERT (attrib != NULL);
+
+  cell->attributes.justification = attrib->justification;
+ 
+  g_string_assign (cell->attributes.fgcolor, attrib->fgcolor->str);
+  g_string_assign (cell->attributes.bgcolor, attrib->bgcolor->str);
+}
+
+/* @description: This method sets the text value of the Cell object.
+   @value: This is a string pointer to the value. */
+static void
+cell_method_set_value (Cell * cell, 
+		       const gchar * value)
+{
+  ASSERT (cell != NULL);
+  
+  g_string_assign (cell->value, value);
+}
+
+static void
+cell_method_destroy (Cell * cell)
+{
+  g_return_if_fail (cell != NULL);
+
+  cell_object_free (cell);
+}
diff --git a/workbook/sheet.c b/workbook/sheet.c
new file mode 100644
index 0000000..308e60c
--- /dev/null
+++ b/workbook/sheet.c
@@ -0,0 +1,460 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#include <workbook/sheet.h>
+#include <string.h>
+
+/* sheet.c (static) */
+static Sheet *sheet_object_init (Workbook *, const gchar *, gint, gint);
+static void sheet_object_free (Sheet *);
+static void sheet_method_destroy (Sheet *);
+static void sheet_method_set_cell (Sheet *, gint, gint, const gchar *);
+static void sheet_method_apply_cell (Sheet *, const Cell *);
+static void sheet_method_apply_cellarray (Sheet *, const Cell **, gint);
+static void sheet_method_apply_cellrange (Sheet *, 
+					  const GtkSheetRange *,
+					  const CellAttributes *);
+static void sheet_method_range_set_background (Sheet *, 
+					       const GtkSheetRange *,
+					       const gchar *);
+static void sheet_method_range_set_foreground (Sheet *,
+					       const GtkSheetRange *,
+					       const gchar *);
+static void sheet_method_set_attention (Sheet *, gint);
+static gboolean sheet_method_load (Sheet *, const gchar *);
+static gboolean sheet_method_save (Sheet *, const gchar *);
+
+struct geometryFileHeader
+{
+  gint fileVersion;
+  gint maxRow;
+  gint maxColumn;
+};
+
+struct geometryFileEntry
+{
+  gint cellRow;
+  gint cellCol;
+  gint cellTextLength;
+  gboolean cellIsVisible;
+  gboolean cellIsEditable;
+  GtkJustification cellJustification;
+  GdkColor cellForeground;
+  GdkColor cellBackground;
+};
+
+/* @description: This method creates a new Sheet object and returns the
+   pointer to that object. It calls the constructor function to do so.
+   @book: A pointer to the Workbook that the object will be a part of.
+   @label: A string to the Sheet's label. 
+   @rows: The number of rows.
+   @columns: The number of columns. */
+Sheet *
+sheet_new (Workbook * book, const gchar * label, gint rows, gint columns)
+{
+  ASSERT (book != NULL);
+  
+  Sheet * sheet = sheet_object_init (book, label, rows, columns);
+
+  /* STUB: Perform anything that is based on a style here. */
+
+  return sheet;
+}
+
+/* @description: This function is the Sheet's constructor. 
+   @book: A pointer to the Workbook that the Sheet object will be assigned.
+   @label: A string label - the name of the sheet that we will use to search.
+   @rows: The amount of rows the GtkSheet widget should have.
+   @cols: The amount of columns the GtkSheet widget should have. */
+static Sheet *
+sheet_object_init (Workbook * book,
+		   const gchar * label, 
+		   gint rows, gint columns)
+{
+  gdk_threads_enter ();
+  Sheet * sheet = NEW (Sheet);
+
+  /* Create the sheet containers and GtkSheet object. */
+  sheet->gtk_box = gtk_vbox_new (FALSE, 1);
+  gtk_widget_show (sheet->gtk_box);
+
+  GtkWidget * scrolled_window = gtk_scrolled_window_new (NULL, NULL);
+  gtk_box_pack_start (GTK_BOX (sheet->gtk_box), scrolled_window, 1,1,1);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
+				  GTK_POLICY_AUTOMATIC,
+				  GTK_POLICY_AUTOMATIC);
+  gtk_widget_show (scrolled_window);
+
+  sheet->gtk_label = gtk_label_new (label);
+  
+  sheet->gtk_sheet = gtk_sheet_new (rows, columns, label);
+  gtk_sheet_set_autoresize (GTK_SHEET (sheet->gtk_sheet), TRUE);
+  gtk_container_add (GTK_CONTAINER (scrolled_window),
+		     GTK_WIDGET (sheet->gtk_sheet));
+  gtk_widget_show (sheet->gtk_sheet);
+
+  /* We should be able to use sheet->gtk_box now throughout all of our
+     tests when iterating through a GtkNotebook structure. The page number
+     will change when something is removed (or reordered). The pointer will
+     stay the same. */
+  sheet->page = gtk_notebook_append_page (GTK_NOTEBOOK (book->gtk_notebook),
+					  sheet->gtk_box,
+					  sheet->gtk_label);
+  /* Members */
+  sheet->workbook = book;
+  sheet->name = g_strdup (label);
+  sheet->attention = 0;
+  sheet->notices = 0;
+  sheet->has_focus = FALSE;
+  sheet->next = sheet->prev = NULL;
+
+  /* Methods */
+  sheet->destroy = sheet_method_destroy;
+  sheet->set_cell = sheet_method_set_cell;
+  sheet->apply_range = sheet_method_apply_cellrange;
+  sheet->apply_array = sheet_method_apply_cellarray;
+  sheet->apply_cell = sheet_method_apply_cell;
+  sheet->range_set_foreground = sheet_method_range_set_foreground;
+  sheet->range_set_background = sheet_method_range_set_background;
+  sheet->set_attention = sheet_method_set_attention;
+  sheet->save = sheet_method_save;
+  sheet->load = sheet_method_load;
+
+  /* Connect any signals that we need to. */
+  if (!IS_NULL (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]))
+    {
+      gtk_signal_connect (GTK_OBJECT (sheet->gtk_sheet),
+			  "changed",
+		  G_CALLBACK (sheet->workbook->signals[SIG_WORKBOOK_CHANGED]),
+			  (gpointer)sheet);
+    }
+
+  gdk_threads_leave ();
+  return sheet;
+}
+
+static gboolean
+sheet_method_load (Sheet * sheet, const gchar * filepath)
+{
+  ASSERT (sheet != NULL);
+
+  if (IS_NULLSTR (filepath))
+    {
+      g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
+      return FALSE;
+    }
+
+  FILE * fp = NULL;
+  if ((fp = fopen (filepath, "rb")) == NULL)
+    {
+      g_warning ("%s: failed opening file '%s' for reading", 
+		 __FUNCTION__,
+		 filepath);
+      return FALSE;
+    }
+
+  gdk_threads_enter ();
+  GtkSheet * gtksheet = GTK_SHEET (sheet->gtk_sheet);
+  struct geometryFileHeader header = {-1,-1,-1};
+  struct geometryFileEntry entry = {-1,-1,-1};
+ 
+  fread ((void *)&header, sizeof (struct geometryFileHeader), 1, fp);
+
+  if (header.fileVersion != GEOMETRY_FILE_VERSION)
+    {
+      g_warning ("Geometry file version %d is not accepted. (%d)",
+		 header.fileVersion, GEOMETRY_FILE_VERSION);
+      FCLOSE (fp);
+      gdk_threads_leave ();
+      return FALSE;
+    }
+
+  while (fread ((void *)&entry, sizeof (struct geometryFileEntry), 1, fp) > 0)
+    {
+      gchar * text = g_strndup ("", entry.cellTextLength);
+      fread ((void *)text, sizeof (gchar), entry.cellTextLength, fp);
+      gtk_sheet_set_cell_text (gtksheet, 
+			       entry.cellRow, 
+			       entry.cellCol, 
+			       text);
+      
+      GtkSheetCell ** cell = &gtksheet->data[entry.cellRow][entry.cellCol];
+      
+      (*cell)->attributes->is_editable = entry.cellIsEditable;
+      (*cell)->attributes->is_visible = entry.cellIsVisible;
+      (*cell)->attributes->justification = entry.cellJustification;
+      (*cell)->attributes->foreground.pixel = entry.cellForeground.pixel;
+      (*cell)->attributes->foreground.red = entry.cellForeground.red;
+      (*cell)->attributes->foreground.green = entry.cellForeground.green;
+      (*cell)->attributes->foreground.blue = entry.cellForeground.blue;
+      (*cell)->attributes->background.pixel = entry.cellBackground.pixel;
+      (*cell)->attributes->background.red = entry.cellBackground.red;
+      (*cell)->attributes->background.green = entry.cellBackground.green;
+      (*cell)->attributes->background.blue = entry.cellBackground.blue;
+
+      FREE (text);
+    }
+
+  FCLOSE (fp);
+  gdk_threads_leave ();
+  return TRUE;
+}
+
+static gboolean
+sheet_method_save (Sheet * sheet, const gchar * filepath)
+{
+  ASSERT (sheet != NULL);
+
+  if (IS_NULLSTR (filepath))
+    {
+      g_warning ("%s: filepath cannot be a NULL string", __FUNCTION__);
+      return FALSE;
+    }
+
+  FILE * fp = NULL;
+  if ((fp = fopen (filepath, "wb")) == NULL)
+    {
+      g_warning ("%s: failed opening file '%s' for writing", 
+		 __FUNCTION__, 
+		 filepath);
+      return FALSE;
+    }
+  
+  gdk_threads_enter ();
+  GtkSheetCell *** data = GTK_SHEET (sheet->gtk_sheet)->data;
+  struct geometryFileHeader header =
+    {
+      GEOMETRY_FILE_VERSION,
+      GTK_SHEET (sheet->gtk_sheet)->maxallocrow,
+      GTK_SHEET (sheet->gtk_sheet)->maxalloccol
+    };
+
+  fwrite ((void *)&header, sizeof(struct geometryFileHeader), 1, fp);
+
+  for (gint ii = 0; ii <= header.maxRow; ii++)
+    {
+      for (gint jj = 0; jj <= header.maxColumn; jj++)
+	{
+	  GtkSheetCell * cell = data[ii][jj];
+
+	  if (!IS_NULL (cell) && !IS_NULLSTR(cell->text))
+	    {
+	      struct geometryFileEntry entry =
+		{
+		  cell->row,
+		  cell->col,
+		  strlen (cell->text),
+		  cell->attributes->is_visible,
+		  cell->attributes->is_editable,
+		  cell->attributes->justification
+		};
+
+	      entry.cellForeground.pixel = cell->attributes->foreground.pixel;
+	      entry.cellForeground.red = cell->attributes->foreground.red;
+	      entry.cellForeground.green = cell->attributes->foreground.green;
+	      entry.cellForeground.blue = cell->attributes->foreground.blue;
+	      entry.cellBackground.pixel = cell->attributes->background.pixel;
+	      entry.cellBackground.red = cell->attributes->background.red;
+	      entry.cellBackground.green = cell->attributes->background.green;
+	      entry.cellBackground.blue = cell->attributes->background.blue;
+
+	      fwrite ((void *)&entry, 
+		      sizeof (struct geometryFileEntry), 1, fp);
+	      fwrite ((void *)cell->text, 
+		      sizeof (gchar), entry.cellTextLength, fp);
+	    }
+	}
+    }
+
+  FCLOSE (fp);
+  gdk_threads_leave ();
+  return TRUE;
+}
+
+/* @description: This method sets the attention level of the Sheet.
+   @sheet: A pointer to the Sheet object.
+   @attention: The attention level. */
+static void 
+sheet_method_set_attention (Sheet * sheet, gint attention)
+{
+  ASSERT (sheet != NULL);
+  gdk_threads_enter ();
+
+  sheet->attention = attention;
+
+  /* Do something funky to show that you should be looking at ME!
+     Oh, GtkNotebook tab, why are thou so vain? */
+  if ((sheet->has_focus == FALSE) && (sheet->notices > 0))
+    {
+      
+    }
+
+  gdk_threads_leave ();
+}
+
+/* @description: This method destroys the Sheet object.
+   @sheet: A pointer to the object that will be destroyed. */
+static void
+sheet_method_destroy (Sheet * sheet)
+{
+  ASSERT (sheet != NULL);
+  gdk_threads_enter ();
+
+  DOUBLE_UNLINK (sheet);
+
+  sheet_object_free (sheet);
+
+  gdk_threads_leave ();
+}
+
+/* @description: This method frees the memory that was used by the Sheet
+   object. This should only be called from sheet->destroy()
+   @sheet: A pointer to the Sheet object that will be freed. */
+static void
+sheet_object_free (Sheet * sheet)
+{
+  ASSERT (sheet != NULL);
+
+  FREE (sheet->name);
+  FREE (sheet);
+  return;
+}
+
+static void
+sheet_method_apply_cellrange (Sheet * sheet, 
+			      const GtkSheetRange * range,
+			      const CellAttributes * attrib)
+{
+  ASSERT (sheet != NULL);
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (attrib != NULL);
+  gdk_threads_enter ();
+
+  gdk_threads_leave ();
+}
+
+static void
+sheet_method_apply_cellarray (Sheet * sheet, 
+			      const Cell ** array,
+			      gint size)
+{
+  ASSERT (sheet != NULL);
+  g_return_if_fail (array != NULL);
+
+  gdk_threads_enter ();
+  
+  gdk_threads_leave ();
+}
+
+/* @description: This method applies the settings from a Cell object into the
+   GtkSheet. In order to properly function this should be really the only the
+   GtkSheet object is modified.
+   @sheet: A pointer to the Sheet that holds the GtkSheet object.
+   @cell: A pointer to the Cell that will be applied. */
+static void
+sheet_method_apply_cell (Sheet * sheet, const Cell * cell)
+{
+  ASSERT (sheet != NULL);
+  g_return_if_fail (cell != NULL);
+
+  gdk_threads_enter ();
+
+  if (sheet->has_focus == FALSE)
+    sheet->notices++;
+
+  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet),
+		      cell->row,
+		      cell->column,
+		      cell->attributes.justification,
+		      cell->value->str);
+  gdk_threads_leave ();
+
+  if (!IS_NULLSTR (cell->attributes.bgcolor->str))
+    sheet->range_set_background (sheet, 
+				 &cell->range, 
+				 cell->attributes.bgcolor->str);
+
+  if (!IS_NULLSTR (cell->attributes.fgcolor->str))
+    sheet->range_set_foreground (sheet, 
+				 &cell->range, 
+				 cell->attributes.fgcolor->str);
+
+  /* Clear all of the strings */
+  g_string_assign (cell->value, "");
+  g_string_assign (cell->attributes.bgcolor, "");
+  g_string_assign (cell->attributes.fgcolor, "");
+}
+
+/* @description: This method changes the background of a range of cells. 
+   @sheet: A pointer to the Sheet object that contains GtkSheet.
+   @range: A pointer to the GtkSheetRange object that contains the ranges
+   that we will be applying the background color to.
+   @desc: A string that contains the color's string value (e.g. white, red
+   green, etc). */
+static void
+sheet_method_range_set_background (Sheet * sheet, 
+				   const GtkSheetRange * range,
+				   const gchar * desc)
+{
+  ASSERT (sheet != NULL); ASSERT (range != NULL);
+  GdkColor color;
+
+  /* The color needs to be taken from the colormap; there is an alternative
+     way to do this if we use #rgb or #rrggbb formats. */
+  gdk_threads_enter ();
+  gdk_color_parse (desc, &color);
+  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
+		   &color);
+  
+  gtk_sheet_range_set_background (GTK_SHEET (sheet->gtk_sheet),
+				  range, &color);
+  gdk_threads_leave ();
+}
+
+/* @description: This method changes the foreground color over a range of
+   cells. 
+   @sheet: A pointer to the Sheet object that contains GtkSheet.
+   @range: A pointer to the GtkSheetRange object that contains the ranges
+   that we will be applying the foreground color to.
+   @desc: The string representation of the color (e.g. white, green, blue). */
+static void
+sheet_method_range_set_foreground (Sheet * sheet, 
+				   const GtkSheetRange * range,
+				   const gchar * desc)
+{
+  ASSERT (sheet != NULL); ASSERT (range != NULL);
+  GdkColor color;
+  
+   /* The color needs to be taken from the colormap; there is an alternative
+     way to do this if we use #rgb or #rrggbb formats. */
+  gdk_threads_enter ();
+  gdk_color_parse (desc, &color);
+  gdk_color_alloc (gtk_widget_get_colormap (sheet->gtk_sheet),
+		   &color);
+      
+  gtk_sheet_range_set_foreground (GTK_SHEET (sheet->gtk_sheet),
+				  range, &color);
+  gdk_threads_leave ();
+ }
+
+/* @description: This method manually sets a GtkSheet cell's value. It does
+   not require the use of the Cell object.
+   @sheet: A pointer to the Sheet object that contains GtkSheet.
+   @row: An integer value of the row.
+   @col: An integer value of the column.
+   @value: The text string to be applied to the cell. */
+static void 
+sheet_method_set_cell (Sheet * sheet,
+		       gint row, gint col,
+		       const gchar * value)
+{
+  ASSERT (sheet != NULL);
+
+  gdk_threads_enter ();
+  if (sheet->has_focus == FALSE)
+    sheet->notices++;
+  gtk_sheet_set_cell (GTK_SHEET (sheet->gtk_sheet), 
+		      row, 
+		      col, 
+		      GTK_JUSTIFY_LEFT, 
+		      value);
+  gdk_threads_leave ();
+}
diff --git a/workbook/workbook.c b/workbook/workbook.c
new file mode 100644
index 0000000..f7a7d9c
--- /dev/null
+++ b/workbook/workbook.c
@@ -0,0 +1,271 @@
+/* @author: John `jb Bellone <jvb4@njit.edu> */
+#include <workbook/workbook.h>
+#include <glib/gthread.h>
+#include <string.h>
+
+/* workbook.c (static) */
+static void workbook_method_destroy (Workbook *);
+static Workbook *workbook_object_init (GtkWidget *, const gchar *);
+static Workbook *workbook_object_free (Workbook *);
+static Sheet *workbook_method_addnewsheet (Workbook *, 
+					   const gchar *, 
+					   gint, gint);
+static Sheet *workbook_method_get_sheet (Workbook *, const gchar *);
+static void workbook_method_remove_sheet (Workbook *, Sheet *);
+static gboolean workbook_method_move_sheet_index (Workbook *, Sheet *, gint);
+static gboolean workbook_method_move_sheet (Workbook *, 
+					    Sheet *,
+					    const gchar *,
+					    gboolean);
+
+/* @description: This method "opens" a Workbook. In the future it will load
+   a Workbook from a specified filename (which will most likely be a GZIP
+   file) but for now it merely loads one into memory.
+   @window: A pointer to the GtkWindow object. 
+   @filename: A pointer to the filename string. */
+Workbook *
+workbook_open (GtkWidget * window, const gchar * filename)
+{
+  ASSERT (window != NULL);
+
+  /* STUB: A workbook is opened here from some form of an archived file.
+     At this point we would load up the configuration files for the styles,
+     sheets and plugins to be loaded then this would all be executed here. */
+
+  Workbook * book = workbook_object_init (window, filename);
+  return book;
+}
+
+/* @description: This method adds a new Sheet to the Workbook object. The
+   specified parameters are passed on to the Sheet object's constructor.
+   But first we check to make sure that a sheet with the same label does
+   not already exist inside of the Workbook.
+   @book: Pointer to the Workbook object.
+   @label: The Sheet's label string.
+   @rows: Number of rows the GtkSheet object should have.
+   @cols: Number of columns the GtkSheet object should have.*/
+static Sheet *
+workbook_method_addnewsheet (Workbook * book,
+			     const gchar * label, 
+			     gint rows, 
+			     gint cols)
+{
+  ASSERT (book != NULL);
+
+  Sheet * sheet = book->get_sheet (book, label);
+  if (sheet != NULL) 
+    {
+      g_warning ("Cannot create '%s' because it already exists", 
+		 label);
+      return NULL;
+    }
+
+  sheet = sheet_new (book, label, rows, cols);
+
+  LINK_OBJECT (book->sheet_first,
+	       book->sheet_last, 
+	       sheet);
+
+  /* We are the first and only sheet; make sure we are set to have focus. */
+  /* BUGFIX: This was in the wrong place... needs to be below LINK_OBJECT */
+  if ((book->sheet_first == sheet) && IS_NULL (book->sheet_last))
+    {
+      sheet->has_focus = TRUE;
+      book->focus_sheet = sheet;
+    }
+
+  return sheet;
+}
+
+/* @description: This method performs a search of all the Workbooks and
+   returns a pointer to the Sheet object if it matches the provided label.
+   @wb: Pointer to the workbook we're searching.
+   @sheet: String label of the sheet we are searching for. */
+static Sheet *
+workbook_method_get_sheet (Workbook * wb, const gchar * sheet)
+{
+  ASSERT (wb != NULL);
+
+  if (!IS_NULLSTR (sheet))
+    {
+      ITERATE_BEGIN (Sheet, wb->sheet_first);
+      {
+	if (!strcmp (sheet, it->name))
+	  return it;
+      }
+      ITERATE_END ();
+    }
+
+  return NULL;
+}
+
+/* @description: This method removes a Sheet object from the Workbook. It also
+   removes to GtkSheet tab from the GtkNotebook (held in the Workbook).
+   @wb: The Workbook pointer we are removing the object from.
+   @sheet: The Sheet object that we will be removing. */
+static void
+workbook_method_remove_sheet (Workbook * wb, Sheet * sheet)
+{
+  ASSERT (wb != NULL);
+
+  if (sheet->workbook != wb)
+    {
+      g_warning ("'%s' does not belong to workbook '%s'",
+		 sheet->name, wb->filename);
+      return;
+    }
+
+  ITERATE_BEGIN (Sheet, wb->sheet_first);
+  {
+    /* Remove the sheet from the GtkNotebook */
+    if (it == sheet)
+      {
+	gdk_threads_enter ();
+	gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
+					   sheet->gtk_box);
+	gtk_notebook_remove_page (GTK_NOTEBOOK (wb->gtk_notebook), page); 
+	gtk_widget_queue_draw (wb->gtk_notebook);
+	gdk_threads_leave ();
+	return;
+      }
+  }
+  ITERATE_END ();
+
+  g_warning ("Sheet '%s' was not found inside of workbook '%s'", 
+	     sheet->name, wb->filename);
+}
+
+/* @description: This method moves the Sheet's GtkSheet tab inside of the
+   Workbook's GtkNotebook.
+   @wb: The Workbook object that contains the GtkNotebook.
+   @sheet: The Sheet object that contains the GtkSheet we're moving.
+   @index: The _new_ page index. */
+static gboolean
+workbook_method_move_sheet_index (Workbook * wb, Sheet * sheet, gint index)
+{
+  gdk_threads_enter ();
+  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
+			      sheet->gtk_box,
+			      index);
+  gdk_threads_leave ();
+  return TRUE;
+}
+
+static gboolean
+workbook_method_move_sheet (Workbook * wb, 
+			    Sheet * sheet, 
+			    const gchar * id,
+			    gboolean after)
+{
+  ASSERT (wb != NULL);
+  ASSERT (sheet != NULL);
+
+  if (IS_NULLSTR (id))
+    return FALSE;
+
+  Sheet * sh = wb->get_sheet (wb, id);
+  if (IS_NULL (sh))
+    {
+      g_warning ("Sheet '%s' does not exist in workbook '%s'", 
+		 sheet->name, wb->filename);
+      return FALSE;
+    }
+  
+  gint page = gtk_notebook_page_num (GTK_NOTEBOOK (wb->gtk_notebook),
+				     sh->gtk_box);
+  if (page == -1)
+    {
+      g_warning ("Sheet '%s' does not appear to be in workbook '%s' notebook",
+		 sheet->name, wb->filename);
+      return FALSE;
+    }
+
+  if (after == TRUE)  page++;
+  else                page--;
+
+  gdk_threads_enter ();
+  gtk_notebook_reorder_child (GTK_NOTEBOOK (wb->gtk_notebook),
+			      sheet->gtk_box,
+			      page);
+  gdk_threads_leave ();
+  return TRUE;
+}
+
+/* @description: This is a Workbook object's constructor. 
+   @window: A pointer to the GtkWindow context.
+   @filename: A pointer to the filename string. */
+static Workbook *
+workbook_object_init (GtkWidget * window, const gchar * filename)
+{
+  Workbook * book = NEW (Workbook);
+
+  /* Set up the signals. */
+  book->signals[SIG_WORKBOOK_CHANGED] = NULL;
+
+  /* Set up the notebook */
+  gdk_threads_enter ();
+  book->gtk_notebook = gtk_notebook_new ();
+  
+  GtkNotebook * notebook = GTK_NOTEBOOK (book->gtk_notebook);
+
+  gtk_notebook_set_tab_pos (notebook, GTK_POS_BOTTOM);
+  gtk_notebook_popup_enable (notebook);
+  gtk_notebook_set_show_tabs (notebook, TRUE);
+  gtk_notebook_set_show_border (notebook, TRUE);
+  gtk_widget_set_usize (book->gtk_notebook, 1024, 768);
+  gtk_widget_show (book->gtk_notebook);
+  gdk_threads_leave ();
+
+  /* Members */
+  book->sheet_first = book->sheet_last = NULL;
+  book->next = book->prev = NULL;
+  book->focus_sheet = NULL;
+  book->gtk_window = window;
+  book->filename = g_strdup (filename);
+    
+  /* Methods */
+  book->destroy = workbook_method_destroy;
+  book->add_new_sheet = workbook_method_addnewsheet;
+  book->get_sheet = workbook_method_get_sheet;
+  book->remove_sheet = workbook_method_remove_sheet;
+  book->move_sheet_index = workbook_method_move_sheet_index;
+  book->move_sheet = workbook_method_move_sheet;
+
+  return book;
+}
+
+/* @description: This method destroys the Workbook object and all of the
+   Sheet objects that it contains. 
+   @book: The Workbook object to destroy. */
+static void
+workbook_method_destroy (Workbook * book)
+{
+  ASSERT (book != NULL);
+
+  /* Wrap anything up here. */
+  Sheet * current = book->sheet_first, * next = NULL;
+  while (current)
+    {
+      next = current->next;
+      current->destroy (current);
+      current = next;
+    }
+
+  UNLINK_OBJECT (book);
+  workbook_object_free (book);
+}
+
+/* @description: This method frees the memory that the Workbook object has 
+   been using. This is only able to be called from book->destroy()
+   @book: The Workbook object we are freeing. */
+static Workbook *
+workbook_object_free (Workbook * book)
+{
+  ASSERT (book != NULL);
+
+  book->sheet_first = book->sheet_last = NULL;
+
+  FREE (book->filename);
+  FREE (book);
+  return book;
+}
